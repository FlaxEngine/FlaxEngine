<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis</name>
    </assembly>
    <members>
        <member name="T:Microsoft.CodeAnalysis.AdditionalTextFile">
            <summary>
            Represents a non source code file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AdditionalTextFile.Path">
            <summary>
            Path to the file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdditionalTextFile.GetText(System.Threading.CancellationToken)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> with the contents of this file, or <c>null</c> if
            there were errors reading the file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AdditionalTextFile.Diagnostics">
            <summary>
            Errors encountered when trying to read the additional file. Always empty if
            <see cref="M:Microsoft.CodeAnalysis.AdditionalTextFile.GetText(System.Threading.CancellationToken)"/> has not been called.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AbstractLookupSymbolsInfo`1.TryGetAritiesAndUniqueSymbol(System.String,Microsoft.CodeAnalysis.AbstractLookupSymbolsInfo{`0}.IArityEnumerable@,`0@)">
            <summary>
            If <paramref name="uniqueSymbol"/> is set, then <paramref name="arities"/> will be null.
            The only arity in that case will be encoded in the symbol. 
            </summary>
            <param name="name"></param>
            <param name="arities"></param>
            <param name="uniqueSymbol"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.BindingDiagnosticBag">
            <summary>
            This is base class for a bag used to accumulate information while binding is performed.
            Including diagnostic messages and dependencies in the form of "used" assemblies. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseSiteInfo`1">
            <summary>
            An information that should be reported at a call site of a symbol. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseSiteInfo`1.DiagnosticInfo">
            <summary>
            Diagnostic info that should be reported at the use site of the symbol, or null if there is none.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseSiteInfo`1.PrimaryDependency">
            <summary>
            When not-null, this is primary dependency of the use-site, usually the assembly defining the used symbol.
            Never a core library. Usually it is not included into the <see cref="F:Microsoft.CodeAnalysis.UseSiteInfo`1.SecondaryDependencies"/>.
            Null if <see cref="F:Microsoft.CodeAnalysis.UseSiteInfo`1.DiagnosticInfo"/> is an error.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseSiteInfo`1.SecondaryDependencies">
            <summary>
            The set of other assemblies the use site will depend upon, excluding a core library.
            Empty if <see cref="F:Microsoft.CodeAnalysis.UseSiteInfo`1.DiagnosticInfo"/> is an error.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CompoundUseSiteInfo`1">
            <summary>
            A helper used to combine information from multiple <see cref="T:Microsoft.CodeAnalysis.UseSiteInfo`1"/>s related to the same
            use site.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CachedUseSiteInfo`1">
            <summary>
            A helper used to efficiently cache <see cref="T:Microsoft.CodeAnalysis.UseSiteInfo`1"/> in the symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CachedUseSiteInfo`1._info">
            <summary>
            Either 
            - null (meaning no diagnostic info and dependencies), or
            - a <see cref="T:Microsoft.CodeAnalysis.DiagnosticInfo"/>, or
            - dependencies as a <see cref="T:System.Collections.Immutable.ImmutableHashSet`1"/>, or
            - a <see cref="T:Microsoft.CodeAnalysis.CachedUseSiteInfo`1.Boxed"/> tuple of a <see cref="T:Microsoft.CodeAnalysis.DiagnosticInfo"/> and a <see cref="T:System.Collections.Immutable.ImmutableHashSet`1"/>. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CachedUseSiteInfo`1.Boxed.DiagnosticInfo">
            <summary>
            Diagnostic info that should be reported at the use site of the symbol, or null if there is none.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CachedUseSiteInfo`1.Boxed.Dependencies">
            <summary>
            The set of assemblies the use site will depend upon, excluding assembly for core library.
            Empty or null if <see cref="F:Microsoft.CodeAnalysis.CachedUseSiteInfo`1.Boxed.DiagnosticInfo"/> is an error.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CaseInsensitiveComparison">
            <summary>
            Case-insensitive operations (mostly comparison) on unicode strings.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(System.Char)">
            <summary>
            ToLower implements the Unicode lowercase mapping
            as described in ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt.
            VB uses these mappings for case-insensitive comparison.
            </summary>
            <param name="c"></param>
            <returns>If <paramref name="c"/> is upper case, then this returns its Unicode lower case equivalent. Otherwise, <paramref name="c"/> is returned unmodified.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CaseInsensitiveComparison.OneToOneUnicodeComparer">
            <summary>
            This class seeks to perform the lowercase Unicode case mapping.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CaseInsensitiveComparison.s_comparer">
            <summary>
            Returns a StringComparer that compares strings according to Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Comparer">
            <summary>
            Returns a StringComparer that compares strings according to Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Equals(System.String,System.String)">
            <summary>
            Determines if two strings are equal according to Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <param name="left">First identifier to compare</param>
            <param name="right">Second identifier to compare</param>
            <returns>true if the identifiers should be considered the same.</returns>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Determines if two strings are equal according to Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <param name="left">First identifier to compare</param>
            <param name="right">Second identifier to compare</param>
            <returns>true if the identifiers should be considered the same.</returns>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.EndsWith(System.String,System.String)">
            <summary>
            Determines if the string 'value' end with string 'possibleEnd'.
            </summary>
            <param name="value"></param>
            <param name="possibleEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.StartsWith(System.String,System.String)">
            <summary>
            Determines if the string 'value' starts with string 'possibleStart'.
            </summary>
            <param name="value"></param>
            <param name="possibleStart"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Compare(System.String,System.String)">
            <summary>
            Compares two strings according to the Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <param name="left">First identifier to compare</param>
            <param name="right">Second identifier to compare</param>
            <returns>-1 if <paramref name="left"/> &lt; <paramref name="right"/>, 1 if <paramref name="left"/> &gt; <paramref name="right"/>, 0 if they are equal.</returns>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Compare(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Compares two strings according to the Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <param name="left">First identifier to compare</param>
            <param name="right">Second identifier to compare</param>
            <returns>-1 if <paramref name="left"/> &lt; <paramref name="right"/>, 1 if <paramref name="left"/> &gt; <paramref name="right"/>, 0 if they are equal.</returns>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.GetHashCode(System.String)">
            <summary>
            Gets a case-insensitive hash code for Unicode identifiers.
            </summary>
            <param name="value">identifier to get the hash code for</param>
            <returns>The hash code for the given identifier</returns>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(System.String)">
            <summary>
            Convert a string to lower case per Unicode
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(System.Text.StringBuilder)">
            <summary>
            In-place convert string in StringBuilder to lower case per Unicode rules
            </summary>
            <param name="builder"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethods">
            <summary>
            Constructs and caches already created pseudo-methods.
            Every compiled module is supposed to have one of this, created lazily 
            (multidimensional arrays are not common).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.GetArrayConstructor(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an array constructor for a given array type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.GetArrayGet(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an element getter method for a given array type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.GetArraySet(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an element setter method for a given array type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.GetArrayAddress(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an element referencer method for a given array type
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ArrayMethods._dict">
            <summary>
            Maps {array type, method kind} tuples to implementing pseudo-methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.GetArrayMethod(Microsoft.Cci.IArrayTypeReference,Microsoft.CodeAnalysis.CodeGen.ArrayMethods.ArrayMethodKind)">
            <summary>
            lazily fetches or creates a new array method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.ArrayConstructor">
            <summary>
            "newobj ArrayConstructor"  is equivalent of "newarr ElementType" 
            when working with multidimensional arrays
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.ArrayGet">
            <summary>
            "call ArrayGet"  is equivalent of "ldelem ElementType" 
            when working with multidimensional arrays
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.ArrayAddress">
            <summary>
            "call ArrayAddress"  is equivalent of "ldelema ElementType" 
            when working with multidimensional arrays
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethods.ArraySet">
            <summary>
            "call ArraySet"  is equivalent of "stelem ElementType" 
            when working with multidimensional arrays
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethodParameterInfo">
            <summary>
            Represents a parameter in an array pseudo-method.
            
            NOTE: It appears that only number of indices is used for verification, 
            types just have to be Int32.
            Even though actual arguments can be native ints.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArraySetValueParameterInfo">
            <summary>
            Represents the "value" parameter of the Set pseudo-method.
            
            NOTE: unlike index parameters, type of the value parameter must match 
            the actual element type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ArrayMethod">
            <summary>
            Base of all array methods. They have a lot in common.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ILBuilder.Reachability.NotReachable">
            <summary>
            Block is not reachable or reachability analysis
            has not been performed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ILBuilder.Reachability.Reachable">
            <summary>
            Block can be reached either falling through
            from previous block or from branch.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ILBuilder.Reachability.BlockedByFinally">
            <summary>
            Block is reachable from try or catch but
            finally prevents falling through.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.IsBranchToLabel">
            <summary>
            Returns true if this block has a branch label
            and is not a "nop" branch.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.RegularInstructions">
            <summary>
            Instructions that are not branches.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.HasNoRegularInstructions">
            <summary>
            The block contains only the final branch or nothing at all
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.AdjustForDelta(System.Int32)">
            <summary>
            Updates position of the current block to account for shorter sizes of previous blocks.
            </summary>
            <param name="delta"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.ShortenBranches(System.Int32@)">
            <summary>
            If possible, changes the branch code of the current block to the short version and 
            updates the delta correspondingly.
            </summary>
            <param name="delta">Position delta created by previous block size reductions.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.OptimizeBranches(System.Int32@)">
            <summary>
            replaces branches with more compact code if possible.
            * same branch as in the next     ===> nop
            * branch to the next block       ===> nop
            * branch to ret block            ===> ret
            * cond branch over uncond branch ===> flip condition, skip next block
            * cond branch to equivalent      ===> pop args + nop
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.AreIdentical(Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock,Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock)">
            <summary>
            Blocks are identical if:
            1) have same regular instructions
            2) lead to unconditional control transfer (no fall through)
            3) branch with the same instruction to the same label
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock.GetReversedBranchOp">
            <summary>
            Returns reversed branch operation for the current block.
            If no reverse opcode can be obtained Nop is returned.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitState">
            <summary>
            Abstract Execution state. 
            If we know something interesting about IL stream we put it here.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitState.MaxStack">
            <summary>
            Eval stack's high watermark.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitState.CurStack">
            <summary>
            Current evaluation stack depth.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitState.AdjustStack(System.Int32)">
            <summary>
            Record effects of that currently emitted instruction on the eval stack.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ILBuilder._allocatedILMarkers">
            <summary> 
            In some cases we have to get a final IL offset during emit phase, for example for
            proper emitting sequence points. The problem is that before the builder is realized we 
            don't know the actual IL offset, but only {block/offset-in-the-block} pair. 
            
            Thus, whenever we need to mark some IL position we allocate a new marker id, store it 
            in allocatedILMarkers and reference this IL marker in the entity requiring the IL offset.
            
            IL markers will be 'materialized' when the builder is realized; the resulting offsets
            will be put into allocatedILMarkers array. Note that only markers from reachable blocks 
            are materialized, the rest will have offset -1.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.Realize">
            <summary>
            Realizes method body.
            No more data can be added to the builder after this call.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.GetAllScopes">
            <summary>
            Gets all scopes that contain variables.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.GetHoistedLocalScopes">
            <summary>
            Gets all scopes that contain variables.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.ILBuilder.InstructionsEmitted">
            <summary>
            IL opcodes emitted by this builder.
            This includes branch instructions that end blocks except if they are fall-through NOPs.
            
            This count allows compilers to see if emitting a particular statement/expression 
            actually produced any instructions.
            
            Example: a label will not result in any code so when emitting debugging information 
                     an extra NOP may be needed if we want to decorate the label with sequence point. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.MarkReachableBlocks">
            <summary>
            Marks blocks that are reachable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.MarkReachableFrom(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock},Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock)">
            <summary>
            Marks blocks that are recursively reachable from the given block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.OptimizeLabels">
            <summary>
            If a label points to a block that does nothing other than passing to block X,
            replaces target label's block with block X.
            </summary>
            
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.DropUnreachableBlocks">
            <summary>
            Drops blocks that are not reachable
            Returns true if any blocks were dropped
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.MarkAllBlocksUnreachable">
            <summary>
            Marks all blocks unreachable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.RewriteSpecialBlocks">
            <summary>
            Rewrite any block marked as BlockedByFinally as an "infinite loop".
            </summary>
            <remarks>
            Matches the code generated by the native compiler in
            ILGENREC::AdjustBlockedLeaveTargets.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.IsSpecialEndHandlerBlock(Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock)">
            <summary>
            Returns true if the block has the signature of the special
            labeled block that follows a complete try/catch or try/finally.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ComputeOffsetsAndAdjustBranches">
            <summary>
            Returns true if any branches were optimized (that does not include shortening)
            We need this because optimizing a branch may result in unreachable code that needs to be eliminated.
            
            === Example:
            
            x = 1;
            
            if (blah)
            {
                global = 1;
            }
            else
            {
                throw null;
            }
            
            return x;
            
            === rewrites into
            
            push 1;
            
            if (blah)
            {
                global = 1;
                ret; 
            }
            else
            {
                throw null;
            }
            
            // this ret unreachable now! 
            // even worse - empty stack is assumed thus the ret is illegal.
            ret;    
            
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.DefineSequencePoint(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Define a sequence point with the given syntax tree and span within it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.DefineHiddenSequencePoint">
            <summary>
            Defines a hidden sequence point.
            The effect of this is that debugger will not associate following code 
            with any source (until it sees a lexically following sequence point).
            
            This is used for synthetic code that is reachable through labels.
            
            If such code is not separated from previous sequence point by the means of a hidden sequence point
            It looks as a part of the statement that previous sequence point specifies.
            As a result, when user steps through the code and goes through a jump to such label,
            it will appear as if the jump landed at the beginning of the previous statement.
            
            NOTE: Also inserted as the first statement of a method that would not otherwise have a leading
            sequence point so that step-into will find the method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.DefineInitialHiddenSequencePoint">
            <summary>
            Define a hidden sequence point at the first statement of
            the method so that step-into will find the method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.SetInitialDebugDocument(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            This is called when starting emitting a method for which there is some source.
            It is done in case the first sequence point is a hidden point.
            Even though hidden points do not have syntax, they need to associate with some document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.MarkFilterConditionEnd">
            <summary>
            Marks the end of filter condition and start of the actual filter handler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.AddLocalToScope(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
            <summary>
            Puts local variable into current scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.AddLocalConstantToScope(Microsoft.CodeAnalysis.CodeGen.LocalConstantDefinition)">
            <summary>
            Puts local constant into current scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.MarkLabel(System.Object)">
            <summary>
            Mark current IL position with a label
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitStringSwitchJumpTable(System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.ConstantValue,System.Object}[],System.Object,Microsoft.CodeAnalysis.CodeGen.LocalOrParameter,Microsoft.CodeAnalysis.CodeGen.LocalDefinition,Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.EmitStringCompareAndBranch,Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.GetStringHashCode)">
            <summary>
            Primary method for emitting string switch jump table
            </summary>
            <param name="caseLabels">switch case labels</param>
            <param name="fallThroughLabel">fall through label for the jump table</param>
            <param name="key">Local holding the value to switch on.
            This value has already been loaded onto the execution stack.
            </param>
            <param name="keyHash">Local holding the hash value of the key for emitting
            hash table switch. Hash value has already been computed and loaded into keyHash.
            This parameter is null if emitting non hash table switch.
            </param>
            <param name="emitStringCondBranchDelegate">
            Delegate to emit string compare call and conditional branch based on the compare result.
            </param>
            <param name="computeStringHashcodeDelegate">
            Delegate to compute string hash consistent with value of keyHash.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitIntegerSwitchJumpTable(System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.ConstantValue,System.Object}[],System.Object,Microsoft.CodeAnalysis.CodeGen.LocalOrParameter,Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Primary method for emitting integer switch jump table.
            </summary>
            <param name="caseLabels">switch case labels</param>
            <param name="fallThroughLabel">fall through label for the jump table.</param>
            <param name="key">Local or parameter holding the value to switch on.
            This value has already been loaded onto the execution stack.
            </param>
            <param name="keyTypeCode">Primitive type code of switch key.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.FinishFilterCondition">
            <summary>
            Finishes filter condition (and starts actual handler portion of the handler).
            Returns the last block of the condition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitArrayCreation(Microsoft.Cci.IArrayTypeReference,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generates code that creates an instance of multidimensional array
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitArrayElementLoad(Microsoft.Cci.IArrayTypeReference,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generates code that loads an element of a multidimensional array
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitArrayElementAddress(Microsoft.Cci.IArrayTypeReference,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generates code that loads an address of an element of a multidimensional array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.EmitArrayElementStore(Microsoft.Cci.IArrayTypeReference,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generates code that stores an element of a multidimensional array.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LabelInfo">
            <summary>
            Contains information about a label.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LabelInfo.targetOfConditionalBranches">
            <summary>
            Sometimes we need to know if a label is targeted by conditional branches.
            For example optimizer can do optimizations of branches into outer try scopes only 
            if they are unconditional (because there are no conditional Leave opcodes)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LabelInfo.#ctor(System.Int32,System.Boolean)">
            <summary>
            Used when we see a branch, but label is not yet marked.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LabelInfo.#ctor(Microsoft.CodeAnalysis.CodeGen.ILBuilder.BasicBlock,System.Int32,System.Boolean)">
            <summary>
            Used when label is marked to the code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LocalScopeManager.GetAllScopesWithLocals">
            <summary>
            Gets all scopes that contain variables.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LocalScopeManager.GetExceptionHandlerRegions">
            <summary>
            Returns an ExceptionHandlerRegion for each exception handler clause
            beneath the root scope. Each ExceptionHandlerRegion indicates the type
            of clause (catch or finally) and the bounds of the try block and clause block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ScopeInfo">
            <summary>
            Base class for IL scopes where a scope contains IL blocks and other nested
            scopes. A scope may represent a scope for variable declarations, an exception
            handler clause, or an entire exception handler (multiple clauses).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ScopeInfo.GetLocalScopes(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.Cci.LocalScope})">
            <summary>
            Recursively calculates the start and end of the given scope.
            Only scopes with locals are actually dumped to the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ScopeInfo.GetHoistedLocalScopes(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope})">
            <summary>
            Recursively calculates the start and end of the given scope.
            Only scopes with locals are actually dumped to the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ScopeInfo.FreeBasicBlocks">
            <summary>
            Free any basic blocks owned by this scope or sub-scopes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.LocalScopeInfo">
            <summary>
            Class that collects content of the scope (blocks, nested scopes, variables etc).
            There is one for every opened scope.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ExceptionHandlerScope">
            <summary>
            A scope for a single try, catch, or finally clause. If the clause
            is a catch clause, ExceptionType will be set.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ExceptionHandlerContainerScope">
            <summary>
            A scope for an entire exception handler (a try block with either several
            catches or a finally block). Unlike other scopes, this scope contains
            nested scopes only, no IL blocks (although nested ExceptionHandlerScopes
            for the clauses will contain IL blocks).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ILBuilder.ScopeComparer">
            <summary>
            Compares scopes by their start (ascending) and then size (descending).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.DebugId">
            <summary>
            Unique identification of an emitted entity (method, lambda, closure) used for debugging purposes (EnC).
            </summary>
            <remarks>
            When used for a synthesized method the ordinal and generation numbers are included its name.
            For user defined methods the ordinal is included in Custom Debug Information record attached to the method.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.DebugId.Ordinal">
            <summary>
            The index of the method in member list of the containing type, or <see cref="F:Microsoft.CodeAnalysis.CodeGen.DebugId.UndefinedOrdinal"/> if undefined.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.DebugId.Generation">
            <summary>
            The EnC generation the method was defined in (0 is the baseline build).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILOpCodeExtensions.IsControlTransfer(System.Reflection.Metadata.ILOpCode)">
            <summary>
            These opcodes represent control transfer.
            They should not appear inside basic blocks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ILOpCodeExtensions.CanFallThrough(System.Reflection.Metadata.ILOpCode)">
            <summary>
            Opcodes that represents a branch to a label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ItemTokenMap`1">
            <summary>
            Handles storage of items referenced via tokens in metadata. When items are stored 
            they are uniquely "associated" with fake tokens, which are basically sequential numbers.
            IL gen will use these fake tokens during codegen and later, when actual values 
            are known, the method bodies will be patched.
            To support these two scenarios we need two maps - Item-->uint, and uint-->Item. (The second is really just a list).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.ITokenDeferral.GetReferenceFromToken(System.UInt32)">
            <summary>
            Gets the <see cref="T:Microsoft.Cci.IReference"/> or <see cref="T:Microsoft.Cci.ISignature"/> corresponding to this token.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo">
            <summary>
            Debug information maintained for each lambda.
            </summary>
            <remarks>
            The information is emitted to PDB in Custom Debug Information record for a method containing the lambda.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo.SyntaxOffset">
            <summary>
            The syntax offset of the syntax node declaring the lambda (lambda expression) or its body (lambda in a query).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo.ClosureOrdinal">
            <summary>
            The ordinal of the closure frame the lambda belongs to, or
            <see cref="F:Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo.StaticClosureOrdinal"/> if the lambda is static, or
            <see cref="F:Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo.ThisOnlyClosureOrdinal"/> if the lambda is closed over "this" pointer only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.LocalConstantDefinition">
            <summary>
            We need a CCI representation for local constants because they are emitted as locals in
            PDB scopes to improve the debugging experience (see LocalScopeProvider.GetConstantsInScope).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.LocalDebugId">
            <summary>
            Id that associates an emitted user-defined or long-lived synthesized local variable 
            with a syntax node that defined it. If a syntax node defines multiple variables it 
            provides information necessary to identify which one of these variables is it.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.LocalDebugId.SyntaxOffset">
            <summary>
            We calculate a "syntax offset" for each user-defined and long-lived synthesized variable. 
            Every such variable symbol has to be associated with a syntax node (its declarator). 
            In usual cases this is the textual distance of the declarator from the start of the method body. 
            It gets a bit complicated when the containing method body is not contiguous (constructors). 
            If the variable is in the body of the constructor the definition of syntax offset is the same. 
            If the variable is defined in a constructor  initializer or in a member initializer 
            (this is only possible when declaration expressions or closures in primary constructors are involved) 
            then the distance is a negative sum of the widths of all the initializers that succeed the declarator 
            of the variable in the emitted constructor body plus the relative offset of the declarator from 
            the start of the containing initializer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.LocalDebugId.Ordinal">
            <summary>
            If a single node is a declarator for multiple variables of the same synthesized kind (it can only happen for synthesized variables) 
            we calculate additional number "ordinal" for such variable. We assign the ordinals to the synthesized variables with the same kind
            and syntax offset in the order as they appear in the lowered bound tree. It is important that a valid EnC edit can't change 
            the ordinal of a synthesized variable. If it could it would need to be assigned a different kind or associated with a different declarator node.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.LocalDefinition._pdbAttributes">
            <see cref="P:Microsoft.Cci.ILocalDefinition.PdbAttributes"/>.
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.LocalDefinition.#ctor(Microsoft.CodeAnalysis.Symbols.ILocalSymbolInternal,System.String,Microsoft.Cci.ITypeReference,System.Int32,Microsoft.CodeAnalysis.SynthesizedLocalKind,Microsoft.CodeAnalysis.CodeGen.LocalDebugId,System.Reflection.Metadata.LocalVariableAttributes,Microsoft.CodeAnalysis.LocalSlotConstraints,System.Collections.Immutable.ImmutableArray{System.Boolean},System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Creates a new LocalDefinition.
            </summary>
            <param name="symbolOpt">Local symbol, used by edit and continue only, null otherwise.</param>
            <param name="nameOpt">Name associated with the slot.</param>
            <param name="type">Type associated with the slot.</param>
            <param name="slot">Slot position in the signature.</param>
            <param name="synthesizedKind">Local kind.</param>
            <param name="id">Local id.</param>
            <param name="pdbAttributes">Value to emit in the attributes field in the PDB.</param>
            <param name="constraints">Specifies whether slot type should have pinned modifier and whether slot should have byref constraint.</param>
            <param name="dynamicTransformFlags">The synthesized dynamic attributes of the local.</param>
            <param name="tupleElementNames">Tuple element names of the local.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager">
            <summary>
            At this level there are two kinds of local variables:
            <list type="bullet">
            <item>
            Locals - have identities by which consuming code refers to them.
                Typical use is a local variable or a compiler generated temp that can be accessed in multiple operations.
                Any object can be used as identity. Reference equality is used.
            </item>
            <item>
            Temps - do not have identity. They are borrowed and returned to the free list.
                Typical use is a scratch temporary or spilling storage.
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.LocalSignature">
            <summary>
            Structure that represents a local signature (as in <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf">ECMA-335</a>, Partition I, §8.6.1.3 Local signatures).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.GetLocal(Microsoft.CodeAnalysis.Symbols.ILocalSymbolInternal)">
            <summary>
            Retrieve a local slot by its symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.FreeLocal(Microsoft.CodeAnalysis.Symbols.ILocalSymbolInternal)">
            <summary>
            Release a local slot by its symbol.
            Slot is not associated with symbol after this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.AllocateSlot(Microsoft.Cci.ITypeReference,Microsoft.CodeAnalysis.LocalSlotConstraints,System.Collections.Immutable.ImmutableArray{System.Boolean},System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Gets a local slot.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.LocalSlotManager.FreeSlot(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
            <summary>
            Frees a local slot.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.MetadataCreateArray">
            <summary>
            An expression that creates an array instance in metadata. Only for use in custom attributes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.MetadataNamedArgument">
            <summary>
            An expression that represents a (name, value) pair and that is typically used in method calls, custom attributes and object initializers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MetadataNamedArgument.Microsoft#Cci#IMetadataNamedArgument#ArgumentName">
            <summary>
            The name of the parameter or property or field that corresponds to the argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MetadataNamedArgument.Microsoft#Cci#IMetadataNamedArgument#ArgumentValue">
            <summary>
            The value of the argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MetadataNamedArgument.Microsoft#Cci#IMetadataNamedArgument#IsField">
            <summary>
            True if the named argument provides the value of a field.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.MetadataTypeOf">
            <summary>
            An expression that results in a System.Type instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MetadataTypeOf.TypeToGet">
            <summary>
            The type that will be represented by the System.Type instance.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.MethodBody">
            <summary>
            Holds on to the method body data.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MethodBody.Microsoft#Cci#IMethodBody#ImportScope">
            <summary>
            This is a list of the using directives that were in scope for this method body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.MethodBody.HasStackalloc">
            <summary>
            True if there's a stackalloc somewhere in the method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference">
            <summary>
            This class represents the PermissionSetAttribute specified in source which needs fixup during codegen.
            </summary>
            <remarks>
            PermissionSetAttribute needs fixup when it contains an assignment to the 'File' property as a single named attribute argument.
            Fixup performed is ported from SecurityAttributes::FixUpPermissionSetAttribute at ndp\clr\src\vm\securityattributes.cpp.
            It involves following steps:
            1) Verifying that the specified file name resolves to a valid path: This is done during binding.
            2) Reading the contents of the file into a byte array.
            3) Convert each byte in the file content into two bytes containing hexadecimal characters (see method <see cref="M:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.ConvertToHex(System.IO.Stream)"/>).
            4) Replacing the 'File = fileName' named argument with 'Hex = hexFileContent' argument, where hexFileContent is the converted output from step 3) above.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.GetArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more positional arguments for the attribute constructor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.Constructor(Microsoft.CodeAnalysis.Emit.EmitContext,System.Boolean)">
            <summary>
            A reference to the constructor that will be used to instantiate this custom attribute during execution (if the attribute is inspected via Reflection).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.GetNamedArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more named arguments that specify values for fields and properties of the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.ArgumentCount">
            <summary>
            The number of positional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.NamedArgumentCount">
            <summary>
            The number of named arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of the attribute. For example System.AttributeUsageAttribute.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.PermissionSetFileReadException">
            <summary>
            Exception class to enable generating ERR_PermissionSetAttributeFileReadError while reading the file for PermissionSetAttribute fixup.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.PrivateImplementationDetails">
            <summary>
            TypeDefinition that represents &lt;PrivateImplementationDetails&gt; class.
            The main purpose of this class so far is to contain mapped fields and their types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ExplicitSizeStruct">
            <summary>
            Simple struct type with explicit size and no members.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.MappedField">
            <summary>
            Definition of a simple field mapped to a metadata block
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.DefaultTypeDef">
            <summary>
            Just a default implementation of a type definition.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.RawSequencePoint">
            <summary>
            Represents a sequence point before translation by #line/ExternalSource directives.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.ReferenceDependencyWalker">
            <summary>
            Some features of the compiler (such as anonymous types, pay-as-you-go, NoPIA, ...)
            rely on all referenced symbols to go through translate mechanism. Because by default
            symbol translator does not translate some of indirectly referenced symbols, such as 
            type argument, we have to force translation here
            
            This class provides unified implementation for this functionality.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.ScopeType.StateMachineVariable">
            <summary>
            Scope of user-defined variable hoisted to state machine.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SequencePointList">
            <summary>
            Maintains a list of sequence points in a space efficient way. Most of the time sequence points
            occur in the same syntax tree, so optimize for that case. Store a sequence point as an offset, and 
            position in a syntax tree, then translate to CCI format only on demand.
            
            Use a ArrayBuilder{RawSequencePoint} to create.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.SequencePointList.Create(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.RawSequencePoint},Microsoft.CodeAnalysis.CodeGen.ILBuilder)">
            <summary>
            Create a SequencePointList with the raw sequence points from an ArrayBuilder.
            A linked list of instances for each syntax tree is created (almost always of length one).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.SequencePointList.GetSequencePoints(Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.Cci.SequencePoint})">
            <summary>
            Get all the sequence points, possibly mapping them using #line/ExternalSource directives, and mapping
            file names to debug documents with the given mapping function.
            </summary>
            <param name="documentProvider">Function that maps file paths to CCI debug documents</param>
            <param name="builder">where sequence points should be deposited</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SequencePointList.OffsetAndSpan">
            <summary>
            Represents the combination of an IL offset and a source text span.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SignatureOnlyLocalDefinition">
            <summary>
            A local whose type is represented by a metadata signature instead of a type symbol.
            </summary>
            <remarks>
            Used when emitting a new version of a method during EnC for variables that are no longer used.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.SignatureOnlyLocalDefinition.PdbAttributes">
            <remarks>
            This temp is not interesting to the expression compiler.  However, it 
            may be replaced by an interesting local in a later stage.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.StateMachineStatesDebugInfo">
            <summary>
            Debug information maintained for each state machine.
            Facilitates mapping of state machine states from a compilation to the previous one (or to a metadata baseline) during EnC.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.StateMachineStatesDebugInfo.FirstUnusedIncreasingStateMachineState">
            <summary>
            The number of the first state that has not been used in any of the previous versions of the state machine,
            or null if we are not generating EnC delta.
            
            For 1st generation EnC delta, this is calculated by examining the <see cref="F:Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation.StateMachineStates"/> stored in the baseline metadata.
            For subsequent generations, the number is updated to account for newly generated states in that generation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.StateMachineStatesDebugInfo.FirstUnusedDecreasingStateMachineState">
            <summary>
            The number of the first state that has not been used in any of the previous versions of the state machine,
            or null if we are not generating EnC delta, or the state machine has no decreasing states.
            
            For 1st generation EnC delta, this is calculated by examining the <see cref="F:Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation.StateMachineStates"/> stored in the baseline metadata.
            For subsequent generations, the number is updated to account for newly generated states in that generation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter">
            <summary>
            Class for emitting the switch jump table for switch statements with integral governing type
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter._key">
            <summary>
            Switch key for the jump table
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter._keyTypeCode">
            <summary>
            Primitive type of the switch key
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter._fallThroughLabel">
            <summary>
            Fall through label for the jump table
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter._sortedCaseLabels">
            <summary>
            Integral case labels sorted and indexed by their ConstantValue
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.SwitchBucket.IsDegenerate">
             <summary>
              Degenerate buckets here are buckets with contiguous range of constants
              leading to the same label. Like:
            
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                       DoOneThing();
                       break;               
            
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                       DoAnotherThing();
                       break;   
              
              NOTE: A trivial bucket with only one case constant is by definition degenerate.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.SwitchBucket.TryMergeWith(Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.SwitchBucket)">
            <summary>
            Try to merge with the nextBucket.
            If merge results in a better bucket than two original ones, merge and return true.
            Else don't merge and return false.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter._key">
            <summary>
            Switch key for the jump table
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter._caseLabels">
            <summary>
            Switch case labels
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter._fallThroughLabel">
            <summary>
            Fall through label for the jump table
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.EmitStringCompareAndBranch">
            <summary>
            Delegate to emit string compare call and conditional branch based on the compare result.
            </summary>
            <param name="key">Key to compare</param>
            <param name="stringConstant">Case constant to compare the key against</param>
            <param name="targetLabel">Target label to branch to if key = stringConstant</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter.GetStringHashCode">
            <summary>
            Delegate to compute string hash code.
            This piece is language-specific because VB treats "" and null as equal while C# does not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter._emitStringCondBranchDelegate">
            <summary>
            Delegate to emit string compare call
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter._computeStringHashcodeDelegate">
            <summary>
            Delegate to emit string hash
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter._keyHash">
            <summary>
            Local storing the key hash value, used for emitting hash table based string switch.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.SynthesizedLocalOrdinalsDispenser">
            <summary>
            Dispenser of unique ordinals for synthesized variable names that have the same kind and syntax offset.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGen.TokenMap">
            <summary>
            Handles storage of items referenced via tokens in metadata (strings or Symbols).
            When items are stored they are uniquely "associated" with fake token, which is basically 
            a sequential number.
            IL gen will use these fake tokens during codegen and later, when actual token values are known
            the method bodies will be patched.
            To support these two scenarios we need two maps - Item-->uint, and uint-->Item.  (the second is really just a list).
            This map supports tokens of type <see cref="T:Microsoft.Cci.ISignature"/> and <see cref="T:Microsoft.Cci.IReference"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator.TryGetPreviousHoistedLocalSlotIndex(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.Cci.ITypeReference,Microsoft.CodeAnalysis.SynthesizedLocalKind,Microsoft.CodeAnalysis.CodeGen.LocalDebugId,Microsoft.CodeAnalysis.DiagnosticBag,System.Int32@)">
            <summary>
            Returns an index of a slot that stores specified hoisted local variable in the previous generation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator.PreviousHoistedLocalSlotCount">
            <summary>
            Number of slots reserved for hoisted local variables.
            </summary>
            <remarks>
            Some of the slots might not be used anymore (a variable might have been deleted or its type changed).
            Still, new hoisted variables are assigned slots starting with <see cref="P:Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator.PreviousHoistedLocalSlotCount"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator.TryGetPreviousAwaiterSlotIndex(Microsoft.Cci.ITypeReference,Microsoft.CodeAnalysis.DiagnosticBag,System.Int32@)">
            <summary>
            Returns true and an index of a slot that stores an awaiter of a specified type in the previous generation, if any. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator.PreviousAwaiterSlotCount">
            <summary>
            Number of slots reserved for awaiters.
            </summary>
            <remarks>
            Some of the slots might not be used anymore (the type of an awaiter might have changed).
            Still, new awaiters are assigned slots starting with <see cref="P:Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator.PreviousAwaiterSlotCount"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator.MethodId">
            <summary>
            The id of the method, or null if the method wasn't assigned one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator.TryGetPreviousClosure(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CodeGen.DebugId@)">
            <summary>
            Finds a closure in the previous generation that corresponds to the specified syntax.
            </summary>
            <remarks>
            See LambdaFrame.AssertIsLambdaScopeSyntax for kinds of syntax nodes that represent closures.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator.TryGetPreviousLambda(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean,Microsoft.CodeAnalysis.CodeGen.DebugId@)">
            <summary>
            Finds a lambda in the previous generation that corresponds to the specified syntax.
            The <paramref name="lambdaOrLambdaBodySyntax"/> is either a lambda syntax (<paramref name="isLambdaBody"/> is false),
            or lambda body syntax (<paramref name="isLambdaBody"/> is true).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator.GetFirstUnusedStateMachineState(System.Boolean)">
            <summary>
            State number to be used for next state of the state machine,
            or <see langword="null"/> if none of the previous versions of the method was a state machine with an increasing state
            </summary>
            <param name="increasing">True if the state number increases with progress, false if it decreases (e.g. states for iterator try-finally blocks, or iterator states of async iterators).</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator.TryGetPreviousStateMachineState(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.StateMachineState@)">
            <summary>
            For a given node associated with entering a state of a state machine in the new compilation,
            returns the ordinal of the corresponding state in the previous version of the state machine.
            </summary>
            <returns>
            True if there is a corresponding node in the previous code version that matches the given <paramref name="syntax"/>.
            </returns>
            <remarks>
            <paramref name="syntax"/> is an await expression, yield return statement, or try block syntax node.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StateMachineState.FirstResumableAsyncIteratorState">
            <summary>
            First state of an async iterator state machine that is used to resume the machine after yield return.
            Initial state is not used to resume state machine that yielded. State numbers decrease as the iterator makes progress.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StateMachineState.InitialAsyncIteratorState">
            <summary>
            Initial iterator state of an async iterator.
            Distinct from <see cref="F:Microsoft.CodeAnalysis.StateMachineState.NotStartedOrRunningState"/> so that DisposeAsync can throw in latter case.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StateMachineState.FirstIteratorFinalizeState">
            <summary>
            First state of an iterator state machine. State numbers decrease for subsequent finalize states.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StateMachineState.FirstResumableAsyncState">
            <summary>
            First state in async state machine that is used to resume the machine after await.
            State numbers increase as the async computation makes progress.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StateMachineState.InitialIteratorState">
            <summary>
            Initial iterator state of an iterator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StateMachineState.FirstResumableIteratorState">
            <summary>
            First state in iterator state machine that is used to resume the machine after yield return.
            Initial state is not used to resume state machine that yielded. State numbers increase as the iterator makes progress.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``2(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1})">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``3(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArrayWithIndex``3(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,System.Int32,``1,``2},``1)">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.Create(System.Int32)">
            <summary>
            Create BitArray with at least the specified number of bits.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.AllSet(System.Int32)">
            <summary>
            return a bit array with all bits set from index 0 through bitCount-1
            </summary>
            <param name="capacity"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.Clone">
            <summary>
            Make a copy of a bit array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.Invert">
            <summary>
            Invert all the bits in the vector.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BitVector.IsNull">
            <summary>
            Is the given bit array null?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.IntersectWith(Microsoft.CodeAnalysis.BitVector@)">
            <summary>
            Modify this bit vector by bitwise AND-ing each element with the other bit vector.
            For the purposes of the intersection, any bits beyond the current length will be treated as zeroes.
            Return true if any changes were made to the bits of this bit vector.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.UnionWith(Microsoft.CodeAnalysis.BitVector@)">
            <summary>
            Modify this bit vector by '|'ing each element with the other bit vector.
            </summary>
            <returns>
            True if any bits were set as a result of the union.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.CachingDictionary`2">
            <summary>
            The CachingLookup class provides a convenient representation of an ILookup that is based
            upon a potentially slow lookup, and caches lookup results so that subsequent lookups are
            fast. Internally a ConcurrentDictionary is used to cache lookup results. The client provides
            two delegates to perform lookups: One that maps a key to a IEnumerable of values, and one
            that provides all keys.
            
            The client must provide an IEqualityComparer used for comparing keys. Failed lookups are
            cached, but that has the disadvantage that every different failed lookup will consume a
            small amount of extra memory. However, that memory can be reclaimed by forcing a full
            population of the cache.
            
            Thread safe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.#ctor(System.Func{`0,System.Collections.Immutable.ImmutableArray{`1}},System.Func{System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.HashSet{`0}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a CachingLookup.
            </summary>
            <param name="getElementsOfKey">A function that takes a key, and returns an IEnumerable of values that
            correspond to that key. If no values correspond, the function may either return null or an empty
            IEnumerable.</param>
            <param name="getKeys">A function that returns an IEnumerable of all keys that have associated values.</param>
            <param name="comparer">A IEqualityComparer used to compare keys.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.Contains(`0)">
            <summary>
            Does this key have one or more associated values?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.Item(`0)">
            <summary>
            Get the values associated with a key. 
            </summary>
            <param name="key">Key to look up.</param>
            <returns>All values associated with key. Returns an empty IEnumerable if
            no values are associated. Never returns null.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.Count">
            <summary>
            Get the number of distinct keys.
            Forces a full population of the cache.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.Keys">
            <summary>
            Enumerate all the keys.
            Forces a full population of the cache.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.AddValues(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{`1})">
            <summary>
            Add the values from all keys to a flat array.
            Forces a full population of the cache.
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.CreateConcurrentDictionary">
            <summary>
            Create an instance of the concurrent dictionary.
            </summary>
            <returns>The concurrent dictionary</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.CreateDictionaryForFullyPopulatedMap(System.Int32)">
            <summary>
            Create a dictionary instance suitable for use as the fully populated map.
            </summary>
            <returns>A new, empty dictionary, suitable for use as the fully populated map.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.GetOrCreateValue(`0)">
            <summary>
            Use the underlying (possibly slow) functions to get the values associated with a key.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.AddToConcurrentMap(System.Collections.Concurrent.ConcurrentDictionary{`0,System.Collections.Immutable.ImmutableArray{`1}},`0)">
            <summary>
            Add a new value with the given key to the given concurrent map.
            </summary>
            <param name="map">The concurrent map to augment.</param>
            <param name="key">The key of the new entry.</param>
            <returns>The added entry. If there was a race, and another thread beat this one, then this returns the previously added entry.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.IsNotFullyPopulatedMap(System.Collections.Generic.IDictionary{`0,System.Collections.Immutable.ImmutableArray{`1}})">
            <summary>
            Determines if the given map is fully populated.
            </summary>
            <param name="existingMap">The map to test.</param>
            <returns>true if the map is fully populated.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.CreateFullyPopulatedMap(System.Collections.Concurrent.ConcurrentDictionary{`0,System.Collections.Immutable.ImmutableArray{`1}})">
            <summary>
            Create the fully populated map from an existing map and the key generator.
            </summary>
            <param name="existingMap">The existing map which may be null or a ConcurrentDictionary.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.CachingDictionary`2.EnsureFullyPopulated">
            <summary>
            Fully populate the underlying dictionary. Once this returns, the dictionary is guaranteed 
            to have every key in it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2">
            <summary>
            A MultiDictionary that allows only adding, and preserves the order of values added to the 
            dictionary. Thread-safe for reading, but not for adding.
            </summary>
            <remarks>
            Always uses the default comparer.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Add(`0,`1)">
            <summary>
            Add a value to the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Item(`0)">
            <summary>
            Get all values associated with K, in the order they were added.
            Returns empty read-only array if no values were present.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Keys">
            <summary>
            Get a collection of all the keys.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.ValueSet._value">
            <summary>
            Each value is either a single V or an <see cref="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1"/>.
            Never null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts">
            <summary>
            A set of ints that is small, thread-safe and lock free.
            Several assumptions have been made that allow it to be small and fast:
            1. Deletes never happen.
            2. The size is small. In dogfooding experiments, 89% had 4 or fewer elements and
               98% had 8 or fewer elements. The largest size was 17.
            3. As a result of assumption 2, linear look-up is good enough.
            4. One value, in this case int.MinValue, is used as a sentinel and may never appear in the set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts.Contains(System.Int32)">
            <summary>
            Determine if the given integer appears in the set.
            </summary>
            <param name="i">The value to look up.</param>
            <returns>true if <paramref name="i"/> appears in the set. false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts.Add(System.Int32)">
            <summary>
            Insert the given value into the set.
            </summary>
            <param name="i">The value to insert</param>
            <returns>true if <paramref name="i"/> was added. false if it was already present.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts.AddHelper(System.Int32@,System.Int32,System.Boolean@)">
            <summary>
            If the given slot is unoccupied, then try to replace it with a new value.
            </summary>
            <param name="slot">The slot to examine.</param>
            <param name="i">The new value to insert if the slot is unoccupied.</param>
            <param name="added">An out param indicating whether the slot was successfully updated.</param>
            <returns>true if the value in the slot either now contains, or already contained <paramref name="i"/>. false otherwise.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary">
            <summary>
            Provides methods for creating a segmented dictionary that is immutable; meaning it cannot be changed once it is
            created.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2">
             <summary>
             Represents a segmented dictionary that is immutable; meaning it cannot be changed once it is created.
             </summary>
             <remarks>
             <para>There are different scenarios best for <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> and others
             best for <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/>.</para>
            
             <para>In general, <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> is applicable in scenarios most like
             the scenarios where <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> is applicable, and
             <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> is applicable in scenarios most like the scenarios where
             <see cref="T:System.Collections.Immutable.ImmutableList`1"/> is applicable.</para>
            
             <para>The following table summarizes the performance characteristics of
             <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>:</para>
             
             <list type="table">
               <item>
                 <description>Operation</description>
                 <description><see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> Complexity</description>
                 <description><see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> Complexity</description>
                 <description>Comments</description>
               </item>
               <item>
                 <description>Item</description>
                 <description>O(1)</description>
                 <description>O(log n)</description>
                 <description>Directly index into the underlying segmented dictionary</description>
               </item>
               <item>
                 <description>Add()</description>
                 <description>O(n)</description>
                 <description>O(log n)</description>
                 <description>Requires creating a new segmented dictionary</description>
               </item>
             </list>
             
             <para>This type is backed by segmented arrays to avoid using the Large Object Heap without impacting algorithmic
             complexity.</para>
             </remarks>
             <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
             <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
             <devremarks>
             <para>This type has a documented contract of being exactly one reference-type field in size. Our own
             <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> class depends on it, as well as others externally.</para>
            
             <para><strong>IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS:</strong></para>
            
             <para>This type should be thread-safe. As a struct, it cannot protect its own fields from being changed from one
             thread while its members are executing on other threads because structs can change <em>in place</em> simply by
             reassigning the field containing this struct. Therefore it is extremely important that <strong>⚠⚠ Every member
             should only dereference <c>this</c> ONCE ⚠⚠</strong>. If a member needs to reference the
             <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2._dictionary"/> field, that counts as a dereference of <c>this</c>. Calling other instance members
             (properties or methods) also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more
             than once must instead assign <c>this</c> to a local variable and use that for the rest of the code instead.
             This effectively copies the one field in the struct to a local variable so that it is insulated from other
             threads.</para>
             </devremarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder._dictionary">
            <summary>
            The immutable collection this builder is based on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder._mutableDictionary">
            <summary>
            The current mutable collection this builder is operating on. This field is initialized to a copy of
            <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder._dictionary"/> the first time a change is made.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Enumerator.ReturnType.KeyValuePair">
            <summary>
            The return value from the implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/> is
            <see cref="T:System.Collections.Generic.KeyValuePair`2"/>. This is the return value for most instances of this
            enumerator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Enumerator.ReturnType.DictionaryEntry">
            <summary>
            The return value from the implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/> is
            <see cref="T:System.Collections.DictionaryEntry"/>. This is the return value for instances of this
            enumerator created by the <see cref="M:System.Collections.IDictionary.GetEnumerator"/> implementation in
            <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.PrivateInterlocked">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(``0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(``0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(``0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateBuilder``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateBuilder``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateBuilder``1(System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateBuilder``1(System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateRange``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateRange``1(System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateRange``1(System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.ToImmutableSegmentedHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.ToImmutableSegmentedHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.ToImmutableSegmentedHashSet``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}.Builder)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet``1(System.Collections.Immutable.ImmutableHashSet{``0}.Builder)"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder._set">
            <summary>
            The immutable collection this builder is based on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder._mutableSet">
            <summary>
            The current mutable collection this builder is operating on. This field is initialized to a copy of
            <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder._set"/> the first time a change is made.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.KeyComparer">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Builder.KeyComparer"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Count">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Builder.Count"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Add(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Add(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Clear">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Clear"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Contains(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.ExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IntersectWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Overlaps(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Remove(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.SetEquals(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.TryGetValue(`0,`0@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.TryGetValue(`0,`0@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.UnionWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.ToImmutable">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.ToImmutable"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator">
            <inheritdoc cref="T:System.Collections.Immutable.ImmutableHashSet`1.Enumerator"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.Current"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.Dispose">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.Dispose"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.MoveNext"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.Reset">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.Reset"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.PrivateInterlocked">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Empty">
            <inheritdoc cref="F:System.Collections.Immutable.ImmutableHashSet`1.Empty"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.KeyComparer">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.KeyComparer"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Count">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Count"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsEmpty">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.IsEmpty"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Add(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Add(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Clear">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Clear"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Contains(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Except(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Except(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Intersect(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Intersect(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Remove(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.SymmetricExcept(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.SymmetricExcept(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.TryGetValue(`0,`0@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.TryGetValue(`0,`0@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Union(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Union(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ToBuilder">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.ToBuilder"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.WithComparer(System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.WithComparer(System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.Create``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.Create``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.Create``1(``0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.Create``1(``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.Create``1(``0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.Create``1(``0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.CreateBuilder``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.CreateBuilder``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.CreateRange``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.ToImmutableSegmentedList``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.ToImmutableList``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.ToImmutableSegmentedList``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}.Builder)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.ToImmutableList``1(System.Collections.Immutable.ImmutableList{``0}.Builder)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1">
             <summary>
             Represents a segmented list that is immutable; meaning it cannot be changed once it is created.
             </summary>
             <remarks>
             <para>There are different scenarios best for <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> and others
             best for <see cref="T:System.Collections.Immutable.ImmutableList`1"/>.</para>
            
             <para>The following table summarizes the performance characteristics of
             <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/>:</para>
             
             <list type="table">
               <item>
                 <description>Operation</description>
                 <description><see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> Complexity</description>
                 <description><see cref="T:System.Collections.Immutable.ImmutableList`1"/> Complexity</description>
                 <description>Comments</description>
               </item>
               <item>
                 <description>Item</description>
                 <description>O(1)</description>
                 <description>O(log n)</description>
                 <description>Directly index into the underlying segmented list</description>
               </item>
               <item>
                 <description>Add()</description>
                 <description>Currently O(n), but could be O(1) with a relatively large constant</description>
                 <description>O(log n)</description>
                 <description>Currently requires creating a new segmented list, but could be modified to only clone the segments with changes</description>
               </item>
               <item>
                 <description>Insert()</description>
                 <description>O(n)</description>
                 <description>O(log n)</description>
                 <description>Requires creating a new segmented list and cloning all impacted segments</description>
               </item>
             </list>
             
             <para>This type is backed by segmented arrays to avoid using the Large Object Heap without impacting algorithmic
             complexity.</para>
             </remarks>
             <typeparam name="T">The type of the value in the list.</typeparam>
             <devremarks>
             <para>This type has a documented contract of being exactly one reference-type field in size. Our own
             <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> class depends on it, as well as others externally.</para>
            
             <para><strong>IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS:</strong></para>
            
             <para>This type should be thread-safe. As a struct, it cannot protect its own fields from being changed from one
             thread while its members are executing on other threads because structs can change <em>in place</em> simply by
             reassigning the field containing this struct. Therefore it is extremely important that <strong>⚠⚠ Every member
             should only dereference <c>this</c> ONCE ⚠⚠</strong>. If a member needs to reference the
             <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1._list"/> field, that counts as a dereference of <c>this</c>. Calling other instance members
             (properties or methods) also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more
             than once must instead assign <c>this</c> to a local variable and use that for the rest of the code instead.
             This effectively copies the one field in the struct to a local variable so that it is insulated from other
             threads.</para>
             </devremarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder._builder">
            <summary>
            The immutable collection this builder is based on.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ItemRef(System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ItemRef(System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.BinarySearch(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ConvertAll``1(System.Converter{`0,``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ConvertAll``1(System.Func{`0,``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.CopyTo(`0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.CopyTo(`0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.CopyTo(System.Int32,`0[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Exists(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Exists(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Find(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Find(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLast(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLast(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLastIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLastIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ForEach(System.Action{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ForEach(System.Action{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.GetRange(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.GetRange(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.IndexOf(`0,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.IndexOf(`0,System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.RemoveAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.RemoveAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Reverse">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Reverse"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Reverse(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Reverse(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort(System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort(System.Comparison{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Comparison{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ToImmutable">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ToImmutable"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.TrueForAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.TrueForAll(System.Predicate{`0})"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.PrivateInterlocked">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ValueBuilder._list">
            <summary>
            The immutable collection this builder is based on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ValueBuilder._mutableList">
            <summary>
            The current mutable collection this builder is operating on. This field is initialized to a copy of
            <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ValueBuilder._list"/> the first time a change is made.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Empty">
            <inheritdoc cref="F:System.Collections.Immutable.ImmutableList`1.Empty"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.IsEmpty">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableList`1.IsEmpty"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ItemRef(System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ItemRef(System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Add(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Add(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.BinarySearch(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.BinarySearch(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Clear">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Clear"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ConvertAll``1(System.Converter{`0,``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ConvertAll``1(System.Func{`0,``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.CopyTo(`0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.CopyTo(`0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Exists(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Exists(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Find(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Find(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLast(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLast(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLastIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ForEach(System.Action{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ForEach(System.Action{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.GetRange(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.GetRange(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Insert(System.Int32,`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Insert(System.Int32,`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Remove(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveAt(System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveAt(System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveRange(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveRange(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Replace(`0,`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Replace(`0,`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Reverse">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Reverse"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Reverse(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Reverse(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.SetItem(System.Int32,`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.SetItem(System.Int32,`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort(System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort(System.Comparison{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort(System.Comparison{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ToBuilder">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ToBuilder"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.TrueForAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.TrueForAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`1.SwapIfGreater(`0@,`0@)">
            <summary>Swaps the values in the two references if the first is greater than the second.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`1.Swap(`0@,`0@)">
            <summary>Swaps the values in the two references, regardless of whether the two references are the same.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortUtils">
            <summary>Helper methods for use in array/span sorting routines.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.BitHelper.ToIntArrayLength(System.Int32)">
            <summary>How many ints must be allocated to represent n bits. Returns (n+31)/32, but avoids overflow.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.HashHelpers.GetFastModMultiplier(System.UInt32)">
            <summary>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).</summary>
            <remarks>This should only be used on 64-bit.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.HashHelpers.FastMod(System.UInt32,System.UInt32,System.UInt64)">
            <summary>Performs a mod operation using the multiplier pre-computed with <see cref="M:Microsoft.CodeAnalysis.Collections.Internal.HashHelpers.GetFastModMultiplier(System.UInt32)"/>.</summary>
            <remarks>
            PERF: This improves performance in 64-bit scenarios at the expense of performance in 32-bit scenarios. Since
            we only build a single AnyCPU binary, we opt for improved performance in the 64-bit scenario.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.ICollection"/> members on value types that explicitly implement the
            member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls`1">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.Generic.ICollection`1"/> members on value types that explicitly implement
            the member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.IEnumerable"/> members on value types that explicitly implement the
            member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls`1">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.Generic.IEnumerable`1"/> members on value types that explicitly implement
            the member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.IListCalls">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.IList"/> members on value types that explicitly implement the
            member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior">
            <summary>
            Used internally to control behavior of insertion into a <see cref="T:System.Collections.Generic.Dictionary`2"/> or <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior.None">
            <summary>
            The default insertion behavior.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior.OverwriteExisting">
            <summary>
            Specifies that an existing entry with the same key should be overwritten if encountered.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior.ThrowOnExisting">
            <summary>
            Specifies that if an existing entry with the same key is encountered, an exception should be thrown.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.RoslynUnsafe.NullRef``1">
            <summary>
            Returns a by-ref to type <typeparamref name="T"/> that is a null reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.RoslynUnsafe.IsNullRef``1(``0@)">
            <summary>
            Returns if a given by-ref to type <typeparamref name="T"/> is a null reference.
            </summary>
            <remarks>
            This check is conceptually similar to <c>(void*)(&amp;source) == nullptr</c>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.FastPathMethodImplOptions">
            <summary>
            A combination of <see cref="F:System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining"/> and
            <see cref="F:System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateSegmentSize(System.Int32)">
            <summary>
            Calculates the maximum number of elements of size <paramref name="elementSize"/> which can fit into an array
            which has the following characteristics:
            <list type="bullet">
            <item><description>The array can be allocated in the small object heap.</description></item>
            <item><description>The array length is a power of 2.</description></item>
            </list>
            </summary>
            <param name="elementSize">The size of the elements in the array.</param>
            <returns>The segment size to use for small object heap segmented arrays.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateSegmentShift(System.Int32)">
            <summary>
            Calculates a shift which can be applied to an absolute index to get the page index within a segmented array.
            </summary>
            <param name="segmentSize">The number of elements in each page of the segmented array. Must be a power of 2.</param>
            <returns>The shift to apply to the absolute index to get the page index within a segmented array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateOffsetMask(System.Int32)">
            <summary>
            Calculates a mask, which can be applied to an absolute index to get the index within a page of a segmented
            array.
            </summary>
            <param name="segmentSize">The number of elements in each page of the segmented array. Must be a power of 2.</param>
            <returns>The bit mask to obtain the index within a page from an absolute index within a segmented array.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.SegmentedHashSetEqualityComparer`1">
            <summary>Equality comparer for hashsets of hashsets</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_ArrayPlusOffTooSmall">
            <summary>Destination array is not long enough to copy all the items in the collection. Check array index and length.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_HTCapacityOverflow">
            <summary>Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_KeyNotFoundWithKey">
            <summary>The given key '{0}' was not present in the dictionary.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_LongerThanDestArray">
            <summary>Destination array was not long enough. Check the destination index, length, and the array's lower bounds.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_LongerThanSrcArray">
            <summary>Source array was not long enough. Check the source index, length, and the array's lower bounds.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_NonZeroLowerBound">
            <summary>The lower bound of target array must be zero.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_RankMultiDimNotSupported">
            <summary>Only single dimensional arrays are supported for the requested action.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_WrongType">
            <summary>The value "{0}" is not of type "{1}" and cannot be used in this generic collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Argument_AddingDuplicateWithKey">
            <summary>An item with the same key has already been added. Key: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Argument_InvalidArrayType">
            <summary>Target array type is not compatible with the type of items in the collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Argument_InvalidOffLen">
            <summary>Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_ArrayLB">
            <summary>Number was less than the array's lower bound in the first dimension.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_BiggerThanCollection">
            <summary>Larger than collection size.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_Count">
            <summary>Count must be positive and count must refer to a location within the string/array/collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_Index">
            <summary>Index was out of range. Must be non-negative and less than the size of the collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_ListInsert">
            <summary>Index must be within the bounds of the List.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_NeedNonNegNum">
            <summary>Non-negative number required.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_SmallCapacity">
            <summary>capacity was less than the current size.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_ConcurrentOperationsNotSupported">
            <summary>Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_EnumFailedVersion">
            <summary>Collection was modified; enumeration operation may not execute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_EnumOpCantHappen">
            <summary>Enumeration has either not started or has already finished.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_IComparerFailed">
            <summary>Failed to compare two elements in the array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.NotSupported_KeyCollectionSet">
            <summary>Mutating a key collection derived from a dictionary is not allowed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.NotSupported_ValueCollectionSet">
            <summary>Mutating a value collection derived from a dictionary is not allowed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Rank_MustMatch">
            <summary>The specified arrays must have the same number of dimensions.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.NotSupported_FixedSizeCollection">
            <summary>Collection was of a fixed size.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentException_OtherNotArrayOfCorrectLength">
            <summary>Object is not a array with the same number of elements as the array to compare it to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_BogusIComparer">
            <summary>Unable to sort because the IComparer.Compare() method returns inconsistent results. Either a value does not compare equal to itself, or one value repeatedly compared to another value yields different results. IComparer: '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.CannotFindOldValue">
            <summary>Cannot find the old value</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}})">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free,
            as it may run multiple times when races occur with other threads.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0},``1,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}},``1)">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <typeparam name="TArg">The type of argument passed to the <paramref name="transformer"/>.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free, as it may run multiple times
            when races occur with other threads.</param>
            <param name="transformerArgument">The argument to pass to <paramref name="transformer"/>.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})">
            <summary>
            Assigns a field or variable containing an immutable list to the specified value and returns the previous
            value.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedCompareExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})">
            <summary>
            Assigns a field or variable containing an immutable list to the specified value if it is currently equal to
            another specified value. Returns the previous value.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <param name="comparand">The value to check equality for before assigning.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedInitialize``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})">
            <summary>
            Assigns a field or variable containing an immutable list to the specified value if it is has not yet been
            initialized.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns><see langword="true"/> if the field was assigned the specified value; otherwise,
            <see langword="false"/> if it was previously initialized.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}})">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free,
            as it may run multiple times when races occur with other threads.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0},``1,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}},``1)">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <typeparam name="TArg">The type of argument passed to the <paramref name="transformer"/>.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free, as it may run multiple times
            when races occur with other threads.</param>
            <param name="transformerArgument">The argument to pass to <paramref name="transformer"/>.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})">
            <summary>
            Assigns a field or variable containing an immutable set to the specified value and returns the
            previous value.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedCompareExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})">
            <summary>
            Assigns a field or variable containing an immutable set to the specified value if it is currently
            equal to another specified value. Returns the previous value.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <param name="comparand">The value to check equality for before assigning.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedInitialize``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})">
            <summary>
            Assigns a field or variable containing an immutable set to the specified value if it is has not yet
            been initialized.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns><see langword="true"/> if the field was assigned the specified value; otherwise,
            <see langword="false"/> if it was previously initialized.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}})">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free,
            as it may run multiple times when races occur with other threads.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``3(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},``2,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}},``2)">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <typeparam name="TArg">The type of argument passed to the <paramref name="transformer"/>.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free, as it may run multiple times
            when races occur with other threads.</param>
            <param name="transformerArgument">The argument to pass to <paramref name="transformer"/>.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedExchange``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value and returns the
            previous value.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedCompareExchange``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value if it is currently
            equal to another specified value. Returns the previous value.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <param name="comparand">The value to check equality for before assigning.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedInitialize``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value if it is has not yet
            been initialized.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns><see langword="true"/> if the field was assigned the specified value; otherwise,
            <see langword="false"/> if it was previously initialized.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``3(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``2,``1},``2)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``3(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``2,``1},``2)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.AddOrUpdate``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``1},System.Func{``0,``1,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1},System.Func{``0,``1,``1})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.AddOrUpdate``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1,System.Func{``0,``1,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,System.Func{``0,``1,``1})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryAdd``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryUpdate``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,``1)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryRemove``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryRemove``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedArray.Clear``1(Microsoft.CodeAnalysis.Collections.SegmentedArray{``0},System.Int32,System.Int32)">
            <seealso cref="M:System.Array.Clear(System.Array,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedArray.Copy``1(Microsoft.CodeAnalysis.Collections.SegmentedArray{``0},Microsoft.CodeAnalysis.Collections.SegmentedArray{``0},System.Int32)">
            <seealso cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1">
            <summary>
            Defines a fixed-size collection with the same API surface and behavior as an "SZArray", which is a
            single-dimensional zero-based array commonly represented in C# as <c>T[]</c>. The implementation of this
            collection uses segmented arrays to avoid placing objects on the Large Object Heap.
            </summary>
            <typeparam name="T">The type of elements stored in the array.</typeparam>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.SegmentSize">
             <summary>
             The number of elements in each page of the segmented array of type <typeparamref name="T"/>.
             </summary>
             <remarks>
             <para>The segment size is calculated according to <see cref="M:System.Runtime.CompilerServices.Unsafe.SizeOf``1"/>, performs the IL operation
             defined by <see cref="F:System.Reflection.Emit.OpCodes.Sizeof"/>. ECMA-335 defines this operation with the following note:</para>
            
             <para><c>sizeof</c> returns the total size that would be occupied by each element in an array of this type –
             including any padding the implementation chooses to add. Specifically, array elements lie <c>sizeof</c>
             bytes apart.</para>
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.SegmentShift">
            <summary>
            The bit shift to apply to an array index to get the page index within <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedArray`1._items"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.OffsetMask">
            <summary>
            The bit mask to apply to an array index to get the index within a page of <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedArray`1._items"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2">
            <summary>
            Represents a collection of keys and values.
            </summary>
            <remarks>
            <para>This collection has the same performance characteristics as <see cref="T:System.Collections.Generic.Dictionary`2"/>, but
            uses segmented arrays to avoid allocations in the Large Object Heap.</para>
            </remarks>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the dictionary can hold up to 'capacity' entries without any further expansion of its backing storage
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.TrimExcess">
             <summary>
             Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries
             </summary>
             <remarks>
             This method can be used to minimize the memory overhead
             once it is known that no new elements will be added.
            
             To allocate minimum size storage array, execute the following statements:
            
             dictionary.Clear();
             dictionary.TrimExcess();
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.TrimExcess(System.Int32)">
            <summary>
            Sets the capacity of this dictionary to hold up 'capacity' entries without any further expansion of its backing storage
            </summary>
            <remarks>
            This method can be used to minimize the memory overhead
            once it is known that no new elements will be added.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.Entry._next">
            <summary>
            0-based index of next entry in chain: -1 means end of chain
            also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,
            so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.StackAllocThreshold">
            <summary>Cutoff point for stackallocs. This corresponds to the number of ints.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.ShrinkThreshold">
            <summary>
            When constructing a hashset from an existing collection, it may contain duplicates,
            so this is used as the max acceptable excess ratio of capacity to count. Note that
            this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
            a lot of adds followed by removes. Users must explicitly shrink by calling TrimExcess.
            This is set to 3 because capacity is acceptable as 2x rounded up to nearest prime.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.ConstructFrom(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
            <summary>Initializes the SegmentedHashSet from another SegmentedHashSet with the same element type and equality comparer.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Clear">
            <summary>Removes all elements from the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Contains(`0)">
            <summary>Determines whether the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> contains the specified element.</summary>
            <param name="item">The element to locate in the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object contains the specified element; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.FindItemIndex(`0)">
            <summary>Gets the index of the item in <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1._entries"/>, or -1 if it's not in the set.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.GetBucketRef(System.Int32)">
            <summary>Gets a reference to the specified hashcode's bucket, containing an index into <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1._entries"/>.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Count">
            <summary>Gets the number of elements that are contained in the set.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Add(`0)">
            <summary>Adds the specified element to the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/>.</summary>
            <param name="item">The element to add to the set.</param>
            <returns>true if the element is added to the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object; false if the element is already present.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.TryGetValue(`0,`0@)">
            <summary>Searches the set for a given value and returns the equal value it finds, if any.</summary>
            <param name="equalValue">The value to search for.</param>
            <param name="actualValue">The value from the set that the search found, or the default value of <typeparamref name="T"/> when the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of
            a newly constructed one (so that more sharing of references can occur) or to look up
            a value that has more complete data than the value you currently have, although their
            comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Modifies the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to contain all elements that are present in itself, the specified collection, or both.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Modifies the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to contain only elements that are present in that object and in the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes all elements in the specified collection from the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Modifies the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to contain only elements that are present either in that object or in the specified collection, but not both.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a subset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a subset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper subset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper subset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper superset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a superset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper superset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper superset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object and a specified collection share common elements.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object and <paramref name="other"/> share at least one common element; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object and the specified collection contain the same elements.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is equal to <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the elements of a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to an array, starting at the specified array index.</summary>
            <param name="array">The destination array.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.RemoveWhere(System.Predicate{`0})">
            <summary>Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Comparer">
            <summary>Gets the <see cref="T:System.Collections.IEqualityComparer"/> object that is used to determine equality for the values in the set.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.EnsureCapacity(System.Int32)">
            <summary>Ensures that this hash set can hold the specified number of elements without growing.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.TrimExcess">
            <summary>
            Sets the capacity of a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to the actual number of elements it contains,
            rounded up to a nearby, implementation-specific value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.CreateSetComparer">
            <summary>Returns an <see cref="T:System.Collections.IEqualityComparer"/> object that can be used for equality testing of a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Initialize(System.Int32)">
            <summary>
            Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
            greater than or equal to capacity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.AddIfNotPresent(`0,System.Int32@)">
            <summary>Adds the specified element to the set if it's not already contained.</summary>
            <param name="value">The element to add to the set.</param>
            <param name="location">The index into <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1._entries"/> of the element.</param>
            <returns>true if the element is added to the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object; false if the element is already present.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.ContainsAllElements(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this contains of other's elements. Iterates over other's elements and
            returns false as soon as it finds an element in other that's not in this.
            Used by SupersetOf, ProperSupersetOf, and SetEquals.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsSubsetOfHashSetWithSameComparer(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
             <summary>
             Implementation Notes:
             If other is a hashset and is using same equality comparer, then checking subset is
             faster. Simply check that each element in this is in other.
            
             Note: if other doesn't use same equality comparer, then Contains check is invalid,
             which is why callers must take are of this.
            
             If callers are concerned about whether this is a proper subset, they take care of that.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IntersectWithHashSetWithSameComparer(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster
            because we can use other's Contains
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IntersectWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Iterate over other. If contained in this, mark an element in bit array corresponding to
             its position in _slots. If anything is unmarked (in bit array), remove it.
            
             This attempts to allocate on the stack, if below StackAllocThreshold.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SymmetricExceptWithUniqueHashSet(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
             <summary>
             if other is a set, we can assume it doesn't have duplicate elements, so use this
             technique: if can't remove, then it wasn't present in this set, so add.
            
             As with other methods, callers take care of ensuring that other is a hashset using the
             same equality comparer.
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SymmetricExceptWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Implementation notes:
            
             Used for symmetric except when other isn't a SegmentedHashSet. This is more tedious because
             other may contain duplicates. SegmentedHashSet technique could fail in these situations:
             1. Other has a duplicate that's not in this: SegmentedHashSet technique would add then
             remove it.
             2. Other has a duplicate that's in this: SegmentedHashSet technique would remove then add it
             back.
             In general, its presence would be toggled each time it appears in other.
            
             This technique uses bit marking to indicate whether to add/remove the item. If already
             present in collection, it will get marked for deletion. If added from other, it will
             get marked as something not to remove.
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.CheckUniqueAndUnfoundElements(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
             <summary>
             Determines counts that can be used to determine equality, subset, and superset. This
             is only used when other is an IEnumerable and not a SegmentedHashSet. If other is a SegmentedHashSet
             these properties can be checked faster without use of marking because we can assume
             other has no duplicates.
            
             The following count checks are performed by callers:
             1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = _count; i.e. everything
             in other is in this and everything in this is in other
             2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = _count; i.e. other may
             have elements not in this and everything in this is in other
             3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = _count; i.e
             other must have at least one element not in this and everything in this is in other
             4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
             than _count; i.e. everything in other was in this and this had at least one element
             not contained in other.
            
             An earlier implementation used delegates to perform these checks rather than returning
             an ElementCount struct; however this was changed due to the perf overhead of delegates.
             </summary>
             <param name="other"></param>
             <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
             because unfoundCount must be 0.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.EqualityComparersAreEqual(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0},Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can
            speed up if it knows the other item has unique elements. I.e. if they're using
            different equality comparers, then uniqueness assumption between sets break.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Entry._next">
            <summary>
            0-based index of next entry in chain: -1 means end of chain
            also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,
            so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1">
            <summary>
            Represents a strongly typed list of objects that can be accessed by index. Provides methods to search, sort, and
            manipulate lists.
            </summary>
            <remarks>
            <para>This collection has the same performance characteristics as <see cref="T:System.Collections.Generic.List`1"/>, but uses segmented
            arrays to avoid allocations in the Large Object Heap.</para>
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConsListExtensions">
            <summary>
            Extension methods associated with ConsList.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DictionaryExtensions">
            <summary>
            The collection of extension methods for the <see cref="T:System.Collections.Generic.Dictionary`2"/> type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
            If the given key is not found in the dictionary, add it with the given value and return the value.
            Otherwise return the existing value associated with that key.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Grouping`2">
            <summary>
            A simple class to implement IGrouping.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IdentifierCollection">
            <summary>
            A dictionary that maps strings to all known spellings of that string. Can be used to
            efficiently store the set of known type names for a module for both VB and C# while also
            answering questions like "do you have a type called Goo" in either a case sensitive or
            insensitive manner.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ImmutableArrayExtensions">
            <summary>
            The collection of extension methods for the <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <exception cref="T:System.ArgumentNullException">If items is null (default)</exception>
            <remarks>If the sequence is null, this will throw <see cref="T:System.ArgumentNullException"/></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return an empty array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(``0[])">
            <summary>
            Converts an array to an immutable array. The array must not be null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(``0[])">
            <summary>
            Converts a array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(``0[])">
            <summary>
            Converts an array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns>If the array is null, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ToImmutable(System.IO.MemoryStream)">
            <summary>
            Reads bytes from specified <see cref="T:System.IO.MemoryStream"/>.
            </summary>
            <param name="stream">The stream.</param>
            <returns>Read-only content of the stream.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1})">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Int32,``1,``2},``1)">
            <summary>
             Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>
            Maps a subset of immutable array to another immutable array.
            </summary>
            <typeparam name="TItem">Type of the source array items</typeparam>
            <typeparam name="TResult">Type of the transformed array items</typeparam>
            <param name="array">The array to transform</param>
            <param name="predicate">The condition to use for filtering the array content.</param>
            <param name="selector">A transform function to apply to each element that is not filtered out by <paramref name="predicate"/>.</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArrayAsync``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{``1}},System.Threading.CancellationToken)">
            <summary>
            Maps an immutable array through a function that returns ValueTasks, returning the new ImmutableArray.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ZipAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``1},System.Func{``0,``1,``2})">
            <summary>
            Zips two immutable arrays together through a mapping function, producing another immutable array.
            </summary>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``1(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean})">
            <summary>
            Creates a new immutable array based on filtered elements by the predicate. The array must not be null.
            </summary>
            <param name="array">The array to process</param>
            <param name="predicate">The delegate that defines the conditions of the element to search for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,System.Boolean},``1)">
            <summary>
            Creates a new immutable array based on filtered elements by the predicate. The array must not be null.
            </summary>
            <param name="array">The array to process</param>
            <param name="predicate">The delegate that defines the conditions of the element to search for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Cast``2(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Casts the immutable array of a Type to an immutable array of its base type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SetEquals``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether this instance and another immutable array are equal.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array1"></param>
            <param name="array2"></param>
            <param name="comparer">The comparer to determine if the two arrays are equal.</param>
            <returns>True if the two arrays are equal</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Returns an empty array if the input array is null (default)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty``1(System.Nullable{System.Collections.Immutable.ImmutableArray{``0}})">
            <summary>
            Returns an empty array if the input nullable value type is null or the underlying array is null (default)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Distinct``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns an array of distinct elements, preserving the order in the original array.
            If the array has no duplicates, the original array is returned. The original array must not be null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rope">
            <summary>
            A representation of a string of characters that requires O(1) extra space to concatenate two ropes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rope.ForString(System.String)">
            <summary>
            A rope can wrap a simple string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rope.Concat(Microsoft.CodeAnalysis.Rope,Microsoft.CodeAnalysis.Rope)">
            <summary>
            A rope can be formed from the concatenation of two ropes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rope.Equals(System.Object)">
            <summary>
            Two ropes are "the same" if they represent the same sequence of characters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rope.StringRope">
            <summary>
            A rope that wraps a simple string.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rope.ConcatRope">
            <summary>
            A rope that represents the concatenation of two ropes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SmallDictionary`2">
             <summary>
             Dictionary designed to hold small number of items.
             Compared to the regular Dictionary, average overhead per-item is roughly the same, but 
             unlike regular dictionary, this one is based on an AVL tree and as such does not require 
             rehashing when items are added.
             It does require rebalancing, but that is allocation-free.
            
             Major caveats:
              1) There is no Remove method. (can be added, but we do not seem to use Remove that much)
              2) foreach [keys|values|pairs] may allocate a small array.
              3) Performance is no longer O(1). At a certain count it becomes slower than regular Dictionary.
                 In comparison to regular Dictionary on my machine:
                    On trivial number of elements (5 or so) it is more than 2x faster.
                    The break even count is about 120 elements for read and 55 for write operations (with unknown initial size).
                    At UShort.MaxValue elements, this dictionary is 6x slower to read and 4x slower to write
            
             Generally, this dictionary is a win if number of elements is small, not known beforehand or both.
            
             If the size of the dictionary is known at creation and it is likely to contain more than 10 elements, 
             then regular Dictionary is a better choice.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArrayExtensions.AsRef``1(Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{``0}@)">
             <summary>
             Gets a mutable reference to a <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/> stored in a <c>using</c> variable.
             </summary>
             <remarks>
             <para>This supporting method allows <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/>, a non-copyable <see langword="struct"/>
             implementing <see cref="T:System.IDisposable"/>, to be used with <c>using</c> statements while still allowing them to
             be passed by reference in calls. The following two calls are equivalent:</para>
            
             <code>
             using var array = TemporaryArray&lt;T&gt;.Empty;
            
             // Using the 'Unsafe.AsRef' method
             Method(ref Unsafe.AsRef(in array));
            
             // Using this helper method
             Method(ref array.AsRef());
             </code>
            
             <para>⚠ Do not move or rename this method without updating the corresponding
             <see href="https://github.com/dotnet/roslyn-analyzers/blob/30180a51af8c4711e51d98df7345f14d083efb63/src/Roslyn.Diagnostics.Analyzers/Core/TemporaryArrayAsRefAnalyzer.cs">RS0049</see>
             analyzer.</para>
             </remarks>
             <typeparam name="T">The type of element stored in the temporary array.</typeparam>
             <param name="array">A read-only reference to a temporary array which is part of a <c>using</c> statement.</param>
             <returns>A mutable reference to the temporary array.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1">
            <summary>
            Provides temporary storage for a collection of elements. This type is optimized for handling of small
            collections, particularly for cases where the collection will eventually be discarded or used to produce an
            <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.
            </summary>
            <remarks>
            This type stores small collections on the stack, with the ability to transition to dynamic storage if/when
            larger number of elements are added.
            </remarks>
            <typeparam name="T">The type of elements stored in the collection.</typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.InlineCapacity">
            <summary>
            The number of elements the temporary can store inline. Storing more than this many elements requires the
            array transition to dynamic storage.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0">
            <summary>
            The first inline element.
            </summary>
            <remarks>
            This field is only used when <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/> is <see langword="null"/>. In other words, this type
            stores elements inline <em>or</em> stores them in <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/>, but does not use both approaches
            at the same time.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item1">
            <summary>
            The second inline element.
            </summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item2">
            <summary>
            The third inline element.
            </summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item3">
            <summary>
            The fourth inline element.
            </summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._count">
            <summary>
            The number of inline elements held in the array. This value is only used when <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/> is
            <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder">
            <summary>
            A builder used for dynamic storage of collections that may exceed the limit for inline elements.
            </summary>
            <remarks>
            This field is initialized to non-<see langword="null"/> the first time the <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/>
            needs to store more than four elements. From that point, <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/> is used instead of inline
            elements, even if items are removed to make the result smaller than four elements.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.ToImmutableAndClear">
            <summary>
            Create an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> with the elements currently held in the temporary array, and clear
            the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.MoveInlineToBuilder">
            <summary>
            Transitions the current <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/> from inline storage to dynamic storage storage. An
            <see cref="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1"/> instance is taken from the shared pool, and all elements currently in inline
            storage are added to it. After this point, dynamic storage will be used instead of inline storage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.ThrowIndexOutOfRangeException">
            <summary>
            Throws <see cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <remarks>
            This helper improves the ability of the JIT to inline callers.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TopologicalSort">
            <summary>
            A helper class that contains a topological sort algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TopologicalSort.TryIterativeSort``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Immutable.ImmutableArray{``0}},System.Collections.Immutable.ImmutableArray{``0}@)">
            <summary>
            Produce a topological sort of a given directed acyclic graph, given a set of nodes which include all nodes
            that have no predecessors. Any nodes not in the given set, but reachable through successors, will be added
            to the result. This is an iterative rather than recursive implementation, so it is unlikely to cause a stack
            overflow.
            </summary>
            <typeparam name="TNode">The type of the node</typeparam>
            <param name="nodes">Any subset of the nodes that includes all nodes with no predecessors</param>
            <param name="successors">A function mapping a node to its set of successors</param>
            <param name="result">A list of all reachable nodes, in which each node always precedes its successors</param>
            <returns>true if successful; false if not successful due to cycles in the graph</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnionCollection`1">
            <summary>
            Implements a readonly collection over a set of existing collections. This can be used to
            prevent having to copy items from one collection over to another (thus bloating space).
            
            Note: this is a *collection*, not a *set*.  There is no removal of duplicated elements. This
            allows us to be able to efficiently do operations like CopyTo, Count, etc. in O(c) time
            instead of O(n) (where 'c' is the number of collections and 'n' is the number of elements).
            If you have a few collections with many elements in them, then this is an appropriate
            collection for you.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AnalyzerConfig">
            <summary>
            Represents a single EditorConfig file, see https://editorconfig.org for details about the format.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerConfig.GlobalKey">
            <summary>
            Key that indicates if this config is a global config
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerConfig.GlobalLevelKey">
            <summary>
            Key that indicates the precedence of this config when <see cref="P:Microsoft.CodeAnalysis.AnalyzerConfig.IsGlobal"/> is true
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerConfig.UserGlobalConfigName">
            <summary>
            Filename that indicates this file is a user provided global config
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.ReservedKeys">
            <summary>
            A set of keys that are reserved for special interpretation for the editorconfig specification.
            All values corresponding to reserved keys in a (key,value) property pair are always lowercased
            during parsing.
            </summary>
            <remarks>
            This list was retrieved from https://github.com/editorconfig/editorconfig/wiki/EditorConfig-Properties
            at 2018-04-21 19:37:05Z. New keys may be added to this list in newer versions, but old ones will
            not be removed.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.ReservedValues">
            <summary>
            A set of values that are reserved for special use for the editorconfig specification
            and will always be lower-cased by the parser.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.NormalizedDirectory">
            <summary>
            The directory the editorconfig was contained in, with all directory separators
            replaced with '/'.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.PathToFile">
            <summary>
            The path passed to <see cref="M:Microsoft.CodeAnalysis.AnalyzerConfig.Parse(System.String,System.String)"/> during construction.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.DirectoryLengthComparer">
            <summary>
            Comparer for sorting <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfig"/> files by <see cref="P:Microsoft.CodeAnalysis.AnalyzerConfig.NormalizedDirectory"/> path length.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.IsRoot">
            <summary>
            Gets whether this editorconfig is a topmost editorconfig.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.IsGlobal">
            <summary>
            Gets whether this editorconfig is a global editorconfig.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.GlobalLevel">
            <summary>
            Get the global level of this config, used to resolve conflicting keys
            </summary>
            <remarks>
            A user can explicitly set the global level via the <see cref="F:Microsoft.CodeAnalysis.AnalyzerConfig.GlobalLevelKey"/>.
            When no global level is explicitly set, we use a heuristic:
             <list type="bullet">
                <item><description>
                Any file matching the <see cref="F:Microsoft.CodeAnalysis.AnalyzerConfig.UserGlobalConfigName"/> is determined to be a user supplied global config and gets a level of 100
                </description></item>
                <item><description>
                Any other file gets a default level of 0
                </description></item>
             </list>
             
            This value is unused when <see cref="P:Microsoft.CodeAnalysis.AnalyzerConfig.IsGlobal"/> is <c>false</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfig.Parse(System.String,System.String)">
            <summary>
            Parses an editor config file text located at the given path. No parsing
            errors are reported. If any line contains a parse error, it is dropped.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfig.Parse(Microsoft.CodeAnalysis.Text.SourceText,System.String)">
            <summary>
            Parses an editor config file text located at the given path. No parsing
            errors are reported. If any line contains a parse error, it is dropped.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AnalyzerConfig.Section">
            <summary>
            Represents a named section of the editorconfig file, which consists of a name followed by a set
            of key-value pairs.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.Section.NameComparer">
            <summary>
            Used to compare <see cref="P:Microsoft.CodeAnalysis.AnalyzerConfig.Section.Name"/>s of sections. Specified by editorconfig to
            be a case-sensitive comparison.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.Section.NameEqualityComparer">
            <summary>
            Used to compare <see cref="P:Microsoft.CodeAnalysis.AnalyzerConfig.Section.Name"/>s of sections. Specified by editorconfig to
            be a case-sensitive comparison.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.Section.PropertiesKeyComparer">
            <summary>
            Used to compare keys in <see cref="P:Microsoft.CodeAnalysis.AnalyzerConfig.Section.Properties"/>. The editorconfig spec defines property
            keys as being compared case-insensitively according to Unicode lower-case rules.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.Section.Name">
            <summary>
            For regular files, the name as present directly in the section specification of the editorconfig file. For sections in
            global configs, this is the unescaped full file path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfig.Section.Properties">
            <summary>
            Keys and values for this section. All keys are lower-cased according to the
            EditorConfig specification and keys are compared case-insensitively. Values are
            lower-cased if the value appears in <see cref="P:Microsoft.CodeAnalysis.AnalyzerConfig.ReservedValues" />
            or if the corresponding key is in <see cref="P:Microsoft.CodeAnalysis.AnalyzerConfig.ReservedKeys" />. Otherwise,
            the values are the literal values present in the source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfig.TryCreateSectionNameMatcher(System.String)">
            <summary>
            Takes a <see cref="P:Microsoft.CodeAnalysis.AnalyzerConfig.Section.Name"/> and creates a matcher that
            matches the given language. Returns null if the section name is
            invalid.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfig.IsAbsoluteEditorConfigPath(System.String)">
            <summary>
            Test if a section name is an absolute path with no special chars
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfig.TryCompilePathList(Microsoft.CodeAnalysis.AnalyzerConfig.SectionNameLexer@,System.Text.StringBuilder,System.Boolean,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.ValueTuple{System.Int32,System.Int32}})">
            <summary>
            <![CDATA[
            <path-list> ::= <path-item> | <path-item> <path-list>
            <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
            <char> ::= any unicode character
            <choice> ::= "{" <choice-list> "}"
            <choice-list> ::= <path-list> | <path-list> "," <choice-list>
            ]]>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfig.TryCompileCharacterClass(Microsoft.CodeAnalysis.AnalyzerConfig.SectionNameLexer@,System.Text.StringBuilder)">
            <summary>
            Compile a globbing character class of the form [...]. Returns true if
            the character class was successfully compiled. False if there was a syntax
            error. The starting character is expected to be directly after the '['.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfig.TryCompileChoice(Microsoft.CodeAnalysis.AnalyzerConfig.SectionNameLexer@,System.Text.StringBuilder,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.ValueTuple{System.Int32,System.Int32}})">
            <summary>
            Parses choice defined by the following grammar:
            <![CDATA[
            <choice> ::= "{" <choice-list> "}"
            <choice-list> ::= <path-list> | <path-list> "," <choice-list>
            ]]>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfig.TryParseNumberRange(Microsoft.CodeAnalysis.AnalyzerConfig.SectionNameLexer@)">
            <summary>
            Parses range defined by the following grammar.
            <![CDATA[
            <range> ::= "{" <integer> ".." <integer> "}"
            <integer> ::= "-" <digit-list> | <digit-list>
            <digit-list> ::= <digit> | <digit> <digit-list>
            <digit> ::= 0-9
            ]]>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfig.SectionNameLexer.EatCurrentCharacter">
            <summary>
            Call after getting <see cref="F:Microsoft.CodeAnalysis.AnalyzerConfig.TokenKind.SimpleCharacter" /> from <see cref="M:Microsoft.CodeAnalysis.AnalyzerConfig.SectionNameLexer.Lex" />
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfig.SectionNameLexer.TryEatCurrentCharacter(System.Char@)">
            <summary>
            Returns false if there are no more characters in the lex stream.
            Otherwise, produces the next character in the stream and returns true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfig.SectionNameLexer.TryLexNumber">
            <summary>
            Returns the string representation of a decimal integer, or null if
            the current lexeme is not an integer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AnalyzerConfigOptionsResult">
            <summary>
            Holds results from <see cref="M:Microsoft.CodeAnalysis.AnalyzerConfigSet.GetOptionsForSourcePath(System.String)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfigOptionsResult.TreeOptions">
            <summary>
            Options that customize diagnostic severity as reported by the compiler.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfigOptionsResult.AnalyzerOptions">
            <summary>
            Options that do not have any special compiler behavior and are passed to analyzers as-is.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfigOptionsResult.Diagnostics">
            <summary>
            Any produced diagnostics while applying analyzer configuration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AnalyzerConfigSet">
            <summary>
            Represents a set of <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfig"/>, and can compute the effective analyzer options for a given source file. This is used to
            collect all the <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfig"/> files for that would apply to a compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerConfigSet._analyzerConfigs">
            <summary>
            The list of <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfig" />s in this set. This list has been sorted per <see cref="P:Microsoft.CodeAnalysis.AnalyzerConfig.DirectoryLengthComparer"/>.
            This does not include any of the global configs that were merged into <see cref="F:Microsoft.CodeAnalysis.AnalyzerConfigSet._globalConfig"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerConfigSet._analyzerMatchers">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfig.SectionNameMatcher"/>s for each section. The entries in the outer array correspond to entries in <see cref="F:Microsoft.CodeAnalysis.AnalyzerConfigSet._analyzerConfigs"/>, and each inner array
            corresponds to each <see cref="P:Microsoft.CodeAnalysis.AnalyzerConfig.NamedSections"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzerConfigSet.GlobalConfigOptions">
            <summary>
            Gets an <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigOptionsResult"/> that contain the options that apply globally
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfigSet.GetOptionsForSourcePath(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigOptionsResult"/> for a source file. This computes which <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfig"/> rules applies to this file, and correctly applies
            precedence rules if there are multiple rules for the same file.
            </summary>
            <param name="sourcePath">The path to a file such as a source file or additional file. Must be non-null.</param>
            <remarks>This method is safe to call from multiple threads.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerConfigSet.MergeGlobalConfigs(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.AnalyzerConfig},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}@)">
            <summary>
            Merge any partial global configs into a single global config, and remove the partial configs
            </summary>
            <param name="analyzerConfigs">An <see cref="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1"/> of <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfig"/> containing a mix of regular and unmerged partial global configs</param>
            <param name="diagnostics">Diagnostics produced during merge will be added to this bag</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigSet.GlobalAnalyzerConfig" /> that contains the merged partial configs, or <c>null</c> if there were no partial configs</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AnalyzerConfigSet.GlobalAnalyzerConfigBuilder">
            <summary>
            Builds a global analyzer config from a series of partial configs
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AnalyzerConfigSet.GlobalAnalyzerConfig">
            <summary>
            Represents a combined global analyzer config.
            </summary>
            <remarks>
            We parse all <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfig"/>s as individual files, according to the editorconfig spec.
            
            However, when viewing the configs as an <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigSet"/> if multiple files have the
            <c>is_global</c> property set to <c>true</c> we combine those files and treat them as a single 
            'logical' global config file. This type represents that combined file. 
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineAnalyzerReference">
            <summary>
            Describes a command line analyzer assembly specification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineAnalyzerReference.FilePath">
            <summary>
            Assembly file path.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineArguments">
            <summary>
            The base class for representing command line arguments to a
            <see cref="T:Microsoft.CodeAnalysis.CommonCompiler"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.InteractiveMode">
            <summary>
            Drop to an interactive loop. If a script is specified in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.SourceFiles"/> executes the script first.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.BaseDirectory">
            <summary>
            Directory used to resolve relative paths stored in the arguments.
            </summary>
            <remarks>
            Except for paths stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences"/>, all
            paths stored in the properties of this class are resolved and
            absolute. This is the directory that relative paths specified on
            command line were resolved against.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.PathMap">
            <summary>
            A list of pairs of paths. This stores the value of the command-line compiler
            option /pathMap:X1=Y1;X2=Y2... which causes a prefix of X1 followed by a path
            separator to be replaced by Y1 followed by a path separator, and so on for each following pair.
            </summary>
            <remarks>
            This option is used to help get build-to-build determinism even when the build
            directory is different from one build to the next.  The prefix matching is case sensitive.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ReferencePaths">
            <summary>
            Sequence of absolute paths used to search for references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.SourcePaths">
            <summary>
            Sequence of absolute paths used to search for sources specified as #load directives.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.KeyFileSearchPaths">
            <summary>
            Sequence of absolute paths used to search for key files.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Utf8Output">
            <summary>
            If true, use UTF-8 for output.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.CompilationName">
            <summary>
            Compilation name or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.EmitOptions">
            <summary>
            Gets the emit options.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.OutputFileName">
            <summary>
            Name of the output file or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.OutputRefFilePath">
            <summary>
            Path of the output ref assembly or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.PdbPath">
            <summary>
            Path of the PDB file or null if same as output binary path with .pdb extension.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.SourceLink">
            <summary>
            Path of the file containing information linking the compilation to source server that stores 
            a snapshot of the source code included in the compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.RuleSetPath">
            <summary>
            Absolute path of the .ruleset file or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.EmitPdb">
            <summary>
            True to emit PDB information (to a standalone PDB file or embedded into the PE file).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.OutputDirectory">
            <summary>
            Absolute path of the output directory (could only be null if there is an error reported).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.DocumentationPath">
            <summary>
            Absolute path of the documentation comment XML file or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.GeneratedFilesOutputDirectory">
            <summary>
            Absolute path of the directory to place generated files in, or <c>null</c> to not emit any generated files.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ErrorLogOptions">
            <summary>
            Options controlling the generation of a SARIF log file containing compilation or
            analysis diagnostics, or null if no log file is desired.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ErrorLogPath">
            <summary>
            Options controlling the generation of a SARIF log file containing compilation or
            analysis diagnostics, or null if no log file is desired.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.AppConfigPath">
            <summary>
            An absolute path of the app.config file or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Errors">
            <summary>
            Errors while parsing the command line arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences">
            <summary>
            References to metadata supplied on the command line. 
            Includes assemblies specified via /r and netmodules specified via /addmodule.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.AnalyzerReferences">
            <summary>
            References to analyzers supplied on the command line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.AnalyzerConfigPaths">
            <summary>
            A set of paths to EditorConfig-compatible analyzer config files.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.AdditionalFiles">
            <summary>
            A set of additional non-code text files that can be used by analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.EmbeddedFiles">
            <summary>
            A set of files to embed in the PDB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ReportAnalyzer">
            <value>
            Report additional information related to analyzers, such as analyzer execution time.
            </value>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.SkipAnalyzers">
            <value>
            Skip execution of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s.
            </value>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.DisplayLogo">
            <summary>
            If true, prepend the command line header logo during 
            <see cref="M:Microsoft.CodeAnalysis.CommonCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.DisplayHelp">
            <summary>
            If true, append the command line help during
            <see cref="M:Microsoft.CodeAnalysis.CommonCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.DisplayVersion">
            <summary>
            If true, append the compiler version during
            <see cref="M:Microsoft.CodeAnalysis.CommonCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.DisplayLangVersions">
            <summary>
            If true, prepend the compiler-supported language versions during
            <see cref="M:Microsoft.CodeAnalysis.CommonCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32ResourceFile">
            <summary>
            The path to a Win32 resource.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32Icon">
            <summary>
            The path to a .ico icon file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32Manifest">
            <summary>
            The path to a Win32 manifest file to embed
            into the output portable executable (PE) file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.NoWin32Manifest">
            <summary>
            If true, do not embed any Win32 manifest, including
            one specified by <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.Win32Manifest"/> or any
            default manifest.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ManifestResources">
            <summary>
            Resources specified as arguments to the compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.Encoding">
            <summary>
            Encoding to be used for source files or 'null' for autodetect/default.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ChecksumAlgorithm">
            <summary>
            Hash algorithm to use to calculate source file debug checksums and PDB checksum.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ScriptArguments">
            <summary>
            Arguments following a script file or separator "--". Null if the command line parser is not interactive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.SourceFiles">
            <summary>
            Source file paths.
            </summary>
            <remarks>
            Includes files specified directly on command line as well as files matching patterns specified 
            on command line using '*' and '?' wildcards or /recurse option.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.TouchedFilesPath">
            <summary>
            Full path of a log of file paths accessed by the compiler, or null if file logging should be suppressed.
            </summary>
            <remarks>
            Two log files will be created: 
            One with path <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.TouchedFilesPath"/> and extension ".read" logging the files read,
            and second with path <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.TouchedFilesPath"/> and extension ".write" logging the files written to during compilation.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.PrintFullPaths">
            <summary>
            If true, prints the full path of the file containing errors or
            warnings in diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.ParseOptions">
            <summary>
            Options to the <see cref="T:Microsoft.CodeAnalysis.CommandLineParser"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.CompilationOptions">
            <summary>
            Options to the <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.PreferredUILang">
            <summary>
            Specify the preferred output language name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineArguments.GetOutputFilePath(System.String)">
            <summary>
            Returns a full path of the file that the compiler will generate the assembly to if compilation succeeds.
            </summary>
            <remarks>
            The method takes <paramref name="outputFileName"/> rather than using the value of <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.OutputFileName"/> 
            since the latter might be unspecified, in which case actual output path can't be determined for C# command line
            without creating a compilation and finding an entry point. VB does not allow <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.OutputFileName"/> to 
            be unspecified.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineArguments.GetPdbFilePath(System.String)">
            <summary>
            Returns a full path of the PDB file that the compiler will generate the debug symbols to 
            if <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.EmitPdbFile"/> is true and the compilation succeeds.
            </summary>
            <remarks>
            The method takes <paramref name="outputFileName"/> rather than using the value of <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.OutputFileName"/> 
            since the latter might be unspecified, in which case actual output path can't be determined for C# command line
            without creating a compilation and finding an entry point. VB does not allow <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.OutputFileName"/> to 
            be unspecified.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineArguments.EmitPdbFile">
            <summary>
            Returns true if the PDB is generated to a PDB file, as opposed to embedded to the output binary and not generated at all.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineArguments.ResolveMetadataReferences(Microsoft.CodeAnalysis.MetadataReferenceResolver)">
            <summary>
            Resolves metadata references stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences"/> using given file resolver and metadata provider.
            </summary>
            <param name="metadataResolver"><see cref="T:Microsoft.CodeAnalysis.MetadataReferenceResolver"/> to use for assembly name and relative path resolution.</param>
            <returns>Yields resolved metadata references or <see cref="T:Microsoft.CodeAnalysis.UnresolvedMetadataReference"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadataResolver"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineArguments.ResolveMetadataReferences(Microsoft.CodeAnalysis.MetadataReferenceResolver,System.Collections.Generic.List{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.CommonMessageProvider)">
            <summary>
            Resolves metadata references stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.MetadataReferences"/> using given file resolver and metadata provider.
            If a non-null diagnostic bag <paramref name="diagnosticsOpt"/> is provided, it catches exceptions that may be generated while reading the metadata file and
            reports appropriate diagnostics.
            Otherwise, if <paramref name="diagnosticsOpt"/> is null, the exceptions are unhandled.
            </summary>
            <remarks>
            called by CommonCompiler with diagnostics and message provider
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineArguments.ResolveAnalyzerReferences(Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader)">
            <summary>
            Resolves analyzer references stored in <see cref="P:Microsoft.CodeAnalysis.CommandLineArguments.AnalyzerReferences"/> using given file resolver.
            </summary>
            <param name="analyzerLoader">Load an assembly from a file path</param>
            <returns>Yields resolved <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference"/> or <see cref="T:Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Enumerates files in the specified directory and subdirectories whose name matches the given pattern.
            </summary>
            <param name="directory">Full path of the directory to enumerate.</param>
            <param name="fileNamePattern">File name pattern. May contain wildcards '*' (matches zero or more characters) and '?' (matches any character).</param>
            <param name="searchOption">Specifies whether to search the specified <paramref name="directory"/> only, or all its subdirectories as well.</param>
            <returns>Sequence of file paths.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.Parse(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String)">
            <summary>
            Parses a command line.
            </summary>
            <param name="args">A collection of strings representing the command line arguments.</param>
            <param name="baseDirectory">The base directory used for qualifying file locations.</param>
            <param name="sdkDirectory">The directory to search for mscorlib, or null if not available.</param>
            <param name="additionalReferenceDirectories">A string representing additional reference paths.</param>
            <returns>a <see cref="T:Microsoft.CodeAnalysis.CommandLineArguments"/> object representing the parsed command line.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.IsOptionName(System.String,System.ReadOnlySpan{System.Char})">
            <summary>
            Determines if a <see cref="T:System.ReadOnlySpan`1"/> is equal to the provided option name
            </summary>
            <remarks>
            Prefer this over the Equals methods on <see cref="T:System.ReadOnlySpan`1"/>. The 
            <see cref="F:System.StringComparison.InvariantCultureIgnoreCase"/> implementation allocates a <see cref="T:System.String"/>.
            The 99% case here is that we are dealing with an ASCII string that matches the input hence
            it's worth special casing that here and falling back to the more complicated comparison 
            when dealing with non-ASCII input
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.RemoveTrailingSpacesAndDots(System.String)">
            <summary>
            Trims all '.' and whitespace from the end of the path
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.SplitWithDoubledSeparatorEscaping(System.String,System.Char)">
            <summary>
            Splits specified <paramref name="str"/> on <paramref name="separator"/>
            treating two consecutive separators as if they were a single non-separating character.
            E.g. "a,,b,c" split on ',' yields ["a,b", "c"].
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.TryParseClientArgs(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.List{System.String}@,System.Boolean@,System.String@,System.String@,System.String@)">
            <summary>
            Returns false if any of the client arguments are invalid and true otherwise.
            </summary>
            <param name="args">
            The original args to the client.
            </param>
            <param name="parsedArgs">
            The original args minus the client args, if no errors were encountered.
            </param>
            <param name="containsShared">
            Only defined if no errors were encountered.
            True if '/shared' was an argument, false otherwise.
            </param>
            <param name="keepAliveValue">
            Only defined if no errors were encountered.
            The value to the '/keepalive' argument if one was specified, null otherwise.
            </param>
            <param name="errorMessage">
            Only defined if errors were encountered.
            The error message for the encountered error.
            </param>
            <param name="pipeName">
            Only specified if <paramref name="containsShared"/> is true and the session key
            was provided.  Can be null
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.SplitCommandLineIntoArguments(System.String,System.Boolean)">
            <summary>
            See <see cref="M:Roslyn.Utilities.CommandLineUtilities.SplitCommandLineIntoArguments(System.String,System.Boolean)"/> 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.RemoveQuotesAndSlashes(System.String)">
            <summary>
            Remove the extraneous quotes and slashes from the argument.  This function is designed to have
            compat behavior with the native compiler.
            </summary>
            <remarks>
            Mimics the function RemoveQuotes from the native C# compiler.  The native VB equivalent of this 
            function is called RemoveQuotesAndSlashes.  It has virtually the same behavior except for a few 
            quirks in error cases.  
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.ParseSeparatedStrings(System.Nullable{System.ReadOnlyMemory{System.Char}},System.Char[],System.Boolean,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.ReadOnlyMemory{System.Char}})">
            <summary>
            Split a string by a set of separators, taking quotes into account.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.TryParseUInt64(System.String,System.UInt64@)">
            <summary>
            Tries to parse a UInt64 from string in either decimal, octal or hex format.
            </summary>
            <param name="value">The string value.</param>
            <param name="result">The result if parsing was successful.</param>
            <returns>true if parsing was successful, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.TryParseUInt16(System.String,System.UInt16@)">
            <summary>
            Tries to parse a UInt16 from string in either decimal, octal or hex format.
            </summary>
            <param name="value">The string value.</param>
            <param name="result">The result if parsing was successful.</param>
            <returns>true if parsing was successful, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineParser.SortPathMap(System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Sort so that more specific keys precede less specific.
            When mapping a path we find the first key in the array that is a prefix of the path.
            If multiple keys are prefixes of the path we want to use the longest (more specific) one for the mapping.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineReference">
            <summary>
            Describes a command line metadata reference (assembly or netmodule) specification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineReference.Reference">
            <summary>
            Metadata file path or an assembly display name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineReference.Properties">
            <summary>
            Metadata reference properties.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommandLineSourceFile">
            <summary>
            Describes a source file specification stored on command line arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineSourceFile.Path">
            <summary>
            Resolved absolute path of the source file (does not contain wildcards).
            </summary>
            <remarks>
            Although this path is absolute it may not be normalized. That is, it may contain ".." and "." in the middle. 
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineSourceFile.IsInputRedirected">
            <summary>
            True if the input has been redirected from the standard input stream.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommandLineSourceFile.IsScript">
            <summary>
            True if the file should be treated as a script file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonCompiler">
            <summary>
            Base class for csc.exe, csi.exe, vbc.exe and vbi.exe implementations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonCompiler.CompilerEmitStreamProvider">
            <summary>
            This implementation of <see cref="T:Microsoft.CodeAnalysis.Compilation.EmitStreamProvider"/> will delay the creation
            of the PE / PDB file until the compiler determines the compilation has succeeded.  This prevents
            the compiler from deleting output from the previous compilation when a new compilation 
            fails. The <see cref="M:Microsoft.CodeAnalysis.CommonCompiler.CompilerEmitStreamProvider.Close(Microsoft.CodeAnalysis.DiagnosticBag)"/> method must be called to retrieve all diagnostics.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonCompiler.CompilerRelativePathResolver">
            <summary>
            Looks for metadata references among the assembly file references given to the compilation when constructed.
            When scripts are included into a project we don't want #r's to reference other assemblies than those 
            specified explicitly in the project references.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonCompiler._fallbackEncoding">
            <summary>
            Fallback encoding that is lazily retrieved if needed. If <see cref="M:Microsoft.CodeAnalysis.Text.EncodedStringText.CreateFallbackEncoding"/> is
            evaluated and stored, the value is used if a PDB is created for this compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonCompiler.EmbeddedSourcePaths">
            <summary>
            The set of source file paths that are in the set of embedded paths.
            This is used to prevent reading source files that are embedded twice.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonCompiler.FileSystem">
            <summary>
            The <see cref="T:Roslyn.Utilities.ICommonCompilerFileSystem"/> used to access the file system inside this instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.PrintVersion(System.IO.TextWriter)">
            <summary>
            Print compiler version
            </summary>
            <param name="consoleOutput"></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonCompiler.Type">
            <summary>
            The type of the compiler class for version information in /help and /version.
            We don't simply use this.GetType() because that would break mock subclasses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.GetCompilerVersion">
            <summary>
            The version of this compiler with commit hash, used in logo and /version output.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.GetToolName">
            <summary>
            Tool name used, along with assembly version, for error logging.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.GetAssemblyVersion">
            <summary>
            Tool version identifier used for error logging.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ResolveMetadataReferences(System.Collections.Generic.List{Microsoft.CodeAnalysis.DiagnosticInfo},Microsoft.CodeAnalysis.TouchedFileLogger,Microsoft.CodeAnalysis.MetadataReferenceResolver@)">
            <summary>
            Resolves metadata references stored in command line arguments and reports errors for those that can't be resolved.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.TryReadFileContent(Microsoft.CodeAnalysis.CommandLineSourceFile,System.Collections.Generic.IList{Microsoft.CodeAnalysis.DiagnosticInfo})">
            <summary>
            Reads content of a source file.
            </summary>
            <param name="file">Source file information.</param>
            <param name="diagnostics">Storage for diagnostics.</param>
            <returns>File content or null on failure.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.TryReadFileContent(Microsoft.CodeAnalysis.CommandLineSourceFile,System.Collections.Generic.IList{Microsoft.CodeAnalysis.DiagnosticInfo},System.String@)">
            <summary>
            Reads content of a source file.
            </summary>
            <param name="file">Source file information.</param>
            <param name="diagnostics">Storage for diagnostics.</param>
            <param name="normalizedFilePath">If given <paramref name="file"/> opens successfully, set to normalized absolute path of the file, null otherwise.</param>
            <returns>File content or null on failure.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.TryGetAnalyzerConfigSet(System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.AnalyzerConfigSet@)">
            <summary>
            Read all analyzer config files from the given paths.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.GetFallbackEncoding">
            <summary>
            Returns the fallback encoding for parsing source files, if used, or null
            if not used
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.TryReadFileContent(System.String,Microsoft.CodeAnalysis.DiagnosticBag,System.String@)">
            <summary>
            Read a UTF-8 encoded file and return the text as a string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ReportDiagnostics(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},System.IO.TextWriter,Microsoft.CodeAnalysis.ErrorLogger,Microsoft.CodeAnalysis.Compilation)">
            <summary>Returns true if there were any errors, false otherwise.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ReportDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag,System.IO.TextWriter,Microsoft.CodeAnalysis.ErrorLogger,Microsoft.CodeAnalysis.Compilation)">
            <summary>Returns true if there were any errors, false otherwise.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.ReportDiagnostics(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DiagnosticInfo},System.IO.TextWriter,Microsoft.CodeAnalysis.ErrorLogger,Microsoft.CodeAnalysis.Compilation)">
            <summary>Returns true if there were any errors, false otherwise.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.HasUnsuppressableErrors(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Returns true if there are any error diagnostics in the bag which cannot be suppressed and
            are guaranteed to break the build.
            Only diagnostics which have default severity error and are tagged as NotConfigurable fall in this bucket.
            This includes all compiler error diagnostics and specific analyzer error diagnostics that are marked as not configurable by the analyzer author.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.HasUnsuppressedErrors(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Returns true if the bag has any diagnostics with effective Severity=Error. Also returns true for warnings or informationals
            or warnings promoted to error via /warnaserror which are not suppressed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)">
            <summary>
            csc.exe and vbc.exe entry point.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.RunGenerators(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ParseOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISourceGenerator},Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AdditionalText},Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Perform source generation, if the compiler supports it.
            </summary>
            <param name="input">The compilation before any source generation has occurred.</param>
            <param name="parseOptions">The <see cref="T:Microsoft.CodeAnalysis.ParseOptions"/> to use when parsing any generated sources.</param>
            <param name="generators">The generators to run</param>
            <param name="analyzerConfigOptionsProvider">A provider that returns analyzer config options.</param>
            <param name="additionalTexts">Any additional texts that should be passed to the generators when run.</param>
            <param name="generatorDiagnostics">Any diagnostics that were produced during generation.</param>
            <returns>A compilation that represents the original compilation with any additional, generated texts added to it.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.CompileAndEmit(Microsoft.CodeAnalysis.TouchedFileLogger,Microsoft.CodeAnalysis.Compilation@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISourceGenerator},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AdditionalText},Microsoft.CodeAnalysis.AnalyzerConfigSet,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AnalyzerConfigOptionsResult},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.EmbeddedText},Microsoft.CodeAnalysis.DiagnosticBag,System.Threading.CancellationToken,System.Threading.CancellationTokenSource@,Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver@,System.Nullable{Microsoft.CodeAnalysis.GeneratorDriverTimingInfo}@)">
            <summary>
            Perform all the work associated with actual compilation
            (parsing, binding, compile, emit), resulting in diagnostics
            and analyzer output.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonCompiler.GetOutputFileName(Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Returns the name with which the assembly should be output
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonCompiler.Culture">
            <summary>
              When overridden by a derived class, this property can override the current thread's
              CurrentUICulture property for diagnostic message resource lookups.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonCompiler.ExistingReferencesResolver">
            <summary>
            Looks for metadata references among the assembly file references given to the compilation when constructed.
            When scripts are included into a project we don't want #r's to reference other assemblies than those 
            specified explicitly in the project references.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonCompiler.SuppressionDiagnostic">
            <summary>
            Special informational diagnostic for each programmatic <see cref="T:Microsoft.CodeAnalysis.Diagnostics.Suppression"/> reported by a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BuildPaths.ClientDirectory">
            <summary>
            The path which contains the compiler binaries and response files.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BuildPaths.WorkingDirectory">
            <summary>
            The path in which the compilation takes place. This is also referred to as "baseDirectory" in 
            the code base.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BuildPaths.SdkDirectory">
            <summary>
            The path which contains mscorlib.  This can be null when specified by the user or running in a 
            CoreClr environment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BuildPaths.TempDirectory">
            <summary>
            The temporary directory a compilation should use instead of <see cref="M:System.IO.Path.GetTempPath"/>.  The latter
            relies on global state individual compilations should ignore.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ErrorLogger">
            <summary>
            Base class for logging compiler diagnostics.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ErrorLogOptions">
            <summary>
            Options controlling the generation of a SARIF log file containing compilation or analyzer diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ErrorLogOptions.Path">
            <summary>
            Absolute path of the error log file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ErrorLogOptions.SarifVersion">
            <summary>
            Version of the SARIF format used in the error log.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorLogOptions.#ctor(System.String,Microsoft.CodeAnalysis.SarifVersion)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.ErrorLogOptions"/> class.
            </summary>
            <param name="path">Absolute path of the error log file.</param>
            <param name="sarifVersion">Version of the SARIF format used in the error log.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SarifDiagnosticComparer">
             <summary>
             Compares descriptors by the values that we write to a SARIF log and nothing else.
            
             We cannot just use <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/>'s built-in implementation
             of <see cref="T:System.IEquatable`1"/> for two reasons:
            
             1. <see cref="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.MessageFormat"/> is part of that built-in 
                equatability, but we do not write it out, and so descriptors differing only
                by MessageFormat (common) would lead to duplicate rule metadata entries in
                the log.
            
             2. <see cref="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.CustomTags"/> is *not* part of that built-in
                equatability, but we do write them out, and so descriptors differing only
                by CustomTags (rare) would cause only one set of tags to be reported in the
                log.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SarifErrorLogger">
            <summary>
            Base class for the <see cref="T:Microsoft.CodeAnalysis.SarifV1ErrorLogger"/> and <see cref="T:Microsoft.CodeAnalysis.SarifV2ErrorLogger"/> classes.
            The SarifV2ErrorLogger produces the standardized SARIF v2.1.0. The SarifV1ErrorLogger produces
            the non-standardized SARIF v1.0.0. It is retained (and in fact, is retained as the default)
            for compatibility with previous versions of the compiler. Customers who want to integrate
            with standardized SARIF tooling should specify /errorlog:logFilePath;version=2 on the command
            line to produce SARIF v2.1.0.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SarifV1ErrorLogger">
            <summary>
            Used for logging compiler diagnostics to a stream in the unstandardized SARIF
            (Static Analysis Results Interchange Format) v1.0.0 format.
            https://github.com/sarif-standard/sarif-spec
            https://rawgit.com/sarif-standard/sarif-spec/main/Static%20Analysis%20Results%20Interchange%20Format%20(SARIF).html
            </summary>
            <remarks>
            To log diagnostics in the standardized SARIF v2.1.0 format, use the SarifV2ErrorLogger.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SarifV1ErrorLogger.DiagnosticDescriptorSet">
             <summary>
             Represents a distinct set of <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/>s and provides unique string keys 
             to distinguish them.
            
             The first <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> added with a given <see cref="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.Id"/>
             value is given that value as its unique key. Subsequent adds with the same ID will have .NNN
             appended to their with an auto-incremented numeric value.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SarifV1ErrorLogger.DiagnosticDescriptorSet.Count">
            <summary>
            The total number of descriptors in the set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SarifV1ErrorLogger.DiagnosticDescriptorSet.Add(Microsoft.CodeAnalysis.DiagnosticDescriptor)">
            <summary>
            Adds a descriptor to the set if not already present.
            </summary>
            <returns>
            The unique key assigned to the given descriptor.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SarifV1ErrorLogger.DiagnosticDescriptorSet.ToSortedList">
            <summary>
            Converts the set to a list of (key, descriptor) pairs sorted by key.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SarifV2ErrorLogger">
            <summary>
            Used for logging compiler diagnostics to a stream in the standardized SARIF
            (Static Analysis Results Interchange Format) v2.1.0 format.
            http://docs.oasis-open.org/sarif/sarif/v2.1.0/sarif-v2.1.0.html
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SarifV2ErrorLogger.DiagnosticDescriptorSet">
            <summary>
            Represents a distinct set of <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/>s and provides unique integer indices
            to distinguish them.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SarifV2ErrorLogger.DiagnosticDescriptorSet.Count">
            <summary>
            The total number of descriptors in the set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SarifV2ErrorLogger.DiagnosticDescriptorSet.Add(Microsoft.CodeAnalysis.DiagnosticDescriptor)">
            <summary>
            Adds a descriptor to the set if not already present.
            </summary>
            <returns>
            The unique key assigned to the given descriptor.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SarifV2ErrorLogger.DiagnosticDescriptorSet.ToSortedList">
            <summary>
            Converts the set to a list, sorted by index.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SarifVersion">
            <summary>
            Specifies the version of the SARIF log file to produce.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SarifVersion.Sarif1">
            <summary>
            The original, non-standardized version of the SARIF format.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SarifVersion.Sarif2">
            <summary>
            The first standardized version of the SARIF format.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SarifVersion.Default">
            <summary>
            The default SARIF version, which is v1.0.0 for compatibility with
            previous versions of the compiler.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SarifVersion.Latest">
            <summary>
            The latest supported SARIF version.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SarifVersionFacts.TryParse(System.String,Microsoft.CodeAnalysis.SarifVersion@)">
            <summary>
            Try to parse the SARIF log file version from a string.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TouchedFileLogger">
            <summary>
            Used for logging all the paths which are "touched" (used) in any way
            in the process of compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.AddRead(System.String)">
            <summary>
            Adds a fully-qualified path to the Logger for a read file.
            Semantics are undefined after a call to <see cref="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteReadPaths(System.IO.TextWriter)" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.AddWritten(System.String)">
            <summary>
            Adds a fully-qualified path to the Logger for a written file.
            Semantics are undefined after a call to <see cref="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteWrittenPaths(System.IO.TextWriter)" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.AddReadWritten(System.String)">
            <summary>
            Adds a fully-qualified path to the Logger for a read and written
            file. Semantics are undefined after a call to
            <see cref="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteWrittenPaths(System.IO.TextWriter)" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteReadPaths(System.IO.TextWriter)">
            <summary>
            Writes all of the paths the TouchedFileLogger to the given 
            TextWriter in upper case. After calling this method the
            logger is in an undefined state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TouchedFileLogger.WriteWrittenPaths(System.IO.TextWriter)">
            <summary>
            Writes all of the paths the TouchedFileLogger to the given 
            TextWriter in upper case. After calling this method the
            logger is in an undefined state.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Compilation">
            <summary>
            The compilation object is an immutable representation of a single invocation of the
            compiler. Although immutable, a compilation is also on-demand, and will realize and cache
            data as necessary. A compilation can produce a new compilation from existing compilation
            with the application of small deltas. In many cases, it is more efficient than creating a
            new compilation from scratch, as the new compilation can reuse information from the old
            compilation.
            </summary>
            <summary>
            The compilation object is an immutable representation of a single invocation of the
            compiler. Although immutable, a compilation is also on-demand, and will realize and cache
            data as necessary. A compilation can produce a new compilation from existing compilation
            with the application of small deltas. In many cases, it is more efficient than creating a
            new compilation from scratch, as the new compilation can reuse information from the old
            compilation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Compilation.EmitStreamSignKind">
            <summary>
            Describes the kind of real signing that is being done during Emit. In the case of public signing
            this value will be <see cref="F:Microsoft.CodeAnalysis.Compilation.EmitStreamSignKind.None"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Compilation.EmitStreamSignKind.SignedWithBuilder">
            <summary>
            This form of signing occurs in memory using the <see cref="T:System.Reflection.PortableExecutable.PEBuilder"/> APIs. This is the default 
            form of signing and will be used when a strong name key is provided in a file on disk.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Compilation.EmitStreamSignKind.SignedWithFile">
            <summary>
            This form of signing occurs using the <see cref="T:Microsoft.CodeAnalysis.Interop.IClrStrongName"/> COM APIs. This form of signing
            requires the unsigned PE to be written to disk before it can be signed (typically by writing it
            out to the %TEMP% folder). This signing is used when the key in a key container, the signing 
            requires a counter signature or customers opted in via the UseLegacyStrongNameProvider feature 
            flag.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Compilation.EmitStream">
            <summary>
            This type abstracts away the legacy COM based signing implementation for PE streams. Under the hood
            a temporary file must be created on disk (at the last possible moment), emitted to, signed on disk
            and then copied back to the original <see cref="T:System.IO.Stream"/>. Only when legacy signing is enabled though.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Compilation.EmitStream._stream">
            <summary>
            The <see cref="T:System.IO.Stream"/> that is being emitted into. This value should _never_ be 
            disposed. It is either returned from the <see cref="T:Microsoft.CodeAnalysis.Compilation.EmitStreamProvider"/> instance in
            which case it is owned by that. Or it is just an alias for the value that is stored 
            in <see cref="F:Microsoft.CodeAnalysis.Compilation.EmitStream._tempInfo"/> in which case it will be disposed from there.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.EmitStream.CreateStream(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Create the stream which should be used for Emit. This should only be called one time.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Compilation.EmitStreamProvider">
            <summary>
            Abstraction that allows the caller to delay the creation of the <see cref="P:Microsoft.CodeAnalysis.Compilation.EmitStreamProvider.Stream"/> values 
            until they are actually needed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.EmitStreamProvider.Stream">
            <summary>
            Returns an existing open stream or null if no stream has been open.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.EmitStreamProvider.CreateStream(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            This method will be called once during Emit at the time the Compilation needs 
            to create a stream for writing. It will not be called in the case of
            user errors in code. Shall not be called when <see cref="P:Microsoft.CodeAnalysis.Compilation.EmitStreamProvider.Stream"/> returns non-null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.EmitStreamProvider.GetOrCreateStream(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Returns a <see cref="P:Microsoft.CodeAnalysis.Compilation.EmitStreamProvider.Stream"/>. If one cannot be gotten or created then a diagnostic will 
            be added to <paramref name="diagnostics"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.IsCaseSensitive">
            <summary>
            Returns true if this is a case sensitive compilation, false otherwise.  Case sensitivity
            affects compilation features such as name lookup as well as choosing what names to emit
            when there are multiple different choices (for example between a virtual method and an
            override).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Compilation._lazyMakeWellKnownTypeMissingMap">
            <summary>
            Used for test purposes only to emulate missing members.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Compilation._lazyMakeMemberMissingMap">
            <summary>
            Used for test purposes only to emulate missing members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.Language">
            <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetDeterministicKey(Microsoft.CodeAnalysis.CompilationOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxTree},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.MetadataReference},System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AdditionalText},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISourceGenerator},System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{System.String,System.String}},Microsoft.CodeAnalysis.Emit.EmitOptions,Microsoft.CodeAnalysis.DeterministicKeyOptions)">
             <summary>
             This method generates a string that represents the input content to the compiler which impacts 
             the output of the build. This string is effectively a content key for a <see cref="T:Microsoft.CodeAnalysis.Compilation"/>
             with these values that can be used to identify the outputs.
            
             The returned string has the following properties:
            
             <list type="bullet">
             <item>
             <description>
             The format is undefined. Consumers should assume the format and content can change between 
             compiler versions.
             </description>
             </item>
             <item>
             <description>
             It is designed to be human readable and diffable. This is to help developers
             understand the difference between two compilations which is impacting the deterministic 
             output
             </description>
             </item>
             <item>
             <description>
             It is *not* in a minimal form. If used as a key in say a content addressable storage consumers
             should first pass it through a strong hashing function.
             </description>
             </item>
             </list>
            
             Compilations which do not use the /deterministic option can still use this API but
             the results will change on every invocation.
             </summary>
             <remarks>
             The set of inputs that impact deterministic output are described in the following document
                 - https://github.com/dotnet/roslyn/blob/main/docs/compilers/Deterministic%20Inputs.md
            
             There are a few dark corners of determinism that are not captured with this key as they are 
             considered outside the scope of this work:
            
             <list type="number">
             <item>
             <description>
             Environment variables: clever developers can subvert determinism by manipulation of 
             environment variables that impact program execution. For example changing normal library 
             loading by manipulating the %LIBPATH% environment variable. Doing so can cause a change 
             in deterministic output of compilation by changing compiler, runtime or generator 
             dependencies.
             </description>
             </item>
             <item>
             <description>
             Manipulation of strong name keys: strong name keys are read "on demand" by the compiler
             and both normal compilation and this key can have non-deterministic output if they are 
             manipulated at the correct point in program execution. That is an existing limitation
             of compilation that is tracked by https://github.com/dotnet/roslyn/issues/57940
             </description>
             </item>
             </list>
             This API can throw exceptions in a few cases like invalid file paths.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CheckSubmissionOptions(Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Checks options passed to submission compilation constructor.
            Throws an exception if the options are not applicable to submissions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.Clone">
            <summary>
            Creates a new compilation equivalent to this one with different symbol instances.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithEventQueue(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue{Microsoft.CodeAnalysis.Diagnostics.CompilationEvent})">
            <summary>
            Returns a new compilation with a given event queue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithSemanticModelProvider(Microsoft.CodeAnalysis.SemanticModelProvider)">
            <summary>
            Returns a new compilation with a given semantic model provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Gets a new <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> for the specified syntax tree.
            </summary>
            <param name="syntaxTree">The specified syntax tree.</param>
            <param name="ignoreAccessibility">
            True if the SemanticModel should ignore accessibility rules when answering semantic questions.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CommonGetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> for the given <paramref name="syntaxTree"/>.
            If <see cref="P:Microsoft.CodeAnalysis.Compilation.SemanticModelProvider"/> is non-null, it attempts to use <see cref="M:Microsoft.CodeAnalysis.SemanticModelProvider.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Compilation,System.Boolean)"/>
            to get a semantic model. Otherwise, it creates a new semantic model using <see cref="M:Microsoft.CodeAnalysis.Compilation.CreateSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)"/>.
            </summary>
            <param name="syntaxTree"></param>
            <param name="ignoreAccessibility"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> for the given <paramref name="syntaxTree"/>.
            Unlike the <see cref="M:Microsoft.CodeAnalysis.Compilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)"/> and <see cref="M:Microsoft.CodeAnalysis.Compilation.CommonGetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)"/>,
            it does not attempt to use the <see cref="P:Microsoft.CodeAnalysis.Compilation.SemanticModelProvider"/> to get a semantic model, but instead always creates a new semantic model.
            </summary>
            <param name="syntaxTree"></param>
            <param name="ignoreAccessibility"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateErrorTypeSymbol(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Int32)">
            <summary>
            Returns a new INamedTypeSymbol representing an error type with the given name and arity
            in the given optional container.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateErrorNamespaceSymbol(Microsoft.CodeAnalysis.INamespaceSymbol,System.String)">
            <summary>
            Returns a new INamespaceSymbol representing an error (missing) namespace with the given name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.AssemblyName">
             <summary>
             Simple assembly name, or null if not specified.
             </summary>
             <remarks>
             The name is used for determining internals-visible-to relationship with referenced assemblies.
            
             If the compilation represents an assembly the value of <see cref="P:Microsoft.CodeAnalysis.Compilation.AssemblyName"/> is its simple name.
            
             Unless <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.ModuleName"/> specifies otherwise the module name
             written to metadata is <see cref="P:Microsoft.CodeAnalysis.Compilation.AssemblyName"/> with an extension based upon <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.OutputKind"/>.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithAssemblyName(System.String)">
            <summary>
            Creates a compilation with the specified assembly name.
            </summary>
            <param name="assemblyName">The new assembly name.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.Options">
            <summary>
            Gets the options the compilation was created with.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithOptions(Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Creates a new compilation with the specified compilation options.
            </summary>
            <param name="options">The new options.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.IsSubmission">
            <summary>
            True if the compilation represents an interactive submission.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.PreviousSubmission">
            <summary>
            The previous submission, if any, or null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetSubmissionSlotIndex">
            <summary>
            Gets or allocates a runtime submission slot index for this compilation.
            </summary>
            <returns>Non-negative integer if this is a submission and it or a previous submission contains code, negative integer otherwise.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.SubmissionReturnType">
            <summary>
            The type object that represents the type of submission result the host requested.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.HostObjectType">
            <summary>
            The type of the globals object or null if not specified for this compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.SyntaxTrees">
            <summary>
            Gets the syntax trees (parsed from source code) that this compilation was created with.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
            <param name="trees">The new syntax trees.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
            <param name="trees">The new syntax trees.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
            <param name="trees">The new syntax trees.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
            <param name="trees">The new syntax trees.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveAllSyntaxTrees">
            <summary>
            Creates a new compilation without any syntax trees. Preserves metadata info for use with
            trees added later.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Creates a new compilation with an old syntax tree replaced with a new syntax tree.
            Reuses metadata from old compilation object.
            </summary>
            <param name="newTree">The new tree.</param>
            <param name="oldTree">The old tree.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns true if this compilation contains the specified tree. False otherwise.
            </summary>
            <param name="syntaxTree">A syntax tree.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.SemanticModelProvider">
            <summary>
            Optional semantic model provider for this compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.EventQueue">
            <summary>
            The event queue that this compilation was created with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ExternalReferences">
            <summary>
            Metadata references passed to the compilation constructor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.DirectiveReferences">
            <summary>
            Unique metadata references specified via #r directive in the source code of this compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ReferenceDirectives">
            <summary>
            All reference directives used in this compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ReferenceDirectiveMap">
            <summary>
            Maps values of #r references to resolved metadata references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.References">
            <summary>
            All metadata references -- references passed to the compilation
            constructor as well as references specified via #r directives.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ToMetadataReference(System.Collections.Immutable.ImmutableArray{System.String},System.Boolean)">
            <summary>
            Creates a metadata reference for this compilation.
            </summary>
            <param name="aliases">
            Optional aliases that can be used to refer to the compilation root namespace via extern alias directive.
            </param>
            <param name="embedInteropTypes">
            Embed the COM types from the reference so that the compiled
            application no longer requires a primary interop assembly (PIA).
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
            <param name="newReferences">
            The new references.
            </param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.WithReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
            <param name="newReferences">The new references.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CommonWithReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.AddReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
            <param name="references">The new references.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.AddReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
            <param name="references">The new references.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
            <param name="references">The new references.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
            <param name="references">The new references.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.RemoveAllReferences">
            <summary>
            Creates a new compilation without any metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ReplaceReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Creates a new compilation with an old metadata reference replaced with a new metadata
            reference.
            </summary>
            <param name="newReference">The new reference.</param>
            <param name="oldReference">The old reference.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> or <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/> for a metadata reference used to create this
            compilation.
            </summary>
            <param name="reference">The target reference.</param>
            <returns>
            Assembly or module symbol corresponding to the given reference or null if there is none.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/> that corresponds to the assembly symbol.
            </summary>
            <param name="assemblySymbol">The target symbol.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ReferencedAssemblyNames">
            <summary>
            Assembly identities of all assemblies directly referenced by this compilation.
            </summary>
            <remarks>
            Includes identities of references passed in the compilation constructor
            as well as those specified via directives in source code.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.Assembly">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.SourceModule">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/> for the module being created by compiling all of
            the source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.GlobalNamespace">
            <summary>
            The root namespace that contains all namespaces and types defined in source code or in
            referenced metadata, merged into a single namespace hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)">
            <summary>
            Gets the corresponding compilation namespace for the specified module or assembly namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetEntryPoint(System.Threading.CancellationToken)">
            <summary>
            Returns the Main method that will serves as the entry point of the assembly, if it is
            executable (and not a script).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Get the symbol for the predefined type from the Cor Library referenced by this
            compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CommonGetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Get the symbol for the predefined type member from the COR Library referenced by this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.IsSystemTypeReference(Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal)">
            <summary>
            Returns true if the type is System.Type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CommonGetWellKnownTypeMember(Microsoft.CodeAnalysis.WellKnownMember)">
            <summary>
            Lookup member declaration in well known type used by this Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CommonGetWellKnownType(Microsoft.CodeAnalysis.WellKnownType)">
            <summary>
            Lookup well-known type used by this Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.IsAttributeType(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Returns true if the specified type is equal to or derives from System.Attribute well-known type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ObjectType">
            <summary>
            The INamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
            Error if there was no COR Library in this Compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.DynamicType">
            <summary>
            The TypeSymbol for the type 'dynamic' in this Compilation.
            </summary>
            <exception cref="T:System.NotSupportedException">If the compilation is a VisualBasic compilation.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ScriptGlobalsType">
            <summary>
            A symbol representing the script globals type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.ScriptClass">
            <summary>
            A symbol representing the implicit Script class. This is null if the class is not
            defined in the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CommonBindScriptClass">
            <summary>
            Resolves a symbol that represents script container (Script class). Uses the
            full name of the container class stored in <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.ScriptClassName"/> to find the symbol.
            </summary>
            <returns>The Script class symbol or null if it is not defined.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32,Microsoft.CodeAnalysis.NullableAnnotation)">
            <summary>
            Returns a new ArrayTypeSymbol representing an array type tied to the base types of the
            COR Library in this Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32)">
            <summary>
            Returns a new ArrayTypeSymbol representing an array type tied to the base types of the
            COR Library in this Compilation.
            </summary>
            <remarks>This overload is for backwards compatibility. Do not remove.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Returns a new IPointerTypeSymbol representing a pointer type tied to a type in this
            Compilation.
            </summary>
            <exception cref="T:System.NotSupportedException">If the compilation is a VisualBasic compilation.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateFunctionPointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.RefKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},System.Reflection.Metadata.SignatureCallingConvention,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Returns a new IFunctionPointerTypeSymbol representing a function pointer type tied to types in this
            Compilation.
            </summary>
            <exception cref="T:System.NotSupportedException">If the compilation is a VisualBasic compilation.</exception>
            <exception cref="T:System.ArgumentException">
            If:
             * <see cref="F:Microsoft.CodeAnalysis.RefKind.Out"/> is passed as the returnRefKind.
             * parameterTypes and parameterRefKinds do not have the same length.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If returnType is <see langword="null"/>, or if parameterTypes or parameterRefKinds are default,
            or if any of the types in parameterTypes are null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateNativeIntegerTypeSymbol(System.Boolean)">
            <summary>
            Returns a new INamedTypeSymbol representing a native integer.
            </summary>
            <exception cref="T:System.NotSupportedException">If the compilation is a VisualBasic compilation.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetTypeByMetadataName(System.String)">
            <summary>
            Gets the type within the compilation's assembly and all referenced assemblies (other than
            those that can only be referenced via an extern alias) using its canonical CLR metadata name.
            This lookup follows the following order:
            <list type="number">
            <item><description>If the type is found in the compilation's assembly, that type is returned.</description></item>
            <item><description>
            Next, the core library (the library that defines <c>System.Object</c> and has no assembly references) is searched.
            If the type is found there, that type is returned.
            </description></item>
            <item><description>
            Finally, all remaining referenced non-extern assemblies are searched. If one and only one type matching the provided metadata name is found, that
            single type is returned. Accessibility is ignored for this check.
            </description></item>
            </list>
            </summary>
            <returns>Null if the type can't be found or there was an ambiguity during lookup.</returns>
            <remarks>
            <para>
            Since VB does not have the concept of extern aliases, it considers all referenced assemblies.
            </para>
            <para>
            In C#, if the core library is referenced as an extern assembly, it will be searched. All other extern-aliased assemblies will not be searched.
            </para>
            <para>
            Because accessibility to the current assembly is ignored when searching for types that match the provided metadata name, if multiple referenced
            assemblies define the same type symbol (as often happens when users copy well-known types from the BCL or other sources) then this API will return null,
            even if all but one of those symbols would be otherwise inaccessible to user-written code in the current assembly. For fine-grained control over ambiguity
            resolution, consider using <see cref="M:Microsoft.CodeAnalysis.Compilation.GetTypesByMetadataName(System.String)" /> instead and filtering the results for the symbol required.
            </para>
            <para>
            Assemblies can contain multiple modules. Within each assembly, the search is performed based on module's position in the module list of that assembly. When
            a match is found in one module in an assembly, no further modules within that assembly are searched.
            </para>
            <para>Type forwarders are ignored, and not considered part of the assembly where the TypeForwardAttribute is written.</para>
            <para>
            Ambiguities are detected on each nested level. For example, if <c>A+B</c> is requested, and there are multiple <c>A</c>s but only one of them has a <c>B</c> nested
            type, the lookup will be considered ambiguous and null will be returned.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetTypesByMetadataName(System.String)">
            <summary>
            Gets all types with the compilation's assembly and all referenced assemblies that have the
            given canonical CLR metadata name. Accessibility to the current assembly is ignored when
            searching for matching type names.
            </summary>
            <returns>Empty array if no types match. Otherwise, all types that match the name, current assembly first if present.</returns>
            <remarks>
            <para>
            Assemblies can contain multiple modules. Within each assembly, the search is performed based on module's position in the module list of that assembly. When
            a match is found in one module in an assembly, no further modules within that assembly are searched.
            </para>
            <para>Type forwarders are ignored, and not considered part of the assembly where the TypeForwardAttribute is written.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateTupleTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.NullableAnnotation})">
            <summary>
            Returns a new INamedTypeSymbol with the given element types and
            (optional) element names, locations, and nullable annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateTupleTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})">
            <summary>
            Returns a new INamedTypeSymbol with the given element types, names, and locations.
            </summary>
            <remarks>This overload is for backwards compatibility. Do not remove.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CheckTupleElementNames(System.Int32,System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Check that if any names are provided, and their number matches the expected cardinality.
            Returns a normalized version of the element names (empty array if all the names are null).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateTupleTypeSymbol(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.NullableAnnotation})">
            <summary>
            Returns a new INamedTypeSymbol with the given underlying type and
            (optional) element names, locations, and nullable annotations.
            The underlying type needs to be tuple-compatible.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateTupleTypeSymbol(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})">
            <summary>
            Returns a new INamedTypeSymbol with the given underlying type and element names and locations.
            The underlying type needs to be tuple-compatible.
            </summary>
            <remarks>This overload is for backwards compatibility. Do not remove.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateAnonymousTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.Boolean},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.NullableAnnotation})">
            <summary>
            Returns a new anonymous type symbol with the given member types, names, source locations, and nullable annotations.
            Anonymous type members will be readonly by default.  Writable properties are
            supported in VB and can be created by passing in <see langword="false"/> in the
            appropriate locations in <paramref name="memberIsReadOnly"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateAnonymousTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.Boolean},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})">
            <summary>
            Returns a new anonymous type symbol with the given member types, names, and source locations.
            Anonymous type members will be readonly by default.  Writable properties are
            supported in VB and can be created by passing in <see langword="false"/> in the
            appropriate locations in <paramref name="memberIsReadOnly"/>.
            </summary>
            <remarks>This overload is for backwards compatibility. Do not remove.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateBuiltinOperator(System.String,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates an <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> whose <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.MethodKind"/> is <see
            cref="F:Microsoft.CodeAnalysis.MethodKind.BuiltinOperator"/> for a binary operator. Built-in operators are commonly created for
            symbols like <c>bool int.operator ==(int v1, int v2)</c> which the language implicitly supports, even if such
            a symbol is not explicitly defined for that type in either source or metadata.
            </summary>
            <param name="name">The binary operator name.  Should be one of the names from <see cref="T:Microsoft.CodeAnalysis.WellKnownMemberNames"/>.</param>
            <param name="returnType">The return type of the binary operator.</param>
            <param name="leftType">The type of the left operand of the binary operator.</param>
            <param name="rightType">The type of the right operand of the binary operator.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateBuiltinOperator(System.String,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates an <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> whose <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.MethodKind"/> is <see
            cref="F:Microsoft.CodeAnalysis.MethodKind.BuiltinOperator"/> for a unary operator. Built-in operators are commonly created for
            symbols like <c>bool int.operator -(int value)</c> which the language implicitly supports, even if such a
            symbol is not explicitly defined for that type in either source or metadata.
            </summary>
            <param name="name">The unary operator name.  Should be one of the names from <see cref="T:Microsoft.CodeAnalysis.WellKnownMemberNames"/>.</param>
            <param name="returnType">The return type of the unary operator.</param>
            <param name="operandType">The type the operator applies to.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ClassifyCommonConversion(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Classifies a conversion from <paramref name="source"/> to <paramref name="destination"/> according
            to this compilation's programming language.
            </summary>
            <param name="source">Source type of value to be converted</param>
            <param name="destination">Destination type of value to be converted</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.Operations.CommonConversion"/> that classifies the conversion from the
            <paramref name="source"/> type to the <paramref name="destination"/> type.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.HasImplicitConversion(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Returns true if there is an implicit (C#) or widening (VB) conversion from
            <paramref name="fromType"/> to <paramref name="toType"/>. Returns false if
            either <paramref name="fromType"/> or <paramref name="toType"/> is null, or
            if no such conversion exists.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.IsSymbolAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if <paramref name="symbol"/> is accessible from within <paramref name="within"/>. An optional qualifier of type
            <paramref name="throughType"/> is used to resolve protected access for instance members. All symbols are
            required to be from this compilation or some assembly referenced (<see cref="P:Microsoft.CodeAnalysis.Compilation.References"/>) by this
            compilation. <paramref name="within"/> is required to be an <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> or <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/>.
            </summary>
            <remarks>
            <para>Submissions can reference symbols from previous submissions and their referenced assemblies, even
            though those references are missing from <see cref="P:Microsoft.CodeAnalysis.Compilation.References"/>.
            See https://github.com/dotnet/roslyn/issues/27356.
            This implementation works around that by permitting symbols from previous submissions as well.</para>
            <para>It is advised to avoid the use of this API within the compilers, as the compilers have additional
            requirements for access checking that are not satisfied by this implementation, including the
            avoidance of infinite recursion that could result from the use of the ISymbol APIs here, the detection
            of use-site diagnostics, and additional returned details (from the compiler's internal APIs) that are
            helpful for more precisely diagnosing reasons for accessibility failure.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetParseDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during the parsing stage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during symbol declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetMethodBodyDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during the analysis of method bodies and field initializers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets all the diagnostics for the compilation, including syntax, declaration, and
            binding. Does not include any diagnostics that might be produced during emit, see
            <see cref="T:Microsoft.CodeAnalysis.Emit.EmitResult"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetUsedAssemblyReferences(System.Threading.CancellationToken)">
            <summary>
            Unique metadata assembly references that are considered to be used by this compilation.
            For example, if a type declared in a referenced assembly is referenced in source code 
            within this compilation, the reference is considered to be used. Etc.
            The returned set is a subset of references returned by <see cref="P:Microsoft.CodeAnalysis.Compilation.References"/> API.
            The result is undefined if the compilation contains errors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.FilterAndAppendAndFreeDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.DiagnosticBag@,System.Threading.CancellationToken)">
            <summary>
            Filter out warnings based on the compiler options (/nowarn, /warn and /warnaserror) and the pragma warning directives.
            'incoming' is freed.
            </summary>
            <param name="accumulator">Bag to which filtered diagnostics will be added.</param>
            <param name="incoming">Diagnostics to be filtered.</param>
            <returns>True if there are no unsuppressed errors (i.e., no errors which fail compilation).</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.FilterAndAppendDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},System.Collections.Generic.HashSet{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Filter out warnings based on the compiler options (/nowarn, /warn and /warnaserror) and the pragma warning directives.
            </summary>
            <returns>True if there are no unsuppressed errors (i.e., no errors which fail compilation).</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CreateDefaultWin32Resources(System.Boolean,System.Boolean,System.IO.Stream,System.IO.Stream)">
            <summary>
            Create a stream filled with default win32 resources.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.SignUsingBuilder">
            <summary>
            There are two ways to sign PE files
              1. By directly signing the <see cref="T:System.Reflection.PortableExecutable.PEBuilder"/>
              2. Write the unsigned PE to disk and use CLR COM APIs to sign.
            The preferred method is #1 as it's more efficient and more resilient (no reliance on %TEMP%). But 
            we must continue to support #2 as it's the only way to do the following:
              - Access private keys stored in a key container
              - Do proper counter signature verification for AssemblySignatureKey attributes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ConstructModuleSerializationProperties(Microsoft.CodeAnalysis.Emit.EmitOptions,System.String,System.Guid)">
            <summary>
            Constructs the module serialization properties out of the compilation options of this compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Compilation.LinkerMajorVersion">
            <summary>
            The value is not used by Windows loader, but the OS appcompat infrastructure uses it to identify apps.
            It is useful for us to have a mechanism to identify the compiler that produced the binary.
            This is the appropriate value to use for that. That is what it was invented for.
            We don't want to have the high bit set for this in case some users perform a signed comparison to
            determine if the value is less than some version. The C++ linker is at 0x0B.
            We'll start our numbering at 0x30 for C#, 0x50 for VB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.HasCodeToEmit">
            <summary>
            Return true if the compilation contains any code or types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CompileMethods(Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,System.Predicate{Microsoft.CodeAnalysis.Symbols.ISymbolInternal},System.Threading.CancellationToken)">
            <summary>
            Report declaration diagnostics and compile and synthesize method bodies.
            </summary>
            <returns>True if successful.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GenerateResources(Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder,System.IO.Stream,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,System.Threading.CancellationToken)">
            <summary>
            Update resources.
            </summary>
            <returns>True if successful.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GenerateDocumentationComments(System.IO.Stream,System.String,Microsoft.CodeAnalysis.DiagnosticBag,System.Threading.CancellationToken)">
            <summary>
            Generate XML documentation comments.
            </summary>
            <returns>True if successful.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ReportUnusedImports(Microsoft.CodeAnalysis.DiagnosticBag,System.Threading.CancellationToken)">
            <summary>
            Reports all unused imports/usings so far (and thus it must be called as a last step of Emit)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CompleteTrees(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Signals the event queue, if any, that we are done compiling.
            There should not be more compiling actions after this step.
            NOTE: once we signal about completion to analyzers they will cancel and thus in some cases we
                  may be effectively cutting off some diagnostics.
                  It is not clear if behavior is desirable.
                  See: https://github.com/dotnet/roslyn/issues/11470
            </summary>
            <param name="filterTree">What tree to complete. null means complete all trees. </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.Emit(System.IO.Stream,System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},Microsoft.CodeAnalysis.Emit.EmitOptions,Microsoft.CodeAnalysis.IMethodSymbol,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.EmbeddedText},System.IO.Stream,System.Threading.CancellationToken)">
             <summary>
             Emit the IL for the compiled source code into the specified stream.
             </summary>
             <param name="peStream">Stream to which the compilation will be written.</param>
             <param name="metadataPEStream">Stream to which the metadata-only output will be written.</param>
             <param name="pdbStream">Stream to which the compilation's debug info will be written.  Null to forego PDB generation.</param>
             <param name="xmlDocumentationStream">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
             <param name="win32Resources">Stream from which the compilation's Win32 resources will be read (in RES format).
             Null to indicate that there are none. The RES format begins with a null resource entry.
             Note that the caller is responsible for disposing this stream, if provided.</param>
             <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
             <param name="options">Emit options.</param>
             <param name="debugEntryPoint">
             Debug entry-point of the assembly. The method token is stored in the generated PDB stream.
            
             When a program launches with a debugger attached the debugger places the first breakpoint to the start of the debug entry-point method.
             The CLR starts executing the static Main method of <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.MainTypeName"/> type. When the first breakpoint is hit
             the debugger steps thru the code statement by statement until user code is reached, skipping methods marked by <see cref="T:System.Diagnostics.DebuggerHiddenAttribute"/>,
             and taking other debugging attributes into consideration.
            
             By default both entry points in an executable program (<see cref="F:Microsoft.CodeAnalysis.OutputKind.ConsoleApplication"/>, <see cref="F:Microsoft.CodeAnalysis.OutputKind.WindowsApplication"/>, <see cref="F:Microsoft.CodeAnalysis.OutputKind.WindowsRuntimeApplication"/>)
             are the same method (Main). A non-executable program has no entry point. Runtimes that implement a custom loader may specify debug entry-point
             to force the debugger to skip over complex custom loader logic executing at the beginning of the .exe and thus improve debugging experience.
            
             Unlike ordinary entry-point which is limited to a non-generic static method of specific signature, there are no restrictions on the <paramref name="debugEntryPoint"/>
             method other than having a method body (extern, interface, or abstract methods are not allowed).
             </param>
             <param name="sourceLinkStream">
             Stream containing information linking the compilation to a source control.
             </param>
             <param name="embeddedTexts">
             Texts to embed in the PDB.
             Only supported when emitting Portable PDBs.
             </param>
             <param name="cancellationToken">To cancel the emit process.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.Emit(System.IO.Stream,System.IO.Stream,System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},Microsoft.CodeAnalysis.Emit.EmitOptions,Microsoft.CodeAnalysis.IMethodSymbol,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.EmbeddedText},Microsoft.CodeAnalysis.RebuildData,Microsoft.CodeAnalysis.CodeGen.CompilationTestData,System.Threading.CancellationToken)">
            <summary>
            This overload is only intended to be directly called by tests that want to pass <paramref name="testData"/>.
            The map is used for storing a list of methods and their associated IL.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.EmitDifference(Microsoft.CodeAnalysis.Emit.EmitBaseline,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Emit.SemanticEdit},System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Collections.Generic.ICollection{System.Reflection.Metadata.MethodDefinitionHandle},System.Threading.CancellationToken)">
            <summary>
            Emit the differences between the compilation and the previous generation
            for Edit and Continue. The differences are expressed as added and changed
            symbols, and are emitted as metadata, IL, and PDB deltas. A representation
            of the current compilation is returned as an EmitBaseline for use in a
            subsequent Edit and Continue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.EmitDifference(Microsoft.CodeAnalysis.Emit.EmitBaseline,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Emit.SemanticEdit},System.Func{Microsoft.CodeAnalysis.ISymbol,System.Boolean},System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Collections.Generic.ICollection{System.Reflection.Metadata.MethodDefinitionHandle},System.Threading.CancellationToken)">
            <summary>
            Emit the differences between the compilation and the previous generation
            for Edit and Continue. The differences are expressed as added and changed
            symbols, and are emitted as metadata, IL, and PDB deltas. A representation
            of the current compilation is returned as an EmitBaseline for use in a
            subsequent Edit and Continue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.EmitDifference(Microsoft.CodeAnalysis.Emit.EmitBaseline,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Emit.SemanticEdit},System.Func{Microsoft.CodeAnalysis.ISymbol,System.Boolean},System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Emit the differences between the compilation and the previous generation
            for Edit and Continue. The differences are expressed as added and changed
            symbols, and are emitted as metadata, IL, and PDB deltas. A representation
            of the current compilation is returned as an EmitBaseline for use in a
            subsequent Edit and Continue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CheckOptionsAndCreateModuleBuilder(Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},Microsoft.CodeAnalysis.Emit.EmitOptions,Microsoft.CodeAnalysis.IMethodSymbol,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.EmbeddedText},Microsoft.CodeAnalysis.CodeGen.CompilationTestData,System.Threading.CancellationToken)">
            <summary>
            Check compilation options and create <see cref="T:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder"/>.
            </summary>
            <returns><see cref="T:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder"/> if successful.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CompareSyntaxTreeOrdering(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            The compiler needs to define an ordering among different partial class in different syntax trees
            in some cases, because emit order for fields in structures, for example, is semantically important.
            This function defines an ordering among syntax trees in this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CompareSourceLocations(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location)">
            <summary>
            Compare two source locations, using their containing trees, and then by Span.First within a tree.
            Can be used to get a total ordering on declarations, for example.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CompareSourceLocations(Microsoft.CodeAnalysis.SyntaxReference,Microsoft.CodeAnalysis.SyntaxReference)">
            <summary>
            Compare two source locations, using their containing trees, and then by Span.First within a tree.
            Can be used to get a total ordering on declarations, for example.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CompareSourceLocations(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Compare two source locations, using their containing trees, and then by Span.First within a tree.
            Can be used to get a total ordering on declarations, for example.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.FirstSourceLocation``1(``0,``0)">
            <summary>
            Return the lexically first of two locations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.FirstSourceLocation``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Return the lexically first of multiple locations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ContainsSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Return true if there is a source declaration symbol name that meets given predicate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Return source declaration symbols whose name meets given predicate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.ContainsSymbolsWithName(System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Return true if there is a source declaration symbol name that matches the provided name.
            This may be faster than <see cref="M:Microsoft.CodeAnalysis.Compilation.ContainsSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)"/> when predicate is just a simple string check.
            <paramref name="name"/> is case sensitive or not depending on the target language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetSymbolsWithName(System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Return source declaration symbols whose name matches the provided name.  This may be
            faster than <see cref="M:Microsoft.CodeAnalysis.Compilation.GetSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)"/> when predicate is just a simple string check.  <paramref
            name="name"/> is case sensitive or not depending on the target language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetUnreferencedAssemblyIdentities(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Given a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> reporting unreferenced <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/>s, returns
            the actual <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/> instances that were not referenced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.GetRequiredLanguageVersion(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Returns the required language version found in a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>, if any is found.
            Returns null if none is found.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Compilation._retargetingAssemblySymbols">
            <summary>
            The list of RetargetingAssemblySymbol objects created for this Compilation. 
            RetargetingAssemblySymbols are created when some other compilation references this one, 
            but the other references provided are incompatible with it. For example, compilation C1 
            references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. In this
            case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
            signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
            RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
            reference C1.AssemblySymbol, but reference a special RetargetingAssemblySymbol created
            for C1 by ReferenceManager.
             
            WeakReference is used to allow RetargetingAssemblySymbol to be collected when they become unused.
            
            Guarded by <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.CacheRetargetingAssemblySymbolNoLock(Microsoft.CodeAnalysis.Symbols.IAssemblySymbolInternal)">
            <summary>
            Adds given retargeting assembly for this compilation into the cache.
            <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/> must be locked while calling this method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Compilation.AddRetargetingAssemblySymbolsNoLock``1(System.Collections.Generic.List{``0})">
            <summary>
            Adds cached retargeting symbols into the given list.
            <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/> must be locked while calling this method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CandidateReason">
            <summary>
            Indicates the reasons why a candidate (or set of candidate) symbols were not considered
            correct in SemanticInfo. Higher values take precedence over lower values, so if, for
            example, there a symbol with a given name that was inaccessible, and other with the wrong
            arity, only the inaccessible one would be reported in the SemanticInfo.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.None">
            <summary>
            No CandidateSymbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotATypeOrNamespace">
            <summary>
            Only a type or namespace was valid in the given location, but the candidate symbols was
            of the wrong kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotAnEvent">
            <summary>
            Only an event was valid in the given location, but the candidate symbols was
            of the wrong kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotAWithEventsMember">
            <summary>
            The candidate symbol must be a WithEvents member, but it was not. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotAnAttributeType">
            <summary>
            Only an attribute type was valid in the given location, but the candidate symbol was
            of the wrong kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.WrongArity">
            <summary>
            The candidate symbol takes a different number of type parameters that was required.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotCreatable">
            <summary>
            The candidate symbol existed, but was not allowed to be created in a new expression. 
            For example, interfaces, static classes, and unconstrained type parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotReferencable">
            <summary>
            The candidate symbol existed, but was not allowed to be referenced. For example, the
            "get_XXX" method used to implement a property named "XXX" may not be directly
            referenced. Similarly, the type "System.Void" can not be directly referenced.
            Also occurs if "this" is used in a context (static method or field initializer)
            where "this" is not available.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.Inaccessible">
            <summary>
            The candidate symbol had an accessibility modifier (private, protected, ...) that made
            it inaccessible.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotAValue">
            <summary>
            The candidate symbol was in a place where a value was required, but was not a value
            (e.g., was a type or namespace).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotAVariable">
            <summary>
            The candidate symbol was in a place where a variable (or sometimes, a property) was
            required, but was not allowed there because it isn't a symbol that can be assigned to. 
            For example, the left hand side of an assignment, or a ref or out parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.NotInvocable">
            <summary>
            The candidate symbol was used in a way that an invocable member (method, or variable of
            delegate type) was required, but the candidate symbol was not invocable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.StaticInstanceMismatch">
            <summary>
            The candidate symbol must be an instance variable, but was used as static, or the
            reverse. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.OverloadResolutionFailure">
            <summary>
            Overload resolution did not choose a method. The candidate symbols are the methods there
            were considered during overload resolution (which may or may not be applicable methods). 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.LateBound">
            <summary>
            Method could not be selected statically.
            The candidate symbols are the methods there were considered during overload resolution 
            (which may or may not be applicable methods). 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.Ambiguous">
            <summary>
            Multiple ambiguous symbols were available with the same name. This can occur if "using"
            statements bring multiple namespaces into scope, and the same type is available in
            multiple. This can also occur if multiple properties of the same name are available in a
            multiple interface inheritance situation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CandidateReason.MemberGroup">
            <summary>
            CandidateSymbols are members of a group of results. This is used when there isn't a problem,
            but there is more than one result, for example nameof(int.ToString).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ModuleCompilationState`2._lazyStateMachineTypes">
            <summary>
            Maps an async/iterator method to the synthesized state machine type that implements the method. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CompilationOptions">
            <summary>
            Represents compilation options common to C# and VB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.OutputKind">
            <summary>
            The kind of assembly generated when emitted.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.ModuleName">
            <summary>
            Name of the primary module, or null if a default name should be used.
            </summary>
            <remarks>
            The name usually (but not necessarily) includes an extension, e.g. "MyModule.dll".
            
            If <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.ModuleName"/> is null the actual name written to metadata  
            is derived from the name of the compilation (<see cref="P:Microsoft.CodeAnalysis.Compilation.AssemblyName"/>)
            by appending a default extension for <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.OutputKind"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.ScriptClassName">
            <summary>
            The full name of a global implicit class (script class). This class implicitly encapsulates top-level statements, 
            type declarations, and member declarations. Could be a namespace qualified name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.MainTypeName">
            <summary>
            The full name of a type that declares static Main method. Must be a valid non-generic namespace-qualified name.
            Null if any static Main method is a candidate for an entry point.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoPublicKey">
            <summary>
            Specifies public key used to generate strong name for the compilation assembly, or empty if not specified.
            </summary>
            <remarks>
            If specified the values of <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyFile"/> and <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyContainer"/>
            must be null. If <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.PublicSign"/> is true the assembly is marked as fully signed
            but only signed with the public key (aka "OSS signing").
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyFile">
            <summary>
            The name of the file containing the public and private keys to use to generate strong name of the 
            compilation assembly and to sign it.
            </summary>
            <remarks>
            <para>
            To sign the output supply either one of <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyFile"/> or <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyContainer"/>.
            but not both. If both are specified <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyContainer"/> is ignored.
            </para>
            <para>
            If <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.PublicSign" /> is also set, <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyFile"/> must be the absolute
            path to key file.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyContainer">
            <summary>
            The CSP container containing the key with which to sign the output.
            </summary>
            <remarks>
            <para>
            To sign the output supply either one of <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyFile"/> or <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyContainer"/>.
            but not both. If both are specified <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyContainer"/> is ignored.
            </para>
            <para>
            This setting is obsolete and only supported on Microsoft Windows platform.
            Use <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoPublicKey"/> to generate assemblies with strong name and 
            a signing tool (Microsoft .NET Framework Strong Name Utility (sn.exe) or equivalent) to sign them.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.DelaySign">
            <summary>
            Mark the compilation assembly as delay-signed.
            </summary>
            <remarks>
            If true the resulting assembly is marked as delay signed.
            
            If false and <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoPublicKey"/>, <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyFile"/>, or <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyContainer"/> is specified
            or attribute System.Reflection.AssemblyKeyFileAttribute or System.Reflection.AssemblyKeyNameAttribute is applied to the 
            compilation assembly in source the resulting assembly is signed accordingly to the specified values/attributes.
            
            If null the semantics is specified by the value of attribute System.Reflection.AssemblyDelaySignAttribute 
            applied to the compilation assembly in source. If the attribute is not present the value defaults to "false".
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.PublicSign">
            <summary>
            Mark the compilation assembly as fully signed, but only sign with the public key.
            </summary>
            <remarks>
            <para>
            If true, the assembly is marked as signed, but is only signed with the public key.
            </para>
            <para>
            The key must be provided through either an absolute path in <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyFile"/>
            or directly via <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoPublicKey" />.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.CheckOverflow">
            <summary>
            Whether bounds checking on integer arithmetic is enforced by default or not.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.Platform">
            <summary>
            Specifies which version of the common language runtime (CLR) can run the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.OptimizationLevel">
            <summary>
            Specifies whether or not optimizations should be performed on the output IL.
            This is independent of whether or not PDB information is generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.GeneralDiagnosticOption">
            <summary>
            Global warning report option
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.WarningLevel">
            <summary>
            Global warning level (a non-negative integer).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.ConcurrentBuild">
            <summary>
            Specifies whether building compilation may use multiple threads.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.Deterministic">
            <summary>
            Specifies whether the compilation should be deterministic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.CurrentLocalTime">
            <summary>
            Used for time-based version generation when <see cref="T:System.Reflection.AssemblyVersionAttribute"/> contains a wildcard.
            If equal to default(<see cref="T:System.DateTime"/>) the actual current local time will be used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.DebugPlusMode">
            <summary>
            Emit mode that favors debuggability. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.MetadataImportOptions">
            <summary>
            Specifies whether to import members with accessibility other than public or protected by default. 
            Default value is <see cref="F:Microsoft.CodeAnalysis.MetadataImportOptions.Public"/>. The value specified is not going to 
            affect correctness of analysis performed by compilers because all members needed for correctness 
            are going to be imported regardless. This setting can force compilation to import members that it 
            normally doesn't.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.ReferencesSupersedeLowerVersions">
            <summary>
            Apply additional disambiguation rules during resolution of referenced assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.FilterDiagnostic(Microsoft.CodeAnalysis.Diagnostic,System.Threading.CancellationToken)">
            <summary>
            Modifies the incoming diagnostic, for example escalating its severity, or discarding it (returning null) based on the compilation options.
            </summary>
            <param name="diagnostic"></param>
            <returns>The modified diagnostic, or null</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.SpecificDiagnosticOptions">
            <summary>
            Warning report option for each warning.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.SyntaxTreeOptionsProvider">
            <summary>
            Provider to retrieve options for particular syntax trees.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.ReportSuppressedDiagnostics">
            <summary>
            Whether diagnostics suppressed in source, i.e. <see cref="P:Microsoft.CodeAnalysis.Diagnostic.IsSuppressed"/> is true, should be reported.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.MetadataReferenceResolver">
            <summary>
            Resolves paths to metadata references specified in source via #r directives.
            Null if the compilation can't contain references to metadata other than those explicitly passed to its factory (such as #r directives in sources). 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.XmlReferenceResolver">
            <summary>
            Gets the resolver for resolving XML document references for the compilation.
            Null if the compilation is not allowed to contain XML file references, such as XML doc comment include tags and permission sets stored in an XML file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.SourceReferenceResolver">
            <summary>
            Gets the resolver for resolving source document references for the compilation.
            Null if the compilation is not allowed to contain source file references, such as #line pragmas and #load directives.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.StrongNameProvider">
            <summary>
            Provides strong name and signature the source assembly.
            Null if assembly signing is not supported.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.AssemblyIdentityComparer">
            <summary>
            Used to compare assembly identities. May implement unification and portability policies specific to the target platform.
            <see cref="P:Microsoft.CodeAnalysis.AssemblyIdentityComparer.Default"/> if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.NullableContextOptions">
            <summary>
            Gets the default nullable context state in this compilation.
            </summary>
            <remarks>
            This context does not apply to files that are marked as generated. Nullable is off
            by default in those locations.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.Features">
            <summary>
            A set of strings designating experimental compiler features that are to be enabled.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.Language">
            <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Creates a new options instance with the specified general diagnostic option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithSpecificDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})">
            <summary>
            Creates a new options instance with the specified diagnostic-specific options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithSpecificDiagnosticOptions(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Microsoft.CodeAnalysis.ReportDiagnostic}})">
            <summary>
            Creates a new options instance with the specified diagnostic-specific options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithReportSuppressedDiagnostics(System.Boolean)">
            <summary>
            Creates a new options instance with the specified suppressed diagnostics reporting option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithConcurrentBuild(System.Boolean)">
            <summary>
            Creates a new options instance with the concurrent build property set accordingly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithDeterministic(System.Boolean)">
            <summary>
            Creates a new options instance with the deterministic property set accordingly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithOutputKind(Microsoft.CodeAnalysis.OutputKind)">
            <summary>
            Creates a new options instance with the specified output kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithPlatform(Microsoft.CodeAnalysis.Platform)">
            <summary>
            Creates a new options instance with the specified platform.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithPublicSign(System.Boolean)">
            <summary>
            Creates a new options instance with the specified public sign setting.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.WithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel)">
            <summary>
            Creates a new options instance with optimizations enabled or disabled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationOptions.ValidateOptions(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Performs validation of options compatibilities and generates diagnostics if needed
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOptions.Errors">
            <summary>
            Errors collection related to an incompatible set of compilation options
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CompilationStage">
            <summary>
            Represents the possible compilation stages for which it is possible to get diagnostics
            (errors).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ControlFlowAnalysis">
            <summary>
            Provides information about statements which transfer control in and out of a region. This
            information is returned from a call to <see cref="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.SyntaxNode)" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ControlFlowAnalysis.EntryPoints">
            <summary>
            The set of statements inside the region what are the
            destination of branches outside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ControlFlowAnalysis.ExitPoints">
            <summary>
            The set of statements inside a region that jump to locations outside
            the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ControlFlowAnalysis.EndPointIsReachable">
            <summary>
            Indicates whether a region completes normally. Return true if and only if the end of the
            last statement in a region is reachable or the region contains no statements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ControlFlowAnalysis.ReturnStatements">
            <summary>
            The set of return statements found within a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ControlFlowAnalysis.Succeeded">
            <summary>
            Returns true if and only if analysis was successful.  Analysis can fail if the region does not properly span a single expression,
            a single statement, or a contiguous series of statements within the enclosing block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DataFlowAnalysis">
            <summary>
            Provides information about how data flows into and out of a region. This information is
            returned from a call to
            <see cref="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />, or one of its language-specific overloads,
            where you pass the first and last statements of the region as parameters.
            "Inside" means those statements or ones between them. "Outside" are any other statements of the same method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.VariablesDeclared">
            <summary>
            The set of local variables that are declared within a region. Note
            that the region must be bounded by a method's body or a field's initializer, so
            parameter symbols are never included in the result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.DataFlowsIn">
            <summary>
            The set of local variables which are assigned a value outside a region
            that may be used inside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.DataFlowsOut">
            <summary>
            The set of local variables which are assigned a value inside a region
            that may be used outside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.DefinitelyAssignedOnEntry">
            <summary>
            <para>
            The set of local variables which are definitely assigned a value when a region is
            entered.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.DefinitelyAssignedOnExit">
            <summary>
            <para>
            The set of local variables which are definitely assigned a value when a region is
            exited.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.AlwaysAssigned">
            <summary>
            The set of local variables for which a value is always assigned inside
            a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.ReadInside">
            <summary>
            The set of local variables that are read inside a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.WrittenInside">
            <summary>
            The set of local variables that are written inside a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.ReadOutside">
            <summary>
            The set of the local variables that are read outside a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.WrittenOutside">
            <summary>
            The set of local variables that are written outside a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.Captured">
            <summary>
            The set of the local variables that have been referenced in anonymous
            functions within a region and therefore must be moved to a field of a frame class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.CapturedInside">
            <summary>
            The set of variables that are captured inside a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.CapturedOutside">
            <summary>
            The set of variables that are captured outside a region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.UnsafeAddressTaken">
            <summary>
            The set of non-constant local variables and parameters that have had their
            address (or the address of one of their fields) taken.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.UsedLocalFunctions">
            <summary>
            The set of local functions that are used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DataFlowAnalysis.Succeeded">
            <summary>
            Returns true if and only if analysis was successful.  Analysis can fail if the region does not
            properly span a single expression, a single statement, or a contiguous series of
            statements within the enclosing block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DeterministicKeyBuilder">
             <summary>
             The string returned from this function represents the inputs to the compiler which impact determinism.  It is 
             meant to be inline with the specification here:
             
                 - https://github.com/dotnet/roslyn/blob/main/docs/compilers/Deterministic%20Inputs.md
             
             Options which can cause compilation failure, but doesn't impact the result of a successful
             compilation should be included. That is because it is interesting to describe error states
             not just success states. Think about caching build failures as well as build successes.
            
             When an option is omitted, say if there is no value for a public crypto key, we should emit
             the property with a null value vs. omitting the property. Either approach would produce 
             correct results the preference is to be declarative that an option is omitted.
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DeterministicKeyOptions.Default">
            <summary>
            The default is to include all inputs to the compilation which impact the output of the 
            compilation: binaries or diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DeterministicKeyOptions.IgnorePaths">
            <summary>
            Ignore all file paths, but still include file names, in the deterministic key.
            </summary>
            <remarks>
            This is useful for scenarios where the consumer is interested in the content of the 
            <see cref="T:Microsoft.CodeAnalysis.Compilation"/> being the same but aren't concerned precisely with the file
            path of the content. A typical example of this type of consumer is one that operates 
            in CI where the path changes frequently.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DeterministicKeyOptions.IgnoreToolVersions">
            <summary>
            Ignore the versions of the tools contributing to the build (compiler and runtime)
            </summary>
            <remarks>
            Compiler output is not guaranteed to be deterministically equivalent between versions
            but very often is for wide ranges of versions. This option is useful for consumers 
            who are comfortable ignoring the versions when looking at compiler output. 
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.EmitResult">
            <summary>
            The result of the Compilation.Emit method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitResult.Success">
            <summary>
            True if the compilation successfully produced an executable.
            If false then the diagnostics should include at least one error diagnostic
            indicating the cause of the failure.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitResult.Diagnostics">
            <summary>
            A list of all the diagnostics associated with compilations. This include parse errors, declaration errors,
            compilation errors, and emitting errors.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.AnonymousTypeKeyField.Name">
            <summary>
            Name of the anonymous type field.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.AnonymousTypeKeyField.IsKey">
            <summary>
            True if the anonymous type field was marked as 'Key' in VB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.AnonymousTypeKeyField.IgnoreCase">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Emit.AnonymousTypeKeyField.Name"/> is case insensitive.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.AsyncMoveNextBodyDebugInfo">
            <summary>
            Represents additional info needed by async method implementation methods 
            (MoveNext methods) to properly emit necessary PDB data for async debugging.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.AsyncMoveNextBodyDebugInfo.CatchHandlerOffset">
            <summary> 
            IL offset of catch handler or -1 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.AsyncMoveNextBodyDebugInfo.YieldOffsets">
            <summary> 
            Set of IL offsets where await operators yield control
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.AsyncMoveNextBodyDebugInfo.ResumeOffsets">
            <summary> 
            Set of IL offsets where await operators are to be resumed 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.EncSymbolChanges">
            <summary>
            Symbol changes when emitting EnC delta.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.PreviousGeneration">
            <summary>
            Previous EnC generation baseline, or null if this is not EnC delta.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.IsEncDelta">
            <summary>
            True if this module is an EnC update.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.CurrentGenerationOrdinal">
            <summary>
            EnC generation. 0 if the module is not an EnC delta, 1 if it is the first EnC delta, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.Name">
            <summary>
            If this module represents an assembly, name of the assembly used in AssemblyDef table. Otherwise name of the module same as <see cref="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.ModuleName"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.ModuleName">
            <summary>
            Name of the module. Used in ModuleDef table.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetExportedTypes(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Public types defined in other modules making up this assembly and to which other assemblies may refer to via this assembly
            followed by types forwarded to another assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GenerateVisualBasicStylePdb">
            <summary>
            Used to distinguish which style to pick while writing native PDB information.
            </summary>
            <remarks>
            The PDB content for custom debug information is different between Visual Basic and CSharp.
            E.g. C# always includes a CustomMetadata Header (MD2) that contains the namespace scope counts, where 
            as VB only outputs namespace imports into the namespace scopes. 
            C# defines forwards in that header, VB includes them into the scopes list.
            
            Currently the compiler doesn't allow mixing C# and VB method bodies. Thus this flag can be per module.
            It is possible to move this flag to per-method basis but native PDB CDI forwarding would need to be adjusted accordingly.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.LinkedAssembliesDebugInfo">
            <summary>
            Linked assembly names to be stored to native PDB (VB only).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetImports">
            <summary>
            Project level imports (VB only, TODO: C# scripts).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.DefaultNamespace">
            <summary>
            Default namespace (VB only).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetAdditionalTopLevelTypeDefinitions(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Additional top-level types injected by the Expression Evaluators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetAnonymousTypeDefinitions(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Anonymous types defined in the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetEmbeddedTypeDefinitions(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Top-level embedded types (e.g. attribute types that are not present in referenced assemblies).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetTopLevelSourceTypeDefinitions(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Top-level named types defined in source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetFiles(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A list of the files that constitute the assembly. Empty for netmodule. These are not the source language files that may have been
            used to compile the assembly, but the files that contain constituent modules of a multi-module assembly as well
            as any external resources. It corresponds to the File table of the .NET assembly file format.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetSymbolToLocationMap">
            <summary>
            Builds symbol definition to location map used for emitting token -> location info
            into PDB to be consumed by WinMdExp.exe tool (only applicable for /t:winmdobj)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetTypeToDebugDocumentMap(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Builds a list of types, and their documents, that would otherwise not be referenced by any document info
            of any methods in those types, or any nested types. This data is helpful for navigating to the source of
            types that have no methods in one or more of the source files they are contained in.
            
            For example:
            
            First.cs:
            <code>
            partial class Outer
            {
                partial class Inner
                {
                    public void Method()
                    {
                    }
                }
            }
            </code>
            
            /// Second.cs:
            <code>
            partial class Outer
            {
                partial class Inner
                {
                }
            }
            </code>
            
            When navigating to the definition of "Outer" we know about First.cs because of the MethodDebugInfo for Outer.Inner.Method()
            but there would be no document information for Second.cs so this method would return that information.
            
            When navigating to "Inner" we likewise know about First.cs because of the MethodDebugInfo, and we know about Second.cs because
            of the document info for its containing type, so this method would not return information for Inner. In fact this method
            will never return information for any nested type.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.DebugDocumentCount">
            <summary>
            Number of debug documents in the module. 
            Used to determine capacities of lists and indices when emitting debug info.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.HintNumberOfMethodDefinitions">
            <summary>
            An approximate number of method definitions that can
            provide a basis for approximating the capacities of
            various databases used during Emit.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetCorLibrary(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            CorLibrary assembly referenced by this module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetStrings">
            <summary>
            Returns User Strings referenced from the IL in the module. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder.GetAssemblyReferenceAliases(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Assembly reference aliases (C# only).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9">
            <summary>
            Common base class for C# and VB PE module builder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9.GetTopLevelTypeDefinitions(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Returns all top-level (not nested) types defined in the module. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9.SynthesizedDefinitions">
            <summary>
            Captures the set of synthesized definitions that should be added to a type
            during emit process.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9.GetSynthesizedTypes(`4)">
            <summary>
            Returns null if there are no compiler generated types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9.GetSynthesizedFields(`4)">
            <summary>
            Returns null if there are no synthesized fields.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9.GetSynthesizedProperties(`4)">
            <summary>
            Returns null if there are no synthesized properties.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9.GetSynthesizedMethods(`4)">
            <summary>
            Returns null if there are no synthesized methods.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation">
            <summary>
            Debugging information associated with the specified method that is emitted by the compiler to support Edit and Continue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation.Create(System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Deserializes Edit and Continue method debug information from specified blobs.
            </summary>
            <param name="compressedSlotMap">Local variable slot map.</param>
            <param name="compressedLambdaMap">Lambda and closure map.</param>
            <exception cref="T:System.IO.InvalidDataException">Invalid data.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation.Create(System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Deserializes Edit and Continue method debug information from specified blobs.
            </summary>
            <param name="compressedSlotMap">Local variable slot map.</param>
            <param name="compressedLambdaMap">Lambda and closure map.</param>
            <param name="compressedStateMachineStateMap">State machine suspension points, if the method is the MoveNext method of the state machine.</param>
            <exception cref="T:System.IO.InvalidDataException">Invalid data.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation.UncompressSlotMap(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <exception cref="T:System.IO.InvalidDataException">Invalid data.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation.UncompressStateMachineStates(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <exception cref="T:System.IO.InvalidDataException">Invalid data.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.EditAndContinue.DeletedDefinition`1.#ctor(`0,System.Collections.Generic.Dictionary{Microsoft.Cci.ITypeDefinition,Microsoft.CodeAnalysis.Emit.EditAndContinue.DeletedTypeDefinition})">
            <summary>
            Constructs a deleted definition
            </summary>
            <param name="oldDefinition">The old definition of the member</param>
            <param name="typesUsedByDeletedMembers">
            Cache of type definitions used in signatures of deleted members. Used so that if a method 'C M(C c)' is deleted
            we use the same <see cref="T:Microsoft.CodeAnalysis.Emit.EditAndContinue.DeletedTypeDefinition"/> instance for the method return type, and the parameter type.
            </param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.EditAndContinue.DeletedTypeDefinition">
            <summary>
            Represents a type referenced from a deleted member (as distinct from a type that has been deleted). This is also
            why it doesn't inherit from <see cref="T:Microsoft.CodeAnalysis.Emit.EditAndContinue.DeletedDefinition`1"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.DeltaMetadataWriter._changedTypeDefs">
            <summary>
            Type definitions containing any changes (includes added types).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.DeltaMetadataWriter._typesUsedByDeletedMembers">
            <summary>
            Cache of type definitions used in signatures of deleted members. Used so that if a method 'C M(C c)' is deleted
            we use the same <see cref="T:Microsoft.CodeAnalysis.Emit.EditAndContinue.DeletedTypeDefinition"/> instance for the method return type, and the parameter type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.DeltaMetadataWriter.GetUpdatedMethodTokens(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Reflection.Metadata.MethodDefinitionHandle})">
            <summary>
            Return tokens for all updated debuggable methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.DeltaMetadataWriter.GetChangedTypeTokens(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Reflection.Metadata.TypeDefinitionHandle})">
            <summary>
            Return tokens for all updated or added types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.DeltaMetadataWriter.PopulateEncLogTableCustomAttributes(System.Collections.Generic.List{System.Int32}@)">
            <summary>
            CustomAttributes point to their target via the Parent column so we cannot simply output new rows
            in the delta or we would end up with duplicates, but we also don't want to do complex logic to determine
            which attributes have changes, so we just emit them all.
            This means our logic for emitting CustomAttributes is to update any existing rows, either from the original
            compilation or subsequent deltas, and only add more if we need to. The EncLog table is the thing that tells
            the runtime which row a CustomAttributes row is (ie, new or existing)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.DeltaMetadataWriter.DefinitionIndex`1.AddUpdated(`0)">
            <summary>
            Add an item from a previous generation
            that has been updated in this generation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.EmitBaseline">
            <summary>
            Represents a module from a previous compilation. Used in Edit and Continue
            to emit the differences in a subsequent compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.MetadataSymbols.AnonymousTypes">
            <summary>
            In C#, this is the set of anonymous types only; in VB, this is the set of anonymous types and delegates.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.MetadataSymbols.AnonymousDelegates">
            <summary>
            In C#, the set of anonymous delegates where the parameter types and return type are
            generic type arguments; in VB, this set is unused and empty.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.MetadataSymbols.AnonymousDelegatesWithFixedTypes">
            <summary>
            In C#, the set of anonymous delegates where at least one of the parameter types or return type
            is not a valid type argument; in VB, this set is unused and empty.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.MetadataSymbols.AssemblyReferenceIdentityMap">
            <summary>
            A map of the assembly identities of the baseline compilation to the identities of the original metadata AssemblyRefs.
            Only includes identities that differ between these two.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.EmitBaseline.CreateInitialBaseline(Microsoft.CodeAnalysis.ModuleMetadata,System.Func{System.Reflection.Metadata.MethodDefinitionHandle,Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation})">
            <summary>
            Creates an <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/> from the metadata of the module before editing
            and from a function that maps from a method to an array of local names. 
            </summary>
            <param name="module">The metadata of the module before editing.</param>
            <param name="debugInformationProvider">
            A function that for a method handle returns Edit and Continue debug information emitted by the compiler into the PDB.
            The function shall throw <see cref="T:System.IO.InvalidDataException"/> if the debug information can't be read for the specified method.
            This exception and <see cref="T:System.IO.IOException"/> are caught and converted to an emit diagnostic. Other exceptions are passed through.
            </param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/> for the module.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="module"/> is not a PE image.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="module"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="debugInformationProvider"/> is null.</exception>
            <exception cref="T:System.IO.IOException">Error reading module metadata.</exception>
            <exception cref="T:System.BadImageFormatException">Module metadata is invalid.</exception>
            <exception cref="T:System.ObjectDisposedException">Module has been disposed.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.EmitBaseline.CreateInitialBaseline(Microsoft.CodeAnalysis.ModuleMetadata,System.Func{System.Reflection.Metadata.MethodDefinitionHandle,Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation},System.Func{System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.StandaloneSignatureHandle},System.Boolean)">
            <summary>
            Creates an <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/> from the metadata of the module before editing
            and from a function that maps from a method to an array of local names. 
            </summary>
            <param name="module">The metadata of the module before editing.</param>
            <param name="debugInformationProvider">
            A function that for a method handle returns Edit and Continue debug information emitted by the compiler into the PDB.
            The function shall throw <see cref="T:System.IO.InvalidDataException"/> if the debug information can't be read for the specified method.
            This exception and <see cref="T:System.IO.IOException"/> are caught and converted to an emit diagnostic. Other exceptions are passed through.
            </param>
            <param name="localSignatureProvider">
            A function that for a method handle returns the signature of its local variables.
            The function shall throw <see cref="T:System.IO.InvalidDataException"/> if the information can't be read for the specified method.
            This exception and <see cref="T:System.IO.IOException"/> are caught and converted to an emit diagnostic. Other exceptions are passed through.
            </param>
            <param name="hasPortableDebugInformation">
            True if the baseline PDB is portable.
            </param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/> for the module.</returns>
            <remarks>
            Only the initial baseline is created using this method; subsequent baselines are created
            automatically when emitting the differences in subsequent compilations.
            
            When an active method (one for which a frame is allocated on a stack) is updated the values of its local variables need to be preserved.
            The mapping of local variable names to their slots in the frame is not included in the metadata and thus needs to be provided by 
            <paramref name="debugInformationProvider"/>.
            
            The <paramref name="debugInformationProvider"/> is only needed for the initial generation. The mapping for the subsequent generations
            is carried over through <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/>. The compiler assigns slots to named local variables (including named temporary variables)
            it the order in which they appear in the source code. This property allows the compiler to reconstruct the local variable mapping 
            for the initial generation. A subsequent generation may add a new variable in between two variables of the previous generation. 
            Since the slots of the previous generation variables need to be preserved the only option is to add these new variables to the end.
            The slot ordering thus no longer matches the syntax ordering. It is therefore necessary to pass <see cref="P:Microsoft.CodeAnalysis.Emit.EmitDifferenceResult.Baseline"/>
            to the next generation (rather than e.g. create new <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/>s from scratch based on metadata produced by subsequent compilations).
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="module"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="debugInformationProvider"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="localSignatureProvider"/> is null.</exception>
            <exception cref="T:System.IO.IOException">Error reading module metadata.</exception>
            <exception cref="T:System.BadImageFormatException">Module metadata is invalid.</exception>
            <exception cref="T:System.ObjectDisposedException">Module has been disposed.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitBaseline.OriginalMetadata">
            <summary>
            The original metadata of the module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.Ordinal">
            <summary>
            Metadata generation ordinal. Zero for
            full metadata and non-zero for delta.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.EncId">
            <summary>
            Unique Guid for this delta, or default(Guid)
            if full metadata.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.GenerationOrdinals">
            <summary>
            The latest generation number of each symbol added via <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Replace"/> edit.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.AddedOrChangedMethods">
            <summary>
            EnC metadata for methods added or updated since the initial generation, indexed by method row id.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.DebugInformationProvider">
            <summary>
            Reads EnC debug information of a method from the initial baseline PDB.
            The function shall throw <see cref="T:System.IO.InvalidDataException"/> if the debug information can't be read for the specified method.
            This exception and <see cref="T:System.IO.IOException"/> are caught and converted to an emit diagnostic. Other exceptions are passed through.
            The function shall return an empty <see cref="T:Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation"/> if the method that corresponds to the specified handle
            has no debug information.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.EmitBaseline.LocalSignatureProvider">
            <summary>
            A function that for a method handle returns the signature of its local variables.
            The function shall throw <see cref="T:System.IO.InvalidDataException"/> if the information can't be read for the specified method.
            This exception and <see cref="T:System.IO.IOException"/> are caught and converted to an emit diagnostic. Other exceptions are passed through.
            The function shall return a nil <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle"/> if the method that corresponds to the specified handle
            has no local variables.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitDifferenceResult.UpdatedMethods">
            <summary>
            Handles of methods with sequence points that have been updated in this delta.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitDifferenceResult.ChangedTypes">
            <summary>
            Handles of types that were changed (updated or inserted) in this delta.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.LambdaSyntaxFacts.TryGetCorrespondingLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            When invoked on a node that represents an anonymous function or a query clause [1]
            with a <paramref name="lambdaOrLambdaBodySyntax"/> of another anonymous function or a query clause of the same kind [2], 
            returns the body of the [1] that positionally corresponds to the specified <paramref name="lambdaOrLambdaBodySyntax"/>.
            
            E.g. join clause declares left expression and right expression -- each of these expressions is a lambda body.
            JoinClause1.GetCorrespondingLambdaBody(JoinClause2.RightExpression) returns JoinClause1.RightExpression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.LambdaSyntaxFacts.GetDeclaratorPosition(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a node that represents a variable declaration, lambda or a closure scope return the position to be used to calculate 
            the node's syntax offset with respect to its containing member.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChange.None">
            <summary>
            No change to symbol or members.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChange.ContainsChanges">
            <summary>
            No change to symbol but may contain changed symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChange.Updated">
            <summary>
            Symbol updated.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChange.Added">
            <summary>
            Symbol added.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChanges._definitionMap">
            <summary>
            Maps definitions being emitted to the corresponding definitions defined in the previous generation (metadata or source).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChanges._changes">
            <summary>
            Contains all symbols explicitly updated/added to the source and 
            their containing types and namespaces. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChanges._replacedSymbols">
            <summary>
            A set of symbols whose name emitted to metadata must include a "#{generation}" suffix to avoid naming collisions with existing types.
            Populated based on semantic edits with <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Replace"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SymbolChanges._deletedMembers">
            <summary>
            A set of symbols, from the old compilation, that have been deleted from the new compilation
            keyed by the containing type from the new compilation.
            Populated based on semantic edits with <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Delete"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.SymbolChanges.IsAdded(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            True if the symbol is a source symbol added during EnC session. 
            The symbol may be declared in any source compilation in the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.SymbolChanges.RequiresCompilation(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true if the symbol or some child symbol has changed and needs to be compiled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.SymbolChanges.CalculateChanges(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Emit.SemanticEdit},System.Collections.Generic.IReadOnlyDictionary{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Emit.SymbolChange}@,System.Collections.Generic.ISet{Microsoft.CodeAnalysis.ISymbol}@,System.Collections.Generic.IReadOnlyDictionary{Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.ISet{Microsoft.CodeAnalysis.ISymbol}}@)">
            <summary>
            Calculate the set of changes up to top-level types. The result
            will be used as a filter when traversing the module.
            
            Note that these changes only include user-defined source symbols, not synthesized symbols since those will be 
            generated during lowering of the changed user-defined symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.SymbolChanges.GetContainingSymbol(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Return the symbol that contains this symbol as far
            as changes are concerned. For instance, an auto property
            is considered the containing symbol for the backing
            field and the accessor methods. By default, the containing
            symbol is simply Symbol.ContainingSymbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.SymbolMatcher.MapSynthesizedOrDeletedMembers(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.Symbols.ISymbolInternal,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Symbols.ISymbolInternal}},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.Symbols.ISymbolInternal,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Symbols.ISymbolInternal}},System.Boolean)">
            <summary>
            Merges synthesized or deleted members generated during lowering, or emit, of the current compilation with aggregate
            synthesized or deleted members from all previous source generations (gen >= 1).
            </summary>
            <remarks>
            Suppose {S -> {A, B, D}, T -> {E, F}} are all synthesized members in previous generations,
            and {S' -> {A', B', C}, U -> {G, H}} members are generated in the current compilation.
            
            Where X matches X' via this matcher, i.e. X' is from the new compilation and 
            represents the same metadata entity as X in the previous compilation.
            
            Then the resulting collection shall have the following entries:
            {S' -> {A', B', C, D}, U -> {G, H}, T -> {E, F}}
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.EmitOptions">
            <summary>
            Represents compilation emit options.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly">
            <summary>
            True to emit an assembly excluding executable code such as method bodies.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.TolerateErrors">
            <summary>
            Tolerate errors, producing a PE stream and a success result even in the presence of (some) errors. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers">
            <summary>
            Unless set (private) members that don't affect the language semantics of the resulting assembly will be excluded
            when emitting metadata-only assemblies as primary output (with <see cref="P:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly"/> on).
            If emitting a secondary output, this flag is required to be false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.InstrumentationKinds">
            <summary>
            Type of instrumentation that should be added to the output binary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.SubsystemVersion">
            <summary>
            Subsystem version
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.FileAlignment">
            <summary>
            Specifies the size of sections in the output file. 
            </summary>
            <remarks>
            Valid values are 0, 512, 1024, 2048, 4096 and 8192.
            If the value is 0 the file alignment is determined based upon the value of <see cref="T:Microsoft.CodeAnalysis.Platform"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.HighEntropyVirtualAddressSpace">
            <summary>
            True to enable high entropy virtual address space for the output binary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.BaseAddress">
            <summary>
            Specifies the preferred base address at which to load the output DLL.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.DebugInformationFormat">
            <summary>
            Debug information format.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.OutputNameOverride">
            <summary>
            Assembly name override - file name and extension. If not specified the compilation name is used.
            </summary>
            <remarks>
            By default the name of the output assembly is <see cref="P:Microsoft.CodeAnalysis.Compilation.AssemblyName"/>. Only in rare cases it is necessary
            to override the name.
            
            CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to
            and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the 
            name of the compilation, may not be visible at runtime and vice-versa.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.PdbFilePath">
            <summary>
            The name of the PDB file to be embedded in the PE image, or null to use the default.
            </summary>
            <remarks>
            If not specified the file name of the source module with an extension changed to "pdb" is used.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.PdbChecksumAlgorithm">
            <summary>
            A crypto hash algorithm used to calculate PDB Checksum stored in the PE/COFF File.
            If not specified (the value is <c>default(HashAlgorithmName)</c>) the checksum is not calculated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.RuntimeMetadataVersion">
            <summary>
            Runtime metadata version. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.DefaultSourceFileEncoding">
            <summary>
            The encoding used to parse source files that do not have a Byte Order Mark. If specified,
            is stored in the emitted PDB in order to allow recreating the original compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.EmitOptions.FallbackSourceFileEncoding">
            <summary>
            If <see cref="P:Microsoft.CodeAnalysis.Emit.EmitOptions.DefaultSourceFileEncoding"/> is not specified, the encoding used to parse source files
            that do not declare their encoding via Byte Order Mark and are not UTF-8 encoded.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.EmitOptions.WithFileAlignment(System.Int32)">
            <summary>
            Sets the byte alignment for portable executable file sections.
            </summary>
            <param name="value">Can be one of the following values: 0, 512, 1024, 2048, 4096, 8192</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.ErrorType">
            <summary>
            Error type symbols should be replaced with an object of this class 
            in the translation layer for emit.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.ErrorType.s_name">
            <summary>
            For the name we will use a word "Error" followed by a guid, generated on the spot.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.ErrorType.ErrorAssembly">
            <summary>
            A fake containing assembly for an ErrorType object.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.ErrorType.ErrorAssembly.s_identity">
            <summary>
            For the name we will use a word "Error" followed by a guid, generated on the spot.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.InstrumentationKind">
            <summary>
            Specifies a kind of instrumentation to be applied in generated code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.InstrumentationKind.None">
            <summary>
            No instrumentation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.InstrumentationKind.TestCoverage">
            <summary>
            Instruments the binary to add test coverage.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.IteratorMoveNextBodyDebugInfo">
            <summary>
            Represents additional info needed by iterator method implementation methods 
            (MoveNext methods) to properly emit necessary PDB data for iterator debugging.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.NoPia.EmbeddedTypesManager`21.CommonEmbeddedMethod.ToString">
            <remarks>
            This is only used for testing.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.NoPia.EmbeddedTypesManager`21.CommonEmbeddedParameter.ToString">
            <remarks>
            This is only used for testing.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.NoPia.EmbeddedTypesManager`21.CommonEmbeddedType.ToString">
            <remarks>
            This is only used for testing.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.NoPia.EmbeddedTypesManager`21.GetEmbeddedTypeForMember(`5,`3,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Returns null if member doesn't belong to an embedded NoPia type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.SemanticEdit">
            <summary>
            Describes a symbol edit between two compilations. 
            For example, an addition of a method, an update of a method, removal of a type, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.SemanticEdit.Kind">
            <summary>
            The type of edit.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.SemanticEdit.OldSymbol">
            <summary>
            The symbol from the earlier compilation,
            or null if the edit represents an addition.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.SemanticEdit.NewSymbol">
            <summary>
            The symbol from the later compilation, or the symbol of the containing type
            from the later compilation if the edit represents a deletion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.SemanticEdit.SyntaxMap">
            <summary>
            A map from syntax node in the later compilation to syntax node in the previous compilation, 
            or null if <see cref="P:Microsoft.CodeAnalysis.Emit.SemanticEdit.PreserveLocalVariables"/> is false and the map is not needed or 
            the source of the current method is the same as the source of the previous method.
            </summary>
            <remarks>
            The map does not need to map all syntax nodes in the active method, only those syntax nodes
            that declare a local or generate a long lived local.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.SemanticEdit.PreserveLocalVariables">
            <summary>
            True if the edit is an update of the active method and local values
            should be preserved; false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.SemanticEdit.#ctor(Microsoft.CodeAnalysis.Emit.SemanticEditKind,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},System.Boolean)">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Emit.SemanticEdit"/>.
            </summary>
            <param name="kind">The type of edit.</param>
            <param name="oldSymbol">
            The symbol from the earlier compilation, or null if the edit represents an addition.
            </param>
            <param name="newSymbol">
            The symbol from the later compilation, or null if the edit represents a deletion.
            </param>
            <param name="syntaxMap">
            A map from syntax node in the later compilation to syntax node in the previous compilation, 
            or null if <paramref name="preserveLocalVariables"/> is false and the map is not needed or 
            the source of the current method is the same as the source of the previous method.
            </param>
            <param name="preserveLocalVariables">
            True if the edit is an update of an active method and local values should be preserved; false otherwise.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="oldSymbol"/> or <paramref name="newSymbol"/> is null and the edit isn't a <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Insert"/> or <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Delete"/>, respectively.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="kind"/> is not a valid kind.
            </exception>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.None">
            <summary>
            No change.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Update">
            <summary>
            Symbol is updated.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Insert">
            <summary>
            Symbol is inserted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Delete">
            <summary>
            Symbol is deleted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Replace">
            <summary>
            Existing symbol is replaced by its new version.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.StateMachineMoveNextBodyDebugInfo">
            <summary>
            Information associated with method body of a state machine MoveNext method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Emit.StateMachineMoveNextBodyDebugInfo.KickoffMethod">
            <summary>
             Original async/iterator method transformed into MoveNext() 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IInvalidOperation">
            <summary>
            Represents an invalid operation with one or more child operations.
            <para>
            Current usage:
             (1) C# invalid expression or invalid statement.
             (2) VB invalid expression or invalid statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Invalid"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IBlockOperation">
            <summary>
            Represents a block containing a sequence of operations and local declarations.
            <para>
            Current usage:
             (1) C# "{ ... }" block statement.
             (2) VB implicit block statement for method bodies and other block scoped statements.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Block"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBlockOperation.Operations">
            <summary>
            Operations contained within the block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBlockOperation.Locals">
            <summary>
            Local declarations contained within the block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation">
            <summary>
            Represents a variable declaration statement.
            </summary>
            <para>
            Current Usage:
              (1) C# local declaration statement
              (2) C# fixed statement
              (3) C# using statement
              (4) C# using declaration
              (5) VB Dim statement
              (6) VB Using statement
            </para>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.VariableDeclarationGroup"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation.Declarations">
            <summary>
            Variable declaration in the statement.
            </summary>
            <remarks>
            In C#, this will always be a single declaration, with all variables in <see cref="P:Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation.Declarators" />.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ISwitchOperation">
            <summary>
            Represents a switch operation with a value to be switched upon and switch cases.
            <para>
            Current usage:
             (1) C# switch statement.
             (2) VB Select Case statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Switch"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchOperation.Locals">
            <summary>
            Locals declared within the switch operation with scope spanning across all <see cref="P:Microsoft.CodeAnalysis.Operations.ISwitchOperation.Cases" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchOperation.Value">
            <summary>
            Value to be switched upon.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchOperation.Cases">
            <summary>
            Cases of the switch.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchOperation.ExitLabel">
            <summary>
            Exit label for the switch statement.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ILoopOperation">
            <summary>
            Represents a loop operation.
            <para>
            Current usage:
              (1) C# 'while', 'for', 'foreach' and 'do' loop statements
              (2) VB 'While', 'ForTo', 'ForEach', 'Do While' and 'Do Until' loop statements
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILoopOperation.LoopKind">
            <summary>
            Kind of the loop.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILoopOperation.Body">
            <summary>
            Body of the loop.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILoopOperation.Locals">
            <summary>
            Declared locals.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILoopOperation.ContinueLabel">
            <summary>
            Loop continue label.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILoopOperation.ExitLabel">
            <summary>
            Loop exit/break label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IForEachLoopOperation">
            <summary>
            Represents a for each loop.
            <para>
            Current usage:
             (1) C# 'foreach' loop statement
             (2) VB 'For Each' loop statement
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForEachLoopOperation.LoopControlVariable">
            <summary>
            Refers to the operation for declaring a new local variable or reference an existing variable or an expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForEachLoopOperation.Collection">
            <summary>
            Collection value over which the loop iterates.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForEachLoopOperation.NextVariables">
            <summary>
            Optional list of comma separated next variables at loop bottom in VB.
            This list is always empty for C#.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForEachLoopOperation.IsAsynchronous">
            <summary>
            Whether this for each loop is asynchronous.
            Always false for VB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IForLoopOperation">
            <summary>
            Represents a for loop.
            <para>
            Current usage:
             (1) C# 'for' loop statement
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForLoopOperation.Before">
            <summary>
            List of operations to execute before entry to the loop. For C#, this comes from the first clause of the for statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForLoopOperation.ConditionLocals">
            <summary>
            Locals declared within the loop Condition and are in scope throughout the <see cref="P:Microsoft.CodeAnalysis.Operations.IForLoopOperation.Condition" />,
            <see cref="P:Microsoft.CodeAnalysis.Operations.ILoopOperation.Body" /> and <see cref="P:Microsoft.CodeAnalysis.Operations.IForLoopOperation.AtLoopBottom" />.
            They are considered to be declared per iteration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForLoopOperation.Condition">
            <summary>
            Condition of the loop. For C#, this comes from the second clause of the for statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForLoopOperation.AtLoopBottom">
            <summary>
            List of operations to execute at the bottom of the loop. For C#, this comes from the third clause of the for statement.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IForToLoopOperation">
            <summary>
            Represents a for to loop with loop control variable and initial, limit and step values for the control variable.
            <para>
            Current usage:
             (1) VB 'For ... To ... Step' loop statement
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForToLoopOperation.LoopControlVariable">
            <summary>
            Refers to the operation for declaring a new local variable or reference an existing variable or an expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForToLoopOperation.InitialValue">
            <summary>
            Operation for setting the initial value of the loop control variable. This comes from the expression between the 'For' and 'To' keywords.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForToLoopOperation.LimitValue">
            <summary>
            Operation for the limit value of the loop control variable. This comes from the expression after the 'To' keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForToLoopOperation.StepValue">
            <summary>
            Operation for the step value of the loop control variable. This comes from the expression after the 'Step' keyword,
            or inferred by the compiler if 'Step' clause is omitted.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForToLoopOperation.IsChecked">
            <summary>
            <code>true</code> if arithmetic operations behind this loop are 'checked'.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IForToLoopOperation.NextVariables">
            <summary>
            Optional list of comma separated next variables at loop bottom.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IWhileLoopOperation">
            <summary>
            Represents a while or do while loop.
            <para>
            Current usage:
             (1) C# 'while' and 'do while' loop statements.
             (2) VB 'While', 'Do While' and 'Do Until' loop statements.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IWhileLoopOperation.Condition">
            <summary>
            Condition of the loop. This can only be null in error scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IWhileLoopOperation.ConditionIsTop">
            <summary>
            True if the <see cref="P:Microsoft.CodeAnalysis.Operations.IWhileLoopOperation.Condition" /> is evaluated at start of each loop iteration.
            False if it is evaluated at the end of each loop iteration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IWhileLoopOperation.ConditionIsUntil">
            <summary>
            True if the loop has 'Until' loop semantics and the loop is executed while <see cref="P:Microsoft.CodeAnalysis.Operations.IWhileLoopOperation.Condition" /> is false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IWhileLoopOperation.IgnoredCondition">
            <summary>
            Additional conditional supplied for loop in error cases, which is ignored by the compiler.
            For example, for VB 'Do While' or 'Do Until' loop with syntax errors where both the top and bottom conditions are provided.
            The top condition is preferred and exposed as <see cref="P:Microsoft.CodeAnalysis.Operations.IWhileLoopOperation.Condition" /> and the bottom condition is ignored and exposed by this property.
            This property should be null for all non-error cases.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ILabeledOperation">
            <summary>
            Represents an operation with a label.
            <para>
            Current usage:
             (1) C# labeled statement.
             (2) VB label statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Labeled"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILabeledOperation.Label">
            <summary>
            Label that can be the target of branches.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILabeledOperation.Operation">
            <summary>
            Operation that has been labeled. In VB, this is always null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IBranchOperation">
            <summary>
            Represents a branch operation.
            <para>
            Current usage:
             (1) C# goto, break, or continue statement.
             (2) VB GoTo, Exit ***, or Continue *** statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Branch"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBranchOperation.Target">
            <summary>
            Label that is the target of the branch.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBranchOperation.BranchKind">
            <summary>
            Kind of the branch.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IEmptyOperation">
            <summary>
            Represents an empty or no-op operation.
            <para>
            Current usage:
             (1) C# empty statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Empty"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IReturnOperation">
            <summary>
            Represents a return from the method with an optional return value.
            <para>
            Current usage:
             (1) C# return statement and yield statement.
             (2) VB Return statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Return"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.YieldBreak"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.YieldReturn"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IReturnOperation.ReturnedValue">
            <summary>
            Value to be returned.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ILockOperation">
            <summary>
            Represents a <see cref="P:Microsoft.CodeAnalysis.Operations.ILockOperation.Body" /> of operations that are executed while holding a lock onto the <see cref="P:Microsoft.CodeAnalysis.Operations.ILockOperation.LockedValue" />.
            <para>
            Current usage:
             (1) C# lock statement.
             (2) VB SyncLock statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Lock"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILockOperation.LockedValue">
            <summary>
            Operation producing a value to be locked.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILockOperation.Body">
            <summary>
            Body of the lock, to be executed while holding the lock.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ITryOperation">
            <summary>
            Represents a try operation for exception handling code with a body, catch clauses and a finally handler.
            <para>
            Current usage:
             (1) C# try statement.
             (2) VB Try statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Try"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITryOperation.Body">
            <summary>
            Body of the try, over which the handlers are active.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITryOperation.Catches">
            <summary>
            Catch clauses of the try.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITryOperation.Finally">
            <summary>
            Finally handler of the try.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITryOperation.ExitLabel">
            <summary>
            Exit label for the try. This will always be null for C#.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IUsingOperation">
            <summary>
            Represents a <see cref="P:Microsoft.CodeAnalysis.Operations.IUsingOperation.Body" /> of operations that are executed while using disposable <see cref="P:Microsoft.CodeAnalysis.Operations.IUsingOperation.Resources" />.
            <para>
            Current usage:
             (1) C# using statement.
             (2) VB Using statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Using"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUsingOperation.Resources">
            <summary>
            Declaration introduced or resource held by the using.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUsingOperation.Body">
            <summary>
            Body of the using, over which the resources of the using are maintained.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUsingOperation.Locals">
            <summary>
            Locals declared within the <see cref="P:Microsoft.CodeAnalysis.Operations.IUsingOperation.Resources" /> with scope spanning across this entire <see cref="T:Microsoft.CodeAnalysis.Operations.IUsingOperation" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUsingOperation.IsAsynchronous">
            <summary>
            Whether this using is asynchronous.
            Always false for VB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IExpressionStatementOperation">
            <summary>
            Represents an operation that drops the resulting value and the type of the underlying wrapped <see cref="P:Microsoft.CodeAnalysis.Operations.IExpressionStatementOperation.Operation" />.
            <para>
            Current usage:
             (1) C# expression statement.
             (2) VB expression statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ExpressionStatement"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IExpressionStatementOperation.Operation">
            <summary>
            Underlying operation with a value and type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ILocalFunctionOperation">
            <summary>
            Represents a local function defined within a method.
            <para>
            Current usage:
             (1) C# local function statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.LocalFunction"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILocalFunctionOperation.Symbol">
            <summary>
            Local function symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILocalFunctionOperation.Body">
            <summary>
            Body of the local function.
            </summary>
            <remarks>
            This can be null in error scenarios, or when the method is an extern method.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILocalFunctionOperation.IgnoredBody">
            <summary>
            An extra body for the local function, if both a block body and expression body are specified in source.
            </summary>
            <remarks>
            This is only ever non-null in error situations.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IStopOperation">
            <summary>
            Represents an operation to stop or suspend execution of code.
            <para>
            Current usage:
             (1) VB Stop statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Stop"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IEndOperation">
            <summary>
            Represents an operation that stops the execution of code abruptly.
            <para>
            Current usage:
             (1) VB End Statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.End"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IRaiseEventOperation">
            <summary>
            Represents an operation for raising an event.
            <para>
            Current usage:
             (1) VB raise event statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.RaiseEvent"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRaiseEventOperation.EventReference">
            <summary>
            Reference to the event to be raised.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRaiseEventOperation.Arguments">
            <summary>
            Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order.
            </summary>
            <remarks>
            If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
            Default values are supplied for optional arguments missing in source.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ILiteralOperation">
            <summary>
            Represents a textual literal numeric, string, etc.
            <para>
            Current usage:
             (1) C# literal expression.
             (2) VB literal expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Literal"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IConversionOperation">
            <summary>
            Represents a type conversion.
            <para>
            Current usage:
             (1) C# conversion expression.
             (2) VB conversion expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Conversion"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConversionOperation.Operand">
            <summary>
            Value to be converted.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConversionOperation.OperatorMethod">
            <summary>
            Operator method used by the operation, null if the operation does not use an operator method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConversionOperation.ConstrainedToType">
            <summary>
            Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="P:Microsoft.CodeAnalysis.Operations.IConversionOperation.OperatorMethod" />, if any.
            Null if <see cref="P:Microsoft.CodeAnalysis.Operations.IConversionOperation.OperatorMethod" /> is resolved statically, or is null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConversionOperation.Conversion">
            <summary>
            Gets the underlying common conversion information.
            </summary>
            <remarks>
            If you need conversion information that is language specific, use either
            <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(IConversionOperation)" /> or
            <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion(IConversionOperation)" />.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConversionOperation.IsTryCast">
            <summary>
            False if the conversion will fail with a <see cref="T:System.InvalidCastException" /> at runtime if the cast fails. This is true for C#'s
            <c>as</c> operator and for VB's <c>TryCast</c> operator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConversionOperation.IsChecked">
            <summary>
            True if the conversion can fail at runtime with an overflow exception. This corresponds to C# checked and unchecked blocks.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IInvocationOperation">
            <summary>
            Represents an invocation of a method.
            <para>
            Current usage:
             (1) C# method invocation expression.
             (2) C# collection element initializer.
                 For example, in the following collection initializer: <code>new C() { 1, 2, 3 }</code>, we will have
                 3 <see cref="T:Microsoft.CodeAnalysis.Operations.IInvocationOperation" /> nodes, each of which will be a call to the corresponding Add method
                 with either 1, 2, 3 as the argument.
             (3) VB method invocation expression.
             (4) VB collection element initializer.
                 Similar to the C# example, <code>New C() From {1, 2, 3}</code> will have 3 <see cref="T:Microsoft.CodeAnalysis.Operations.IInvocationOperation" />
                 nodes with 1, 2, and 3 as their arguments, respectively.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Invocation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInvocationOperation.TargetMethod">
            <summary>
            Method to be invoked.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInvocationOperation.ConstrainedToType">
            <summary>
            Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="P:Microsoft.CodeAnalysis.Operations.IInvocationOperation.TargetMethod" />.
            Null if <see cref="P:Microsoft.CodeAnalysis.Operations.IInvocationOperation.TargetMethod" /> is resolved statically, or is an instance method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInvocationOperation.Instance">
            <summary>
            'This' or 'Me' instance to be supplied to the method, or null if the method is static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInvocationOperation.IsVirtual">
            <summary>
            True if the invocation uses a virtual mechanism, and false otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInvocationOperation.Arguments">
            <summary>
            Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order.
            </summary>
            <remarks>
            If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
            Default values are supplied for optional arguments missing in source.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IArrayElementReferenceOperation">
            <summary>
            Represents a reference to an array element.
            <para>
            Current usage:
             (1) C# array element reference expression.
             (2) VB array element reference expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ArrayElementReference"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IArrayElementReferenceOperation.ArrayReference">
            <summary>
            Array to be indexed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IArrayElementReferenceOperation.Indices">
            <summary>
            Indices that specify an individual element.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ILocalReferenceOperation">
            <summary>
            Represents a reference to a declared local variable.
            <para>
            Current usage:
             (1) C# local reference expression.
             (2) VB local reference expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.LocalReference"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILocalReferenceOperation.Local">
            <summary>
            Referenced local variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ILocalReferenceOperation.IsDeclaration">
            <summary>
            True if this reference is also the declaration site of this variable. This is true in out variable declarations
            and in deconstruction operations where a new variable is being declared.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IParameterReferenceOperation">
            <summary>
            Represents a reference to a parameter.
            <para>
            Current usage:
             (1) C# parameter reference expression.
             (2) VB parameter reference expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ParameterReference"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IParameterReferenceOperation.Parameter">
            <summary>
            Referenced parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IMemberReferenceOperation">
            <summary>
            Represents a reference to a member of a class, struct, or interface.
            <para>
            Current usage:
             (1) C# member reference expression.
             (2) VB member reference expression.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IMemberReferenceOperation.Instance">
            <summary>
            Instance of the type. Null if the reference is to a static/shared member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IMemberReferenceOperation.Member">
            <summary>
            Referenced member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IMemberReferenceOperation.ConstrainedToType">
            <summary>
            Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="P:Microsoft.CodeAnalysis.Operations.IMemberReferenceOperation.Member" />.
            Null if <see cref="P:Microsoft.CodeAnalysis.Operations.IMemberReferenceOperation.Member" /> is resolved statically, or is an instance member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IFieldReferenceOperation">
            <summary>
            Represents a reference to a field.
            <para>
            Current usage:
             (1) C# field reference expression.
             (2) VB field reference expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.FieldReference"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IFieldReferenceOperation.Field">
            <summary>
            Referenced field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IFieldReferenceOperation.IsDeclaration">
            <summary>
            If the field reference is also where the field was declared.
            </summary>
            <remarks>
            This is only ever true in CSharp scripts, where a top-level statement creates a new variable
            in a reference, such as an out variable declaration or a deconstruction declaration.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IMethodReferenceOperation">
            <summary>
            Represents a reference to a method other than as the target of an invocation.
            <para>
            Current usage:
             (1) C# method reference expression.
             (2) VB method reference expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.MethodReference"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IMethodReferenceOperation.Method">
            <summary>
            Referenced method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IMethodReferenceOperation.IsVirtual">
            <summary>
            Indicates whether the reference uses virtual semantics.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IPropertyReferenceOperation">
            <summary>
            Represents a reference to a property.
            <para>
            Current usage:
             (1) C# property reference expression.
             (2) VB property reference expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.PropertyReference"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IPropertyReferenceOperation.Property">
            <summary>
            Referenced property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IPropertyReferenceOperation.Arguments">
            <summary>
            Arguments of the indexer property reference, excluding the instance argument. Arguments are in evaluation order.
            </summary>
            <remarks>
            If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
            Default values are supplied for optional arguments missing in source.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IEventReferenceOperation">
            <summary>
            Represents a reference to an event.
            <para>
            Current usage:
             (1) C# event reference expression.
             (2) VB event reference expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.EventReference"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IEventReferenceOperation.Event">
            <summary>
            Referenced event.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IUnaryOperation">
            <summary>
            Represents an operation with one operand and a unary operator.
            <para>
            Current usage:
             (1) C# unary operation expression.
             (2) VB unary operation expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Unary"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.UnaryOperator"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUnaryOperation.OperatorKind">
            <summary>
            Kind of unary operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUnaryOperation.Operand">
            <summary>
            Operand.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUnaryOperation.IsLifted">
            <summary>
            <see langword="true" /> if this is a 'lifted' unary operator.  When there is an
            operator that is defined to work on a value type, 'lifted' operators are
            created to work on the <see cref="T:System.Nullable`1" /> versions of those
            value types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUnaryOperation.IsChecked">
            <summary>
            <see langword="true" /> if overflow checking is performed for the arithmetic operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUnaryOperation.OperatorMethod">
            <summary>
            Operator method used by the operation, null if the operation does not use an operator method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUnaryOperation.ConstrainedToType">
            <summary>
            Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="P:Microsoft.CodeAnalysis.Operations.IUnaryOperation.OperatorMethod" />, if any.
            Null if <see cref="P:Microsoft.CodeAnalysis.Operations.IUnaryOperation.OperatorMethod" /> is resolved statically, or is null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IBinaryOperation">
            <summary>
            Represents an operation with two operands and a binary operator that produces a result with a non-null type.
            <para>
            Current usage:
             (1) C# binary operator expression.
             (2) VB binary operator expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Binary"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.BinaryOperator"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBinaryOperation.OperatorKind">
            <summary>
            Kind of binary operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBinaryOperation.LeftOperand">
            <summary>
            Left operand.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBinaryOperation.RightOperand">
            <summary>
            Right operand.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBinaryOperation.IsLifted">
            <summary>
            <see langword="true" /> if this is a 'lifted' binary operator.  When there is an
            operator that is defined to work on a value type, 'lifted' operators are
            created to work on the <see cref="T:System.Nullable`1" /> versions of those
            value types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBinaryOperation.IsChecked">
            <summary>
            <see langword="true" /> if this is a 'checked' binary operator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBinaryOperation.IsCompareText">
            <summary>
            <see langword="true" /> if the comparison is text based for string or object comparison in VB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBinaryOperation.OperatorMethod">
            <summary>
            Operator method used by the operation, null if the operation does not use an operator method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBinaryOperation.ConstrainedToType">
            <summary>
            Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="P:Microsoft.CodeAnalysis.Operations.IBinaryOperation.OperatorMethod" />
            or corresponding true/false operator, if any.
            Null if operators are resolved statically, or are not used.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IConditionalOperation">
            <summary>
            Represents a conditional operation with:
            (1) <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalOperation.Condition" /> to be tested,
            (2) <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalOperation.WhenTrue" /> operation to be executed when <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalOperation.Condition" /> is true and
            (3) <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalOperation.WhenFalse" /> operation to be executed when the <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalOperation.Condition" /> is false.
            <para>
            Current usage:
             (1) C# ternary expression "a ? b : c" and if statement.
             (2) VB ternary expression "If(a, b, c)" and If Else statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Conditional"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConditionalOperation.Condition">
            <summary>
            Condition to be tested.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConditionalOperation.WhenTrue">
            <summary>
            Operation to be executed if the <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalOperation.Condition" /> is true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConditionalOperation.WhenFalse">
            <summary>
            Operation to be executed if the <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalOperation.Condition" /> is false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConditionalOperation.IsRef">
            <summary>
            Is result a managed reference
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ICoalesceOperation">
            <summary>
            Represents a coalesce operation with two operands:
            (1) <see cref="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.Value" />, which is the first operand that is unconditionally evaluated and is the result of the operation if non null.
            (2) <see cref="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.WhenNull" />, which is the second operand that is conditionally evaluated and is the result of the operation if <see cref="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.Value" /> is null.
            <para>
            Current usage:
             (1) C# null-coalescing expression "Value ?? WhenNull".
             (2) VB binary conditional expression "If(Value, WhenNull)".
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Coalesce"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.Value">
            <summary>
            Operation to be unconditionally evaluated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.WhenNull">
            <summary>
            Operation to be conditionally evaluated if <see cref="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.Value" /> evaluates to null/Nothing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.ValueConversion">
            <summary>
            Conversion associated with <see cref="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.Value" /> when it is not null/Nothing.
            Identity if result type of the operation is the same as type of <see cref="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.Value" />.
            Otherwise, if type of <see cref="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.Value" /> is nullable, then conversion is applied to an
            unwrapped <see cref="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.Value" />, otherwise to the <see cref="P:Microsoft.CodeAnalysis.Operations.ICoalesceOperation.Value" /> itself.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IAnonymousFunctionOperation">
            <summary>
            Represents an anonymous function operation.
            <para>
            Current usage:
             (1) C# lambda expression.
             (2) VB anonymous delegate expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.AnonymousFunction"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IAnonymousFunctionOperation.Symbol">
            <summary>
            Symbol of the anonymous function.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IAnonymousFunctionOperation.Body">
            <summary>
            Body of the anonymous function.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IObjectCreationOperation">
            <summary>
            Represents creation of an object instance.
            <para>
            Current usage:
             (1) C# new expression.
             (2) VB New expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ObjectCreation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IObjectCreationOperation.Constructor">
            <summary>
            Constructor to be invoked on the created instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IObjectCreationOperation.Initializer">
            <summary>
            Object or collection initializer, if any.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IObjectCreationOperation.Arguments">
            <summary>
            Arguments of the object creation, excluding the instance argument. Arguments are in evaluation order.
            </summary>
            <remarks>
            If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
            Default values are supplied for optional arguments missing in source.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ITypeParameterObjectCreationOperation">
            <summary>
            Represents a creation of a type parameter object, i.e. new T(), where T is a type parameter with new constraint.
            <para>
            Current usage:
             (1) C# type parameter object creation expression.
             (2) VB type parameter object creation expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.TypeParameterObjectCreation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITypeParameterObjectCreationOperation.Initializer">
            <summary>
            Object or collection initializer, if any.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IArrayCreationOperation">
            <summary>
            Represents the creation of an array instance.
            <para>
            Current usage:
             (1) C# array creation expression.
             (2) VB array creation expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ArrayCreation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IArrayCreationOperation.DimensionSizes">
            <summary>
            Sizes of the dimensions of the created array instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IArrayCreationOperation.Initializer">
            <summary>
            Values of elements of the created array instance.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IInstanceReferenceOperation">
            <summary>
            Represents an implicit/explicit reference to an instance.
            <para>
            Current usage:
             (1) C# this or base expression.
             (2) VB Me, MyClass, or MyBase expression.
             (3) C# object or collection or 'with' expression initializers.
             (4) VB With statements, object or collection initializers.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.InstanceReference"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInstanceReferenceOperation.ReferenceKind">
            <summary>
            The kind of reference that is being made.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IIsTypeOperation">
            <summary>
            Represents an operation that tests if a value is of a specific type.
            <para>
            Current usage:
             (1) C# "is" operator expression.
             (2) VB "TypeOf" and "TypeOf IsNot" expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.IsType"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IIsTypeOperation.ValueOperand">
            <summary>
            Value to test.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IIsTypeOperation.TypeOperand">
            <summary>
            Type for which to test.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IIsTypeOperation.IsNegated">
            <summary>
            Flag indicating if this is an "is not" type expression.
            True for VB "TypeOf ... IsNot ..." expression.
            False, otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IAwaitOperation">
            <summary>
            Represents an await operation.
            <para>
            Current usage:
             (1) C# await expression.
             (2) VB await expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Await"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IAwaitOperation.Operation">
            <summary>
            Awaited operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IAssignmentOperation">
            <summary>
            Represents a base interface for assignments.
            <para>
            Current usage:
             (1) C# simple, compound and deconstruction assignment expressions.
             (2) VB simple and compound assignment expressions.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Target">
            <summary>
            Target of the assignment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Value">
            <summary>
            Value to be assigned to the target of the assignment.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ISimpleAssignmentOperation">
            <summary>
            Represents a simple assignment operation.
            <para>
            Current usage:
             (1) C# simple assignment expression.
             (2) VB simple assignment expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.SimpleAssignment"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISimpleAssignmentOperation.IsRef">
            <summary>
            Is this a ref assignment
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation">
            <summary>
            Represents a compound assignment that mutates the target with the result of a binary operation.
            <para>
            Current usage:
             (1) C# compound assignment expression.
             (2) VB compound assignment expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.CompoundAssignment"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation.InConversion">
            <summary>
            Conversion applied to <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Target" /> before the operation occurs.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation.OutConversion">
            <summary>
            Conversion applied to the result of the binary operation, before it is assigned back to
            <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Target" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation.OperatorKind">
            <summary>
            Kind of binary operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation.IsLifted">
            <summary>
            <see langword="true" /> if this assignment contains a 'lifted' binary operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation.IsChecked">
            <summary>
            <see langword="true" /> if overflow checking is performed for the arithmetic operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation.OperatorMethod">
            <summary>
            Operator method used by the operation, null if the operation does not use an operator method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation.ConstrainedToType">
            <summary>
            Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="P:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation.OperatorMethod" />, if any.
            Null if <see cref="P:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation.OperatorMethod" /> is resolved statically, or is null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IParenthesizedOperation">
            <summary>
            Represents a parenthesized operation.
            <para>
            Current usage:
             (1) VB parenthesized expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Parenthesized"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IParenthesizedOperation.Operand">
            <summary>
            Operand enclosed in parentheses.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IEventAssignmentOperation">
            <summary>
            Represents a binding of an event.
            <para>
            Current usage:
             (1) C# event assignment expression.
             (2) VB Add/Remove handler statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.EventAssignment"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IEventAssignmentOperation.EventReference">
            <summary>
            Reference to the event being bound.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IEventAssignmentOperation.HandlerValue">
            <summary>
            Handler supplied for the event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IEventAssignmentOperation.Adds">
            <summary>
            True for adding a binding, false for removing one.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IConditionalAccessOperation">
            <summary>
            Represents a conditionally accessed operation. Note that <see cref="T:Microsoft.CodeAnalysis.Operations.IConditionalAccessInstanceOperation" /> is used to refer to the value
            of <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalAccessOperation.Operation" /> within <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalAccessOperation.WhenNotNull" />.
            <para>
            Current usage:
             (1) C# conditional access expression (? or ?. operator).
             (2) VB conditional access expression (? or ?. operator).
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ConditionalAccess"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConditionalAccessOperation.Operation">
            <summary>
            Operation that will be evaluated and accessed if non null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConditionalAccessOperation.WhenNotNull">
            <summary>
            Operation to be evaluated if <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalAccessOperation.Operation" /> is non null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IConditionalAccessInstanceOperation">
            <summary>
            Represents the value of a conditionally-accessed operation within <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalAccessOperation.WhenNotNull" />.
            For a conditional access operation of the form <c>someExpr?.Member</c>, this operation is used as the InstanceReceiver for the right operation <c>Member</c>.
            See https://github.com/dotnet/roslyn/issues/21279#issuecomment-323153041 for more details.
            <para>
            Current usage:
             (1) C# conditional access instance expression.
             (2) VB conditional access instance expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ConditionalAccessInstance"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringOperation">
            <summary>
            Represents an interpolated string.
            <para>
            Current usage:
             (1) C# interpolated string expression.
             (2) VB interpolated string expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedString"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringOperation.Parts">
            <summary>
            Constituent parts of interpolated string, each of which is an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringContentOperation" />.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IAnonymousObjectCreationOperation">
            <summary>
            Represents a creation of anonymous object.
            <para>
            Current usage:
             (1) C# "new { ... }" expression
             (2) VB "New With { ... }" expression
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.AnonymousObjectCreation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IAnonymousObjectCreationOperation.Initializers">
            <summary>
            Property initializers.
            Each initializer is an <see cref="T:Microsoft.CodeAnalysis.Operations.ISimpleAssignmentOperation" />, with an <see cref="T:Microsoft.CodeAnalysis.Operations.IPropertyReferenceOperation" />
            as the target whose Instance is an <see cref="T:Microsoft.CodeAnalysis.Operations.IInstanceReferenceOperation" /> with <see cref="F:Microsoft.CodeAnalysis.Operations.InstanceReferenceKind.ImplicitReceiver" /> kind.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IObjectOrCollectionInitializerOperation">
            <summary>
            Represents an initialization for an object or collection creation.
            <para>
            Current usage:
             (1) C# object or collection initializer expression.
             (2) VB object or collection initializer expression.
            For example, object initializer "{ X = x }" within object creation "new Class() { X = x }" and
            collection initializer "{ x, y, 3 }" within collection creation "new MyList() { x, y, 3 }".
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ObjectOrCollectionInitializer"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IObjectOrCollectionInitializerOperation.Initializers">
            <summary>
            Object member or collection initializers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IMemberInitializerOperation">
            <summary>
            Represents an initialization of member within an object initializer with a nested object or collection initializer.
            <para>
            Current usage:
             (1) C# nested member initializer expression.
              For example, given an object creation with initializer "new Class() { X = x, Y = { x, y, 3 }, Z = { X = z } }",
              member initializers for Y and Z, i.e. "Y = { x, y, 3 }", and "Z = { X = z }" are nested member initializers represented by this operation.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.MemberInitializer"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IMemberInitializerOperation.InitializedMember">
            <summary>
            Initialized member reference <see cref="T:Microsoft.CodeAnalysis.Operations.IMemberReferenceOperation" /> or an invalid operation for error cases.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IMemberInitializerOperation.Initializer">
            <summary>
            Member initializer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ICollectionElementInitializerOperation">
            <summary>
            Obsolete interface that used to represent a collection element initializer. It has been replaced by
            <see cref="T:Microsoft.CodeAnalysis.Operations.IInvocationOperation" /> and <see cref="T:Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation" />, as appropriate.
            <para>
            Current usage:
              None. This API has been obsoleted in favor of <see cref="T:Microsoft.CodeAnalysis.Operations.IInvocationOperation" /> and <see cref="T:Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation" />.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.CollectionElementInitializer"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.INameOfOperation">
            <summary>
            Represents an operation that gets a string value for the <see cref="P:Microsoft.CodeAnalysis.Operations.INameOfOperation.Argument" /> name.
            <para>
            Current usage:
             (1) C# nameof expression.
             (2) VB NameOf expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.NameOf"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.INameOfOperation.Argument">
            <summary>
            Argument to the name of operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ITupleOperation">
            <summary>
            Represents a tuple with one or more elements.
            <para>
            Current usage:
             (1) C# tuple expression.
             (2) VB tuple expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Tuple"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITupleOperation.Elements">
            <summary>
            Tuple elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITupleOperation.NaturalType">
            <summary>
            Natural type of the tuple, or null if tuple doesn't have a natural type.
            Natural type can be different from <see cref="P:Microsoft.CodeAnalysis.IOperation.Type" /> depending on the
            conversion context, in which the tuple is used.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation">
            <summary>
            Represents an object creation with a dynamically bound constructor.
            <para>
            Current usage:
             (1) C# "new" expression with dynamic argument(s).
             (2) VB late bound "New" expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.DynamicObjectCreation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation.Initializer">
            <summary>
            Object or collection initializer, if any.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation.Arguments">
            <summary>
            Dynamically bound arguments, excluding the instance argument.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDynamicMemberReferenceOperation">
            <summary>
            Represents a reference to a member of a class, struct, or module that is dynamically bound.
            <para>
            Current usage:
             (1) C# dynamic member reference expression.
             (2) VB late bound member reference expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.DynamicMemberReference"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDynamicMemberReferenceOperation.Instance">
            <summary>
            Instance receiver, if it exists.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDynamicMemberReferenceOperation.MemberName">
            <summary>
            Referenced member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDynamicMemberReferenceOperation.TypeArguments">
            <summary>
            Type arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDynamicMemberReferenceOperation.ContainingType">
            <summary>
            The containing type of the referenced member, if different from type of the <see cref="P:Microsoft.CodeAnalysis.Operations.IDynamicMemberReferenceOperation.Instance" />.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation">
            <summary>
            Represents a invocation that is dynamically bound.
            <para>
            Current usage:
             (1) C# dynamic invocation expression.
             (2) C# dynamic collection element initializer.
                 For example, in the following collection initializer: <code>new C() { do1, do2, do3 }</code> where
                 the doX objects are of type dynamic, we'll have 3 <see cref="T:Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation" /> with do1, do2, and
                 do3 as their arguments.
             (3) VB late bound invocation expression.
             (4) VB dynamic collection element initializer.
                 Similar to the C# example, <code>New C() From {do1, do2, do3}</code> will generate 3 <see cref="T:Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation" />
                 nodes with do1, do2, and do3 as their arguments, respectively.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.DynamicInvocation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation.Operation">
            <summary>
            Dynamically or late bound operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation.Arguments">
            <summary>
            Dynamically bound arguments, excluding the instance argument.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation">
            <summary>
            Represents an indexer access that is dynamically bound.
            <para>
            Current usage:
             (1) C# dynamic indexer access expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.DynamicIndexerAccess"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation.Operation">
            <summary>
            Dynamically indexed operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation.Arguments">
            <summary>
            Dynamically bound arguments, excluding the instance argument.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ITranslatedQueryOperation">
            <summary>
            Represents an unrolled/lowered query operation.
            For example, for a C# query expression "from x in set where x.Name != null select x.Name", the Operation tree has the following shape:
              ITranslatedQueryExpression
                IInvocationExpression ('Select' invocation for "select x.Name")
                  IInvocationExpression ('Where' invocation for "where x.Name != null")
                    IInvocationExpression ('From' invocation for "from x in set")
            <para>
            Current usage:
             (1) C# query expression.
             (2) VB query expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.TranslatedQuery"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITranslatedQueryOperation.Operation">
            <summary>
            Underlying unrolled operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation">
            <summary>
            Represents a delegate creation. This is created whenever a new delegate is created.
            <para>
            Current usage:
             (1) C# delegate creation expression.
             (2) VB delegate creation expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.DelegateCreation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation.Target">
            <summary>
            The lambda or method binding that this delegate is created from.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDefaultValueOperation">
            <summary>
            Represents a default value operation.
            <para>
            Current usage:
             (1) C# default value expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.DefaultValue"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ITypeOfOperation">
            <summary>
            Represents an operation that gets <see cref="T:System.Type" /> for the given <see cref="P:Microsoft.CodeAnalysis.Operations.ITypeOfOperation.TypeOperand" />.
            <para>
            Current usage:
             (1) C# typeof expression.
             (2) VB GetType expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.TypeOf"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITypeOfOperation.TypeOperand">
            <summary>
            Type operand.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ISizeOfOperation">
            <summary>
            Represents an operation to compute the size of a given type.
            <para>
            Current usage:
             (1) C# sizeof expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.SizeOf"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISizeOfOperation.TypeOperand">
            <summary>
            Type operand.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IAddressOfOperation">
            <summary>
            Represents an operation that creates a pointer value by taking the address of a reference.
            <para>
            Current usage:
             (1) C# address of expression
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.AddressOf"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IAddressOfOperation.Reference">
            <summary>
            Addressed reference.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IIsPatternOperation">
            <summary>
            Represents an operation that tests if a value matches a specific pattern.
            <para>
            Current usage:
             (1) C# is pattern expression. For example, "x is int i".
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.IsPattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IIsPatternOperation.Value">
            <summary>
            Underlying operation to test.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IIsPatternOperation.Pattern">
            <summary>
            Pattern.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation">
            <summary>
            Represents an <see cref="F:Microsoft.CodeAnalysis.OperationKind.Increment" /> or <see cref="F:Microsoft.CodeAnalysis.OperationKind.Decrement" /> operation.
            Note that this operation is different from an <see cref="T:Microsoft.CodeAnalysis.Operations.IUnaryOperation" /> as it mutates the <see cref="P:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation.Target" />,
            while unary operator expression does not mutate it's operand.
            <para>
            Current usage:
             (1) C# increment expression or decrement expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Increment"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Decrement"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation.IsPostfix">
            <summary>
            <see langword="true" /> if this is a postfix expression. <see langword="false" /> if this is a prefix expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation.IsLifted">
            <summary>
            <see langword="true" /> if this is a 'lifted' increment operator.  When there
            is an operator that is defined to work on a value type, 'lifted' operators are
            created to work on the <see cref="T:System.Nullable`1" /> versions of those
            value types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation.IsChecked">
            <summary>
            <see langword="true" /> if overflow checking is performed for the arithmetic operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation.Target">
            <summary>
            Target of the assignment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation.OperatorMethod">
            <summary>
            Operator method used by the operation, null if the operation does not use an operator method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation.ConstrainedToType">
            <summary>
            Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="P:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation.OperatorMethod" />, if any.
            Null if <see cref="P:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation.OperatorMethod" /> is resolved statically, or is null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IThrowOperation">
            <summary>
            Represents an operation to throw an exception.
            <para>
            Current usage:
             (1) C# throw expression.
             (2) C# throw statement.
             (2) VB Throw statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Throw"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IThrowOperation.Exception">
            <summary>
            Instance of an exception being thrown.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDeconstructionAssignmentOperation">
            <summary>
            Represents a assignment with a deconstruction.
            <para>
            Current usage:
             (1) C# deconstruction assignment expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.DeconstructionAssignment"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDeclarationExpressionOperation">
            <summary>
            Represents a declaration expression operation. Unlike a regular variable declaration <see cref="T:Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation" /> and <see cref="T:Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation" />, this operation represents an "expression" declaring a variable.
            <para>
            Current usage:
             (1) C# declaration expression. For example,
             (a) "var (x, y)" is a deconstruction declaration expression with variables x and y.
             (b) "(var x, var y)" is a tuple expression with two declaration expressions.
             (c) "M(out var x);" is an invocation expression with an out "var x" declaration expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.DeclarationExpression"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDeclarationExpressionOperation.Expression">
            <summary>
            Underlying expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IOmittedArgumentOperation">
            <summary>
            Represents an argument value that has been omitted in an invocation.
            <para>
            Current usage:
             (1) VB omitted argument in an invocation expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.OmittedArgument"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ISymbolInitializerOperation">
            <summary>
            Represents an initializer for a field, property, parameter or a local variable declaration.
            <para>
            Current usage:
             (1) C# field, property, parameter or local variable initializer.
             (2) VB field(s), property, parameter or local variable initializer.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISymbolInitializerOperation.Locals">
            <summary>
            Local declared in and scoped to the <see cref="P:Microsoft.CodeAnalysis.Operations.ISymbolInitializerOperation.Value" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISymbolInitializerOperation.Value">
            <summary>
            Underlying initializer value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IFieldInitializerOperation">
            <summary>
            Represents an initialization of a field.
            <para>
            Current usage:
             (1) C# field initializer with equals value clause.
             (2) VB field(s) initializer with equals value clause or AsNew clause. Multiple fields can be initialized with AsNew clause in VB.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.FieldInitializer"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IFieldInitializerOperation.InitializedFields">
            <summary>
            Initialized fields. There can be multiple fields for Visual Basic fields declared with AsNew clause.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IVariableInitializerOperation">
            <summary>
            Represents an initialization of a local variable.
            <para>
            Current usage:
             (1) C# local variable initializer with equals value clause.
             (2) VB local variable initializer with equals value clause or AsNew clause.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.VariableInitializer"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IPropertyInitializerOperation">
            <summary>
            Represents an initialization of a property.
            <para>
            Current usage:
             (1) C# property initializer with equals value clause.
             (2) VB property initializer with equals value clause or AsNew clause. Multiple properties can be initialized with 'WithEvents' declaration with AsNew clause in VB.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.PropertyInitializer"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IPropertyInitializerOperation.InitializedProperties">
            <summary>
            Initialized properties. There can be multiple properties for Visual Basic 'WithEvents' declaration with AsNew clause.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IParameterInitializerOperation">
            <summary>
            Represents an initialization of a parameter at the point of declaration.
            <para>
            Current usage:
             (1) C# parameter initializer with equals value clause.
             (2) VB parameter initializer with equals value clause.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ParameterInitializer"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IParameterInitializerOperation.Parameter">
            <summary>
            Initialized parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IArrayInitializerOperation">
            <summary>
            Represents the initialization of an array instance.
            <para>
            Current usage:
             (1) C# array initializer.
             (2) VB array initializer.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ArrayInitializer"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IArrayInitializerOperation.ElementValues">
            <summary>
            Values to initialize array elements.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation">
            <summary>
            Represents a single variable declarator and initializer.
            </summary>
            <para>
            Current Usage:
              (1) C# variable declarator
              (2) C# catch variable declaration
              (3) VB single variable declaration
              (4) VB catch variable declaration
            </para>
            <remarks>
            In VB, the initializer for this node is only ever used for explicit array bounds initializers. This node corresponds to
            the VariableDeclaratorSyntax in C# and the ModifiedIdentifierSyntax in VB.
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.VariableDeclarator"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation.Symbol">
            <summary>
            Symbol declared by this variable declaration
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation.Initializer">
            <summary>
            Optional initializer of the variable.
            </summary>
            <remarks>
            If this variable is in an <see cref="T:Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation" />, the initializer may be located
            in the parent operation. Call <see cref="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetVariableInitializer(Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation)" />
            to check in all locations. It is only possible to have initializers in both locations in VB invalid code scenarios.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation.IgnoredArguments">
            <summary>
            Additional arguments supplied to the declarator in error cases, ignored by the compiler. This only used for the C# case of
            DeclaredArgumentSyntax nodes on a VariableDeclaratorSyntax.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation">
            <summary>
            Represents a declarator that declares multiple individual variables.
            </summary>
            <para>
            Current Usage:
              (1) C# VariableDeclaration
              (2) C# fixed declarations
              (3) VB Dim statement declaration groups
              (4) VB Using statement variable declarations
            </para>
            <remarks>
            The initializer of this node is applied to all individual declarations in <see cref="P:Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation.Declarators" />. There cannot
            be initializers in both locations except in invalid code scenarios.
            In C#, this node will never have an initializer.
            This corresponds to the VariableDeclarationSyntax in C#, and the VariableDeclaratorSyntax in Visual Basic.
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.VariableDeclaration"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation.Declarators">
            <summary>
            Individual variable declarations declared by this multiple declaration.
            </summary>
            <remarks>
            All <see cref="T:Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation" /> will have at least 1 <see cref="T:Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation" />,
            even if the declaration group only declares 1 variable.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation.Initializer">
            <summary>
            Optional initializer of the variable.
            </summary>
            <remarks>
            In C#, this will always be null.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation.IgnoredDimensions">
            <summary>
            Array dimensions supplied to an array declaration in error cases, ignored by the compiler. This is only used for the C# case of
            RankSpecifierSyntax nodes on an ArrayTypeSyntax.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IArgumentOperation">
            <summary>
            Represents an argument to a method invocation.
            <para>
            Current usage:
             (1) C# argument to an invocation expression, object creation expression, etc.
             (2) VB argument to an invocation expression, object creation expression, etc.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Argument"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IArgumentOperation.ArgumentKind">
            <summary>
            Kind of argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IArgumentOperation.Parameter">
            <summary>
            Parameter the argument matches. This can be null for __arglist parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IArgumentOperation.Value">
            <summary>
            Value supplied for the argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IArgumentOperation.InConversion">
            <summary>
            Information of the conversion applied to the argument value passing it into the target method. Applicable only to VB Reference arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IArgumentOperation.OutConversion">
            <summary>
            Information of the conversion applied to the argument value after the invocation. Applicable only to VB Reference arguments.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ICatchClauseOperation">
            <summary>
            Represents a catch clause.
            <para>
            Current usage:
             (1) C# catch clause.
             (2) VB Catch clause.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.CatchClause"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICatchClauseOperation.ExceptionDeclarationOrExpression">
            <summary>
            Optional source for exception. This could be any of the following operation:
            1. Declaration for the local catch variable bound to the caught exception (C# and VB) OR
            2. Null, indicating no declaration or expression (C# and VB)
            3. Reference to an existing local or parameter (VB) OR
            4. Other expression for error scenarios (VB)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICatchClauseOperation.ExceptionType">
            <summary>
            Type of the exception handled by the catch clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICatchClauseOperation.Locals">
            <summary>
            Locals declared by the <see cref="P:Microsoft.CodeAnalysis.Operations.ICatchClauseOperation.ExceptionDeclarationOrExpression" /> and/or <see cref="P:Microsoft.CodeAnalysis.Operations.ICatchClauseOperation.Filter" /> clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICatchClauseOperation.Filter">
            <summary>
            Filter operation to be executed to determine whether to handle the exception.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICatchClauseOperation.Handler">
            <summary>
            Body of the exception handler.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ISwitchCaseOperation">
            <summary>
            Represents a switch case section with one or more case clauses to match and one or more operations to execute within the section.
            <para>
            Current usage:
             (1) C# switch section for one or more case clause and set of statements to execute.
             (2) VB case block with a case statement for one or more case clause and set of statements to execute.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.SwitchCase"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchCaseOperation.Clauses">
            <summary>
            Clauses of the case.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchCaseOperation.Body">
            <summary>
            One or more operations to execute within the switch section.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchCaseOperation.Locals">
            <summary>
            Locals declared within the switch case section scoped to the section.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ICaseClauseOperation">
            <summary>
            Represents a case clause.
            <para>
            Current usage:
             (1) C# case clause.
             (2) VB Case clause.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICaseClauseOperation.CaseKind">
            <summary>
            Kind of the clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ICaseClauseOperation.Label">
            <summary>
            Label associated with the case clause, if any.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDefaultCaseClauseOperation">
            <summary>
            Represents a default case clause.
            <para>
            Current usage:
             (1) C# default clause.
             (2) VB Case Else clause.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IPatternCaseClauseOperation">
            <summary>
            Represents a case clause with a pattern and an optional guard operation.
            <para>
            Current usage:
             (1) C# pattern case clause.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IPatternCaseClauseOperation.Label">
            <summary>
            Label associated with the case clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IPatternCaseClauseOperation.Pattern">
            <summary>
            Pattern associated with case clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IPatternCaseClauseOperation.Guard">
            <summary>
            Guard associated with the pattern case clause.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IRangeCaseClauseOperation">
            <summary>
            Represents a case clause with range of values for comparison.
            <para>
            Current usage:
             (1) VB range case clause of the form "Case x To y".
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRangeCaseClauseOperation.MinimumValue">
            <summary>
            Minimum value of the case range.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRangeCaseClauseOperation.MaximumValue">
            <summary>
            Maximum value of the case range.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IRelationalCaseClauseOperation">
            <summary>
            Represents a case clause with custom relational operator for comparison.
            <para>
            Current usage:
             (1) VB relational case clause of the form "Case Is op x".
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRelationalCaseClauseOperation.Value">
            <summary>
            Case value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRelationalCaseClauseOperation.Relation">
            <summary>
            Relational operator used to compare the switch value with the case value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ISingleValueCaseClauseOperation">
            <summary>
            Represents a case clause with a single value for comparison.
            <para>
            Current usage:
             (1) C# case clause of the form "case x"
             (2) VB case clause of the form "Case x".
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISingleValueCaseClauseOperation.Value">
            <summary>
            Case value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringContentOperation">
            <summary>
            Represents a constituent part of an interpolated string.
            <para>
            Current usage:
             (1) C# interpolated string content.
             (2) VB interpolated string content.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringTextOperation">
            <summary>
            Represents a constituent string literal part of an interpolated string operation.
            <para>
            Current usage:
             (1) C# interpolated string text.
             (2) VB interpolated string text.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringText"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringTextOperation.Text">
            <summary>
            Text content.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IInterpolationOperation">
            <summary>
            Represents a constituent interpolation part of an interpolated string operation.
            <para>
            Current usage:
             (1) C# interpolation part.
             (2) VB interpolation part.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Interpolation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolationOperation.Expression">
            <summary>
            Expression of the interpolation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolationOperation.Alignment">
            <summary>
            Optional alignment of the interpolation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolationOperation.FormatString">
            <summary>
            Optional format string of the interpolation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IPatternOperation">
            <summary>
            Represents a pattern matching operation.
            <para>
            Current usage:
             (1) C# pattern.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IPatternOperation.InputType">
            <summary>
            The input type to the pattern-matching operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IPatternOperation.NarrowedType">
            <summary>
            The narrowed type of the pattern-matching operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IConstantPatternOperation">
            <summary>
            Represents a pattern with a constant value.
            <para>
            Current usage:
             (1) C# constant pattern.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ConstantPattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConstantPatternOperation.Value">
            <summary>
            Constant value of the pattern operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDeclarationPatternOperation">
            <summary>
            Represents a pattern that declares a symbol.
            <para>
            Current usage:
             (1) C# declaration pattern.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.DeclarationPattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDeclarationPatternOperation.MatchedType">
            <summary>
            The type explicitly specified, or null if it was inferred (e.g. using <code>var</code> in C#).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDeclarationPatternOperation.MatchesNull">
            <summary>
            True if the pattern is of a form that accepts null.
            For example, in C# the pattern `var x` will match a null input,
            while the pattern `string x` will not.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDeclarationPatternOperation.DeclaredSymbol">
            <summary>
            Symbol declared by the pattern, if any.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ITupleBinaryOperation">
            <summary>
            Represents a comparison of two operands that returns a bool type.
            <para>
            Current usage:
             (1) C# tuple binary operator expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.TupleBinary"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.TupleBinaryOperator"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITupleBinaryOperation.OperatorKind">
            <summary>
            Kind of binary operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITupleBinaryOperation.LeftOperand">
            <summary>
            Left operand.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITupleBinaryOperation.RightOperand">
            <summary>
            Right operand.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IMethodBodyBaseOperation">
            <summary>
            Represents a method body operation.
            <para>
            Current usage:
             (1) C# method body
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IMethodBodyBaseOperation.BlockBody">
            <summary>
            Method body corresponding to BaseMethodDeclarationSyntax.Body or AccessorDeclarationSyntax.Body
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IMethodBodyBaseOperation.ExpressionBody">
            <summary>
            Method body corresponding to BaseMethodDeclarationSyntax.ExpressionBody or AccessorDeclarationSyntax.ExpressionBody
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IMethodBodyOperation">
            <summary>
            Represents a method body operation.
            <para>
            Current usage:
             (1) C# method body for non-constructor
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.MethodBody"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.MethodBodyOperation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation">
            <summary>
            Represents a constructor method body operation.
            <para>
            Current usage:
             (1) C# method body for constructor declaration
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ConstructorBody"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ConstructorBodyOperation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation.Locals">
            <summary>
            Local declarations contained within the <see cref="P:Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation.Initializer" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation.Initializer">
            <summary>
            Constructor initializer, if any.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDiscardOperation">
            <summary>
            Represents a discard operation.
            <para>
            Current usage: C# discard expressions
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Discard"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IDiscardOperation.DiscardSymbol">
            <summary>
            The symbol of the discard operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ICoalesceAssignmentOperation">
            <summary>
            Represents a coalesce assignment operation with a target and a conditionally-evaluated value:
            (1) <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Target" /> is evaluated for null. If it is null, <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Value" /> is evaluated and assigned to target.
            (2) <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Value" /> is conditionally evaluated if <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Target" /> is null, and the result is assigned into <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Target" />.
            The result of the entire expression is<see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Target" />, which is only evaluated once.
            <para>
            Current usage:
             (1) C# null-coalescing assignment operation <code>Target ??= Value</code>.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.CoalesceAssignment"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IRangeOperation">
            <summary>
            Represents a range operation.
            <para>
            Current usage:
             (1) C# range expressions
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Range"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRangeOperation.LeftOperand">
            <summary>
            Left operand.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRangeOperation.RightOperand">
            <summary>
            Right operand.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRangeOperation.IsLifted">
            <summary>
            <code>true</code> if this is a 'lifted' range operation.  When there is an
            operator that is defined to work on a value type, 'lifted' operators are
            created to work on the <see cref="T:System.Nullable`1" /> versions of those
            value types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRangeOperation.Method">
            <summary>
            Factory method used to create this Range value. Can be null if appropriate
            symbol was not found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IReDimOperation">
            <summary>
            Represents the ReDim operation to re-allocate storage space for array variables.
            <para>
            Current usage:
             (1) VB ReDim statement.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ReDim"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IReDimOperation.Clauses">
            <summary>
            Individual clauses of the ReDim operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IReDimOperation.Preserve">
            <summary>
            Modifier used to preserve the data in the existing array when you change the size of only the last dimension.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IReDimClauseOperation">
            <summary>
            Represents an individual clause of an <see cref="T:Microsoft.CodeAnalysis.Operations.IReDimOperation" /> to re-allocate storage space for a single array variable.
            <para>
            Current usage:
             (1) VB ReDim clause.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ReDimClause"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IReDimClauseOperation.Operand">
            <summary>
            Operand whose storage space needs to be re-allocated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IReDimClauseOperation.DimensionSizes">
            <summary>
            Sizes of the dimensions of the created array instance.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IRecursivePatternOperation">
            <summary>
            Represents a C# recursive pattern.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.RecursivePattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRecursivePatternOperation.MatchedType">
            <summary>
            The type accepted for the recursive pattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRecursivePatternOperation.DeconstructSymbol">
            <summary>
            The symbol, if any, used for the fetching values for subpatterns. This is either a <code>Deconstruct</code>
            method, the type <code>System.Runtime.CompilerServices.ITuple</code>, or null (for example, in
            error cases or when matching a tuple type).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRecursivePatternOperation.DeconstructionSubpatterns">
            <summary>
            This contains the patterns contained within a deconstruction or positional subpattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRecursivePatternOperation.PropertySubpatterns">
            <summary>
            This contains the (symbol, property) pairs within a property subpattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRecursivePatternOperation.DeclaredSymbol">
            <summary>
            Symbol declared by the pattern.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IDiscardPatternOperation">
            <summary>
            Represents a discard pattern.
            <para>
            Current usage: C# discard pattern
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.DiscardPattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ISwitchExpressionOperation">
            <summary>
            Represents a switch expression.
            <para>
            Current usage:
             (1) C# switch expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.SwitchExpression"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchExpressionOperation.Value">
            <summary>
            Value to be switched upon.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchExpressionOperation.Arms">
            <summary>
            Arms of the switch expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchExpressionOperation.IsExhaustive">
            <summary>
            True if the switch expressions arms cover every possible input value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ISwitchExpressionArmOperation">
            <summary>
            Represents one arm of a switch expression.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.SwitchExpressionArm"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchExpressionArmOperation.Pattern">
            <summary>
            The pattern to match.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchExpressionArmOperation.Guard">
            <summary>
            Guard (when clause expression) associated with the switch arm, if any.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchExpressionArmOperation.Value">
            <summary>
            Result value of the enclosing switch expression when this arm matches.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISwitchExpressionArmOperation.Locals">
            <summary>
            Locals declared within the switch arm (e.g. pattern locals and locals declared in the guard) scoped to the arm.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IPropertySubpatternOperation">
            <summary>
            Represents an element of a property subpattern, which identifies a member to be matched and the
            pattern to match it against.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.PropertySubpattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IPropertySubpatternOperation.Member">
            <summary>
            The member being matched in a property subpattern.  This can be a <see cref="T:Microsoft.CodeAnalysis.Operations.IMemberReferenceOperation" />
            in non-error cases, or an <see cref="T:Microsoft.CodeAnalysis.Operations.IInvalidOperation" /> in error cases.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IPropertySubpatternOperation.Pattern">
            <summary>
            The pattern to which the member is matched in a property subpattern.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IAggregateQueryOperation">
            <summary>
            Represents a standalone VB query Aggregate operation with more than one item in Into clause.
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IFixedOperation">
            <summary>
            Represents a C# fixed statement.
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IFixedOperation.Locals">
            <summary>
            Locals declared.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IFixedOperation.Variables">
            <summary>
            Variables to be fixed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IFixedOperation.Body">
            <summary>
            Body of the fixed, over which the variables are fixed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.INoPiaObjectCreationOperation">
            <summary>
            Represents a creation of an instance of a NoPia interface, i.e. new I(), where I is an embedded NoPia interface.
            <para>
            Current usage:
             (1) C# NoPia interface instance creation expression.
             (2) VB NoPia interface instance creation expression.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.INoPiaObjectCreationOperation.Initializer">
            <summary>
            Object or collection initializer, if any.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IPlaceholderOperation">
            <summary>
            Represents a general placeholder when no more specific kind of placeholder is available.
            A placeholder is an expression whose meaning is inferred from context.
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IPointerIndirectionReferenceOperation">
            <summary>
            Represents a reference through a pointer.
            <para>
            Current usage:
             (1) C# pointer indirection reference expression.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IPointerIndirectionReferenceOperation.Pointer">
            <summary>
            Pointer to be dereferenced.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IWithStatementOperation">
            <summary>
            Represents a <see cref="P:Microsoft.CodeAnalysis.Operations.IWithStatementOperation.Body" /> of operations that are executed with implicit reference to the <see cref="P:Microsoft.CodeAnalysis.Operations.IWithStatementOperation.Value" /> for member references.
            <para>
            Current usage:
             (1) VB With statement.
            </para>
            </summary>
            <remarks>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IWithStatementOperation.Body">
            <summary>
            Body of the with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IWithStatementOperation.Value">
            <summary>
            Value to whose members leading-dot-qualified references within the with body bind.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IUsingDeclarationOperation">
            <summary>
            Represents using variable declaration, with scope spanning across the parent <see cref="T:Microsoft.CodeAnalysis.Operations.IBlockOperation" />.
            <para>
            Current Usage:
             (1) C# using declaration
             (1) C# asynchronous using declaration
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.UsingDeclaration"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUsingDeclarationOperation.DeclarationGroup">
            <summary>
            The variables declared by this using declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUsingDeclarationOperation.IsAsynchronous">
            <summary>
            True if this is an asynchronous using declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.INegatedPatternOperation">
            <summary>
            Represents a negated pattern.
            <para>
              Current usage:
              (1) C# negated pattern.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.NegatedPattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.INegatedPatternOperation.Pattern">
            <summary>
            The negated pattern.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IBinaryPatternOperation">
            <summary>
            Represents a binary ("and" or "or") pattern.
            <para>
              Current usage:
              (1) C# "and" and "or" patterns.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.BinaryPattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBinaryPatternOperation.OperatorKind">
            <summary>
            Kind of binary pattern; either <see cref="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.And" /> or <see cref="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.Or" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBinaryPatternOperation.LeftPattern">
            <summary>
            The pattern on the left.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBinaryPatternOperation.RightPattern">
            <summary>
            The pattern on the right.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ITypePatternOperation">
            <summary>
            Represents a pattern comparing the input with a given type.
            <para>
              Current usage:
              (1) C# type pattern.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.TypePattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ITypePatternOperation.MatchedType">
            <summary>
            The type explicitly specified, or null if it was inferred (e.g. using <code>var</code> in C#).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IRelationalPatternOperation">
            <summary>
            Represents a pattern comparing the input with a constant value using a relational operator.
            <para>
            Current usage:
             (1) C# relational pattern.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.RelationalPattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRelationalPatternOperation.OperatorKind">
            <summary>
            The kind of the relational operator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IRelationalPatternOperation.Value">
            <summary>
            Constant value of the pattern operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IWithOperation">
            <summary>
            Represents cloning of an object instance.
            <para>
              Current usage:
              (1) C# with expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.With"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IWithOperation.Operand">
            <summary>
            Operand to be cloned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IWithOperation.CloneMethod">
            <summary>
            Clone method to be invoked on the value. This can be null in error scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IWithOperation.Initializer">
            <summary>
            With collection initializer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerCreationOperation">
            <summary>
            Represents an interpolated string converted to a custom interpolated string handler type.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringHandlerCreation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerCreationOperation.HandlerCreation">
            <summary>
            The construction of the interpolated string handler instance. This can be an <see cref="T:Microsoft.CodeAnalysis.Operations.IObjectCreationOperation" /> for valid code, and
            <see cref="T:Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation" /> or <see cref="T:Microsoft.CodeAnalysis.Operations.IInvalidOperation" /> for invalid code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerCreationOperation.HandlerCreationHasSuccessParameter">
            <summary>
            True if the last parameter of <see cref="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerCreationOperation.HandlerCreation" /> is an out <see langword="bool" /> parameter that will be checked before executing the code in
            <see cref="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerCreationOperation.Content" />. False otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerCreationOperation.HandlerAppendCallsReturnBool">
            <summary>
            True if the AppendLiteral or AppendFormatted calls in nested <see cref="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringOperation.Parts" /> return <see langword="bool" />. When that is true, each part
            will be conditional on the return of the part before it, only being executed when the Append call returns true. False otherwise.
            </summary>
            <remarks>
            when this is true and <see cref="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerCreationOperation.HandlerCreationHasSuccessParameter" /> is true, then the first part in nested <see cref="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringOperation.Parts" /> is conditionally
            run. If this is true and <see cref="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerCreationOperation.HandlerCreationHasSuccessParameter" /> is false, then the first part is unconditionally run.
            <br />
            Just because this is true or false does not guarantee that all Append calls actually do return boolean values, as there could be dynamic calls or errors.
            It only governs what the compiler was expecting, based on the first calls it did see.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerCreationOperation.Content">
            <summary>
            The interpolated string expression or addition operation that makes up the content of this string. This is either an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringOperation" />
            or an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAdditionOperation" /> operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAdditionOperation">
            <summary>
            Represents an addition of multiple interpolated string literals being converted to an interpolated string handler type.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringAddition"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAdditionOperation.Left">
            <summary>
            The interpolated string expression or addition operation on the left side of the operator. This is either an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringOperation" />
            or an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAdditionOperation" /> operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAdditionOperation.Right">
            <summary>
            The interpolated string expression or addition operation on the right side of the operator. This is either an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringOperation" />
            or an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAdditionOperation" /> operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAppendOperation">
            <summary>
            Represents a call to either AppendLiteral or AppendFormatted as part of an interpolated string handler conversion.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringAppendLiteral"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringAppendFormatted"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringAppendInvalid"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAppendOperation.AppendCall">
            <summary>
            If this interpolated string is subject to an interpolated string handler conversion, the construction of the interpolated string handler instance.
            This can be an <see cref="T:Microsoft.CodeAnalysis.Operations.IInvocationOperation" />  or <see cref="T:Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation" /> for valid code, and <see cref="T:Microsoft.CodeAnalysis.Operations.IInvalidOperation" /> for invalid code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerArgumentPlaceholderOperation">
            <summary>
            Represents an argument from the method call, indexer access, or constructor invocation that is creating the containing <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerCreationOperation" />
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringHandlerArgumentPlaceholder"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerArgumentPlaceholderOperation.ArgumentIndex">
            <summary>
            The index of the argument of the method call, indexer, or object creation containing the interpolated string handler conversion this placeholder is referencing.
            -1 if <see cref="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerArgumentPlaceholderOperation.PlaceholderKind" /> is anything other than <see cref="F:Microsoft.CodeAnalysis.Operations.InterpolatedStringArgumentPlaceholderKind.CallsiteArgument" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerArgumentPlaceholderOperation.PlaceholderKind">
            <summary>
            The component this placeholder represents.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IFunctionPointerInvocationOperation">
            <summary>
            Represents an invocation of a function pointer.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.FunctionPointerInvocation"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IFunctionPointerInvocationOperation.Target">
            <summary>
            Invoked pointer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IFunctionPointerInvocationOperation.Arguments">
            <summary>
            Arguments of the invocation. Arguments are in evaluation order.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IListPatternOperation">
            <summary>
            Represents a C# list pattern.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ListPattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IListPatternOperation.LengthSymbol">
            <summary>
            The <c>Length</c> or <c>Count</c> property that is used to fetch the length value.
            Returns <c>null</c> if no such property is found.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IListPatternOperation.IndexerSymbol">
            <summary>
            The indexer that is used to fetch elements.
            Returns <c>null</c> for an array input.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IListPatternOperation.Patterns">
            <summary>
            Returns subpatterns contained within the list pattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IListPatternOperation.DeclaredSymbol">
            <summary>
            Symbol declared by the pattern, if any.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ISlicePatternOperation">
            <summary>
            Represents a C# slice pattern.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.SlicePattern"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISlicePatternOperation.SliceSymbol">
            <summary>
            The range indexer or the <c>Slice</c> method used to fetch the slice value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.ISlicePatternOperation.Pattern">
            <summary>
            The pattern that the slice value is matched with, if any.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IImplicitIndexerReferenceOperation">
            <summary>
            Represents a reference to an implicit System.Index or System.Range indexer over a non-array type.
            <para>
              Current usage:
              (1) C# implicit System.Index or System.Range indexer reference expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.ImplicitIndexerReference"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IImplicitIndexerReferenceOperation.Instance">
            <summary>
            Instance of the type to be indexed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IImplicitIndexerReferenceOperation.Argument">
            <summary>
            System.Index or System.Range value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IImplicitIndexerReferenceOperation.LengthSymbol">
            <summary>
            The <c>Length</c> or <c>Count</c> property that might be used to fetch the length value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IImplicitIndexerReferenceOperation.IndexerSymbol">
            <summary>
            Symbol for the underlying indexer or a slice method that is used to implement the implicit indexer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.IUtf8StringOperation">
            <summary>
            Represents a UTF-8 encoded byte representation of a string.
            <para>
              Current usage:
              (1) C# UTF-8 string literal expression.
            </para>
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.Utf8String"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IUtf8StringOperation.Value">
            <summary>
            The underlying string value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.BlockOperation.CreateTemporaryBlock(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IOperation},Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            This creates a block that can be used for temporary, internal applications that require a block composed of
            statements from another block. Blocks created by this API violate IOperation tree constraints and should
            never be exposed from a public API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationCloner.CloneOperation``1(``0)">
            <summary>Deep clone given IOperation</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.OperationVisitor">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.IOperation"/> visitor that visits only the single IOperation
            passed into its Visit method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.OperationVisitor`2">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.IOperation"/> visitor that visits only the single IOperation
            passed into its Visit method with an additional argument of the type specified by the
            <typeparamref name="TArgument"/> parameter and produces a value of the type specified by
            the <typeparamref name="TResult"/> parameter.
            </summary>
            <typeparam name="TArgument">
            The type of the additional argument passed to this visitor's Visit method.
            </typeparam>
            <typeparam name="TResult">
            The type of the return value of this visitor's Visit method.
            </typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.ArgumentKind">
            <summary>
            Kinds of arguments.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.ArgumentKind.None">
            <summary>
            Represents unknown argument kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.ArgumentKind.Explicit">
            <summary>
            Argument value is explicitly supplied.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.ArgumentKind.ParamArray">
            <summary>
            Argument is a param array created by compilers for the matching C# params or VB ParamArray parameter. 
            Note, the value is a an array creation expression that encapsulates all the elements, if any.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.ArgumentKind.DefaultValue">
            <summary>
            Argument is a default value supplied automatically by the compilers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind">
            <summary>
            Kind of binary operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.None">
            <summary>
            Represents unknown or error operator kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.Add">
            <summary>
            Represents the '+' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.Subtract">
            <summary>
            Represents the '-' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.Multiply">
            <summary>
            Represents the '*' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.Divide">
            <summary>
            Represents the '/' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.IntegerDivide">
            <summary>
            Represents the VB '\' integer divide operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.Remainder">
            <summary>
            Represents the C# '%' operator and VB 'Mod' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.Power">
            <summary>
            Represents the VB '^' exponentiation operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.LeftShift">
            <summary>
            Represents the <![CDATA['<<']]> operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.RightShift">
            <summary>
            Represents the <![CDATA['>>']]> operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.And">
            <summary>
            Represents the C# <![CDATA['&']]> operator and VB 'And' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.Or">
            <summary>
            Represents the C# <![CDATA['|']]> operator and VB 'Or' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.ExclusiveOr">
            <summary>
            Represents the C# '^' operator and VB 'Xor' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.ConditionalAnd">
            <summary>
            Represents the C# <![CDATA['&&']]> operator and VB 'AndAlso' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.ConditionalOr">
            <summary>
            Represents the C# <![CDATA['||']]> operator and VB 'OrElse' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.Concatenate">
            <summary>
            Represents the VB <![CDATA['&']]> operator for string concatenation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.Equals">
            <summary>
            Represents the C# '==' operator and VB 'Is' operator and '=' operator for non-object typed operands.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.ObjectValueEquals">
            <summary>
            Represents the VB '=' operator for object typed operands.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.NotEquals">
            <summary>
            Represents the C# '!=' operator and VB 'IsNot' operator and <![CDATA['<>']]> operator for non-object typed operands.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.ObjectValueNotEquals">
            <summary>
            Represents the VB <![CDATA['<>']]> operator for object typed operands.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.LessThan">
            <summary>
            Represents the <![CDATA['<']]> operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.LessThanOrEqual">
            <summary>
            Represents the <![CDATA['<=']]> operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.GreaterThanOrEqual">
            <summary>
            Represents the <![CDATA['>=']]> operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.GreaterThan">
            <summary>
            Represents the <![CDATA['>']]> operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.Like">
            <summary>
            Represents the VB 'Like' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.UnsignedRightShift">
            <summary>
            Represents the <![CDATA['>>>']]> operator.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.BranchKind">
            <summary>
            Kind of the branch for an <see cref="T:Microsoft.CodeAnalysis.Operations.IBranchOperation"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BranchKind.None">
            <summary>
            Represents unknown branch kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BranchKind.Continue">
            <summary>
            Represents a continue branch kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BranchKind.Break">
            <summary>
            Represents a break branch kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.BranchKind.GoTo">
            <summary>
            Represents a goto branch kind.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.CaseKind">
            <summary>
            Kinds of cases.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.CaseKind.None">
            <summary>
            Represents unknown case kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.CaseKind.SingleValue">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ISingleValueCaseClauseOperation"/> in C# or VB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.CaseKind.Relational">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IRelationalCaseClauseOperation"/> in VB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.CaseKind.Range">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IRangeCaseClauseOperation"/> in VB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.CaseKind.Default">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDefaultCaseClauseOperation"/> in C# or VB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.CaseKind.Pattern">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IPatternCaseClauseOperation" /> in C#.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.CommonConversion">
            <summary>
            Represents the common, language-agnostic elements of a conversion.
            </summary>
            <remarks>
            We reserve the right to change this struct in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.CommonConversion.Exists">
            <summary>
            Returns true if the conversion exists, as defined by the target language.
            </summary>
            <remarks>
            The existence of a conversion does not necessarily imply that the conversion is valid.
            For example, an ambiguous user-defined conversion may exist but may not be valid.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.CommonConversion.IsIdentity">
            <summary>
            Returns true if the conversion is an identity conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.CommonConversion.IsNullable">
            <summary>
            Returns true if the conversion is an nullable conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.CommonConversion.IsNumeric">
            <summary>
            Returns true if the conversion is a numeric conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.CommonConversion.IsReference">
            <summary>
            Returns true if the conversion is a reference conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.CommonConversion.IsImplicit">
            <summary>
            Returns true if the conversion is an implicit (C#) or widening (VB) conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.CommonConversion.IsUserDefined">
            <summary>
            Returns true if the conversion is a user-defined conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.CommonConversion.MethodSymbol">
            <summary>
            Returns the method used to perform the conversion for a user-defined conversion if <see cref="P:Microsoft.CodeAnalysis.Operations.CommonConversion.IsUserDefined"/> is true.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.CommonConversion.ConstrainedToType">
            <summary>
            Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="P:Microsoft.CodeAnalysis.Operations.CommonConversion.MethodSymbol" />, if any.
            Null if <see cref="P:Microsoft.CodeAnalysis.Operations.CommonConversion.MethodSymbol" /> is resolved statically, or is null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.InstanceReferenceKind">
            <summary>
            Kind of reference for an <see cref="T:Microsoft.CodeAnalysis.Operations.IInstanceReferenceOperation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.InstanceReferenceKind.ContainingTypeInstance">
            <summary>
            Reference to an instance of the containing type. Used for <code>this</code> and <code>base</code> in C# code, and <code>Me</code>,
            <code>MyClass</code>, <code>MyBase</code> in VB code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.InstanceReferenceKind.ImplicitReceiver">
            <summary>
            Reference to the object being initialized in C# or VB object or collection initializer,
            anonymous type creation initializer, or to the object being referred to in a VB With statement,
            or the C# 'with' expression initializer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.InstanceReferenceKind.PatternInput">
            <summary>
            Reference to the value being matching in a property subpattern.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.InstanceReferenceKind.InterpolatedStringHandler">
            <summary>
            Reference to the interpolated string handler instance created as part of a parent interpolated string handler conversion.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.InterpolatedStringArgumentPlaceholderKind">
            <summary>
            Kind of placeholder for an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerArgumentPlaceholderOperation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.InterpolatedStringArgumentPlaceholderKind.CallsiteArgument">
            <summary>
            This is a placeholder for an argument from the containing method call, indexer access, or object creation.
            The corresponding argument index is accessed in <see cref="P:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerArgumentPlaceholderOperation.ArgumentIndex"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.InterpolatedStringArgumentPlaceholderKind.CallsiteReceiver">
            <summary>
            This is a placeholder for the receiver of the containing method call, indexer access, or object creation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.InterpolatedStringArgumentPlaceholderKind.TrailingValidityArgument">
            <summary>
            This is a placeholder for the trailing bool out parameter of the interpolated string handler type. This bool
            controls whether the conditional evaluation for the rest of the interpolated string should be run after the
            constructor returns.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.ForEachLoopOperationInfo.ElementType">
            <summary>
            Element type of the collection
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.ForEachLoopOperationInfo.CurrentConversion">
            <summary>
            The conversion from the type of the <see cref="F:Microsoft.CodeAnalysis.Operations.ForEachLoopOperationInfo.CurrentProperty"/> to the <see cref="F:Microsoft.CodeAnalysis.Operations.ForEachLoopOperationInfo.ElementType"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.ForEachLoopOperationInfo.ElementConversion">
            <summary>
            The conversion from the <see cref="F:Microsoft.CodeAnalysis.Operations.ForEachLoopOperationInfo.ElementType"/> to the iteration variable type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.LoopKind">
            <summary>
            Kinds of loop operations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.LoopKind.None">
            <summary>
            Represents unknown loop kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.LoopKind.While">
            <summary>
            Represents an <see cref="T:Microsoft.CodeAnalysis.Operations.IWhileLoopOperation"/> in C# or VB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.LoopKind.For">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IForLoopOperation"/> in C#.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.LoopKind.ForTo">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IForToLoopOperation"/> in VB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.LoopKind.ForEach">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IForEachLoopOperation"/> in C# or VB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetFunctionPointerSignature(Microsoft.CodeAnalysis.Operations.IFunctionPointerInvocationOperation)">
            <summary>
            Helper function to simplify the access to the function pointer signature of an FunctionPointerInvocationOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.HasErrors(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            This will check whether context around the operation has any error such as syntax or semantic error
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.Descendants(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Returns all the descendant operations of the given <paramref name="operation"/> in evaluation order.
            </summary>
            <param name="operation">Operation whose descendants are to be fetched.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.DescendantsAndSelf(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Returns all the descendant operations of the given <paramref name="operation"/> including the given <paramref name="operation"/> in evaluation order.
            </summary>
            <param name="operation">Operation whose descendants are to be fetched.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetDeclaredVariables(Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation)">
            <summary>
            Gets all the declared local variables in the given <paramref name="declarationGroup"/>.
            </summary>
            <param name="declarationGroup">Variable declaration group</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetDeclaredVariables(Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation)">
            <summary>
            Gets all the declared local variables in the given <paramref name="declaration"/>.
            </summary>
            <param name="declaration">Variable declaration</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetVariableInitializer(Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation)">
            <summary>
            Gets the variable initializer for the given <paramref name="declarationOperation"/>, checking to see if there is a parent initializer
            if the single variable initializer is null.
            </summary>
            <param name="declarationOperation">Single variable declaration to retrieve initializer for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName(Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation,System.Int32)">
            <summary>
            Get an optional argument name for a named argument to the given <paramref name="dynamicOperation"/> at the given <paramref name="index"/>.
            </summary>
            <param name="dynamicOperation">Dynamic or late bound operation.</param>
            <param name="index">Argument index.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName(Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation,System.Int32)">
            <summary>
            Get an optional argument name for a named argument to the given <paramref name="dynamicOperation"/> at the given <paramref name="index"/>.
            </summary>
            <param name="dynamicOperation">Dynamic or late bound operation.</param>
            <param name="index">Argument index.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName(Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation,System.Int32)">
            <summary>
            Get an optional argument name for a named argument to the given <paramref name="dynamicOperation"/> at the given <paramref name="index"/>.
            </summary>
            <param name="dynamicOperation">Dynamic or late bound operation.</param>
            <param name="index">Argument index.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName(Microsoft.CodeAnalysis.Operations.HasDynamicArgumentsExpression,System.Int32)">
            <summary>
            Get an optional argument name for a named argument to the given <paramref name="dynamicOperation"/> at the given <paramref name="index"/>.
            </summary>
            <param name="dynamicOperation">Dynamic or late bound operation.</param>
            <param name="index">Argument index.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind(Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation,System.Int32)">
            <summary>
            Get an optional argument <see cref="T:Microsoft.CodeAnalysis.RefKind"/> for an argument at the given <paramref name="index"/> to the given <paramref name="dynamicOperation"/>.
            Returns a non-null argument <see cref="T:Microsoft.CodeAnalysis.RefKind"/> for C#.
            Always returns null for VB as <see cref="T:Microsoft.CodeAnalysis.RefKind"/> cannot be specified for an argument in VB.
            </summary>
            <param name="dynamicOperation">Dynamic or late bound operation.</param>
            <param name="index">Argument index.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind(Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation,System.Int32)">
            <summary>
            Get an optional argument <see cref="T:Microsoft.CodeAnalysis.RefKind"/> for an argument at the given <paramref name="index"/> to the given <paramref name="dynamicOperation"/>.
            Returns a non-null argument <see cref="T:Microsoft.CodeAnalysis.RefKind"/> for C#.
            Always returns null for VB as <see cref="T:Microsoft.CodeAnalysis.RefKind"/> cannot be specified for an argument in VB.
            </summary>
            <param name="dynamicOperation">Dynamic or late bound operation.</param>
            <param name="index">Argument index.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind(Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation,System.Int32)">
            <summary>
            Get an optional argument <see cref="T:Microsoft.CodeAnalysis.RefKind"/> for an argument at the given <paramref name="index"/> to the given <paramref name="dynamicOperation"/>.
            Returns a non-null argument <see cref="T:Microsoft.CodeAnalysis.RefKind"/> for C#.
            Always returns null for VB as <see cref="T:Microsoft.CodeAnalysis.RefKind"/> cannot be specified for an argument in VB.
            </summary>
            <param name="dynamicOperation">Dynamic or late bound operation.</param>
            <param name="index">Argument index.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetRootOperation(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Gets the root operation for the <see cref="T:Microsoft.CodeAnalysis.IOperation"/> tree containing the given <paramref name="operation"/>.
            </summary>
            <param name="operation">Operation whose root is requested.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetCorrespondingOperation(Microsoft.CodeAnalysis.Operations.IBranchOperation)">
            <summary>
            Gets either a loop or a switch operation that corresponds to the given branch operation.
            </summary>
            <param name="operation">The branch operation for which a corresponding operation is looked up</param>
            <returns>The corresponding operation or <c>null</c> in case not found (e.g. no loop or switch syntax, or the branch is not a break or continue)</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="operation"/> is null</exception>
            <exception cref="T:System.InvalidOperationException">The operation is a part of Control Flow Graph</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.NoneOperation">
            <summary>
            Use this to create IOperation when we don't have proper specific IOperation yet for given language construct
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.OperationWalker">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.Operations.OperationVisitor"/> that descends an entire <see cref="T:Microsoft.CodeAnalysis.IOperation"/> tree
            visiting each IOperation and its child IOperation nodes in depth-first order.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.OperationWalker`1">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.Operations.OperationVisitor`2"/> that descends an entire <see cref="T:Microsoft.CodeAnalysis.IOperation"/> tree
            visiting each IOperation and its child IOperation nodes in depth-first order. Returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operations.UnaryOperatorKind">
            <summary>
            Kind of unary operator
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.UnaryOperatorKind.None">
            <summary>
            Represents unknown or error operator kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.UnaryOperatorKind.BitwiseNegation">
            <summary>
            Represents the C# '~' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.UnaryOperatorKind.Not">
            <summary>
            Represents the C# '!' operator and VB 'Not' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.UnaryOperatorKind.Plus">
            <summary>
            Represents the unary '+' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.UnaryOperatorKind.Minus">
            <summary>
            Represents the unary '-' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.UnaryOperatorKind.True">
            <summary>
            Represents the C# 'true' operator and VB 'IsTrue' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.UnaryOperatorKind.False">
            <summary>
            Represents the C# 'false' operator and VB 'IsFalse' operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Operations.UnaryOperatorKind.Hat">
            <summary>
            Represents the C# '^' operator.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about a syntax node.
            </summary>
            <param name="semanticModel"></param>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="semanticModel"></param>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a syntax node.
            </summary>
            <param name="semanticModel"></param>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If "nameSyntax" resolves to an alias name, return the IAliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
            <param name="semanticModel"></param>
            <param name="nameSyntax">Name to get alias info for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the alias information.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
            <param name="semanticModel"></param>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <remarks>The passed in name is interpreted as a stand-alone name, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="semanticModel"></param>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node.
            </summary>
            <param name="semanticModel"></param>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol declared by the node or null if the node is not a declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets a list of method or indexed property symbols for a syntax node.
            </summary>
            <param name="semanticModel"></param>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body.
            note (for C#): ConstructorInitializerSyntax and PrimaryConstructorBaseTypeSyntax are treated by this API as regular statements
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GeneratedKind.Unknown">
            <summary>
            It is unknown if the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> is automatically generated.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GeneratedKind.NotGenerated">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> is not automatically generated.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GeneratedKind.MarkedGenerated">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> is marked as automatically generated.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IImportScope">
            <summary>
            Represents the set of symbols that are imported to a particular position in a source file. Each import has a
            reference to the location the import directive was declared at.  For the <see cref="T:Microsoft.CodeAnalysis.IAliasSymbol"/> import, the
            location can be found using either <see cref="P:Microsoft.CodeAnalysis.ISymbol.Locations"/> or <see
            cref="P:Microsoft.CodeAnalysis.ISymbol.DeclaringSyntaxReferences"/> on the <see cref="T:Microsoft.CodeAnalysis.IAliasSymbol"/> itself.  For <see cref="P:Microsoft.CodeAnalysis.IImportScope.Imports"/>
            or <see cref="P:Microsoft.CodeAnalysis.IImportScope.XmlNamespaces"/> the location is found through <see
            cref="P:Microsoft.CodeAnalysis.ImportedNamespaceOrType.DeclaringSyntaxReference"/> or <see
            cref="P:Microsoft.CodeAnalysis.ImportedXmlNamespace.DeclaringSyntaxReference"/> respectively.
            </summary>
            <remarks>
            <list type="bullet">
            <item>Scopes returned will always have at least one non-empty property value in them.</item>
            <item>Symbols may be imported, but may not necessarily be available at that location (for example, an alias
            symbol hidden by another symbol).</item>
            <item>
            In C# there will be an <see cref="T:Microsoft.CodeAnalysis.IImportScope"/> for every containing namespace-declarations that include any
            import directives.  There will also be an <see cref="T:Microsoft.CodeAnalysis.IImportScope"/> for the containing compilation-unit if it
            includes any import directives or if there are global import directives pulled in from other files.
            </item>
            <item>
            In Visual Basic there will commonly be one or two <see cref="T:Microsoft.CodeAnalysis.IImportScope"/>s returned for any position.  This will
            commonly be a scope for the containing compilation unit if it includes any import directives.  As well as a scope
            representing any imports specified at the project level.
            </item>
            <item>
            Elements of any property have no defined order.  Even if they represent items from a single document, they are
            not guaranteed to be returned in any specific file-oriented order.
            </item>
            <item>There is no guarantee that the same scope instances will be returned from successive calls to <see
            cref="M:Microsoft.CodeAnalysis.SemanticModel.GetImportScopes(System.Int32,System.Threading.CancellationToken)"/>.</item> 
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IImportScope.Aliases">
            <summary>
            Aliases defined at this level of the chain.  This corresponds to <c>using X = TypeOrNamespace;</c> in C# or
            <c>Imports X = TypeOrNamespace</c> in Visual Basic.  This will include global aliases if present for both
            languages.
            </summary>
            <remarks>May be <see cref="F:System.Collections.Immutable.ImmutableArray`1.Empty"/>, will never be <see cref="P:System.Collections.Immutable.ImmutableArray`1.IsDefault"/>.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IImportScope.ExternAliases">
            <summary>
            Extern aliases defined at this level of the chain.  This corresponds to <c>extern alias X;</c> in C#.  It
            will be empty in Visual Basic.
            </summary>
            <remarks>May be <see cref="F:System.Collections.Immutable.ImmutableArray`1.Empty"/>, will never be <see cref="P:System.Collections.Immutable.ImmutableArray`1.IsDefault"/>.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IImportScope.Imports">
            <summary>
            Types or namespaces imported at this level of the chain.  This corresponds to <c>using Namespace;</c> or
            <c>using static Type;</c> in C#, or <c>Imports TypeOrNamespace</c> in Visual Basic.  This will include
            global namespace or type imports for both languages.
            </summary>
            <remarks>May be <see cref="F:System.Collections.Immutable.ImmutableArray`1.Empty"/>, will never be <see cref="P:System.Collections.Immutable.ImmutableArray`1.IsDefault"/>.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IImportScope.XmlNamespaces">
            <summary>
            Xml namespaces imported at this level of the chain.  This corresponds to <c>Imports &lt;xmlns:prefix =
            "name"&gt;</c> in Visual Basic.  It will be empty in C#.
            </summary>
            <remarks>May be <see cref="F:System.Collections.Immutable.ImmutableArray`1.Empty"/>, will never be <see cref="P:System.Collections.Immutable.ImmutableArray`1.IsDefault"/>.</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ImportedNamespaceOrType">
            <summary>
            Represents an <see cref="T:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol"/> that has been imported, and the location the import was
            declared at.  This corresponds to <c>using Namespace;</c> or <c>using static Type;</c> in C#, or <c>Imports
            TypeOrNamespace</c> in Visual Basic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ImportedNamespaceOrType.DeclaringSyntaxReference">
            <summary>
            Location in source where the <c>using</c> directive or <c>Imports</c> clause was declared. May be null for
            Visual Basic for a project-level import directive, or for a C# global using provided directly through <see
            cref="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions.Usings"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ImportedXmlNamespace">
            <summary>
            Represents an imported xml namespace name. This corresponds to <c>Imports &lt;xmlns:prefix = "name"&gt;</c> in
            Visual Basic.  It does not exist for C#.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ImportedXmlNamespace.DeclaringSyntaxReference">
            <summary>
            Location in source where the <c>Imports</c> clause was declared. May be null for a project-level import
            directive.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SimpleImportScope">
            <summary>
            Simple POCO implementation of the import scope, usable by both C# and VB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NullableContext">
            <summary>
            Represents the state of the nullable analysis at a specific point in a file. Bits one and
            two correspond to whether the nullable feature is enabled. Bits three and four correspond
            to whether the context was inherited from the global context.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableContext.Disabled">
            <summary>
            Nullable warnings and annotations are explicitly turned off at this location.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableContext.WarningsEnabled">
            <summary>
            Nullable warnings are enabled and will be reported at this file location.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableContext.AnnotationsEnabled">
            <summary>
            Nullable annotations are enabled and will be shown when APIs defined at
            this location are used in other contexts.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableContext.Enabled">
            <summary>
            The nullable feature is fully enabled.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableContext.WarningsContextInherited">
            <summary>
            The nullable warning state is inherited from the project default.
            <para>
            The project default can change depending on the file type. Generated
            files have nullable off by default, regardless of the project-level
            default setting.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableContext.AnnotationsContextInherited">
            <summary>
            The nullable annotation state is inherited from the project default.
            <para>
            The project default can change depending on the file type. Generated
            files have nullable off by default, regardless of the project-level
            default setting.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableContext.ContextInherited">
             <summary>
             The current state of both warnings and annotations are inherited from
             the project default.
             <para>
             This flag is set by default at the start of all files.
            
             The project default can change depending on the file type. Generated
             files have nullable off by default, regardless of the project-level
             default setting.
             </para>
             </summary>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.NullableContextExtensions.WarningsEnabled(Microsoft.CodeAnalysis.NullableContext)">
            <summary>
            Returns whether nullable warnings are enabled for this context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NullableContextExtensions.AnnotationsEnabled(Microsoft.CodeAnalysis.NullableContext)">
            <summary>
            Returns whether nullable annotations are enabled for this context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NullableContextExtensions.WarningsInherited(Microsoft.CodeAnalysis.NullableContext)">
            <summary>
            Returns whether the nullable warning state was inherited from the project default for this file type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NullableContextExtensions.AnnotationsInherited(Microsoft.CodeAnalysis.NullableContext)">
            <summary>
            Returns whether the nullable annotation state was inherited from the project default for this file type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NullableContextOptions">
            <summary>
            Represents the default state of nullable analysis in this compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableContextOptions.Disable">
            <summary>
            The nullable analysis feature is disabled.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableContextOptions.Warnings">
            <summary>
            Nullable warnings are enabled and will be reported by default.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableContextOptions.Annotations">
            <summary>
            Nullable annotations are enabled and will be shown when APIs
            defined in this project are used in other contexts.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableContextOptions.Enable">
            <summary>
            The nullable analysis feature is fully enabled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NullableContextOptionsExtensions.WarningsEnabled(Microsoft.CodeAnalysis.NullableContextOptions)">
            <summary>
            Returns whether nullable warnings are enabled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NullableContextOptionsExtensions.AnnotationsEnabled(Microsoft.CodeAnalysis.NullableContextOptions)">
            <summary>
            Returns whether nullable annotations are enabled.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.OptimizationLevel">
            <summary>
            Determines the level of optimization of the generated code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OptimizationLevel.Debug">
            <summary>
            Disables all optimizations and instruments the generated code to improve debugging experience.
            <para>
            The compiler prefers debuggability over performance. Do not use for code running in a production environment.
            </para>
            <list type="bullet">
            <item><description>JIT optimizations are disabled via assembly level attribute (<see cref="T:System.Diagnostics.DebuggableAttribute"/>).</description></item>
            <item><description>Edit and Continue is enabled.</description></item>
            <item><description>Slots for local variables are not reused, lifetime of local variables is extended to make the values available during debugging.</description></item>
            </list>
            <para>
            Corresponds to command line argument /optimize-.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OptimizationLevel.Release">
            <summary>
            Enables all optimizations, debugging experience might be degraded.
            <para>
            The compiler prefers performance over debuggability. Use for code running in a production environment.
            </para>
            <list type="bullet">
            <item><description>JIT optimizations are enabled via assembly level attribute (<see cref="T:System.Diagnostics.DebuggableAttribute"/>).</description></item>
            <item><description>Edit and Continue is disabled.</description></item>
            <item><description>Sequence points may be optimized away. As a result it might not be possible to place or hit a breakpoint.</description></item>
            <item><description>User-defined locals might be optimized away. They might not be available while debugging.</description></item>
            </list>
            <para>
            Corresponds to command line argument /optimize+.
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ParseOptions">
            <summary>
            Represents parse options common to C# and VB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ParseOptions.Kind">
            <summary>
            Specifies whether to parse as regular code files, script files or interactive code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ParseOptions.SpecifiedKind">
            <summary>
            Gets the specified source code kind, which is the value that was specified in
            the call to the constructor, or modified using the <see cref="M:Microsoft.CodeAnalysis.ParseOptions.WithKind(Microsoft.CodeAnalysis.SourceCodeKind)"/> method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ParseOptions.DocumentationMode">
            <summary>
            Gets a value indicating whether the documentation comments are parsed and analyzed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ParseOptions.Language">
            <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ParseOptions.Errors">
            <summary>
            Errors collection related to an incompatible set of parse options
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ParseOptions.WithKind(Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Creates a new options instance with the specified source code kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ParseOptions.ValidateOptions(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Performs validation of options compatibilities and generates diagnostics if needed
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ParseOptions.WithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode)">
            <summary>
            Creates a new options instance with the specified documentation mode.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ParseOptions.WithFeatures(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Enable some experimental language features for testing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ParseOptions.Features">
            <summary>
            Returns the experimental features.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ParseOptions.PreprocessorSymbolNames">
            <summary>
            Names of defined preprocessor symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.AnyCpu">
            <summary>
            AnyCPU (default) compiles the assembly to run on any platform.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.X86">
            <summary>
            x86 compiles the assembly to be run by the 32-bit, x86-compatible common language runtime.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.X64">
            <summary>
            x64 compiles the assembly to be run by the 64-bit common language runtime on a computer that supports the AMD64 or EM64T instruction set.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.Itanium">
            <summary>
            Itanium compiles the assembly to be run by the 64-bit common language runtime on a computer with an Itanium processor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.AnyCpu32BitPreferred">
            <summary>
            Compiles your assembly to run on any platform. Your application runs in 32-bit mode on systems that support both 64-bit and 32-bit applications.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.Arm">
            <summary>
            Compiles your assembly to run on a computer that has an Advanced RISC Machine (ARM) processor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Platform.Arm64">
            <summary>
            Compiles your assembly to run on a computer that has an Advanced RISC Machine 64 bit (ARM64) processor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PreprocessingSymbolInfo.Symbol">
            <summary>
            The symbol that was referred to by the identifier, if any. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PreprocessingSymbolInfo.IsDefined">
            <summary>
            Returns true if this preprocessing symbol is defined at the identifier position.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RebuildData.NonSourceFileDocumentNames">
            <summary>
            This represents the set of document names for the #line / #ExternalSource directives
            that we need to emit into the PDB (in the order specified in the array).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SemanticModel">
            <summary>
            Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,
            an instance is obtained by a call to GetBinding on a Compilation or Compilation.
            </summary>
            <remarks>
            <para>An instance of SemanticModel caches local symbols and semantic information. Thus, it
            is much more efficient to use a single instance of SemanticModel when asking multiple
            questions about a syntax tree, because information from the first question may be reused.
            This also means that holding onto an instance of SemanticModel for a long time may keep a
            significant amount of memory from being garbage collected.
            </para>
            <para>
            When an answer is a named symbol that is reachable by traversing from the root of the symbol
            table, (that is, from an AssemblySymbol of the Compilation), that symbol will be returned
            (i.e. the returned value will be reference-equal to one reachable from the root of the
            symbol table). Symbols representing entities without names (e.g. array-of-int) may or may
            not exhibit reference equality. However, some named symbols (such as local variables) are
            not reachable from the root. These symbols are visible as answers to semantic questions.
            When the same SemanticModel object is used, the answers exhibit reference-equality.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.Language">
            <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.Compilation">
            <summary>
            The compilation this model was obtained from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.CompilationCore">
            <summary>
            The compilation this model was obtained from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.SyntaxTree">
            <summary>
            The syntax tree this model was obtained from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.SyntaxTreeCore">
            <summary>
            The syntax tree this model was obtained from.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetOperation(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the operation corresponding to the expression or statement syntax node.
            </summary>
            <param name="node">The expression or statement syntax node.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.IgnoresAccessibility">
            <summary>
            Returns true if this is a SemanticModel that ignores accessibility rules when answering semantic questions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about a syntax node.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about a syntax node.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeSymbolInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeTypeInfo(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeTypeInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a syntax node.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetTypeInfoCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a syntax node.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetAliasInfo(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If "nameSyntax" resolves to an alias name, return the IAliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
            <param name="nameSyntax">Name to get alias info for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the alias information.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetAliasInfoCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If "nameSyntax" resolves to an alias name, return the IAliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
            <param name="nameSyntax">Name to get alias info for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the alias information.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel">
            <summary>
            Returns true if this is a speculative semantic model created with any of the TryGetSpeculativeSemanticModel methods.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.OriginalPositionForSpeculation">
            <summary>
            If this is a speculative semantic model, returns the original position at which the speculative model was created.
            Otherwise, returns 0.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.ParentModel">
            <summary>
            If this is a speculative semantic model, then returns its parent semantic model.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.ParentModelCore">
            <summary>
            If this is a speculative semantic model, then returns its parent semantic model.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.ContainingModelOrSelf">
            <summary>
            If this is a non-speculative member semantic model, then returns the containing semantic model for the entire tree.
            Otherwise, returns this instance of the semantic model.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeAliasInfo(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <remarks>The passed in name is interpreted as a stand-alone name, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeAliasInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <remarks>The passed in name is interpreted as a stand-alone name, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSyntaxDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Get all of the syntax errors within the syntax tree associated with this
            object. Does not get errors involving declarations or compiling method bodies or initializers.
            </summary>
            <param name="span">Optional span within the syntax tree for which to get diagnostics.
            If no argument is specified, then diagnostics for the entire tree are returned.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclarationDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Get all of the declaration errors within the syntax tree associated with this
            object. Does not get errors involving incorrect syntax, compiling method bodies or initializers.
            </summary>
            <param name="span">Optional span within the syntax tree for which to get diagnostics.
            If no argument is specified, then diagnostics for the entire tree are returned.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>The declaration errors for a syntax tree are cached. The first time this method
            is called, all declarations are analyzed for diagnostics. Calling this a second time
            will return the cached diagnostics.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetMethodBodyDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Get all of the method body and initializer errors within the syntax tree associated with this
            object. Does not get errors involving incorrect syntax or declarations.
            </summary>
            <param name="span">Optional span within the syntax tree for which to get diagnostics.
            If no argument is specified, then diagnostics for the entire tree are returned.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>The method body errors for a syntax tree are not cached. The first time this method
            is called, all method bodies are analyzed for diagnostics. Calling this a second time
            will repeat this work.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Get all the errors within the syntax tree associated with this object. Includes errors
            involving compiling method bodies or initializers, in addition to the errors returned by
            GetDeclarationDiagnostics.
            </summary>
            <param name="span">Optional span within the syntax tree for which to get diagnostics.
            If no argument is specified, then diagnostics for the entire tree are returned.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>
            Because this method must semantically bind all method bodies and initializers to check
            for diagnostics, it may take a significant amount of time. Unlike
            GetDeclarationDiagnostics, diagnostics for method bodies and initializers are not
            cached, any semantic information used to obtain the diagnostics is discarded.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolForNode(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node.
            </summary>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol declared by the node or null if the node is not a declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node.
            </summary>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol declared by the node or null if the node is not a declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolsForNode(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node. Unlike <see cref="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolForNode(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/>,
            this method returns all symbols declared by a given declaration syntax node. Specifically, in the case of field declaration syntax nodes,
            which can declare multiple symbols, this method returns all declared symbols.
            </summary>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbols declared by the node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolsCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node. Unlike <see cref="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolForNode(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/>,
            this method returns all symbols declared by a given declaration syntax node. Specifically, in the case of field declaration syntax nodes,
            which can declare multiple symbols, this method returns all declared symbols.
            </summary>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbols declared by the node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)">
             <summary>
             Gets the available named symbols in the context of the specified location and optional container. Only
             symbols that are accessible and visible from the given location are returned.
             </summary>
             <param name="position">The character position for determining the enclosing declaration scope and
             accessibility.</param>
             <param name="container">The container to search for symbols within. If null then the enclosing declaration
             scope around position is used.</param>
             <param name="name">The name of the symbol to find. If null is specified then symbols
             with any names are returned.</param>
             <param name="includeReducedExtensionMethods">Consider (reduced) extension methods.</param>
             <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
             <remarks>
             The "position" is used to determine what variables are visible and accessible. Even if "container" is
             specified, the "position" location is significant for determining which members of "containing" are
             accessible.
            
             Labels are not considered (see <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)"/>).
            
             Non-reduced extension methods are considered regardless of the value of <paramref name="includeReducedExtensionMethods"/>.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbolsCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)">
            <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembers(System.Int32,System.String)">
             <summary>
             Gets the available base type members in the context of the specified location.  Akin to
             calling <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)"/> with the container set to the immediate base type of
             the type in which <paramref name="position"/> occurs.  However, the accessibility rules
             are different: protected members of the base type will be visible.
            
             Consider the following example:
            
               public class Base
               {
                   protected void M() { }
               }
            
               public class Derived : Base
               {
                   void Test(Base b)
                   {
                       b.M(); // Error - cannot access protected member.
                       base.M();
                   }
               }
            
             Protected members of an instance of another type are only accessible if the instance is known
             to be "this" instance (as indicated by the "base" keyword).
             </summary>
             <param name="position">The character position for determining the enclosing declaration scope and
             accessibility.</param>
             <param name="name">The name of the symbol to find. If null is specified then symbols
             with any names are returned.</param>
             <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
             <remarks>
             The "position" is used to determine what variables are visible and accessible.
            
             Non-reduced extension methods are considered, but reduced extension methods are not.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembersCore(System.Int32,System.String)">
            <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembers(System.Int32,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
             <summary>
             Gets the available named static member symbols in the context of the specified location and optional container.
             Only members that are accessible and visible from the given location are returned.
            
             Non-reduced extension methods are considered, since they are static methods.
             </summary>
             <param name="position">The character position for determining the enclosing declaration scope and
             accessibility.</param>
             <param name="container">The container to search for symbols within. If null then the enclosing declaration
             scope around position is used.</param>
             <param name="name">The name of the symbol to find. If null is specified then symbols
             with any names are returned.</param>
             <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
             <remarks>
             The "position" is used to determine what variables are visible and accessible. Even if "container" is
             specified, the "position" location is significant for determining which members of "containing" are
             accessible.
            
             Essentially the same as filtering instance members out of the results of an analogous <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)"/> call.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembersCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
            <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
             <summary>
             Gets the available named namespace and type symbols in the context of the specified location and optional container.
             Only members that are accessible and visible from the given location are returned.
             </summary>
             <param name="position">The character position for determining the enclosing declaration scope and
             accessibility.</param>
             <param name="container">The container to search for symbols within. If null then the enclosing declaration
             scope around position is used.</param>
             <param name="name">The name of the symbol to find. If null is specified then symbols
             with any names are returned.</param>
             <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
             <remarks>
             The "position" is used to determine what variables are visible and accessible. Even if "container" is
             specified, the "position" location is significant for determining which members of "containing" are
             accessible.
            
             Does not return INamespaceOrTypeSymbol, because there could be aliases.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypesCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
            <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)">
            <summary>
            Gets the available named label symbols in the context of the specified location and optional container.
            Only members that are accessible and visible from the given location are returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabelsCore(System.Int32,System.String)">
            <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body.
            </summary>
            <param name="firstStatement">The first node to be included within the analysis.</param>
            <param name="lastStatement">The last node to be included within the analysis.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body.
            </summary>
            <param name="firstStatement">The first node to be included within the analysis.</param>
            <param name="lastStatement">The last node to be included within the analysis.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body.
            </summary>
            <param name="statement">The statement to be analyzed.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The statement must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body.
            </summary>
            <param name="statement">The statement to be analyzed.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The statement must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body.
            </summary>
            <param name="firstStatement">The first node to be included within the analysis.</param>
            <param name="lastStatement">The last node to be included within the analysis.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body.
            </summary>
            <param name="firstStatement">The first node to be included within the analysis.</param>
            <param name="lastStatement">The last node to be included within the analysis.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body.
            </summary>
            <param name="statementOrExpression">The statement or expression to be analyzed. A ConstructorInitializerSyntax / PrimaryConstructorBaseTypeSyntax is treated here as a regular statement.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The statement or expression is not with a method
            body or field or property initializer.</exception>
            <remarks>
            The statement or expression must be fully inside a method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body.
            </summary>
            <param name="statementOrExpression">The statement or expression to be analyzed.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The statement or expression is not with a method
            body or field or property initializer.</exception>
            <remarks>
            The statement or expression must be fully inside a method body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValue(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If the node provided has a constant value an Optional value will be returned with
            HasValue set to true and with Value set to the constant.  If the node does not have an
            constant value, an Optional will be returned with HasValue set to false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValueCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If the node provided has a constant value an Optional value will be returned with
            HasValue set to true and with Value set to the constant.  If the node does not have an
            constant value, an Optional will be returned with HasValue set to false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetMemberGroup(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            When getting information for a symbol that resolves to a method group or property group,
            from which a method is then chosen; the chosen method or property is present in Symbol;
            all methods in the group that was consulted are placed in this property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetMemberGroupCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            When getting information for a symbol that resolves to a method group or property group,
            from which a method is then chosen; the chosen method or property is present in Symbol;
            all methods in the group that was consulted are placed in this property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbol(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol
            that the position is considered inside of.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbolCore(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol
            that the position is considered inside of.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetImportScopes(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a position in the SyntaxTree for this SemanticModel returns the <see cref="T:Microsoft.CodeAnalysis.IImportScope"/>s at that
            point.  Scopes are ordered from closest to the passed in <paramref name="position"/> to the furthest. See
            <see cref="T:Microsoft.CodeAnalysis.IImportScope"/> for a deeper description of what information is available for each scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.IsAccessible(System.Int32,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is accessible from the specified location.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="symbol">The symbol that we are checking to see if it accessible.</param>
            <returns>
            True if "symbol is accessible, false otherwise.</returns>
            <remarks>
            This method only checks accessibility from the point of view of the accessibility
            modifiers on symbol and its containing types. Even if true is returned, the given symbol
            may not be able to be referenced for other reasons, such as name hiding.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.IsAccessibleCore(System.Int32,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is accessible from the specified location.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="symbol">The symbol that we are checking to see if it accessible.</param>
            <returns>
            True if "symbol is accessible, false otherwise.</returns>
            <remarks>
            This method only checks accessibility from the point of view of the accessibility
            modifiers on symbol and its containing types. Even if true is returned, the given symbol
            may not be able to be referenced for other reasons, such as name hiding.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsField(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)">
            <summary>
            Field-like events can be used as fields in types that can access private
            members of the declaring type of the event.
            </summary>
            <remarks>
            Always false for VB events.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsFieldCore(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)">
            <summary>
            Field-like events can be used as fields in types that can access private
            members of the declaring type of the event.
            </summary>
            <remarks>
            Always false for VB events.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            If <paramref name="nameSyntax"/> is an identifier name syntax node, return the <see cref="T:Microsoft.CodeAnalysis.PreprocessingSymbolInfo"/> corresponding
            to it.
            </summary>
            <param name="nameSyntax">The nameSyntax node to get semantic information for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            If <paramref name="nameSyntax"/> is an identifier name syntax node, return the <see cref="T:Microsoft.CodeAnalysis.PreprocessingSymbolInfo"/> corresponding
            to it.
            </summary>
            <param name="nameSyntax">The nameSyntax node to get semantic information for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.ComputeDeclarationsInSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.DeclarationInfo},System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.DeclarationInfo"/> for all the declarations whose span overlaps with the given <paramref name="span"/>.
            </summary>
            <param name="span">Span to get declarations.</param>
            <param name="getSymbol">Flag indicating whether <see cref="P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredSymbol"/> should be computed for the returned declaration infos.
            If false, then <see cref="P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredSymbol"/> is always null.</param>
            <param name="builder">Builder to add declarations.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.ComputeDeclarationsInNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.DeclarationInfo},System.Threading.CancellationToken,System.Nullable{System.Int32})">
            <summary>
            Takes a node and returns a set of declarations that overlap the node's span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetSyntaxNodesToAnalyzeFilter(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets a filter that determines whether or not a given syntax node and its descendants should be analyzed for the given
            declared node and declared symbol. We have scenarios where certain syntax nodes declare multiple symbols,
            for example record declarations, and we want to avoid duplicate syntax node callbacks for such nodes.
            Note that the predicate returned by this method filters out both the node and all its descendants from analysis.
            If you wish to skip analysis just for a specific node, but not its descendants, then add the required logic in
            <see cref="M:Microsoft.CodeAnalysis.SemanticModel.ShouldSkipSyntaxNodeAnalysis(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.ShouldSkipSyntaxNodeAnalysis(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the given syntax node with the given containing symbol should be analyzed or not.
            Note that only the given syntax node will be filtered out from analysis, this API will be invoked separately
            for each of its descendants. If you wish to skip analysis of the node and all its descendants, then add the required
            logic to <see cref="M:Microsoft.CodeAnalysis.SemanticModel.GetSyntaxNodesToAnalyzeFilter(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetTopmostNodeForDiagnosticAnalysis(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Takes a Symbol and syntax for one of its declaring syntax reference and returns the topmost syntax node to be used by syntax analyzer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.Root">
            <summary>
            Root of this semantic model
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticModel.RootCore">
            <summary>
            Root of this semantic model
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModel.GetNullableContext(System.Int32)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.NullableContext"/> at a position in the file.
            </summary>
            <param name="position">The position to get the context for.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SemanticModelProvider">
            <summary>
            Provides semantic models for syntax trees in a compilation.
            This provider can be attached to a compilation, see <see cref="P:Microsoft.CodeAnalysis.Compilation.SemanticModelProvider"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModelProvider.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Compilation,System.Boolean)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> for the given <paramref name="tree"/> that belongs to the given <paramref name="compilation"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceReferenceResolver">
            <summary>
            Resolves references to source documents specified in the source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceReferenceResolver.NormalizePath(System.String,System.String)">
            <summary>
            Normalizes specified source path with respect to base file path.
            </summary>
            <param name="path">The source path to normalize. May be absolute or relative.</param>
            <param name="baseFilePath">Path of the source file that contains the <paramref name="path"/> (may also be relative), or null if not available.</param>
            <returns>Normalized path, or null if <paramref name="path"/> can't be normalized. The resulting path doesn't need to exist.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceReferenceResolver.ResolveReference(System.String,System.String)">
            <summary>
            Resolves specified path with respect to base file path.
            </summary>
            <param name="path">The path to resolve. May be absolute or relative.</param>
            <param name="baseFilePath">Path of the source file that contains the <paramref name="path"/> (may also be relative), or null if not available.</param>
            <returns>Normalized path, or null if the file can't be resolved.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceReferenceResolver.OpenRead(System.String)">
            <summary>
            Opens a <see cref="T:System.IO.Stream"/> that allows reading the content of the specified file.
            </summary>
            <param name="resolvedPath">Path returned by <see cref="M:Microsoft.CodeAnalysis.SourceReferenceResolver.ResolveReference(System.String,System.String)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="resolvedPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="resolvedPath"/> is not a valid absolute path.</exception>
            <exception cref="T:System.IO.IOException">Error reading file <paramref name="resolvedPath"/>. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceReferenceResolver.ReadText(System.String)">
            <summary>
            Reads the contents of <paramref name="resolvedPath"/> and returns a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
            <param name="resolvedPath">Path returned by <see cref="M:Microsoft.CodeAnalysis.SourceReferenceResolver.ResolveReference(System.String,System.String)"/>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SpeculativeBindingOption">
            <summary>
            Describes the kind of binding to be performed in one of the SemanticModel
            speculative binding methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsExpression">
            <summary>
            Binds the given expression using the normal expression binding rules
            that would occur during normal binding of expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsTypeOrNamespace">
            <summary>
            Binds the given expression as a type or namespace only. If this option
            is selected, then the given expression must derive from TypeSyntax.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SubsystemVersion">
            <summary>
            Represents subsystem version, see /subsystemversion command line 
            option for details and valid values.
            
            The following table lists common subsystem versions of Windows.
            
            Windows version             Subsystem version
              - Windows 2000                5.00
              - Windows XP                  5.01
              - Windows Vista               6.00
              - Windows 7                   6.01
              - Windows 8 Release Preview   6.02
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SubsystemVersion.Major">
            <summary>
            Major subsystem version
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SubsystemVersion.Minor">
            <summary>
            Minor subsystem version
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SubsystemVersion.None">
            <summary>
            Subsystem version not specified
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SubsystemVersion.Windows2000">
            <summary>
            Subsystem version: Windows 2000
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SubsystemVersion.WindowsXP">
            <summary>
            Subsystem version: Windows XP 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SubsystemVersion.WindowsVista">
            <summary>
            Subsystem version: Windows Vista
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SubsystemVersion.Windows7">
            <summary>
            Subsystem version: Windows 7
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SubsystemVersion.Windows8">
            <summary>
            Subsystem version: Windows 8
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SubsystemVersion.TryParse(System.String,Microsoft.CodeAnalysis.SubsystemVersion@)">
            <summary>
            Try parse subsystem version in "x.y" format. Note, no spaces are allowed in string representation.
            </summary>
            <param name="str">String to parse</param>
            <param name="version">the value if successfully parsed or None otherwise</param>
            <returns>true if parsed successfully, false otherwise</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SubsystemVersion.Create(System.Int32,System.Int32)">
            <summary>
            Create a new instance of subsystem version with specified major and minor values.
            </summary>
            <param name="major">major subsystem version</param>
            <param name="minor">minor subsystem version</param>
            <returns>subsystem version with provided major and minor</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SubsystemVersion.Default(Microsoft.CodeAnalysis.OutputKind,Microsoft.CodeAnalysis.Platform)">
            <summary>
            Subsystem version default for the specified output kind and platform combination
            </summary>
            <param name="outputKind">Output kind</param>
            <param name="platform">Platform</param>
            <returns>Subsystem version</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SubsystemVersion.IsValid">
            <summary>
            True if the subsystem version has a valid value
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolFilter">
            <summary>
            Indicate what kinds of declaration symbols will be included
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolFilter.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolFilter.Namespace">
            <summary>
            include namespace symbols
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolFilter.Type">
            <summary>
            include type symbols
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolFilter.Member">
            <summary>
            include member symbols such as method, event, property, field
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember">
            <summary>
            include type and member
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolFilter.All">
            <summary>
            include all namespace, type and member
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolInfo._candidateSymbols">
            <summary>
            Array of potential candidate symbols if <see cref="P:Microsoft.CodeAnalysis.SymbolInfo.Symbol"/> did not bind successfully.  Note: all code in
            this type should prefer referencing <see cref="P:Microsoft.CodeAnalysis.SymbolInfo.CandidateSymbols"/> instead of this so that they uniformly
            only see an non-<see langword="default"/> array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolInfo.Symbol">
            <summary>
            The symbol that was referred to by the syntax node, if any. Returns null if the given expression did not
            bind successfully to a single symbol. If null is returned, it may still be that case that we have one or
            more "best guesses" as to what symbol was intended. These best guesses are available via the <see
            cref="P:Microsoft.CodeAnalysis.SymbolInfo.CandidateSymbols"/> property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolInfo.CandidateSymbols">
            <summary>
            If the expression did not successfully resolve to a symbol, but there were one or more symbols that may have
            been considered but discarded, this property returns those symbols. The reason that the symbols did not
            successfully resolve to a symbol are available in the <see cref="P:Microsoft.CodeAnalysis.SymbolInfo.CandidateReason"/> property. For example,
            if the symbol was inaccessible, ambiguous, or used in the wrong context.
            </summary>
            <remarks>Will never return a <see langword="default"/> array.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolInfo.CandidateReason">
            <summary>
             If the expression did not successfully resolve to a symbol, but there were one or more symbols that may have
             been considered but discarded, this property describes why those symbol or symbols were not considered
             suitable.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeOptionsProvider.IsGenerated(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)">
            <summary>
            Get whether the given tree is generated.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeOptionsProvider.TryGetDiagnosticValue(Microsoft.CodeAnalysis.SyntaxTree,System.String,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ReportDiagnostic@)">
            <summary>
            Get diagnostic severity setting for a given diagnostic identifier in a given tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeOptionsProvider.TryGetGlobalDiagnosticValue(System.String,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ReportDiagnostic@)">
            <summary>
            Get diagnostic severity set globally for a given diagnostic identifier
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeInfo.Type">
            <summary>
            The type of the expression represented by the syntax node. For expressions that do not
            have a type, null is returned. If the type could not be determined due to an error, then
            an IErrorTypeSymbol is returned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeInfo.Nullability">
            <summary>
            The top-level nullability information of the expression represented by the syntax node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeInfo.ConvertedType">
            <summary>
            The type of the expression after it has undergone an implicit conversion. If the type
            did not undergo an implicit conversion, returns the same as Type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeInfo.ConvertedNullability">
            <summary>
            The top-level nullability of the expression after it has undergone an implicit conversion.
            For most expressions, this will be the same as the type. It can change in situations such
            as implicit user-defined conversions that have a nullable return type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlReferenceResolver">
            <summary>
            Resolves references to XML documents specified in source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlReferenceResolver.ResolveReference(System.String,System.String)">
            <summary>
            Resolves specified XML reference with respect to base file path.
            </summary>
            <param name="path">The reference path to resolve. May be absolute or relative path.</param>
            <param name="baseFilePath">Path of the source file that contains the <paramref name="path"/> (may also be relative), or null if not available.</param>
            <returns>Path to the XML artifact, or null if the file can't be resolved.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlReferenceResolver.OpenRead(System.String)">
            <summary>
            Opens a <see cref="T:System.IO.Stream"/> that allows reading the content of the specified file.
            </summary>
            <param name="resolvedPath">Path returned by <see cref="M:Microsoft.CodeAnalysis.XmlReferenceResolver.ResolveReference(System.String,System.String)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="resolvedPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="resolvedPath"/> is not a valid absolute path.</exception>
            <exception cref="T:System.IO.IOException">Error reading file <paramref name="resolvedPath"/>. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConstantValue._s_IEEE_canonical_NaN">
            <summary>
            The IEEE floating-point spec doesn't specify which bit pattern an implementation
            is required to use when producing NaN values.  Indeed, the spec does recommend
            "diagnostic" information "left to the implementer’s discretion" be placed in the
            undefined bits. It is therefore likely that NaNs produced on different platforms
            will differ even for the same arithmetic such as 0.0 / 0.0.  To ensure that the
            compiler behaves in a deterministic way, we force NaN values to use the
            IEEE "canonical" form with the diagnostic bits set to zero and the sign bit set
            to one.  Conversion of this value to float produces the corresponding
            canonical NaN of the float type (IEEE Std 754-2008 section 6.2.3).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConstantValue.ConstantValueString._constantValueReference">
            <summary>
            Some string constant values can have large costs to realize. To compensate, we realize
            constant values lazily, and hold onto a weak reference. If the next time we're asked for the constant
            value the previous one still exists, we can avoid rerealizing it. But we don't want to root the constant
            value if it's not being used.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CvtResFile">
            <summary>
            Parses .RES a file into its constituent resource elements.
            Mostly translated from cvtres.cpp.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Win32ResourceConversions.VersionResourceSerializer.PadKeyLen(System.Int32)">
            <summary>
            Assume that 3 WORDs preceded this string and that they began 32-bit aligned.
            Given the string length compute the number of bytes that should be written to end
            the buffer on a 32-bit boundary</summary>
            <param name="cb"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Win32ResourceConversions.VersionResourceSerializer.PadToDword(System.Int32)">
            <summary>
            assuming the length of bytes submitted began on a 32-bit boundary,
            round up this length as necessary so that it ends at a 32-bit boundary.
            </summary>
            <param name="cb"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Win32ResourceConversions.VersionResourceSerializer.KEYSIZE(System.String)">
            <summary>
            compute number of chars needed to end up on a 32-bit boundary assuming that three
            WORDS preceded this string.
            </summary>
            <param name="sz"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.SourceHashAlgorithms">
            <summary>
            Hash algorithms supported by the debugger used for source file checksums stored in the PDB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoConstants">
            <summary>
            Constants for producing and consuming streams of binary custom debug info.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoEncoder.ToArray">
            <exception cref="T:System.InvalidOperationException">More than <see cref="F:System.Byte.MaxValue"/> records added.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind">
            <summary>
            The kinds of custom debug info in Windows PDBs that we know how to interpret.
            The values correspond to possible values of the "kind" byte
            in the record header.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.UsingGroups">
            <summary>
            C# only. Encodes the sizes of using groups that are applicable to the method.
            The actual import strings are stored separately trhu ISymUnmanagedWriter.UsingNamespace.
            </summary>
            <remarks>
            Represented by <code>using</code> XML node in PDB tests.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.ForwardMethodInfo">
            <summary>
            C# only. Indicates that per-method debug information (import strings) is stored on another method, 
            whose token is specified.
            </summary>
            <remarks>
            Represented by <code>forward</code> XML node in PDB tests.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.ForwardModuleInfo">
            <summary>
            C# only. Indicates that per-module debug information (assembly reference aliases) is stored on another method, 
            whose token is specified.
            </summary>
            <remarks>
            Represented by <code>forwardToModule</code> XML node in PDB tests.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.StateMachineHoistedLocalScopes">
            <summary>
            C# only. Specifies local scopes for state machine hoisted local variables.
            </summary>
            <remarks>
            Represented by <code>hoistedLocalScopes</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.StateMachineHoistedLocalScopes"/> in Portable PDB.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.StateMachineTypeName">
            <summary>
            C# and VB. The name of the state machine type. Emitted for async and iterator kick-off methods.
            </summary>
            <remarks>
            Represented by <code>forwardIterator</code> XML node in PDB tests.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.DynamicLocals">
            <summary>
            C# only. Dynamic flags for local variables and constants.
            </summary>
            <remarks>
            Represented by <code>dynamicLocals</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.DynamicLocalVariables"/> in Portable PDB.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.EditAndContinueLocalSlotMap">
            <summary>
            C# and VB. Encodes EnC local variable slot map.
            See https://github.com/dotnet/corefx/blob/main/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLocalSlotMap.
            </summary>
            <remarks>
            Represented by <code>encLocalSlotMap</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.EncLocalSlotMap"/> in Portable PDB.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.EditAndContinueLambdaMap">
            <summary>
            C# and VB. Encodes EnC lambda map.
            See https://github.com/dotnet/corefx/blob/main/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLambdaAndClosureMap.
            </summary>
            <remarks>
            Represented by <code>encLambdaMap</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.EncLambdaAndClosureMap"/> in Portable PDB.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.TupleElementNames">
            <summary>
            C# and VB. Tuple element names for local variables and constants.
            </summary>
            <remarks>
            Represented by <code>tupleElementNames</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.TupleElementNames"/> in Portable PDB.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.EditAndContinueStateMachineStateMap">
            <summary>
            C# and VB. Syntax offsets of nodes associated with state machine states in an async/iterator method and their corresponding state numbers.
            </summary>
            <remarks>
            Represented by <code>encStateMachineStateMap</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.EncStateMachineStateMap"/> in Portable PDB.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader">
            <summary>
            A collection of utility method for consuming custom debug info from a PDB.
            </summary>
            <remarks>
            This is not a public API, so we're just going to let bad offsets fail on their own.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadGlobalHeader(System.Byte[],System.Int32@,System.Byte@,System.Byte@)">
            <summary>
            This is the first header in the custom debug info blob.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadRecordHeader(System.Byte[],System.Int32@,System.Byte@,Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind@,System.Int32@,System.Int32@)">
            <summary>
            After the global header (see <see cref="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadGlobalHeader(System.Byte[],System.Int32@,System.Byte@,System.Byte@)"/> comes list of custom debug info record.
            Each record begins with a standard header.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.TryGetCustomDebugInfoRecord(System.Byte[],Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind)">
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.GetCustomDebugInfoRecords(System.Byte[])">
            <remarks>
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeUsingRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            For each namespace declaration enclosing a method (innermost-to-outermost), there is a count
            of the number of imports in that declaration.
            </summary>
            <remarks>
            There's always at least one entry (for the global namespace).
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeForwardRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            This indicates that further information can be obtained by looking at the custom debug
            info of another method (specified by token).
            </summary>
            <remarks>
            Appears when multiple method would otherwise have identical using records (see <see cref="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeUsingRecord(System.Collections.Immutable.ImmutableArray{System.Byte})"/>).
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeForwardToModuleRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            This indicates that further information can be obtained by looking at the custom debug
            info of another method (specified by token).
            </summary>
            <remarks>
            Appears when there are extern aliases and edit-and-continue is disabled.
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeStateMachineHoistedLocalScopesRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Scopes of state machine hoisted local variables.
            </summary>
            <remarks>
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeForwardIteratorRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Indicates that this method is the iterator state machine for the method named in the record.
            </summary>
            <remarks>
            Appears when are iterator methods.
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeDynamicLocalsRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Does for locals what System.Runtime.CompilerServices.DynamicAttribute does for parameters, return types, and fields.
            In particular, indicates which occurrences of <see cref="T:System.Object"/> in the signature are really dynamic.
            </summary>
            <remarks>
            Appears when there are dynamic locals.
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Bad data.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeTupleElementNamesRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Tuple element names for locals.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.GetCSharpGroupedImportStrings``1(System.Int32,``0,System.Func{System.Int32,``0,System.Byte[]},System.Func{System.Int32,``0,System.Collections.Immutable.ImmutableArray{System.String}},System.Collections.Immutable.ImmutableArray{System.String}@)">
            <summary>
            Get the import strings for a given method, following forward pointers as necessary.
            </summary>
            <returns>
            For each namespace enclosing the method, a list of import strings, innermost to outermost.
            There should always be at least one entry, for the global namespace.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.GetVisualBasicImportStrings``1(System.Int32,``0,System.Func{System.Int32,``0,System.Collections.Immutable.ImmutableArray{System.String}})">
            <summary>
            Get the import strings for a given method, following forward pointers as necessary.
            </summary>
            <returns>
            A list of import strings.  There should always be at least one entry, for the global namespace.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.TryParseCSharpImportString(System.String,System.String@,System.String@,System.String@,Microsoft.CodeAnalysis.Debugging.ImportTargetKind@)">
            <summary>
            Parse a string representing a C# using (or extern alias) directive.
            </summary>
            <remarks>
            <![CDATA[
            For C#:
             "USystem" -> <namespace name="System" />
             "AS USystem" -> <alias name="S" target="System" kind="namespace" />
             "AC TSystem.Console" -> <alias name="C" target="System.Console" kind="type" />
             "AS ESystem alias" -> <alias name="S" qualifier="alias" target="System" kind="type" />
             "XOldLib" -> <extern alias="OldLib" />
             "ZOldLib assembly" -> <externinfo name="OldLib" assembly="assembly" />
             "ESystem alias" -> <namespace qualifier="alias" name="System" />
             "TSystem.Math" -> <type name="System.Math" />
            ]]>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.TryParseVisualBasicImportString(System.String,System.String@,System.String@,Microsoft.CodeAnalysis.Debugging.ImportTargetKind@,Microsoft.CodeAnalysis.Debugging.VBImportScopeKind@)">
            <summary>
            Parse a string representing a VB import statement.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="import"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Format of <paramref name="import"/> is not valid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadUtf8String(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32@)">
            <summary>
            Read UTF-8 string with null terminator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Namespace">
            <summary>
            C# or VB namespace import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Type">
            <summary>
            C# or VB type import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.NamespaceOrType">
            <summary>
            VB namespace or type alias target (not specified).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Assembly">
            <summary>
            C# extern alias.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.XmlNamespace">
            <summary>
            VB XML import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.MethodToken">
            <summary>
            VB forwarding information (i.e. another method has the imports for this one).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.CurrentNamespace">
            <summary>
            VB containing namespace (not an import).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.DefaultNamespace">
            <summary>
            VB root namespace (not an import).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Defunct">
            <summary>
            A kind that is no longer used.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope.StartOffset">
            <summary>
            The offset of the first operation in the scope.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope.EndOffset">
            <summary>
            The offset of the first operation outside of the scope, or the method body length.
            If zero then <see cref="F:Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope.StartOffset"/> is also zero and the slot represents a synthesized local.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyPortabilityPolicy">
            <summary>
            Policy to be used when matching assembly reference to an assembly definition across platforms.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyVersion.op_Explicit(System.Version)~Microsoft.CodeAnalysis.AssemblyVersion">
            <summary>
            Converts <see cref="T:System.Version"/> to <see cref="T:Microsoft.CodeAnalysis.AssemblyVersion"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">Major, minor, build or revision number are less than 0 or greater than 0xFFFF.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer.#ctor(Microsoft.CodeAnalysis.AssemblyPortabilityPolicy)">
            <param name="policy">Assembly portability policy, usually provided through an app.config file.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer.LoadFromXml(System.IO.Stream)">
            <summary>
            Loads <see cref="T:Microsoft.CodeAnalysis.AssemblyPortabilityPolicy"/> information from XML with app.config schema.
            </summary>
            <exception cref="T:System.Xml.XmlException">The stream doesn't contain a well formed XML.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="input"/> is null.</exception>
            <remarks>
            Tries to find supportPortability elements in the given XML:
            <![CDATA[
            <configuration>
               <runtime>
                  <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
                     <supportPortability PKT="7cec85d7bea7798e" enable="false"/>
                     <supportPortability PKT="31bf3856ad364e35" enable="false"/>
                  </assemblyBinding>
               </runtime>
            </configuration>
            ]]>
            
            Keeps the stream open.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer.IsFrameworkAssembly(Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Returns true if the identity is a Framework 4.5 or lower assembly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AdditionalText">
            <summary>
            Represents a non source code file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AdditionalText.Path">
            <summary>
            Path to the text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdditionalText.GetText(System.Threading.CancellationToken)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> with the contents of this file, or <c>null</c> if
            there were errors reading the file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisContextInfo">
            <summary>
            this hold onto analyzer executor context which will be used later to put context information in analyzer exception if it occurs.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult">
            <summary>
            Stores the results of analyzer execution:
            1. Local and non-local diagnostics, per-analyzer.
            2. Analyzer execution times, if requested.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.Analyzers">
            <summary>
            Analyzers corresponding to this analysis result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.SyntaxDiagnostics">
            <summary>
            Syntax diagnostics reported by the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.Analyzers"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.SemanticDiagnostics">
            <summary>
            Semantic diagnostics reported by the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.Analyzers"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.AdditionalFileDiagnostics">
            <summary>
            Diagnostics in additional files reported by the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.Analyzers"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.CompilationDiagnostics">
            <summary>
            Compilation diagnostics reported by the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.Analyzers"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.AnalyzerTelemetryInfo">
            <summary>
            Analyzer telemetry info (register action counts and execution times).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.GetAllDiagnostics(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Gets all the diagnostics reported by the given <paramref name="analyzer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.GetAllDiagnostics">
            <summary>
            Gets all the diagnostics reported by all the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.Analyzers"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisResultBuilder">
            <summary>
            Stores the results of analyzer execution:
            1. Local and non-local diagnostics, per-analyzer.
            2. Analyzer execution times, if requested.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisScope">
            <summary>
            Scope for analyzer execution.
            This scope could either be the entire compilation for all analyzers (command line build) or
            could be scoped to a specific tree/span and/or a subset of analyzers (CompilationWithAnalyzers).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisScope.SyntaxTrees">
            <summary>
            Syntax trees on which we need to perform syntax analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisScope.AdditionalFiles">
            <summary>
            Non-source files on which we need to perform analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisScope.CategorizeDiagnostics">
            <summary>
            True if we need to categorize diagnostics into local and non-local diagnostics and track the analyzer reporting each diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisScope.IsSyntacticSingleFileAnalysis">
            <summary>
            True if we need to perform only syntax analysis for a single source or additional file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisScope.IsSingleFileAnalysis">
            <summary>
            True if we need to perform analysis for a single source or additional file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisScope.IsPartialAnalysis">
            <summary>
            Flag indicating if this is a partial analysis for the corresponding <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/>,
            i.e. <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisScope.IsSingleFileAnalysis"/> is true and/or <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisScope.Analyzers"/> is a subset of <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState">
            <summary>
            Stores the partial analysis state for analyzers executed on a specific compilation.
            </summary>
            <summary>
            Stores the current partial analysis state for an analyzer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.AnalyzerStateData">
            <summary>
            Stores the partial analysis state for a specific event/symbol/tree for a specific analyzer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.AnalyzerStateData.StateKind">
            <summary>
            Current state of analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.AnalyzerStateData.ProcessedActions">
            <summary>
            Set of completed actions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.AnalyzerStateData.ResetToReadyState">
            <summary>
            Resets the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.AnalyzerStateData.StateKind"/> from <see cref="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.StateKind.InProcess"/> to <see cref="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.StateKind.ReadyToProcess"/>.
            This method must be invoked after successful analysis completion AND on analysis cancellation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState._analyzerStateMap">
            <summary>
            Per-analyzer analysis state map.
            The integer value points to the index within the <see cref="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState._analyzerStates"/> array.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState._analyzerStates">
            <summary>
            Per-analyzer analysis state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState._pendingSourceEvents">
            <summary>
            Compilation events corresponding to source tree, that are not completely processed for all analyzers.
            Events are dropped as and when they are fully processed by all analyzers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState._pendingNonSourceEvents">
            <summary>
            Compilation events corresponding to the compilation (compilation start and completed events), that are not completely processed for all analyzers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState._lazyAnalyzerActionCountsMap">
            <summary>
            Action counts per-analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.OnCompilationEventProcessedAsync(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Func{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Threading.Tasks.Task})">
            <summary>
            Invoke this method at completion of event processing for the given analyzers.
            It updates the analysis state of this event for each analyzer and if the event has been fully processed for all analyzers, then removes it from our event cache.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.GetPendingEvents(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)">
            <summary>
            Gets pending events for given set of analyzers for the given syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.GetPendingEvents_NoLock(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets pending events for given set of analyzers for the given syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.GetPendingEvents(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets all pending events for given set of analyzers.
            </summary>
            <param name="analyzers"></param>
            <param name="includeSourceEvents">Indicates if source events (symbol declared, compilation unit completed event) should be included.</param>
            <param name="includeNonSourceEvents">Indicates if compilation wide events (compilation started and completed event) should be included.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.HasPendingSyntaxAnalysis(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope)">
            <summary>
            Returns true if we have any pending syntax analysis for given analysis scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.HasPendingSymbolAnalysis(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,System.Threading.CancellationToken)">
            <summary>
            Returns true if we have any pending symbol analysis for given analysis scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.TryStartProcessingEvent(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalysisState.AnalyzerStateData@)">
            <summary>
            Attempts to start processing a compilation event for the given analyzer.
            </summary>
            <returns>
            Returns false if the event has already been processed for the analyzer OR is currently being processed by another task.
            If true, then it returns a non-null <paramref name="state"/> representing partial analysis state for the given event for the given analyzer.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkEventComplete(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Marks the given event as fully analyzed for the given analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkEventComplete(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})">
            <summary>
            Marks the given event as fully analyzed for the given analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkEventCompleteForUnprocessedAnalyzers(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})">
            <summary>
            Marks the given event as fully analyzed for the unprocessed analyzers in the given analysisScope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.IsEventComplete(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Checks if the given event has been fully analyzed for the given analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.TryStartAnalyzingSymbol(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalysisState.AnalyzerStateData@)">
            <summary>
            Attempts to start processing a symbol for the given analyzer's symbol actions.
            </summary>
            <returns>
            Returns false if the symbol has already been processed for the analyzer OR is currently being processed by another task.
            If true, then it returns a non-null <paramref name="state"/> representing partial analysis state for the given symbol for the given analyzer.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.TryStartSymbolEndAnalysis(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalysisState.AnalyzerStateData@)">
            <summary>
            Attempts to start executing a symbol's end actions for the given analyzer.
            </summary>
            <returns>
            Returns false if the symbol end actions have already been executed for the analyzer OR are currently being executed by another task.
            If true, then it returns a non-null <paramref name="state"/> representing partial analysis state for the given symbol end actions for the given analyzer.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkSymbolComplete(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Marks the given symbol as fully analyzed for the given analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkSymbolCompleteForUnprocessedAnalyzers(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})">
            <summary>
            Marks the given symbol as fully analyzed for the unprocessed analyzers in the given analysisScope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.IsSymbolComplete(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            True if the given symbol is fully analyzed for the given analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkSymbolEndAnalysisComplete(Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})">
            <summary>
            Marks the given symbol end actions as fully executed for the given analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkSymbolEndAnalysisComplete(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Marks the given symbol end actions as fully executed for the given analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.IsSymbolEndAnalysisComplete(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            True if the given symbol end analysis is complete for the given analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.TryStartAnalyzingDeclaration(Microsoft.CodeAnalysis.ISymbol,System.Int32,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalysisState.DeclarationAnalyzerStateData@)">
            <summary>
            Attempts to start processing a symbol declaration for the given analyzer's syntax node and code block actions.
            </summary>
            <returns>
            Returns false if the declaration has already been processed for the analyzer OR is currently being processed by another task.
            If true, then it returns a non-null <paramref name="state"/> representing partial analysis state for the given declaration for the given analyzer.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.IsDeclarationComplete(Microsoft.CodeAnalysis.ISymbol,System.Int32)">
            <summary>
            True if the given symbol declaration is fully analyzed for all the analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.IsDeclarationComplete(Microsoft.CodeAnalysis.ISymbol,System.Int32,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            True if the given symbol declaration is fully analyzed for the given analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkDeclarationComplete(Microsoft.CodeAnalysis.ISymbol,System.Int32,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Marks the given symbol declaration as fully analyzed for the given analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkDeclarationComplete(Microsoft.CodeAnalysis.ISymbol,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})">
            <summary>
            Marks the given symbol declaration as fully analyzed for the given analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkDeclarationsComplete(Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})">
            <summary>
            Marks all the symbol declarations for the given symbol as fully analyzed for all the given analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.TryStartSyntaxAnalysis(Microsoft.CodeAnalysis.Diagnostics.SourceOrAdditionalFile,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalysisState.AnalyzerStateData@)">
            <summary>
            Attempts to start processing a syntax tree or additional file for the given analyzer's syntax tree or additional file actions respectively.
            </summary>
            <returns>
            Returns false if the file has already been processed for the analyzer OR is currently being processed by another task.
            If true, then it returns a non-null <paramref name="state"/> representing partial syntax analysis state for the given tree for the given analyzer.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkSyntaxAnalysisComplete(Microsoft.CodeAnalysis.Diagnostics.SourceOrAdditionalFile,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Marks the given file as fully syntactically analyzed for the given analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkSyntaxAnalysisComplete(Microsoft.CodeAnalysis.Diagnostics.SourceOrAdditionalFile,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})">
            <summary>
            Marks the given file as fully syntactically analyzed for the given analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.MarkSyntaxAnalysisCompleteForUnprocessedAnalyzers(Microsoft.CodeAnalysis.Diagnostics.SourceOrAdditionalFile,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})">
            <summary>
            Marks the given file as fully syntactically analyzed for the unprocessed analyzers in the given analysisScope.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.StateKind">
            <summary>
            State kind of per-analyzer <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.AnalyzerStateData"/> tracking an analyzer's partial analysis state.
            An analysis state object can be in one of the following states:
            1. Completely unprocessed: <see cref="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.StateKind.ReadyToProcess"/>
            2. Currently being processed: <see cref="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.StateKind.InProcess"/>
            3. Partially processed by one or more older requests that was either completed or cancelled: <see cref="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.StateKind.ReadyToProcess"/>
            4. Fully processed: <see cref="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.StateKind.FullyProcessed"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.StateKind.ReadyToProcess">
            <summary>
            Ready for processing.
            Indicates it is either completely unprocessed or partially processed by one or more older requests that was either completed or cancelled.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.StateKind.InProcess">
            <summary>
            Currently being processed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.StateKind.FullyProcessed">
            <summary>
            Fully processed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.DeclarationAnalyzerStateData">
            <summary>
            Stores the partial analysis state for a specific symbol declaration for a specific analyzer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.DeclarationAnalyzerStateData.CodeBlockAnalysisState">
            <summary>
            Partial analysis state for code block actions executed on the declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.DeclarationAnalyzerStateData.OperationBlockAnalysisState">
            <summary>
            Partial analysis state for operation block actions executed on the declaration.
            
            NOTE: This state tracks operations actions registered inside operation block start context.
            Operation actions registered outside operation block start context are tracked
            with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.DeclarationAnalyzerStateData.OperationAnalysisState"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.DeclarationAnalyzerStateData.OperationAnalysisState">
            <summary>
            Partial analysis state for operation actions executed on the declaration.
            
            NOTE: This state tracks operations actions registered outside of operation block start context.
            Operation actions registered inside operation block start context are tracked
            with <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.OperationBlockAnalyzerStateData"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.SyntaxNodeAnalyzerStateData">
            <summary>
            Stores the partial analysis state for syntax node actions executed on the declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.OperationAnalyzerStateData">
            <summary>
            Stores the partial analysis state for operation actions executed on the declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.BlockAnalyzerStateData`2">
            <summary>
            Stores the partial analysis state for code block actions or operation block actions executed on the declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.CodeBlockAnalyzerStateData">
            <summary>
            Stores the partial analysis state for code block actions executed on the declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.OperationBlockAnalyzerStateData">
            <summary>
            Stores the partial analysis state for operation block actions executed on the declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts">
            <summary>
            Contains the counts of registered actions for an analyzer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.CompilationStartActionsCount">
            <summary>
            Count of registered compilation start actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.CompilationEndActionsCount">
            <summary>
            Count of registered compilation end actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.CompilationActionsCount">
            <summary>
            Count of registered compilation actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.SyntaxTreeActionsCount">
            <summary>
            Count of registered syntax tree actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.AdditionalFileActionsCount">
            <summary>
            Count of registered additional file actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.SemanticModelActionsCount">
            <summary>
            Count of registered semantic model actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.SymbolActionsCount">
            <summary>
            Count of registered symbol actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.SymbolStartActionsCount">
            <summary>
            Count of registered symbol start actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.SymbolEndActionsCount">
            <summary>
            Count of registered symbol end actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.SyntaxNodeActionsCount">
            <summary>
            Count of registered syntax node actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.CodeBlockStartActionsCount">
            <summary>
            Count of code block start actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.CodeBlockEndActionsCount">
            <summary>
            Count of code block end actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.CodeBlockActionsCount">
            <summary>
            Count of code block actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.OperationActionsCount">
            <summary>
            Count of Operation actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.OperationBlockStartActionsCount">
            <summary>
            Count of Operation block start actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.OperationBlockEndActionsCount">
            <summary>
            Count of Operation block end actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.OperationBlockActionsCount">
            <summary>
            Count of Operation block actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.HasAnyExecutableCodeActions">
            <summary>
            Returns true if there are any actions that need to run on executable code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts.Concurrent">
            <summary>
            Gets a value indicating whether the analyzer supports concurrent execution.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo">
            <summary>
            Contains telemetry info for a specific analyzer, such as count of registered actions, the total execution time, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.CompilationStartActionsCount">
            <summary>
            Count of registered compilation start actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.CompilationEndActionsCount">
            <summary>
            Count of registered compilation end actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.CompilationActionsCount">
            <summary>
            Count of registered compilation actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.SyntaxTreeActionsCount">
            <summary>
            Count of registered syntax tree actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.AdditionalFileActionsCount">
            <summary>
            Count of registered additional file actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.SemanticModelActionsCount">
            <summary>
            Count of registered semantic model actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.SymbolActionsCount">
            <summary>
            Count of registered symbol actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.SymbolStartActionsCount">
            <summary>
            Count of registered symbol start actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.SymbolEndActionsCount">
            <summary>
            Count of registered symbol end actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.SyntaxNodeActionsCount">
            <summary>
            Count of registered syntax node actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.CodeBlockStartActionsCount">
            <summary>
            Count of registered code block start actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.CodeBlockEndActionsCount">
            <summary>
            Count of registered code block end actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.CodeBlockActionsCount">
            <summary>
            Count of registered code block actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.OperationActionsCount">
            <summary>
            Count of registered operation actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.OperationBlockStartActionsCount">
            <summary>
            Count of registered operation block start actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.OperationBlockEndActionsCount">
            <summary>
            Count of registered operation block end actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.OperationBlockActionsCount">
            <summary>
            Count of registered operation block actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.SuppressionActionsCount">
            <summary>
            Count of registered suppression actions.
            This is the same as count of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor"/>s as each suppressor
            has a single suppression action, i.e. <see cref="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor.ReportSuppressions(Microsoft.CodeAnalysis.Diagnostics.SuppressionAnalysisContext)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.ExecutionTime">
            <summary>
            Total execution time.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.Concurrent">
            <summary>
            Gets a value indicating whether the analyzer supports concurrent execution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo.#ctor">
            <summary>
            Create telemetry info for a specific analyzer, such as count of registered actions, the total execution time, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions.KeyComparer">
            <summary>
            Comparer that should be used for all analyzer config keys. This is a case-insensitive comparison based
            on Unicode case sensitivity rules for identifiers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions.TryGetValue(System.String,System.String@)">
            <summary>
            Get an analyzer config value for the given key, using the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions.KeyComparer"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions.Keys">
            <summary>
            Enumerates unique keys of all available options in no specific order.
            </summary>
            <exception cref="T:System.NotImplementedException">Not implemented by the derived type.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider">
            <summary>
            Provide options from an analyzer config file keyed on a source file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider.GlobalOptions">
            <summary>
            Gets global options that do not apply to any specific file
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider.GetOptions(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Get options for a given <paramref name="tree"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider.GetOptions(Microsoft.CodeAnalysis.AdditionalText)">
            <summary>
            Get options for a given <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver">
            <summary>
            Driver to execute diagnostic analyzers for a given compilation.
            It uses a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1"/> of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent"/>s to drive its analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.CompilationData">
            <summary>
            Stores <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.DeclarationAnalysisData"/> for symbols declared in the compilation.
            This allows us to avoid recomputing this data across analyzer execution for different analyzers
            on the same symbols. This cached compilation data is strongly held by the associated
            <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/> object.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._programmaticSuppressions">
            <summary>
            Set of diagnostic suppressions that are suppressed via analyzer suppression actions. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._diagnosticsProcessedForProgrammaticSuppressions">
            <summary>
            Set of diagnostics that have already been processed for application of programmatic suppressions. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._hasDiagnosticSuppressors">
            <summary>
            Flag indicating if the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.Analyzers"/> include any <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor"/>
            which can suppress reported analyzer/compiler diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._severityFilter">
            <summary>
            Filtered diagnostic severities in the compilation, i.e. diagnostics with effective severity from this set should not be reported.
            PERF: If all supported diagnostics for an analyzer are from this set, we completely skip executing the analyzer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.UnsuppressedAnalyzers">
            <summary>
            Unsuppressed analyzers that need to be executed. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.PerSymbolAnalyzerActionsCache">
            <summary>
            Cache of additional analyzer actions to be executed per symbol per analyzer, which are registered in symbol start actions.
            We cache the tuple:
              1. myActions: analyzer actions registered in the symbol start actions of containing namespace/type, which are to be executed for this symbol
              2. childActions: analyzer actions registered in this symbol's start actions, which are to be executed for member symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.DefaultGeneratedCodeAnalysisFlags">
            <summary>
            Default analysis mode for generated code.
            </summary>
            <remarks>
            This mode should always guarantee that analyzer action callbacks are enabled for generated code, i.e. <see cref="F:Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags.Analyze"/> is set.
            However, the default diagnostic reporting mode is liable to change in future.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._lazyAnalyzerGateMap">
            <summary>
            Map from non-concurrent analyzers to the gate guarding callback into the analyzer. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GeneratedCodeAnalysisFlagsMap">
            <summary>
            Map from analyzers to their <see cref="T:Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags"/> setting. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._lazyAnalyzerActions">
            <summary>
            The set of registered analyzer actions.
            </summary>
            <seealso cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.AnalyzerActions"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.NonConfigurableAnalyzers">
            <summary>
            Set of unsuppressed analyzers that report non-configurable diagnostics that cannot be suppressed with end user configuration. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.SymbolStartAnalyzers">
            <summary>
            Set of analyzers that have registered symbol start analyzer actions. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TreatAllCodeAsNonGeneratedCode">
            <summary>
            True if all analyzers need to analyze and report diagnostics in generated code - we can assume all code to be non-generated code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._lazyDoNotAnalyzeGeneratedCode">
            <summary>
            True if no analyzer needs generated code analysis - we can skip all analysis on a generated code symbol/tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GeneratedCodeFilesMap">
            <summary>
            Lazily populated dictionary indicating whether a source file is a generated code file or not - we populate it lazily to avoid realizing all syntax trees in the compilation upfront.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GeneratedCodeSymbolsForTreeMap">
            <summary>
            Lazily populated dictionary from tree to declared symbols with GeneratedCodeAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.SuppressedAnalyzersForTreeMap">
            <summary>
            Lazily populated dictionary from tree to analyzers that are suppressed on the entire tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.IsGeneratedCodeSymbolMap">
            <summary>
            Lazily populated dictionary from symbol to a bool indicating if it is a generated code symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._lazyTreesWithHiddenRegionsMap">
            <summary>
            Lazily populated dictionary indicating whether a source file has any hidden regions - we populate it lazily to avoid realizing all syntax trees in the compilation upfront.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._lazyGeneratedCodeAttribute">
            <summary>
            Symbol for <see cref="T:System.CodeDom.Compiler.GeneratedCodeAttribute"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._lazyInitializeTask">
            <summary>
            Driver task which initializes all analyzers.
            This task is initialized and executed only once at start of analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._initializeSucceeded">
            <summary>
            Flag to indicate if the <see cref="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._lazyInitializeTask"/> was successfully started.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._lazyPrimaryTask">
            <summary>
            Primary driver task which processes all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.CompilationEventQueue"/> events, runs analyzer actions and signals completion of <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.DiagnosticQueue"/> at the end.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver._workerCount">
            <summary>
            Number of worker tasks processing compilation events and executing analyzer actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.CompilationEventQueue">
            <summary>
            Events queue for analyzer execution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.DiagnosticQueue">
            <summary>
            <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.DiagnosticQueue"/> that is fed the diagnostics as they are computed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager,Microsoft.CodeAnalysis.Diagnostics.SeverityFilter,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Create an analyzer driver.
            </summary>
            <param name="analyzers">The set of analyzers to include in the analysis</param>
            <param name="analyzerManager">AnalyzerManager to manage analyzers for analyzer host's lifetime.</param>
            <param name="severityFilter">Filtered diagnostic severities in the compilation, i.e. diagnostics with effective severity from this set should not be reported.</param>
            <param name="isComment">Delegate to identify if the given trivia is a comment.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor,Microsoft.CodeAnalysis.Diagnostics.DiagnosticQueue,Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.CompilationData,System.Threading.CancellationToken)">
            <summary>
            Initializes the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.AnalyzerActions"/> and related actions maps for the analyzer driver.
            It kicks off the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.WhenInitializedTask"/> task for initialization.
            Note: This method must be invoked exactly once on the driver.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ComputeShouldTreatAllCodeAsNonGeneratedCode(System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags})">
            <summary>
            Returns true if all analyzers need to analyze and report diagnostics in generated code - we can assume all code to be non-generated code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.AttachQueueAndProcessAllEventsAsync(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue{Microsoft.CodeAnalysis.Diagnostics.CompilationEvent},Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Threading.CancellationToken)">
            <summary>
            Attaches a pre-populated event queue to the driver and processes all events in the queue.
            </summary>
            <param name="eventQueue">Compilation events to analyze.</param>
            <param name="analysisScope">Scope of analysis.</param>
            <param name="analysisState">An optional object to track partial analysis state.</param>
            <param name="cancellationToken">Cancellation token to abort analysis.</param>
            <remarks>Driver must be initialized before invoking this method, i.e. <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor,Microsoft.CodeAnalysis.Diagnostics.DiagnosticQueue,Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.CompilationData,System.Threading.CancellationToken)"/> method must have been invoked and <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.WhenInitializedTask"/> must be non-null.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.AttachQueueAndStartProcessingEvents(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue{Microsoft.CodeAnalysis.Diagnostics.CompilationEvent},Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,System.Threading.CancellationToken)">
            <summary>
            Attaches event queue to the driver and start processing all events pertaining to the given analysis scope.
            </summary>
            <param name="eventQueue">Compilation events to analyze.</param>
            <param name="analysisScope">Scope of analysis.</param>
            <param name="cancellationToken">Cancellation token to abort analysis.</param>
            <remarks>Driver must be initialized before invoking this method, i.e. <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor,Microsoft.CodeAnalysis.Diagnostics.DiagnosticQueue,Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.CompilationData,System.Threading.CancellationToken)"/> method must have been invoked and <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.WhenInitializedTask"/> must be non-null.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.CreateAndAttachToCompilation(Microsoft.CodeAnalysis.Compilation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Boolean,Microsoft.CodeAnalysis.Diagnostics.SeverityFilter,Microsoft.CodeAnalysis.Compilation@,System.Threading.CancellationToken)">
            <summary>
            Create an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver"/> and attach it to the given compilation. 
            </summary>
            <param name="compilation">The compilation to which the new driver should be attached.</param>
            <param name="analyzers">The set of analyzers to include in the analysis.</param>
            <param name="options">Options that are passed to analyzers.</param>
            <param name="analyzerManager">AnalyzerManager to manage analyzers for the lifetime of analyzer host.</param>
            <param name="addExceptionDiagnostic">Delegate to add diagnostics generated for exceptions from third party analyzers.</param>
            <param name="reportAnalyzer">Report additional information related to analyzers, such as analyzer execution time.</param>
            <param name="severityFilter">Filtered diagnostic severities in the compilation, i.e. diagnostics with effective severity from this set should not be reported.</param>
            <param name="newCompilation">The new compilation with the analyzer driver attached.</param>
            <param name="cancellationToken">A cancellation token that can be used to abort analysis.</param>
            <returns>A newly created analyzer driver</returns>
            <remarks>
            Note that since a compilation is immutable, the act of creating a driver and attaching it produces
            a new compilation. Any further actions on the compilation should use the new compilation.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetDiagnosticsAsync(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Returns all diagnostics computed by the analyzers since the last time this was invoked.
            If <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.CompilationEventQueue"/> has been completed with all compilation events, then it waits for
            <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.WhenCompletedTask"/> task for the driver to finish processing all events and generate remaining analyzer diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.WhenInitializedTask">
            <summary>
            Return a task that completes when the driver is initialized.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.WhenCompletedTask">
            <summary>
            Return a task that completes when the driver is done producing diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessSymbolDeclaredAsync(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Threading.CancellationToken)">
            <summary>
            Tries to execute symbol action, symbol start/end actions and declaration actions for the given symbol.
            </summary>
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.EventProcessedState"/> indicating the current state of processing of the given compilation event.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryExecuteSymbolActions(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Tries to execute symbol actions.
            </summary>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR no actions were required to be executed for the given analysis scope.
            False, otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessCompilationUnitCompleted(Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Threading.CancellationToken)">
            <summary>
            Tries to execute compilation unit actions.
            </summary>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR no actions were required to be executed for the given analysis scope.
            False, otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessCompilationStarted(Microsoft.CodeAnalysis.Diagnostics.CompilationStartedEvent,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState)">
            <summary>
            Tries to execute compilation started actions.
            </summary>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR no actions were required to be executed for the given analysis scope.
            False, otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessCompilationCompleted(Microsoft.CodeAnalysis.Diagnostics.CompilationCompletedEvent,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState)">
            <summary>
            Tries to execute compilation completed actions.
            </summary>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR no actions were required to be executed for the given analysis scope.
            False, otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryExecuteCompilationActions(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.CompilationAnalyzerAction}}},Microsoft.CodeAnalysis.Diagnostics.CompilationEvent,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState)">
            <summary>
            Tries to execute compilation actions.
            </summary>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR no actions were required to be executed for the given analysis scope.
            False, otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.IsDiagnosticAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager,Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor,Microsoft.CodeAnalysis.Diagnostics.SeverityFilter)">
            <summary>
            Returns true if all the diagnostics that can be produced by this analyzer are suppressed through options.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.DeclarationAnalysisData.DeclaringReferenceSyntax">
            <summary>
            GetSyntax() for the given SyntaxReference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.DeclarationAnalysisData.TopmostNodeForAnalysis">
            <summary>
            Topmost declaration node for analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.DeclarationAnalysisData.DeclarationsInNode">
            <summary>
            All member declarations within the declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.DeclarationAnalysisData.DescendantNodesToAnalyze">
            <summary>
            All descendant nodes for syntax node actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.DeclarationAnalysisData.IsPartialAnalysis">
            <summary>
            Flag indicating if this is a partial analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.EventProcessedState">
            <summary>
            Used to represent state of processing of a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.EventProcessedState.SubsetProcessedAnalyzers">
            <summary>
            Subset of processed analyzers.
            NOTE: This property is only non-null for <see cref="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.EventProcessedStateKind.PartiallyProcessed"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1">
            <summary>
            Driver to execute diagnostic analyzers for a given compilation.
            It uses a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1"/> of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent"/>s to drive its analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Func{Microsoft.CodeAnalysis.SyntaxNode,`0},Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager,Microsoft.CodeAnalysis.Diagnostics.SeverityFilter,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Create an analyzer driver.
            </summary>
            <param name="analyzers">The set of analyzers to include in the analysis</param>
            <param name="getKind">A delegate that returns the language-specific kind for a given syntax node</param>
            <param name="analyzerManager">AnalyzerManager to manage analyzers for the lifetime of analyzer host.</param>
            <param name="severityFilter">Filtered diagnostic severities in the compilation, i.e. diagnostics with effective severity from this set should not be reported.</param>
            <param name="isComment">Delegate to identify if the given trivia is a comment.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.TryExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Boolean,Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.IGroupedAnalyzerActions,System.Threading.CancellationToken)">
            <summary>
            Tries to execute syntax node, code block and operation actions for all declarations for the given symbol.
            </summary>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR no actions were required to be executed for the given analysis scope.
            False, otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.TryExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.SyntaxReference,System.Int32,Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver{`0}.GroupedAnalyzerActions,Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver{`0}.GroupedAnalyzerActions,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Tries to execute syntax node, code block and operation actions for the given declaration.
            </summary>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR no actions were required to be executed for the given analysis scope.
            False, otherwise.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.GroupedAnalyzerActions">
            <summary>
            <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.GroupedAnalyzerActions.AnalyzerActions"/> grouped by <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>, and possibly other entities, such as <see cref="T:Microsoft.CodeAnalysis.OperationKind"/>, <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>, etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor">
            <summary>
            Contains the core execution logic for callbacks into analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.AnalyzerDiagnosticReporter">
            <summary>
            Pooled object that carries the info needed to process
            a reported diagnostic from a syntax node action.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor._analyzerExecutionTimeMap">
            <summary>
            The values in this map convert to <see cref="T:System.TimeSpan"/> using <see cref="M:System.TimeSpan.FromTicks(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.Create(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Action{System.Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostic},System.Func{System.Exception,System.Boolean},System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager,System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},System.Func{Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean},System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTreeOptionsProvider,System.Boolean},System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Object},System.Func{Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SemanticModel},System.Boolean,System.Action{Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},System.Action{Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Action{Microsoft.CodeAnalysis.Diagnostics.Suppression},System.Threading.CancellationToken)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor"/> to execute analyzer actions with given arguments
            </summary>
            <param name="compilation">Compilation to be used in the analysis.</param>
            <param name="analyzerOptions">Analyzer options.</param>
            <param name="addNonCategorizedDiagnostic">Optional delegate to add non-categorized analyzer diagnostics.</param>
            <param name="onAnalyzerException">
            Delegate which is invoked when an analyzer throws an exception.
            Delegate can do custom tasks such as report the given analyzer exception diagnostic, report a non-fatal watson for the exception, etc.
            </param>
            <param name="analyzerExceptionFilter">
            Optional delegate which is invoked when an analyzer throws an exception as an exception filter.
            Delegate can do custom tasks such as crash hosting process to create a dump.
            </param>
            <param name="isCompilerAnalyzer">Delegate to determine if the given analyzer is compiler analyzer. 
            We need to special case the compiler analyzer at few places for performance reasons.</param>
            <param name="analyzerManager">Analyzer manager to fetch supported diagnostics.</param>
            <param name="getAnalyzerGate">
            Delegate to fetch the gate object to guard all callbacks into the analyzer.
            It should return a unique gate object for the given analyzer instance for non-concurrent analyzers, and null otherwise.
            All analyzer callbacks for non-concurrent analyzers will be guarded with a lock on the gate.
            </param>
            <param name="getSemanticModel">Delegate to get a semantic model for the given syntax tree which can be shared across analyzers.</param>
            <param name="shouldSkipAnalysisOnGeneratedCode">Delegate to identify if analysis should be skipped on generated code.</param>
            <param name="shouldSuppressGeneratedCodeDiagnostic">Delegate to identify if diagnostic reported while analyzing generated code should be suppressed.</param>
            <param name="isGeneratedCodeLocation">Delegate to identify if the given location is in generated code.</param>
            <param name="isAnalyzerSuppressedForTree">Delegate to identify if the given analyzer is suppressed for the given tree.</param>
            <param name="logExecutionTime">Flag indicating whether we need to log analyzer execution time.</param>
            <param name="addCategorizedLocalDiagnostic">Optional delegate to add categorized local analyzer diagnostics.</param>
            <param name="addCategorizedNonLocalDiagnostic">Optional delegate to add categorized non-local analyzer diagnostics.</param>
            <param name="addSuppression">Optional thread-safe delegate to add diagnostic suppressions from suppressors.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.CreateForSupportedDiagnostics(System.Action{System.Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager,System.Threading.CancellationToken)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor"/> to fetch <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics"/>.
            </summary>
            <param name="onAnalyzerException">
            Optional delegate which is invoked when an analyzer throws an exception.
            Delegate can do custom tasks such as report the given analyzer exception diagnostic, report a non-fatal watson for the exception, etc.
            </param>
            <param name="analyzerManager">Analyzer manager to fetch supported diagnostics.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteInitializeMethod(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.HostSessionStartAnalysisScope)">
            <summary>
            Executes the <see cref="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)"/> for the given analyzer.
            </summary>
            <param name="analyzer">Analyzer to get session wide analyzer actions.</param>
            <param name="sessionScope">Session scope to store register session wide analyzer actions.</param>
            <remarks>
            Note that this API doesn't execute any <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalyzerAction"/> registered by the Initialize invocation.
            Use <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteCompilationStartActions(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalyzerAction},Microsoft.CodeAnalysis.Diagnostics.HostCompilationStartAnalysisScope)"/> API
            to get execute these actions to get the per-compilation analyzer actions.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteCompilationStartActions(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalyzerAction},Microsoft.CodeAnalysis.Diagnostics.HostCompilationStartAnalysisScope)">
            <summary>
            Executes the compilation start actions.
            </summary>
            <param name="actions"><see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerActions"/> whose compilation start actions are to be executed.</param>
            <param name="compilationScope">Compilation scope to store the analyzer actions.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSymbolStartActions(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalyzerAction},Microsoft.CodeAnalysis.Diagnostics.HostSymbolStartAnalysisScope,System.Boolean)">
            <summary>
            Executes the symbol start actions.
            </summary>
            <param name="symbol">Symbol whose symbol start actions are to be executed.</param>
            <param name="analyzer">Analyzer whose symbol start actions are to be executed.</param>
            <param name="actions"><see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerActions"/> whose symbol start actions are to be executed.</param>
            <param name="symbolScope">Symbol scope to store the analyzer actions.</param>
            <param name="isGeneratedCodeSymbol">Flag indicating if the symbol being analyzed is generated code.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSuppressionAction(Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Executes the given diagnostic suppressor.
            </summary>
            <param name="suppressor">Suppressor to be executed.</param>
            <param name="reportedDiagnostics">Reported analyzer/compiler diagnostics that can be suppressed.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteCompilationActions(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.CompilationAnalyzerAction},Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.CompilationEvent,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState)">
            <summary>
            Tries to executes compilation actions or compilation end actions.
            </summary>
            <param name="compilationActions">Compilation actions to be executed.</param>
            <param name="analyzer">Analyzer whose actions are to be executed.</param>
            <param name="compilationEvent">Compilation event.</param>
            <param name="analysisScope">Scope for analyzer execution.</param>
            <param name="analysisState">An optional object to track analysis state.</param>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR all the actions have already been executed for the given analysis scope.
            False, if there are some pending actions that are currently being executed on another thread.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteSymbolActions(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.SymbolAnalyzerAction},Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent,System.Func{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxReference,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken,Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Boolean)">
            <summary>
            Tries to execute the symbol actions on the given symbol.
            </summary>
            <param name="symbolActions">Symbol actions to be executed.</param>
            <param name="analyzer">Analyzer whose actions are to be executed.</param>
            <param name="symbolDeclaredEvent">Symbol event to be analyzed.</param>
            <param name="getTopMostNodeForAnalysis">Delegate to get topmost declaration node for a symbol declaration reference.</param>
            <param name="analysisScope">Scope for analyzer execution.</param>
            <param name="analysisState">An optional object to track analysis state.</param>
            <param name="isGeneratedCodeSymbol">Flag indicating if this is a generated code symbol.</param>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR all the actions have already been executed for the given analysis scope.
            False, if there are some pending actions that are currently being executed on another thread.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteSymbolEndActionsForContainer(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Func{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxReference,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken,Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Boolean,Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent@)">
            <summary>
            Tries to execute the symbol end actions on the given namespace or type containing symbol for the process member symbol for the given analyzer.
            </summary>
            <param name="containingSymbol">Symbol whose actions are to be executed.</param>
            <param name="processedMemberSymbol">Completed member symbol.</param>
            <param name="analyzer">Analyzer whose actions are to be executed.</param>
            <param name="getTopMostNodeForAnalysis">Delegate to get topmost declaration node for a symbol declaration reference.</param>
            <param name="isGeneratedCode">Flag indicating if the containing symbol being analyzed is generated code.</param>
            <param name="analysisState">An optional object to track analysis state.</param>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR all the actions have already been executed for the given analysis scope.
            False, if there are some pending actions.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteSymbolEndActions(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.SymbolEndAnalyzerAction},Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent,System.Func{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxReference,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken,Microsoft.CodeAnalysis.SyntaxNode},System.Boolean,Microsoft.CodeAnalysis.Diagnostics.AnalysisState)">
            <summary>
            Tries to execute the symbol end actions on the given symbol for the given analyzer.
            </summary>
            <param name="symbolEndActions">Symbol actions to be executed.</param>
            <param name="analyzer">Analyzer whose actions are to be executed.</param>
            <param name="symbolDeclaredEvent">Symbol event to be analyzed.</param>
            <param name="getTopMostNodeForAnalysis">Delegate to get topmost declaration node for a symbol declaration reference.</param>
            <param name="isGeneratedCode">Flag indicating if the symbol being analyzed is generated code.</param>
            <param name="analysisState">An optional object to track analysis state.</param>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR all the actions have already been executed for the given analysis scope.
            False, if there are some pending actions.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteSemanticModelActions(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalyzerAction},Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Boolean)">
            <summary>
            Tries to execute the semantic model actions on the given semantic model.
            </summary>
            <param name="semanticModelActions">Semantic model actions to be executed.</param>
            <param name="analyzer">Analyzer whose actions are to be executed.</param>
            <param name="semanticModel">Semantic model to analyze.</param>
            <param name="compilationUnitCompletedEvent">Compilation event for semantic model analysis.</param>
            <param name="analysisScope">Scope for analyzer execution.</param>
            <param name="analysisState">An optional object to track analysis state.</param>
            <param name="isGeneratedCode">Flag indicating if the syntax tree being analyzed is generated code.</param>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR all the actions have already been executed for the given analysis scope.
            False, if there are some pending actions that are currently being executed on another thread.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteSyntaxTreeActions(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalyzerAction},Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.SourceOrAdditionalFile,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Boolean)">
            <summary>
            Tries to execute the syntax tree actions on the given syntax tree.
            </summary>
            <param name="syntaxTreeActions">Syntax tree actions to be executed.</param>
            <param name="analyzer">Analyzer whose actions are to be executed.</param>
            <param name="file">Syntax tree to analyze.</param>
            <param name="analysisScope">Scope for analyzer execution.</param>
            <param name="analysisState">An optional object to track analysis state.</param>
            <param name="isGeneratedCode">Flag indicating if the syntax tree being analyzed is generated code.</param>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR all the actions have already been executed for the given analysis scope.
            False, if there are some pending actions that are currently being executed on another thread.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteAdditionalFileActions(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalyzerAction},Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.SourceOrAdditionalFile,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState)">
            <summary>
            Tries to execute the additional file actions.
            </summary>
            <param name="additionalFileActions">Actions to be executed.</param>
            <param name="analyzer">Analyzer whose actions are to be executed.</param>
            <param name="file">Additional file to analyze.</param>
            <param name="analysisScope">Scope for analyzer execution.</param>
            <param name="analysisState">An optional object to track analysis state.</param>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR all the actions have already been executed for the given analysis scope.
            False, if there are some pending actions that are currently being executed on another thread.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteCodeBlockActions``1(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalyzerAction{``0}},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalyzerAction},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalyzerAction},Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SemanticModel,System.Func{Microsoft.CodeAnalysis.SyntaxNode,``0},System.Int32,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Boolean)">
            <summary>
            Tries to execute code block actions for the given analyzer for the given declaration.
            </summary>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR all the actions have already been executed for the given analysis scope.
            False, if there are some pending actions that are currently being executed on another thread.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteOperationBlockActions(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalyzerAction},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalyzerAction},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalyzerAction},Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IOperation},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IOperation},Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Boolean)">
            <summary>
            Tries to execute operation block actions for the given analyzer for the given declaration.
            </summary>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR all the actions have already been executed for the given analysis scope.
            False, if there are some pending actions that are currently being executed on another thread.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteSyntaxNodeActions``1(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction{``0}}},Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.SemanticModel,System.Func{Microsoft.CodeAnalysis.SyntaxNode,``0},Microsoft.CodeAnalysis.Text.TextSpan,System.Int32,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Boolean)">
            <summary>
            Tries to execute syntax node actions for the given analyzer for the given declaration.
            </summary>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR all the actions have already been executed for the given analysis scope.
            False, if there are some pending actions that are currently being executed on another thread.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteOperationActions(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IOperation},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{Microsoft.CodeAnalysis.OperationKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.OperationAnalyzerAction}},Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Text.TextSpan,System.Int32,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,Microsoft.CodeAnalysis.Diagnostics.AnalysisState,System.Boolean)">
            <summary>
            Tries to execute operation actions for the given analyzer for the given declaration.
            </summary>
            <returns>
            True, if successfully executed the actions for the given analysis scope OR all the actions have already been executed for the given analysis scope.
            False, if there are some pending actions that are currently being executed on another thread.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference">
            <summary>
            Represents analyzers stored in an analyzer assembly file.
            </summary>
            <remarks>
            Analyzer are read from the file, owned by the reference, and doesn't change 
            since the reference is accessed until the reference object is garbage collected.
            
            If you need to manage the lifetime of the analyzer reference (and the file stream) explicitly use <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.#ctor(System.String,Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader)">
            <summary>
            Creates an AnalyzerFileReference with the given <paramref name="fullPath"/> and <paramref name="assemblyLoader"/>.
            </summary>
            <param name="fullPath">Full path of the analyzer assembly.</param>
            <param name="assemblyLoader">Loader for obtaining the <see cref="T:System.Reflection.Assembly"/> from the <paramref name="fullPath"/></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.AddAnalyzers(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer}.Builder,System.String,System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean})">
            <summary>
            Adds the <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> defined in this assembly reference of given <paramref name="language"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.AddGenerators(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISourceGenerator}.Builder,System.String)">
            <summary>
            Adds the <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> of <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> defined in this assembly reference of given <paramref name="language"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.GetAnalyzerTypeNameMap(System.String,System.Type,Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.AttributeLanguagesFunc)">
            <summary>
            Opens the analyzer dll with the metadata reader and builds a map of language -> analyzer type names.
            </summary>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
            <exception cref="T:System.IO.IOException">IO error reading the metadata.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference">
            <summary>
            Represents an in-memory analyzer reference image.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.TypeName">
            <summary>
            If a specific analyzer failed to load the namespace-qualified name of its type, null otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.Message">
            <summary>
            Error message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.ErrorCode">
            <summary>
            Error code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.Exception">
            <summary>
            Exception that was thrown while loading the analyzer. May be null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.ReferencedCompilerVersion">
            <summary>
            If <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.ErrorCode"/> is <see cref="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.FailureErrorCode.ReferencesNewerCompiler"/>, returns the compiler version referenced by the analyzer assembly. Otherwise, returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager">
            <summary>
            Manages properties of analyzers (such as registered actions, supported diagnostics) for analyzer host's lifetime
            and executes the callbacks into the analyzers.
            
            It ensures the following for the lifetime of analyzer host:
            1) <see cref="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)"/> is invoked only once per-analyzer.
            2) <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics"/> is invoked only once per-analyzer.
            3) <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalyzerAction"/> registered during Initialize are invoked only once per-compilation per-analyzer and analyzer options.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.AnalyzerExecutionContext._lazyPendingMemberSymbolsMap">
            <summary>
            Map from (symbol, analyzer) to count of its member symbols whose symbol declared events are not yet processed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.AnalyzerExecutionContext._lazyPendingSymbolEndActionsMap">
            <summary>
            Symbol declared events for symbols with pending symbol end analysis for given analyzer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.AnalyzerExecutionContext._lazySessionScopeTask">
            <summary>
            Task to compute HostSessionStartAnalysisScope for session wide analyzer actions, i.e. AnalyzerActions registered by analyzer's Initialize method.
            These are run only once per every analyzer. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.AnalyzerExecutionContext._lazyCompilationScopeTask">
            <summary>
            Task to compute HostCompilationStartAnalysisScope for per-compilation analyzer actions, i.e. AnalyzerActions registered by analyzer's CompilationStartActions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.AnalyzerExecutionContext._lazySymbolScopeTasks">
            <summary>
            Task to compute HostSymbolStartAnalysisScope for per-symbol analyzer actions, i.e. AnalyzerActions registered by analyzer's SymbolStartActions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.AnalyzerExecutionContext._lazyDiagnosticDescriptors">
            <summary>
            Supported diagnostic descriptors for diagnostic analyzer, if any.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.AnalyzerExecutionContext._lazySuppressionDescriptors">
            <summary>
            Supported suppression descriptors for diagnostic suppressor, if any.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.AnalyzerExecutionContext.ComputeDiagnosticDescriptors(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor)">
            <summary>
            Compute <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics"/> and exception handler for the given <paramref name="analyzer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.GetAnalyzerActionsAsync(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor)">
            <summary>
            Get all the analyzer actions to execute for the given analyzer against a given compilation.
            The returned actions include the actions registered during <see cref="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)"/> method as well as
            the actions registered during <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalyzerAction"/> for the given compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.GetPerSymbolAnalyzerActionsAsync(Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor)">
            <summary>
            Get the per-symbol analyzer actions to be executed by the given analyzer.
            These are the actions registered during the various RegisterSymbolStartAction method invocations for the given symbol on different analysis contexts.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.IsConcurrentAnalyzerAsync(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor)">
            <summary>
            Returns true if the given analyzer has enabled concurrent execution by invoking <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.EnableConcurrentExecution"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.GetGeneratedCodeAnalysisFlagsAsync(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor)">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags"/> for the given analyzer.
            If an analyzer hasn't configured generated code analysis, returns <see cref="F:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.DefaultGeneratedCodeAnalysisFlags"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.GetSupportedDiagnosticDescriptors(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor)">
            <summary>
            Return <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics"/> of given <paramref name="analyzer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.GetSupportedSuppressionDescriptors(Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor,Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor)">
            <summary>
            Return <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor.SupportedSuppressions"/> of given <paramref name="suppressor"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager.IsDiagnosticAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.CompilationOptions,System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor,Microsoft.CodeAnalysis.Diagnostics.SeverityFilter)">
            <summary>
            Returns true if all the diagnostics that can be produced by this analyzer are suppressed through options.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions">
            <summary>
            Options passed to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions.AdditionalFiles">
            <summary>
            A set of additional non-code text files that can be used by analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions.AnalyzerConfigOptionsProvider">
            <summary>
            A set of options keyed to <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AdditionalText},Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider)">
            <summary>
            Creates analyzer options to be passed to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>.
            </summary>
            <param name="additionalFiles">A set of additional non-code text files that can be used by analyzers.</param>
            <param name="optionsProvider">A set of per-tree options that can be used by analyzers.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AdditionalText})">
            <summary>
            Creates analyzer options to be passed to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>.
            </summary>
            <param name="additionalFiles">A set of additional non-code text files that can be used by analyzers.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions.WithAdditionalFiles(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AdditionalText})">
            <summary>
            Returns analyzer options with the given <paramref name="additionalFiles"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptionsExtensions.TryGetSeverityFromBulkConfiguration(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.DiagnosticDescriptor,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ReportDiagnostic@)">
            <summary>
            Tries to get configured severity for the given <paramref name="descriptor"/>
            for the given <paramref name="tree"/> from bulk configuration analyzer config options, i.e.
                'dotnet_analyzer_diagnostic.category-%RuleCategory%.severity = %severity%'
                    or
                'dotnet_analyzer_diagnostic.severity = %severity%'
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference">
            <summary>
            Represents an analyzer assembly reference that contains diagnostic analyzers.
            </summary>
            <remarks>
            Represents a logical location of the analyzer reference, not the content of the reference. 
            The content might change in time. A snapshot is taken when the compiler queries the reference for its analyzers.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.FullPath">
            <summary>
            Full path describing the location of the analyzer reference, or null if the reference has no location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.Display">
            <summary>
            Path or name used in error messages to identity the reference.
            </summary>
            <remarks>
            Should not be null.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.Id">
            <summary>
            A unique identifier for this analyzer reference.
            </summary>
            <remarks>
            Should not be null.
            Note that this and <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.FullPath"/> serve different purposes. An analyzer reference may not
            have a path, but it always has an ID. Further, two analyzer references with different paths may
            represent two copies of the same analyzer, in which case the IDs should also be the same.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetAnalyzersForAllLanguages">
            <summary>
            Gets all the diagnostic analyzers defined in this assembly reference, irrespective of the language supported by the analyzer.
            Use this method only if you need all the analyzers defined in the assembly, without a language context.
            In most instances, either the analyzer reference is associated with a project or is being queried for analyzers in a particular language context.
            If so, use <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetAnalyzers(System.String)"/> method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetAnalyzers(System.String)">
            <summary>
            Gets all the diagnostic analyzers defined in this assembly reference for the given <paramref name="language"/>.
            </summary>
            <param name="language">Language name.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetGeneratorsForAllLanguages">
            <summary>
            Gets all the source generators defined in this assembly reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetGenerators(System.String)">
            <summary>
            Gets all the generators defined in this assembly reference for the given <paramref name="language"/>.
            </summary>
            <param name="language">Language name.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1">
            <summary>
            A queue whose enqueue and dequeue operations can be performed in parallel.
            </summary>
            <typeparam name="TElement">The type of values kept by the queue.</typeparam>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Count">
            <summary>
            The number of unconsumed elements in the queue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Enqueue(`0)">
            <summary>
            Adds an element to the tail of the queue.  This method will throw if the queue 
            is completed.
            </summary>
            <exception cref="T:System.InvalidOperationException">The queue is already completed.</exception>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.TryEnqueue(`0)">
            <summary>
            Tries to add an element to the tail of the queue.  This method will return false if the queue
            is completed.
            </summary>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.TryDequeue(`0@)">
            <summary>
            Attempts to dequeue an existing item and return whether or not it was available.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.IsCompleted">
            <summary>
            Gets a value indicating whether the queue has completed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete">
            <summary>
            Signals that no further elements will be enqueued.  All outstanding and future
            Dequeue Task will be cancelled.
            </summary>
            <exception cref="T:System.InvalidOperationException">The queue is already completed.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.TryComplete">
            <summary>
            Same operation as <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete"/> except it will not
            throw if the queue is already completed.
            </summary>
            <returns>Whether or not the operation succeeded.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.WhenCompletedTask">
            <summary>
            Gets a task that transitions to a completed state when <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete"/> or
            <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.TryComplete"/> is called.  This transition will not happen synchronously.
            
            This Task will not complete until it has completed all existing values returned
            from <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.DequeueAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.DequeueAsync(System.Threading.CancellationToken)">
            <summary>
            Gets a task whose result is the element at the head of the queue. If the queue
            is empty, the returned task waits for an element to be enqueued. If <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete"/> 
            is called before an element becomes available, the returned task is cancelled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.TryDequeueAsync(System.Threading.CancellationToken)">
            <summary>
            Gets a task whose result is the element at the head of the queue. If the queue
            is empty, the returned task waits for an element to be enqueued. If <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete"/> 
            is called before an element becomes available, the returned task is completed and
            <see cref="P:Microsoft.CodeAnalysis.Optional`1.HasValue"/> will be <see langword="false"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.AttachCancellation``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.CancellationToken)">
            <summary>
            Cancels a <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> if a given <see cref="T:System.Threading.CancellationToken"/> is canceled.
            </summary>
            <typeparam name="T">The type of value returned by a successfully completed <see cref="T:System.Threading.Tasks.Task`1"/>.</typeparam>
            <param name="taskCompletionSource">The <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> to cancel.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/>.</param>
            <seealso href="https://github.com/microsoft/vs-threading/blob/558f24c576cc620a00b20ed1fa90a5e2d13b0440/src/Microsoft.VisualStudio.Threading/ThreadingTools.cs#L181-L255"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.CancelableTaskCompletionSource`1">
            <summary>
            A state object for tracking cancellation and a TaskCompletionSource.
            </summary>
            <typeparam name="T">The type of value returned from a task.</typeparam>
            <remarks>
            We use this class so that we only allocate one object to support all continuations
            required for cancellation handling, rather than a special closure and delegate for each one.
            </remarks>
            <seealso href="https://github.com/microsoft/vs-threading/blob/558f24c576cc620a00b20ed1fa90a5e2d13b0440/src/Microsoft.VisualStudio.Threading/ThreadingTools.cs#L318-L372"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.CancelableTaskCompletionSource`1.#ctor(System.Threading.Tasks.TaskCompletionSource{`1},System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.CancelableTaskCompletionSource`1"/> class.
            </summary>
            <param name="taskCompletionSource">The task completion source.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.CancelableTaskCompletionSource`1.CancellationToken">
            <summary>
            Gets the cancellation token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.CancelableTaskCompletionSource`1.TaskCompletionSource">
            <summary>
            Gets the Task completion source.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.CancelableTaskCompletionSource`1.CancellationTokenRegistration">
            <summary>
            Gets or sets the cancellation token registration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CachingSemanticModelProvider">
            <summary>
            Provider that caches semantic models for requested trees, with a strong reference to the model.
            Clients using this provider are responsible for maintaining the lifetime of the entries in this cache,
            and should invoke <see cref="M:Microsoft.CodeAnalysis.Diagnostics.CachingSemanticModelProvider.ClearCache(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Compilation)"/> and <see cref="M:Microsoft.CodeAnalysis.Diagnostics.CachingSemanticModelProvider.ClearCache(Microsoft.CodeAnalysis.Compilation)"/> to clear entries when appropriate.
            For example, <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/> uses this provider to ensure that semantic model instances
            are shared between the compiler and analyzers for improved analyzer execution performance. The underlying
            <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver"/> executing analyzers clears per-tree entries in the cache whenever a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent"/>
            has been processed, indicating all relevant analyzers have executed on the corresponding syntax tree for the event.
            Similarly, it clears the entire compilation wide cache whenever a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationCompletedEvent"/> has been processed,
            indicating all relevant analyzers have executed on the entire compilation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisValueProvider`2">
            <summary>
            Wrapper over the core <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisValueProvider`2"/> which holds a strong reference to key-value pairs for the lifetime of a compilation that this provider is associated with.
            This ensures that values are never re-computed for equivalent keys while analyzing each compilation, improving overall analyzer performance.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CompilationCompletedEvent">
            <summary>
            The last event placed into a compilation's event queue.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartedEvent">
            <summary>
            The first event placed into a compilation's event queue.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent.FilterSpan">
            <summary>
            Optional filter span for a synthesized CompilationUnitCompletedEvent generated for span-based semantic diagnostic computation.
            Such synthesized events are used primarily for performance improvements when running compiler analyzer in span-based mode in the IDE,
            such as computing diagnostics for the lightbulb for the current line.
            Note that such a synthesized CompilationUnitCompletedEvent with non-null FilterSpan is not a true
            compilation unit completed event, but just a stub event to drive span-based semantic model action callbacks
            for analyzer execution. This event will eventually be followed by a true CompilationUnitCompletedEvent
            with null FilterSpan when the entire compilation unit has actually completed.
            See https://github.com/dotnet/roslyn/issues/56843 for details.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers._driverPool">
            <summary>
            Pool of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver"/>s used for analyzer execution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers._analysisState">
            <summary>
            Contains the partial analysis state per-analyzer. It tracks:
            1. Global set of pending compilation events. This is used to populate the event queue for analyzer execution.
            2. Per-analyzer set of pending compilation events, symbols, declarations, etc. Each of these pending entities has a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisState.AnalyzerStateData"/> state object to track partial analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers._analysisResultBuilder">
            <summary>
            Builder for storing current, possibly partial, analysis results:
            1. Diagnostics reported by analyzers.
            2. AnalyzerTelemetryInfo.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers._exceptionDiagnostics">
            <summary>
            Set of exception diagnostics reported for exceptions thrown by the analyzers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers._executingTasksLock">
            <summary>
            Lock to track the set of active tasks computing tree diagnostics and task computing compilation diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers._currentToken">
            <summary>
            Used to generate a unique token for each tree diagnostics request.
            The token is used to determine the priority of each request.
            Each new tree diagnostic request gets an incremented token value and has higher priority over other requests for the same tree.
            Compilation diagnostics requests always have the lowest priority.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers._concurrentTreeTaskTokensOpt">
            <summary>
            Map from active tasks computing tree diagnostics to their token number.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers._eventQueuePool">
            <summary>
            Pool of event queues to serve each diagnostics request.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Compilation">
            <summary>
            Underlying <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Compilation"/> with a non-null <see cref="P:Microsoft.CodeAnalysis.Compilation.EventQueue"/>, used to drive analyzer execution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers">
            <summary>
            Analyzers to execute on the compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.AnalysisOptions">
            <summary>
            Options to configure analyzer execution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.CancellationToken">
            <summary>
            An optional cancellation token which can be used to cancel analysis.
            Note: This token is only used if the API invoked to get diagnostics doesn't provide a cancellation token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.#ctor(Microsoft.CodeAnalysis.Compilation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Threading.CancellationToken)">
            <summary>
            Creates a new compilation by attaching diagnostic analyzers to an existing compilation.
            </summary>
            <param name="compilation">The original compilation.</param>
            <param name="analyzers">The set of analyzers to include in future analyses.</param>
            <param name="options">Options that are passed to analyzers.</param>
            <param name="cancellationToken">A cancellation token that can be used to abort analysis.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.#ctor(Microsoft.CodeAnalysis.Compilation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions)">
            <summary>
            Creates a new compilation by attaching diagnostic analyzers to an existing compilation.
            </summary>
            <param name="compilation">The original compilation.</param>
            <param name="analyzers">The set of analyzers to include in future analyses.</param>
            <param name="analysisOptions">Options to configure analyzer execution.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerDiagnosticsAsync">
            <summary>
            Returns diagnostics produced by all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerDiagnosticsAsync(System.Threading.CancellationToken)">
            <summary>
            Returns diagnostics produced by all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerDiagnosticsAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Threading.CancellationToken)">
            <summary>
            Returns diagnostics produced by given <paramref name="analyzers"/>.
            </summary>
            <param name="analyzers">Analyzers whose diagnostics are required. All the given analyzers must be from the analyzers passed into the constructor of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/>.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalysisResultAsync(System.Threading.CancellationToken)">
            <summary>
            Executes all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/> and returns the corresponding <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult"/> with all diagnostics and telemetry info.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalysisResultAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Threading.CancellationToken)">
            <summary>
            Executes the given <paramref name="analyzers"/> and returns the corresponding <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult"/> with all diagnostics and telemetry info.
            </summary>
            <param name="analyzers">Analyzers whose analysis results are required. All the given analyzers must be from the analyzers passed into the constructor of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/>.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAllDiagnosticsAsync">
            <summary>
            Returns all diagnostics produced by compilation and by all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAllDiagnosticsAsync(System.Threading.CancellationToken)">
            <summary>
            Returns all diagnostics produced by compilation and by all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerCompilationDiagnosticsAsync(System.Threading.CancellationToken)">
            <summary>
            Returns diagnostics produced by compilation actions of all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerCompilationDiagnosticsAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Threading.CancellationToken)">
            <summary>
            Returns diagnostics produced by compilation actions of given <paramref name="analyzers"/>.
            </summary>
            <param name="analyzers">Analyzers whose diagnostics are required. All the given analyzers must be from the analyzers passed into the constructor of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/>.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerSyntaxDiagnosticsAsync(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)">
            <summary>
            Returns syntax diagnostics produced by all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/> from analyzing the given <paramref name="tree"/>.
            Depending on analyzers' behavior, returned diagnostics can have locations outside the tree,
            and some diagnostics that would be reported for the tree by an analysis of the complete compilation
            can be absent.
            </summary>
            <param name="tree">Syntax tree to analyze.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerSyntaxDiagnosticsAsync(Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Threading.CancellationToken)">
            <summary>
            Returns syntax diagnostics produced by given <paramref name="analyzers"/> from analyzing the given <paramref name="tree"/>.
            Depending on analyzers' behavior, returned diagnostics can have locations outside the tree,
            and some diagnostics that would be reported for the tree by an analysis of the complete compilation
            can be absent.
            </summary>
            <param name="tree">Syntax tree to analyze.</param>
            <param name="analyzers">Analyzers whose diagnostics are required. All the given analyzers must be from the analyzers passed into the constructor of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/>.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalysisResultAsync(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)">
            <summary>
            Returns an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult"/> populated with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.SyntaxDiagnostics"/> produced by all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/> from analyzing the given <paramref name="tree"/>.
            Depending on analyzers' behavior, some diagnostics that would be reported for the tree by an analysis of the complete compilation can be absent.
            </summary>
            <param name="tree">Syntax tree to analyze.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalysisResultAsync(Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Threading.CancellationToken)">
            <summary>
            Returns an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult"/> populated with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.SyntaxDiagnostics"/> produced by given <paramref name="analyzers"/> from analyzing the given <paramref name="tree"/>.
            Depending on analyzers' behavior, some diagnostics that would be reported for the tree by an analysis of the complete compilation can be absent.
            </summary>
            <param name="tree">Syntax tree to analyze.</param>
            <param name="analyzers">Analyzers whose diagnostics are required. All the given analyzers must be from the analyzers passed into the constructor of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/>.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalysisResultAsync(Microsoft.CodeAnalysis.AdditionalText,System.Threading.CancellationToken)">
            <summary>
            Returns an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult"/> populated with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.AdditionalFileDiagnostics"/> produced by all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/> from analyzing the given additional <paramref name="file"/>.
            The given <paramref name="file"/> must be part of <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions.AdditionalFiles"/> for the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.AnalysisOptions"/> for this CompilationWithAnalyzers instance.
            Depending on analyzers' behavior, some diagnostics that would be reported for the file by an analysis of the complete compilation can be absent.
            </summary>
            <param name="file">Additional file to analyze.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalysisResultAsync(Microsoft.CodeAnalysis.AdditionalText,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Threading.CancellationToken)">
            <summary>
            Returns an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult"/> populated with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.AdditionalFileDiagnostics"/> produced by given <paramref name="analyzers"/> from analyzing the given additional <paramref name="file"/>.
            The given <paramref name="file"/> must be part of <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions.AdditionalFiles"/> for the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.AnalysisOptions"/> for this CompilationWithAnalyzers instance.
            Depending on analyzers' behavior, some diagnostics that would be reported for the file by an analysis of the complete compilation can be absent.
            </summary>
            <param name="file">Additional file to analyze.</param>
            <param name="analyzers">Analyzers whose diagnostics are required. All the given analyzers must be from the analyzers passed into the constructor of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/>.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerSemanticDiagnosticsAsync(Microsoft.CodeAnalysis.SemanticModel,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Returns semantic diagnostics produced by all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/> from analyzing the given <paramref name="model"/>, optionally scoped to a <paramref name="filterSpan"/>.
            Depending on analyzers' behavior, some diagnostics that would be reported for the tree by an analysis of the complete compilation can be absent.
            </summary>
            <param name="model">Semantic model representing the syntax tree to analyze.</param>
            <param name="filterSpan">An optional span within the tree to scope analysis.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerSemanticDiagnosticsAsync(Microsoft.CodeAnalysis.SemanticModel,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Threading.CancellationToken)">
            <summary>
            Returns semantic diagnostics produced by the given <paramref name="analyzers"/> from analyzing the given <paramref name="model"/>, optionally scoped to a <paramref name="filterSpan"/>.
            Depending on analyzers' behavior, some diagnostics that would be reported for the tree by an analysis of the complete compilation can be absent.
            </summary>
            <param name="model">Semantic model representing the syntax tree to analyze.</param>
            <param name="filterSpan">An optional span within the tree to scope analysis.</param>
            <param name="analyzers">Analyzers whose diagnostics are required. All the given analyzers must be from the analyzers passed into the constructor of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/>.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalysisResultAsync(Microsoft.CodeAnalysis.SemanticModel,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Returns an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult"/> populated with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.SemanticDiagnostics"/> produced by all <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.Analyzers"/> from analyzing the given <paramref name="model"/>, optionally scoped to a <paramref name="filterSpan"/>.
            Depending on analyzers' behavior, some diagnostics that would be reported for the tree by an analysis of the complete compilation can be absent.
            </summary>
            <param name="model">Semantic model representing the syntax tree to analyze.</param>
            <param name="filterSpan">An optional span within the tree to scope analysis.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalysisResultAsync(Microsoft.CodeAnalysis.SemanticModel,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Threading.CancellationToken)">
            <summary>
            Returns an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult"/> populated with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalysisResult.SemanticDiagnostics"/> produced by the given <paramref name="analyzers"/> from analyzing the given <paramref name="model"/>, optionally scoped to a <paramref name="filterSpan"/>.
            Depending on analyzers' behavior, some diagnostics that would be reported for the tree by an analysis of the complete compilation can be absent.
            </summary>
            <param name="model">Semantic model representing the syntax tree to analyze.</param>
            <param name="filterSpan">An optional span within the tree to scope analysis.</param>
            <param name="analyzers">Analyzers whose diagnostics are required. All the given analyzers must be from the analyzers passed into the constructor of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/>.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.ComputeAnalyzerDiagnosticsCoreAsync(Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver,Microsoft.CodeAnalysis.Diagnostics.AsyncQueue{Microsoft.CodeAnalysis.Diagnostics.CompilationEvent},Microsoft.CodeAnalysis.Diagnostics.AnalysisScope,System.Threading.CancellationToken)">
            <summary>
            Core method for executing analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetEffectiveDiagnostics(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Given a set of compiler or <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> generated <paramref name="diagnostics"/>, returns the effective diagnostics after applying the below filters:
            1) <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.SpecificDiagnosticOptions"/> specified for the given <paramref name="compilation"/>.
            2) <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.GeneralDiagnosticOption"/> specified for the given <paramref name="compilation"/>.
            3) Diagnostic suppression through applied <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute"/>.
            4) Pragma directives for the given <paramref name="compilation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetEffectiveDiagnostics(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Given a set of compiler or <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> generated <paramref name="diagnostics"/>, returns the effective diagnostics after applying the below filters:
            1) <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.SpecificDiagnosticOptions"/> specified for the given <paramref name="compilation"/>.
            2) <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.GeneralDiagnosticOption"/> specified for the given <paramref name="compilation"/>.
            3) Diagnostic suppression through applied <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute"/>.
            4) Pragma directives for the given <paramref name="compilation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.IsDiagnosticAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.CompilationOptions,System.Action{System.Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Returns true if all the diagnostics that can be produced by this analyzer are suppressed through options.
            </summary>
            <param name="analyzer">Analyzer to be checked for suppression.</param>
            <param name="options">Compilation options.</param>
            <param name="onAnalyzerException">
            Optional delegate which is invoked when an analyzer throws an exception.
            Delegate can do custom tasks such as report the given analyzer exception diagnostic, report a non-fatal watson for the exception, etc.
            </param>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.ClearAnalyzerState(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})">
            <summary>
            This method should be invoked when the analyzer host is disposing off the given <paramref name="analyzers"/>.
            It clears the cached internal state (supported descriptors, registered actions, exception handlers, etc.) for analyzers.
            </summary>
            <param name="analyzers">Analyzers whose state needs to be cleared.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Threading.CancellationToken)">
            <summary>
            Gets telemetry info for the given analyzer, such as count of registered actions, the total execution time (if <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions.LogAnalyzerExecutionTime"/> is true), etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerActionCountsAsync(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Threading.CancellationToken)">
            <summary>
            Gets the count of registered actions for the analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.GetAnalyzerExecutionTime(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Gets the execution time for the given analyzer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions">
            <summary>
            Options to configure analyzer execution within <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions.Options">
            <summary>
            Options passed to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions.OnAnalyzerException">
            <summary>
            An optional delegate to be invoked when an analyzer throws an exception.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions.AnalyzerExceptionFilter">
            <summary>
            An optional delegate to be invoked when an analyzer throws an exception as an exception filter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions.ConcurrentAnalysis">
            <summary>
            Flag indicating whether analysis can be performed concurrently on multiple threads.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions.LogAnalyzerExecutionTime">
            <summary>
            Flag indicating whether analyzer execution time should be logged.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions.ReportSuppressedDiagnostics">
            <summary>
            Flag indicating whether analyzer diagnostics with <see cref="P:Microsoft.CodeAnalysis.Diagnostic.IsSuppressed"/> should be reported.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions.#ctor(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Action{System.Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostic},System.Boolean,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions"/>.
            </summary>
            <param name="options">Options that are passed to analyzers.</param>
            <param name="onAnalyzerException">Action to invoke if an analyzer throws an exception.</param>
            <param name="concurrentAnalysis">Flag indicating whether analysis can be performed concurrently on multiple threads.</param>
            <param name="logAnalyzerExecutionTime">Flag indicating whether analyzer execution time should be logged.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions.#ctor(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Action{System.Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostic},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions"/>.
            </summary>
            <param name="options">Options that are passed to analyzers.</param>
            <param name="onAnalyzerException">Action to invoke if an analyzer throws an exception.</param>
            <param name="concurrentAnalysis">Flag indicating whether analysis can be performed concurrently on multiple threads.</param>
            <param name="logAnalyzerExecutionTime">Flag indicating whether analyzer execution time should be logged.</param>
            <param name="reportSuppressedDiagnostics">Flag indicating whether analyzer diagnostics with <see cref="P:Microsoft.CodeAnalysis.Diagnostic.IsSuppressed"/> should be reported.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions.#ctor(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Action{System.Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostic},System.Boolean,System.Boolean,System.Boolean,System.Func{System.Exception,System.Boolean})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions"/>.
            </summary>
            <param name="options">Options that are passed to analyzers.</param>
            <param name="onAnalyzerException">Action to invoke if an analyzer throws an exception.</param>
            <param name="analyzerExceptionFilter">Action to invoke if an analyzer throws an exception as an exception filter.</param>
            <param name="concurrentAnalysis">Flag indicating whether analysis can be performed concurrently on multiple threads.</param>
            <param name="logAnalyzerExecutionTime">Flag indicating whether analyzer execution time should be logged.</param>
            <param name="reportSuppressedDiagnostics">Flag indicating whether analyzer diagnostics with <see cref="P:Microsoft.CodeAnalysis.Diagnostic.IsSuppressed"/> should be reported.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CompilerDiagnosticAnalyzer">
            <summary>
            DiagnosticAnalyzer for compiler's syntax/semantic/compilation diagnostics.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CompilerDiagnosticAnalyzer.CompilationAnalyzer">
            <summary>
            Per-compilation DiagnosticAnalyzer for compiler's syntax/semantic/compilation diagnostics.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext">
            <summary>
            Context for initializing an analyzer.
            Analyzer initialization can use an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext"/> to register actions to be executed at any of:
            <list type="bullet">
            <item>
            <description>compilation start,</description>
            </item>
            <item>
            <description>compilation end,</description>
            </item>
            <item>
            <description>completion of parsing a code document,</description>
            </item>
            <item>
            <description>completion of semantic analysis of a code document,</description>
            </item>
            <item>
            <description>completion of semantic analysis of a symbol,</description>
            </item>
            <item>
            <description>start of semantic analysis of a method body or an expression appearing outside a method body,</description>
            </item>
            <item>
            <description>completion of semantic analysis of a method body or an expression appearing outside a method body, or</description>
            </item>
            <item>
            <description>completion of semantic analysis of a syntax node.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterCompilationStartAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext})">
            <summary>
            Register an action to be executed at compilation start.
            A compilation start action can register other actions and/or collect state information to be used in diagnostic analysis,
            but cannot itself report any <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s.
            </summary>
            <param name="action">Action to be executed at compilation start.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterCompilationAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext})">
            <summary>
            Register an action to be executed for a complete compilation.
            A compilation action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about the <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
            <param name="action">Action to be executed at compilation end.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterSemanticModelAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext})">
            <summary>
            Register an action to be executed at completion of semantic analysis of a document,
            which will operate on the <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> of the document. A semantic model action
            reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about the model.
            </summary>
            <param name="action">Action to be executed for a document's <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterSymbolAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext},Microsoft.CodeAnalysis.SymbolKind[])">
            <summary>
            Register an action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> with an appropriate Kind.
            A symbol action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>s.
            </summary>
            <param name="action">Action to be executed for an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>.</param>
            <param name="symbolKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>'s Kind matches one of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/> values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterSymbolAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SymbolKind})">
            <summary>
            Register an action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> with an appropriate Kind.
            A symbol action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>s.
            </summary>
            <param name="action">Action to be executed for an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>.</param>
            <param name="symbolKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>'s Kind matches one of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/> values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterSymbolStartAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext},Microsoft.CodeAnalysis.SymbolKind)">
            <summary>
            Register an action to be executed at start of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> and its members with an appropriate Kind.
            </summary>
            <param name="action">Action to be executed.</param>
            <param name="symbolKind">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>'s Kind matches the given <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterCodeBlockStartAction``1(System.Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext{``0}})">
            <summary>
            Register an action to be executed at the start of semantic analysis of a method body or an expression appearing outside a method body.
            A code block start action can register other actions and/or collect state information to be used in diagnostic analysis,
            but cannot itself report any <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s.
            </summary>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which the action applies.</typeparam>
            <param name="action">Action to be executed at the start of semantic analysis of a code block.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterCodeBlockAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext})">
            <summary> 
            Register an action to be executed after semantic analysis of a method body or an expression appearing outside a method body. 
            A code block action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about code blocks. 
            </summary> 
            <param name="action">Action to be executed for a code block.</param> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterSyntaxTreeAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext})">
            <summary>
            Register an action to be executed at completion of parsing of a code document.
            A syntax tree action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> of a document.
            </summary>
            <param name="action">Action to be executed at completion of parsing of a document.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterAdditionalFileAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext})">
            <summary>
            Register an action to be executed for each non-code document.
            An additional file action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about the <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/> of a document.
            </summary>
            <param name="action">Action to be executed for each non-code document.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterSyntaxNodeAction``1(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},``0[])">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an appropriate Kind.
            A syntax node action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s, and can also collect
            state information to be used by other syntax node actions or code block end actions.
            </summary>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which the action applies.</typeparam>
            <param name="action">Action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKinds">Action will be executed only if a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>'s Kind matches one of the syntax kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterSyntaxNodeAction``1(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an appropriate Kind.
            A syntax node action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s, and can also collect
            state information to be used by other syntax node actions or code block end actions.
            </summary>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which the action applies.</typeparam>
            <param name="action">Action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKinds">Action will be executed only if a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>'s Kind matches one of the syntax kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterOperationBlockStartAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext})">
            <summary>
            Register an action to be executed at the start of semantic analysis of a method body or an expression appearing outside a method body.
            An operation block start action can register other actions and/or collect state information to be used in diagnostic analysis,
            but cannot itself report any <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s.
            </summary>
            <param name="action">Action to be executed at the start of semantic analysis of an operation block.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterOperationBlockAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext})">
            <summary> 
            Register an action to be executed after semantic analysis of a method body or an expression appearing outside a method body. 
            An operation block action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about operation blocks. 
            </summary> 
            <param name="action">Action to be executed for an operation block.</param> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterOperationAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext},Microsoft.CodeAnalysis.OperationKind[])">
            <summary>
            Register an action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/> with an appropriate Kind.
            An operation action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s, and can also collect
            state information to be used by other operation actions or code block end actions.
            </summary>
            <param name="action">Action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>.</param>
            <param name="operationKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>'s Kind matches one of the operation kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterOperationAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.OperationKind})">
            <summary>
            Register an action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/> with an appropriate Kind.
            An operation action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s, and can also collect
            state information to be used by other operation actions or code block end actions.
            </summary>
            <param name="action">Action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>.</param>
            <param name="operationKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>'s Kind matches one of the operation kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.EnableConcurrentExecution">
            <summary>
            Enable concurrent execution of analyzer actions registered by this analyzer.
            An analyzer that registers for concurrent execution can have better performance than a non-concurrent analyzer.
            However, such an analyzer must ensure that its actions can execute correctly in parallel.
            </summary>
            <remarks>
            Even when an analyzer registers for concurrent execution, certain related actions are *never* executed concurrently.
            For example, end actions registered on any analysis unit (compilation, code block, operation block, etc.) are by definition semantically dependent on analysis from non-end actions registered on the same analysis unit.
            Hence, end actions are never executed concurrently with non-end actions operating on the same analysis unit.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.ConfigureGeneratedCodeAnalysis(Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags)">
            <summary>
            Configure analysis mode of generated code for this analyzer.
            Non-configured analyzers will default to an appropriate default mode for generated code.
            It is recommended for the analyzer to invoke this API with the required <see cref="T:Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags"/> setting.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.TryGetValue``1(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider{``0},``0@)">
            <summary>
            Attempts to compute or get the cached value provided by the given <paramref name="valueProvider"/> for the given <paramref name="text"/>.
            Note that the pair {<paramref name="valueProvider"/>, <paramref name="text"/>} acts as the key.
            Reusing the same <paramref name="valueProvider"/> instance across analyzer actions and/or analyzer instances can improve the overall analyzer performance by avoiding recomputation of the values.
            </summary>
            <typeparam name="TValue">The type of the value associated with the key.</typeparam>
            <param name="text"><see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> for which the value is queried.</param>
            <param name="valueProvider">Provider that computes the underlying value.</param>
            <param name="value">Value associated with the key.</param>
            <returns>Returns true on success, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags">
            <summary>
            Flags to configure mode of generated code analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags.None">
            <summary>
            Disable analyzer action callbacks and diagnostic reporting for generated code.
            Analyzer driver will not make callbacks into the analyzer for entities (source files, symbols, etc.) that it classifies as generated code.
            Additionally, any diagnostic reported by the analyzer with location in generated code will not be reported.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags.Analyze">
            <summary>
            Enable analyzer action callbacks for generated code.
            Analyzer driver will make callbacks into the analyzer for all entities (source files, symbols, etc.) in the compilation, including generated code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags.ReportDiagnostics">
            <summary>
            Enable reporting diagnostics on generated code.
            Analyzer driver will not suppress any analyzer diagnostic based on whether or not it's location is in generated code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext">
            <summary>
            Context for a compilation start action.
            A compilation start action can use a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext"/> to register actions to be executed at any of:
            <list type="bullet">
            <item>
            <description>compilation end,</description>
            </item>
            <item>
            <description>completion of parsing a code document,</description>
            </item>
            <item>
            <description>completion of semantic analysis of a code document,</description>
            </item>
            <item>
            <description>completion of semantic analysis of a symbol,</description>
            </item>
            <item>
            <description>start of semantic analysis of a method body or an expression appearing outside a method body,</description>
            </item>
            <item>
            <description>completion of semantic analysis of a method body or an expression appearing outside a method body, or</description>
            </item>
            <item>
            <description>completion of semantic analysis of a syntax node.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.Compilation">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Compilation"/> that is the subject of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterCompilationEndAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext})">
            <summary>
            Register an action to be executed at compilation end.
            A compilation end action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about the <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
            <param name="action">Action to be executed at compilation end.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterSemanticModelAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext})">
            <summary>
            Register an action to be executed at completion of semantic analysis of a document,
            which will operate on the <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> of the document. A semantic model action
            reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about the model.
            </summary>
            <param name="action">Action to be executed for a document's <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterSymbolAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext},Microsoft.CodeAnalysis.SymbolKind[])">
            <summary>
            Register an action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> with an appropriate Kind.
            A symbol action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>s.
            </summary>
            <param name="action">Action to be executed for an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>.</param>
            <param name="symbolKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>'s Kind matches one of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/> values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterSymbolAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SymbolKind})">
            <summary>
            Register an action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> with an appropriate Kind.
            A symbol action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>s.
            </summary>
            <param name="action">Action to be executed for an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>.</param>
            <param name="symbolKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>'s Kind matches one of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/> values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterSymbolStartAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext},Microsoft.CodeAnalysis.SymbolKind)">
            <summary>
            Register an action to be executed at start of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> and its members with an appropriate Kind.
            </summary>
            <param name="action">Action to be executed.</param>
            <param name="symbolKind">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>'s Kind matches the given <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterCodeBlockStartAction``1(System.Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext{``0}})">
            <summary>
            Register an action to be executed at the start of semantic analysis of a method body or an expression appearing outside a method body.
            A code block start action can register other actions and/or collect state information to be used in diagnostic analysis,
            but cannot itself report any <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s.
            </summary>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which the action applies.</typeparam>
            <param name="action">Action to be executed at the start of semantic analysis of a code block.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterCodeBlockAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext})">
            <summary> 
            Register an action to be executed at the end of semantic analysis of a method body or an expression appearing outside a method body. 
            A code block action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about code blocks. 
            </summary> 
            <param name="action">Action to be executed for a code block.</param> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterOperationBlockStartAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext})">
            <summary>
            Register an action to be executed at the start of semantic analysis of a method body or an expression appearing outside a method body.
            An operation block start action can register other actions and/or collect state information to be used in diagnostic analysis,
            but cannot itself report any <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s.
            </summary>
            <param name="action">Action to be executed at the start of semantic analysis of an operation block.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterOperationBlockAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext})">
            <summary> 
            Register an action to be executed after semantic analysis of a method body or an expression appearing outside a method body. 
            An operation block action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about operation blocks. 
            </summary> 
            <param name="action">Action to be executed for an operation block.</param> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterSyntaxTreeAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext})">
            <summary>
            Register an action to be executed at completion of parsing of a code document.
            A syntax tree action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> of a document.
            </summary>
            <param name="action">Action to be executed at completion of parsing of a document.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterAdditionalFileAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext})">
            <summary>
            Register an action to be executed for each non-code document.
            An additional file action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about the <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/> of a document.
            </summary>
            <param name="action">Action to be executed for each non-code document.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterSyntaxNodeAction``1(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},``0[])">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an appropriate Kind.
            A syntax node action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s, and can also collect
            state information to be used by other syntax node actions or code block end actions.
            </summary>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which the action applies.</typeparam>
            <param name="action">Action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKinds">Action will be executed only if a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>'s Kind matches one of the syntax kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterSyntaxNodeAction``1(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an appropriate Kind.
            A syntax node action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s, and can also collect
            state information to be used by other syntax node actions or code block end actions.
            </summary>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which the action applies.</typeparam>
            <param name="action">Action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKinds">Action will be executed only if a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>'s Kind matches one of the syntax kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterOperationAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext},Microsoft.CodeAnalysis.OperationKind[])">
            <summary>
            Register an action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/> with an appropriate Kind.
            An operation action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s, and can also collect
            state information to be used by other operation actions or code block end actions.
            </summary>
            <param name="action">Action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>.</param>
            <param name="operationKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>'s Kind matches one of the operation kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.RegisterOperationAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.OperationKind})">
            <summary>
            Register an action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/> with an appropriate Kind.
            An operation action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s, and can also collect
            state information to be used by other operation actions or code block end actions.
            </summary>
            <param name="action">Action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>.</param>
            <param name="operationKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>'s Kind matches one of the operation kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.TryGetValue``1(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider{``0},``0@)">
            <summary>
            Attempts to compute or get the cached value provided by the given <paramref name="valueProvider"/> for the given <paramref name="text"/>.
            Note that the pair {<paramref name="valueProvider"/>, <paramref name="text"/>} acts as the key.
            Reusing the same <paramref name="valueProvider"/> instance across analyzer actions and/or analyzer instances can improve the overall analyzer performance by avoiding recomputation of the values.
            </summary>
            <typeparam name="TValue">The type of the value associated with the key.</typeparam>
            <param name="text"><see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> for which the value is queried.</param>
            <param name="valueProvider">Provider that computes the underlying value.</param>
            <param name="value">Value associated with the key.</param>
            <returns>Returns true on success, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext.TryGetValue``1(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeValueProvider{``0},``0@)">
            <summary>
            Attempts to compute or get the cached value provided by the given <paramref name="valueProvider"/> for the given <paramref name="tree"/>.
            Note that the pair {<paramref name="valueProvider"/>, <paramref name="tree"/>} acts as the key.
            Reusing the same <paramref name="valueProvider"/> instance across analyzer actions and/or analyzer instances can improve the overall analyzer performance by avoiding recomputation of the values.
            </summary>
            <typeparam name="TValue">The type of the value associated with the key.</typeparam>
            <param name="tree"><see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> instance for which the value is queried.</param>
            <param name="valueProvider">Provider that computes the underlying value.</param>
            <param name="value">Value associated with the key.</param>
            <returns>Returns true on success, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext">
            <summary>
            Context for a compilation action or compilation end action.
            A compilation action or compilation end action can use a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext"/> to report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about a <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext.Compilation">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Compilation"/> that is the subject of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> about a <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
            <param name="diagnostic"><see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> to be reported.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext.TryGetValue``1(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider{``0},``0@)">
            <summary>
            Attempts to compute or get the cached value provided by the given <paramref name="valueProvider"/> for the given <paramref name="text"/>.
            Note that the pair {<paramref name="valueProvider"/>, <paramref name="text"/>} acts as the key.
            Reusing the same <paramref name="valueProvider"/> instance across analyzer actions and/or analyzer instances can improve the overall analyzer performance by avoiding recomputation of the values.
            </summary>
            <typeparam name="TValue">The type of the value associated with the key.</typeparam>
            <param name="text"><see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> for which the value is queried.</param>
            <param name="valueProvider">Provider that computes the underlying value.</param>
            <param name="value">Value associated with the key.</param>
            <returns>Returns true on success, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext.TryGetValue``1(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeValueProvider{``0},``0@)">
            <summary>
            Attempts to compute or get the cached value provided by the given <paramref name="valueProvider"/> for the given <paramref name="tree"/>.
            Note that the pair {<paramref name="valueProvider"/>, <paramref name="tree"/>} acts as the key.
            Reusing the same <paramref name="valueProvider"/> instance across analyzer actions and/or analyzer instances can improve the overall analyzer performance by avoiding recomputation of the values.
            </summary>
            <typeparam name="TValue">The type of the value associated with the key.</typeparam>
            <param name="tree"><see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> for which the value is queried.</param>
            <param name="valueProvider">Provider that computes the underlying value.</param>
            <param name="value">Value associated with the key.</param>
            <returns>Returns true on success, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext">
            <summary>
            Context for a semantic model action.
            A semantic model action operates on the <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> of a code document, and can use a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext"/> to report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about the model.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext.SemanticModel">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> that is the subject of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext.FilterSpan">
            <summary>
            Optional filter span for which to compute diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext.IsGeneratedCode">
            <summary>
            Indicates if the underlying <see cref="P:Microsoft.CodeAnalysis.SemanticModel.SyntaxTree"/> is generated code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> about a <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/>.
            </summary>
            <param name="diagnostic"><see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> to be reported.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext">
            <summary>
            Context for a symbol action.
            A symbol action can use a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext"/> to report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.Symbol">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> that is the subject of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.Compilation">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Compilation"/> containing the <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.IsGeneratedCode">
            <summary>
            Indicates if the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.Symbol"/> is generated code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> about an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>.
            </summary>
            <param name="diagnostic"><see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> to be reported.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext">
            <summary>
            Context for a symbol start action to analyze a symbol and its members.
            A symbol start/end action can use a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext"/> to report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about code within a <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> and its members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.Symbol">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> that is the subject of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.Compilation">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Compilation"/> containing the <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.IsGeneratedCode">
            <summary>
            Indicates if the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.Symbol"/> is generated code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.RegisterSymbolEndAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext})">
            <summary>
            Register an action to be executed at end of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> and its members.
            A symbol end action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about the code within a <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.Symbol"/> and its members.
            </summary>
            <param name="action">Action to be executed at compilation end.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.RegisterCodeBlockStartAction``1(System.Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext{``0}})">
            <summary>
            Register an action to be executed at the start of semantic analysis of a method body or an expression appearing outside a method body.
            A code block start action can register other actions and/or collect state information to be used in diagnostic analysis,
            but cannot itself report any <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s.
            </summary>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which the action applies.</typeparam>
            <param name="action">Action to be executed at the start of semantic analysis of a code block.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.RegisterCodeBlockAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext})">
            <summary> 
            Register an action to be executed after semantic analysis of a method body or an expression appearing outside a method body. 
            A code block action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about code blocks. 
            </summary> 
            <param name="action">Action to be executed for a code block.</param> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.RegisterSyntaxNodeAction``1(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},``0[])">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an appropriate Kind.
            A syntax node action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s, and can also collect
            state information to be used by other syntax node actions or code block end actions.
            </summary>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which the action applies.</typeparam>
            <param name="action">Action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKinds">Action will be executed only if a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>'s Kind matches one of the syntax kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.RegisterSyntaxNodeAction``1(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an appropriate Kind.
            A syntax node action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s, and can also collect
            state information to be used by other syntax node actions or code block end actions.
            </summary>
            <typeparam name="TLanguageKindEnum">Enum type giving the syntax node kinds of the source language for which the action applies.</typeparam>
            <param name="action">Action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKinds">Action will be executed only if a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>'s Kind matches one of the syntax kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.RegisterOperationBlockStartAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext})">
            <summary>
            Register an action to be executed at the start of semantic analysis of a method body or an expression appearing outside a method body.
            An operation block start action can register other actions and/or collect state information to be used in diagnostic analysis,
            but cannot itself report any <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s.
            </summary>
            <param name="action">Action to be executed at the start of semantic analysis of an operation block.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.RegisterOperationBlockAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext})">
            <summary> 
            Register an action to be executed after semantic analysis of a method body or an expression appearing outside a method body. 
            An operation block action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about operation blocks. 
            </summary> 
            <param name="action">Action to be executed for an operation block.</param> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.RegisterOperationAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext},Microsoft.CodeAnalysis.OperationKind[])">
            <summary>
            Register an action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/> with an appropriate Kind.
            An operation action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s, and can also collect
            state information to be used by other operation actions or code block end actions.
            </summary>
            <param name="action">Action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>.</param>
            <param name="operationKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>'s Kind matches one of the operation kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.RegisterOperationAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.OperationKind})">
            <summary>
            Register an action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/> with an appropriate Kind.
            An operation action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s, and can also collect
            state information to be used by other operation actions or code block end actions.
            </summary>
            <param name="action">Action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>.</param>
            <param name="operationKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>'s Kind matches one of the operation kind values.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1">
            <summary>
            Context for a code block start action.
            A code block start action can use a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1"/> to register actions to be executed
            at any of:
            <list type="bullet">
            <item>
            <description>completion of semantic analysis of a method body or an expression appearing outside a method body, or</description>
            </item>
            <item>
            <description>completion of semantic analysis of a syntax node.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.CodeBlock">
            <summary>
            Method body or expression subject to analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.OwningSymbol">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> for which the code block provides a definition or value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.SemanticModel">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> that can provide semantic information about the <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s in the code block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.IsGeneratedCode">
            <summary>
            Indicates if the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.CodeBlock"/> is generated code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.RegisterCodeBlockEndAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext})">
            <summary>
            Register an action to be executed at the end of semantic analysis of a method body or an expression appearing outside a method body.
            A code block end action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about code blocks.
            </summary>
            <param name="action">Action to be executed at the end of semantic analysis of a code block.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.RegisterSyntaxNodeAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},`0[])">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an appropriate Kind.
            A syntax node action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s, and can also collect
            state information to be used by other syntax node actions or code block end actions.
            </summary>
            <param name="action">Action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKinds">Action will be executed only if a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>'s Kind matches one of the syntax kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.RegisterSyntaxNodeAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},System.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Register an action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> with an appropriate Kind.
            A syntax node action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s, and can also collect
            state information to be used by other syntax node actions or code block end actions.
            </summary>
            <param name="action">Action to be executed at completion of semantic analysis of a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.</param>
            <param name="syntaxKinds">Action will be executed only if a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>'s Kind matches one of the syntax kind values.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext">
            <summary>
            Context for a code block action or code block end action.
            A code block action or code block end action can use a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext"/> to report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about a code block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.CodeBlock">
            <summary>
            Code block that is the subject of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.OwningSymbol">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> for which the code block provides a definition or value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.SemanticModel">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> that can provide semantic information about the <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s in the code block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.IsGeneratedCode">
            <summary>
            Indicates if the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.CodeBlock"/> is generated code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> about a code block.
            </summary>
            <param name="diagnostic"><see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> to be reported.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext">
            <summary>
            Context for an operation block start action.
            An operation block start action can use an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext"/> to register actions to be executed
            at any of:
            <list type="bullet">
            <item>
            <description>completion of semantic analysis of a method body or an expression appearing outside a method body, or</description>
            </item>
            <item>
            <description>completion of semantic analysis of an operation.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.OperationBlocks">
            <summary>
            One or more operation blocks that are the subject of the analysis.
            This includes all blocks associated with the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.OwningSymbol"/>,
            such as method body, field/property/constructor/parameter initializer(s), attributes, etc.
            </summary>
            <remarks>Note that the operation blocks are not in any specific order.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.OwningSymbol">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> for which the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.OperationBlocks"/> provides a definition or value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.Compilation">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Compilation"/> containing the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.OperationBlocks"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.IsGeneratedCode">
            <summary>
            Indicates if the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.OperationBlocks"/> is generated code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.RegisterOperationBlockEndAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext})">
            <summary>
            Register an action to be executed at the end of semantic analysis of a method body or an expression appearing outside a method body.
            A code block end action reports <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about code blocks.
            </summary>
            <param name="action">Action to be executed at the end of semantic analysis of a code block.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.RegisterOperationAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext},Microsoft.CodeAnalysis.OperationKind[])">
            <summary>
            Register an action to be executed at completion of semantic analysis of an operation with an appropriate Kind.
            An operation action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s, and can also collect
            state information to be used by other operation actions or operation block end actions.
            </summary>
            <param name="action">Action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>.</param>
            <param name="operationKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>'s Kind matches one of the operation kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.RegisterOperationAction(System.Action{Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.OperationKind})">
            <summary>
            Register an action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/> with an appropriate Kind.
            An operation action can report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s, and can also collect
            state information to be used by other operation actions or operation block end actions.
            </summary>
            <param name="action">Action to be executed at completion of semantic analysis of an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>.</param>
            <param name="operationKinds">Action will be executed only if an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>'s Kind matches one of the operation kind values.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.GetControlFlowGraph(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> for a given <paramref name="operationBlock"/> from this analysis context's <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.OperationBlocks"/>.
            </summary>
            <param name="operationBlock">Operation block.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext">
            <summary>
            Context for an operation block action or operation block end action.
            An operation block action or operation block end action can use an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext"/> to report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about an operation block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.OperationBlocks">
            <summary>
            One or more operation blocks that are the subject of the analysis.
            This includes all blocks associated with the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.OwningSymbol"/>,
            such as method body, field/property/constructor/parameter initializer(s), attributes, etc.
            </summary>
            <remarks>Note that the operation blocks are not in any specific order.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.OwningSymbol">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> for which the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.OperationBlocks"/> provides a definition or value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.Compilation">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Compilation"/> containing the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.OperationBlocks"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.IsGeneratedCode">
            <summary>
            Indicates if the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.OperationBlocks"/> is generated code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> about a code block.
            </summary>
            <param name="diagnostic"><see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> to be reported.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.GetControlFlowGraph(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> for a given <paramref name="operationBlock"/> from this analysis context's <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.OperationBlocks"/>.
            </summary>
            <param name="operationBlock">Operation block.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext">
            <summary>
            Context for a syntax tree action.
            A syntax tree action can use a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext"/> to report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> for a code document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext.Tree">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> that is the subject of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext.IsGeneratedCode">
            <summary>
            Indicates if the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext.Tree"/> is generated code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>.
            </summary>
            <param name="diagnostic"><see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> to be reported.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext">
            <summary>
            Context for an additional file action.
            An additional file action can use an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext"/> to report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s about a non-source <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/> document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext.AdditionalFile">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/> that is the subject of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext.Compilation">
            <summary>
            Compilation being analyzed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Report a diagnostic for the given <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext.AdditionalFile"/>.
            A diagnostic in a non-source document should be created with a non-source <see cref="T:Microsoft.CodeAnalysis.Location"/>,
            which can be created using <see cref="M:Microsoft.CodeAnalysis.Location.Create(System.String,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.LinePositionSpan)"/> API.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext">
            <summary>
            Context for a syntax node action.
            A syntax node action can use a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext"/> to report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s for a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.Node">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> that is the subject of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.ContainingSymbol">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> for the declaration containing the syntax node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.SemanticModel">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> that can provide semantic information about the <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.Compilation">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Compilation"/> containing the <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.IsGeneratedCode">
            <summary>
            Indicates if the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.Node"/> is generated code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.
            </summary>
            <param name="diagnostic"><see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> to be reported.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext">
            <summary>
            Context for an operation action.
            An operation action can use an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext"/> to report <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s for an <see cref="T:Microsoft.CodeAnalysis.IOperation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.Operation">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.IOperation"/> that is the subject of the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.ContainingSymbol">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> for the declaration containing the operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.Compilation">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Compilation"/> containing the <see cref="T:Microsoft.CodeAnalysis.IOperation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.IsGeneratedCode">
            <summary>
            Indicates if the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.Operation"/> is generated code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.
            </summary>
            <param name="diagnostic"><see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> to be reported.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.GetControlFlowGraph">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> for the operation block containing the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.Operation"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SuppressionAnalysisContext">
            <summary>
            Context for suppressing analyzer and/or compiler non-error diagnostics reported for the compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SuppressionAnalysisContext.ReportedDiagnostics">
            <summary>
            Analyzer and/or compiler non-error diagnostics reported for the compilation.
            Each <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor"/> only receives diagnostics whose IDs were declared suppressible in its <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor.SupportedSuppressions"/>.
            This may be a subset of the full set of reported diagnostics, as an optimization for
            supporting incremental and partial analysis scenarios.
            A diagnostic is considered suppressible by a DiagnosticSuppressor if *all* of the following conditions are met:
                1. Diagnostic is not already suppressed in source via pragma/suppress message attribute.
                2. Diagnostic's <see cref="P:Microsoft.CodeAnalysis.Diagnostic.DefaultSeverity"/> is not <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Error"/>.
                3. Diagnostic is not tagged with <see cref="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.NotConfigurable"/> custom tag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SuppressionAnalysisContext.Compilation">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Compilation"/> for the context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SuppressionAnalysisContext.Options">
            <summary>
            Options specified for the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SuppressionAnalysisContext.CancellationToken">
            <summary>
            Token to check for requested cancellation of the analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SuppressionAnalysisContext.ReportSuppression(Microsoft.CodeAnalysis.Diagnostics.Suppression)">
            <summary>
            Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.Suppression"/> for a reported diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SuppressionAnalysisContext.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> for the given <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>, which is shared across all analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer">
            <summary>
            The base type for diagnostic analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics">
            <summary>
            Returns a set of descriptors for the diagnostics that this analyzer is capable of producing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <summary>
            Called once at session start to register actions in the analysis context.
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute">
            <summary>
            Place this attribute onto a type to cause it to be considered a diagnostic analyzer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute.Languages">
            <summary>
            The source languages to which this analyzer applies.  See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute.#ctor(System.String,System.String[])">
            <summary>
            Attribute constructor used to specify automatic application of a diagnostic analyzer.
            </summary>
            <param name="firstLanguage">One language to which the analyzer applies.</param>
            <param name="additionalLanguages">Additional languages to which the analyzer applies. See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions.WithAnalyzers(Microsoft.CodeAnalysis.Compilation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Threading.CancellationToken)">
            <summary>
            Returns a new compilation with attached diagnostic analyzers.
            </summary>
            <param name="compilation">Compilation to which analyzers are to be added.</param>
            <param name="analyzers">The set of analyzers to include in future analyses.</param>
            <param name="options">Options that are passed to analyzers.</param>
            <param name="cancellationToken">A cancellation token that can be used to abort analysis.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions.WithAnalyzers(Microsoft.CodeAnalysis.Compilation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions)">
            <summary>
            Returns a new compilation with attached diagnostic analyzers.
            </summary>
            <param name="compilation">Compilation to which analyzers are to be added.</param>
            <param name="analyzers">The set of analyzers to include in future analyses.</param>
            <param name="analysisOptions">Options to configure analyzer execution within <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticQueue">
            <summary>
            Queue to store analyzer diagnostics on the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticQueue.SimpleDiagnosticQueue">
            <summary>
            Simple diagnostics queue: maintains all diagnostics reported by all analyzers in a single queue.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticQueue.CategorizedDiagnosticQueue">
            <summary>
            Categorized diagnostics queue: maintains separate set of simple diagnostic queues for local semantic, local syntax and non-local diagnostics for every analyzer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerAnalysisContext">
            <summary>
            Scope for setting up analyzers for an entire session, automatically associating actions with analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerCompilationStartAnalysisContext">
            <summary>
            Scope for setting up analyzers for a compilation, automatically associating actions with analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerSymbolStartAnalysisContext">
            <summary>
            Scope for setting up analyzers for code within a symbol and its members.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerCodeBlockStartAnalysisContext`1">
            <summary>
            Scope for setting up analyzers for a code block, automatically associating actions with analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOperationBlockStartAnalysisContext">
            <summary>
            Scope for setting up analyzers for an operation block, automatically associating actions with analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.HostSessionStartAnalysisScope">
            <summary>
            Scope for setting up analyzers for an entire session, capable of retrieving the actions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.HostCompilationStartAnalysisScope">
            <summary>
            Scope for setting up analyzers for a compilation, capable of retrieving the actions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.HostSymbolStartAnalysisScope">
            <summary>
            Scope for setting up analyzers for analyzing a symbol and its members.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.HostCodeBlockStartAnalysisScope`1">
            <summary>
            Scope for setting up analyzers for a code block, capable of retrieving the actions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerActions">
            <summary>
            Actions registered by a particular analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerActions.Append(Microsoft.CodeAnalysis.Diagnostics.AnalyzerActions@,System.Boolean)">
            <summary>
            Append analyzer actions from <paramref name="otherActions"/> to actions from this instance.
            </summary>
            <param name="otherActions">Analyzer actions to append</param>.
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor">
            <summary>
            The base type for diagnostic suppressors that can programmatically suppress analyzer and/or compiler non-error diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor.SupportedSuppressions">
            <summary>
            Returns a set of descriptors for the suppressions that this suppressor is capable of producing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor.ReportSuppressions(Microsoft.CodeAnalysis.Diagnostics.SuppressionAnalysisContext)">
            <summary>
            Suppress analyzer and/or compiler non-error diagnostics reported for the compilation.
            This may be a subset of the full set of reported diagnostics, as an optimization for
            supporting incremental and partial analysis scenarios.
            A diagnostic is considered suppressible by a DiagnosticSuppressor if *all* of the following conditions are met:
                1. Diagnostic is not already suppressed in source via pragma/suppress message attribute.
                2. Diagnostic's <see cref="P:Microsoft.CodeAnalysis.Diagnostic.DefaultSeverity"/> is not <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Error"/>.
                3. Diagnostic is not tagged with <see cref="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.NotConfigurable"/> custom tag.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SourceOrAdditionalFile">
            <summary>
            Represents a source file or an additional file.
            For source files, <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SourceOrAdditionalFile.SourceTree"/> is non-null and <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SourceOrAdditionalFile.AdditionalFile"/> is null.
            For additional files, <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SourceOrAdditionalFile.AdditionalFile"/> is non-null and <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SourceOrAdditionalFile.SourceTree"/> is null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider`1">
            <summary>
            Provides custom values associated with <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> instances using the given computeValue delegate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider`1.#ctor(System.Func{Microsoft.CodeAnalysis.Text.SourceText,`0},System.Collections.Generic.IEqualityComparer{Microsoft.CodeAnalysis.Text.SourceText})">
            <summary>
            Provides custom values associated with <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> instances using the given <paramref name="computeValue"/>.
            </summary>
            <param name="computeValue">Delegate to compute the value associated with a given <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> instance.</param>
            <param name="sourceTextComparer">Optional equality comparer to determine equivalent <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> instances that have the same value.
            If no comparer is provided, then <see cref="T:Microsoft.CodeAnalysis.Text.SourceTextComparer"/> is used by default.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.Suppression">
            <summary>
            Programmatic suppression of a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> by a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Suppression.Create(Microsoft.CodeAnalysis.SuppressionDescriptor,Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Creates a suppression of a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> with the given <see cref="T:Microsoft.CodeAnalysis.SuppressionDescriptor"/>.
            </summary>
            <param name="descriptor">
            Descriptor for the suppression, which must be from <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor.SupportedSuppressions"/>
            for the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor"/> creating this suppression.
            </param>
            <param name="suppressedDiagnostic">
            <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> to be suppressed, which must be from <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SuppressionAnalysisContext.ReportedDiagnostics"/>
            for the suppression context in which this suppression is being created.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Suppression.Descriptor">
            <summary>
            Descriptor for this suppression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.Suppression.SuppressedDiagnostic">
            <summary>
            Diagnostic suppressed by this suppression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SuppressMessageAttributeState.TargetSymbolResolver.Resolve(System.Boolean@)">
            <summary>
            Attempts to resolve the "Target" argument of the global SuppressMessageAttribute to symbols in compilation.
            </summary>
            <param name="resolvedWithDocCommentIdFormat">Indicates if resolved "Target" argument is in Roslyn's <see cref="T:Microsoft.CodeAnalysis.DocumentationCommentId"/> format.</param>
            <returns>Resolved symbols for the the "Target" argument of the global SuppressMessageAttribute.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent">
            <summary>
            An event for each declaration in the program (namespace, type, method, field, parameter, etc).
            Note that some symbols may have multiple declarations (namespaces, partial types) and may therefore
            have multiple events.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeValueProvider`1">
            <summary>
            Provides custom values associated with <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> instances using the given computeValue delegate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeValueProvider`1.#ctor(System.Func{Microsoft.CodeAnalysis.SyntaxTree,`0},System.Collections.Generic.IEqualityComparer{Microsoft.CodeAnalysis.SyntaxTree})">
            <summary>
            Provides values associated with <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> instances using the given <paramref name="computeValue"/>.
            </summary>
            <param name="computeValue">Delegate to compute the value associated with a given <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> instance.</param>
            <param name="syntaxTreeComparer">Optional equality comparer to determine equivalent <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> instances that have the same value.
            If no comparer is provided, then <see cref="T:Microsoft.CodeAnalysis.SyntaxTreeComparer"/> is used by default.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference">
            <summary>
            Represents an analyzer reference that can't be resolved.
            </summary>
            <remarks>
            For error reporting only, can't be used to reference an analyzer assembly.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ProgrammaticSuppressionInfo">
            <summary>
            Contains information about the source of a programmatic diagnostic suppression produced by an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SeverityFilter">
            <summary>
            Represents a set of filtered diagnostic severities.
            Currently, we only support filtering out Hidden and Info severities during build.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo">
            <summary>
            Contains information about the source of diagnostic suppression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo.Id">
            <summary>
            <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> of the suppressed diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo.Attribute">
            <summary>
            If the diagnostic was suppressed by an attribute, then returns that attribute.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader">
            <summary>
            The base implementation for <see cref="T:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader"/>. This type provides caching and tracking of inputs given
            to <see cref="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.AddDependencyLocation(System.String)"/>.
            </summary>
            <remarks>
            This type generally assumes that files on disk aren't changing, since it ensure that two calls to <see cref="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.LoadFromPath(System.String)"/>
            will always return the same thing, per that interface's contract.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.LoadFromPathUncheckedImpl(System.String)">
            <summary>
            Implemented by derived types to actually perform the load for an assembly that doesn't have a cached result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.LoadFromPathUnchecked(System.String)">
            <summary>
            Returns the cached assembly for fullPath if we've done a load for this path before, or calls <see cref="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.LoadFromPathUncheckedImpl(System.String)"/> if
            it needs to be loaded. This method skips the check in release builds that the path is an absolute path, hence the "Unchecked" in the name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.GetPathToLoad(System.String)">
            <summary>
            When overridden in a derived class, allows substituting an assembly path after we've
            identified the context to load an assembly in, but before the assembly is actually
            loaded from disk. This is used to substitute out the original path with the shadow-copied version.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DefaultAnalyzerAssemblyLoader.CompilerAssemblySimpleNames">
             <summary>
             <p>Typically a user analyzer has a reference to the compiler and some of the compiler's
             dependencies such as System.Collections.Immutable. For the analyzer to correctly
             interoperate with the compiler that created it, we need to ensure that we always use the
             compiler's version of a given assembly over the analyzer's version.</p>
            
             <p>If we neglect to do this, then in the case where the user ships the compiler or its
             dependencies in the analyzer's bin directory, we could end up loading a separate
             instance of those assemblies in the process of loading the analyzer, which will surface
             as a failure to load the analyzer.</p>
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader">
            <summary>
            Handles loading analyzer assemblies and their dependencies.
            
            Before an analyzer assembly is loaded with <see cref="M:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader.LoadFromPath(System.String)"/>,
            its location and the location of all of its dependencies must first be specified
            by calls to <see cref="M:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader.AddDependencyLocation(System.String)"/>.
            </summary>
            <remarks>
            To the extent possible, implementations should remain consistent in the face
            of exceptions and allow the caller to handle them. This allows the caller to
            decide how to surface issues to the user and whether or not they are fatal. For
            example, if asked to load an a non-existent or inaccessible file a command line
            tool may wish to exit immediately, while an IDE may wish to keep going and give
            the user a chance to correct the issue.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader.LoadFromPath(System.String)">
            <summary>
            Given the full path to an assembly on disk, loads and returns the
            corresponding <see cref="T:System.Reflection.Assembly"/> object.
            </summary>
            <remarks>
            Multiple calls with the same path should return the same 
            <see cref="T:System.Reflection.Assembly"/> instance.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="fullPath" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fullPath" /> is not a full path.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader.AddDependencyLocation(System.String)">
            <summary>
            Adds a file to consider when loading an analyzer or its dependencies.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="fullPath" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fullPath" /> is not a full path.</exception>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ShadowCopyAnalyzerAssemblyLoader._baseDirectory">
            <summary>
            The base directory for shadow copies. Each instance of
            <see cref="T:Microsoft.CodeAnalysis.ShadowCopyAnalyzerAssemblyLoader"/> gets its own
            subdirectory under this directory. This is also the starting point
            for scavenge operations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ShadowCopyAnalyzerAssemblyLoader._shadowCopyDirectoryAndMutex">
            <summary>
            The directory where this instance of <see cref="T:Microsoft.CodeAnalysis.ShadowCopyAnalyzerAssemblyLoader"/>
            will shadow-copy assemblies, and the mutex created to mark that the owner of it is still active.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ShadowCopyAnalyzerAssemblyLoader._assemblyDirectoryId">
            <summary>
            Used to generate unique names for per-assembly directories. Should be updated with <see cref="M:System.Threading.Interlocked.Increment(System.Int32@)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonMessageProvider">
            <summary>
            Abstracts the ability to classify and load messages for error codes. Allows the error
            infrastructure to be reused between C# and VB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonMessageProvider.s_errorIdCache">
            <summary>
            Caches the return values for <see cref="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetIdForErrorCode(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetSeverity(System.Int32)">
            <summary>
            Given an error code, get the severity (warning or error) of the code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.LoadMessage(System.Int32,System.Globalization.CultureInfo)">
            <summary>
            Load the message for the given error code. If the message contains
            "fill-in" placeholders, those should be expressed in standard string.Format notation
            and be in the string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetTitle(System.Int32)">
            <summary>
            Get an optional localizable title for the given diagnostic code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetDescription(System.Int32)">
            <summary>
            Get an optional localizable description for the given diagnostic code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetMessageFormat(System.Int32)">
            <summary>
            Get a localizable message format string for the given diagnostic code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetHelpLink(System.Int32)">
            <summary>
            Get an optional help link for the given diagnostic code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetCategory(System.Int32)">
            <summary>
            Get the diagnostic category for the given diagnostic code.
            Default category is <see cref="F:Microsoft.CodeAnalysis.Diagnostic.CompilerDiagnosticCategory"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonMessageProvider.CodePrefix">
            <summary>
            Get the text prefix (e.g., "CS" for C#) used on error messages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetWarningLevel(System.Int32)">
            <summary>
            Get the warning level for warnings (e.g., 1 or greater for C#). VB does not have warning
            levels and always uses 1. Errors should return 0.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonMessageProvider.ErrorCodeType">
            <summary>
            Type that defines error codes. For testing purposes only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.CreateDiagnostic(System.Int32,Microsoft.CodeAnalysis.Location)">
            <summary>
            Create a simple language specific diagnostic for given error code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.CreateDiagnostic(Microsoft.CodeAnalysis.DiagnosticInfo)">
            <summary>
            Create a simple language specific diagnostic with no location for given info.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.CreateDiagnostic(System.Int32,Microsoft.CodeAnalysis.Location,System.Object[])">
            <summary>
            Create a simple language specific diagnostic for given error code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetMessagePrefix(System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Given a message identifier (e.g., CS0219), severity, warning as error and a culture, 
            get the entire prefix (e.g., "error CS0219: Warning as Error:" for C# or "error BC42024:" for VB) used on error messages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetErrorDisplayString(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Convert given symbol to string representation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetIdForErrorCode(System.Int32)">
            <summary>
            Given an error code (like 1234) return the identifier (CS1234 or BC1234).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.GetDiagnosticReport(Microsoft.CodeAnalysis.DiagnosticInfo,Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Produces the filtering action for the diagnostic based on the options passed in.
            </summary>
            <returns>
            A new <see cref="T:Microsoft.CodeAnalysis.DiagnosticInfo"/> with new effective severity based on the options or null if the
            diagnostic has been suppressed.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.FilterDiagnosticInfo(Microsoft.CodeAnalysis.DiagnosticInfo,Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Filter a <see cref="T:Microsoft.CodeAnalysis.DiagnosticInfo"/> based on the compilation options so that /nowarn and /warnaserror etc. take effect.options
            </summary>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.DiagnosticInfo"/> with effective severity based on option or null if suppressed.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonMessageProvider.ReportStreamWriteException(System.Exception,System.String,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Takes an exception produced while writing to a file stream and produces a diagnostic.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostic">
            <summary>
            Represents a diagnostic, such as a compiler error or a warning, along with the location where it occurred.
            </summary>
            <summary>
            A diagnostic (such as a compiler error or a warning), along with the location where it occurred.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostic.DefaultWarningLevel">
            <summary>
            The default warning level, which is also used for non-error diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostic.InfoAndHiddenWarningLevel">
            <summary>
            The warning level used for hidden and info diagnostics. Because these diagnostics interact with other editor features, we want them to always be produced unless /warn:0 is set.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostic.MaxWarningLevel">
            <summary>
            The maximum warning level represented by a large value of 9999.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,System.Object[])">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="messageArgs">Arguments to the message of the diagnostic</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Object[])">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="effectiveSeverity">Effective severity of the diagnostic.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.Create(System.String,System.String,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.DiagnosticSeverity,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.Int32,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.String,Microsoft.CodeAnalysis.Location,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Generic.IEnumerable{System.String},System.Collections.Immutable.ImmutableDictionary{System.String,System.String})">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance which is localizable.
            </summary>
            <param name="id">An identifier for the diagnostic. For diagnostics generated by the compiler, this will be a numeric code with a prefix such as "CS1001".</param>
            <param name="category">The category of the diagnostic. For diagnostics generated by the compiler, the category will be "Compiler".</param>
            <param name="message">The diagnostic message text.</param>
            <param name="severity">The diagnostic's effective severity.</param>
            <param name="defaultSeverity">The diagnostic's default severity.</param>
            <param name="isEnabledByDefault">True if the diagnostic is enabled by default</param>
            <param name="warningLevel">The warning level, greater than 0 if severity is <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning"/>; otherwise 0.</param>
            <param name="title">An optional short localizable title describing the diagnostic.</param>
            <param name="description">An optional longer localizable description for the diagnostic.</param>
            <param name="helpLink">An optional hyperlink that provides more detailed information regarding the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="customTags">
            An optional set of custom tags for the diagnostic. See <see cref="T:Microsoft.CodeAnalysis.WellKnownDiagnosticTags"/> for some well known tags.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.CustomTags"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.Create(System.String,System.String,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.DiagnosticSeverity,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.Int32,System.Boolean,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.String,Microsoft.CodeAnalysis.Location,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Generic.IEnumerable{System.String},System.Collections.Immutable.ImmutableDictionary{System.String,System.String})">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance which is localizable.
            </summary>
            <param name="id">An identifier for the diagnostic. For diagnostics generated by the compiler, this will be a numeric code with a prefix such as "CS1001".</param>
            <param name="category">The category of the diagnostic. For diagnostics generated by the compiler, the category will be "Compiler".</param>
            <param name="message">The diagnostic message text.</param>
            <param name="severity">The diagnostic's effective severity.</param>
            <param name="defaultSeverity">The diagnostic's default severity.</param>
            <param name="isEnabledByDefault">True if the diagnostic is enabled by default</param>
            <param name="warningLevel">The warning level, greater than 0 if severity is <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning"/>; otherwise 0.</param>
            <param name="isSuppressed">Flag indicating whether the diagnostic is suppressed by a source suppression.</param>
            <param name="title">An optional short localizable title describing the diagnostic.</param>
            <param name="description">An optional longer localizable description for the diagnostic.</param>
            <param name="helpLink">An optional hyperlink that provides more detailed information regarding the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="customTags">
            An optional set of custom tags for the diagnostic. See <see cref="T:Microsoft.CodeAnalysis.WellKnownDiagnosticTags"/> for some well known tags.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.CustomTags"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.Descriptor">
            <summary>
            Gets the diagnostic descriptor, which provides a description about a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.Id">
            <summary>
            Gets the diagnostic identifier. For diagnostics generated by the compiler, this will be a numeric code with a prefix such as "CS1001".
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.Category">
            <summary>
            Gets the category of diagnostic. For diagnostics generated by the compiler, the category will be "Compiler".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.GetMessage(System.IFormatProvider)">
            <summary>
            Get the culture specific text of the message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.DefaultSeverity">
            <summary>
            Gets the default <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> of the diagnostic's <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/>.
            </summary>
            <remarks>
            To get the effective severity of the diagnostic, use <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Severity"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.Severity">
            <summary>
            Gets the effective <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> of the diagnostic.
            </summary>
            <remarks>
            To get the default severity of diagnostic's <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/>, use <see cref="P:Microsoft.CodeAnalysis.Diagnostic.DefaultSeverity"/>.
            To determine if this is a warning treated as an error, use <see cref="P:Microsoft.CodeAnalysis.Diagnostic.IsWarningAsError"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.WarningLevel">
            <summary>
            Gets the warning level. This is 0 for diagnostics with severity <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Error"/>,
            otherwise an integer greater than zero.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.IsSuppressed">
            <summary>
            Returns true if the diagnostic has a source suppression, i.e. an attribute or a pragma suppression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.GetSuppressionInfo(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo"/> for suppressed diagnostics, i.e. <see cref="P:Microsoft.CodeAnalysis.Diagnostic.IsSuppressed"/> = true.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.IsEnabledByDefault">
            <summary>
            Returns true if this diagnostic is enabled by default by the author of the diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.IsWarningAsError">
            <summary>
            Returns true if this is a warning treated as an error; otherwise false.
            </summary>
            <remarks>
            True implies <see cref="P:Microsoft.CodeAnalysis.Diagnostic.DefaultSeverity"/> = <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning"/>
            and <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Severity"/> = <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Error"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.Location">
            <summary>
            Gets the primary location of the diagnostic, or <see cref="P:Microsoft.CodeAnalysis.Location.None"/> if no primary location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations">
            <summary>
            Gets an array of additional locations related to the diagnostic.
            Typically these are the locations of other items referenced in the message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.CustomTags">
            <summary>
            Gets custom tags for the diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.Properties">
            <summary>
            Gets property bag for the diagnostic. it will return <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/> 
            if there is no entry. This can be used to put diagnostic specific information you want 
            to pass around. for example, to corresponding fixer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.WithLocation(Microsoft.CodeAnalysis.Location)">
            <summary>
            Create a new instance of this diagnostic with the Location property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.WithSeverity(Microsoft.CodeAnalysis.DiagnosticSeverity)">
            <summary>
            Create a new instance of this diagnostic with the Severity property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.WithIsSuppressed(System.Boolean)">
            <summary>
            Create a new instance of this diagnostic with the suppression info changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.WithProgrammaticSuppression(Microsoft.CodeAnalysis.Diagnostics.ProgrammaticSuppressionInfo)">
            <summary>
            Create a new instance of this diagnostic with the given programmatic suppression info.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.HasIntersectingLocation(Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Returns true if the diagnostic location (or any additional location) is within the given tree and intersects with the filterSpanWithinTree, if non-null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.GetDefaultWarningLevel(Microsoft.CodeAnalysis.DiagnosticSeverity)">
            <summary>
            Gets the default warning level for a diagnostic severity. Warning levels are used with the <c>/warn:N</c>
            command line option to suppress diagnostics over a severity of interest. When N is 0, only error severity
            messages are produced by the compiler. Values greater than 0 indicated that warnings up to and including
            level N should also be included.
            </summary>
            <remarks>
            <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Info"/> and <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Hidden"/> are treated as warning
            level 1. In other words, these diagnostics which typically interact with editor features are enabled unless
            the special <c>/warn:0</c> option is set.
            </remarks>
            <param name="severity">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> value.</param>
            <returns>The default compiler warning level for <paramref name="severity"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.IsNotConfigurable">
            <summary>
            Returns true if a diagnostic is not configurable, i.e. cannot be suppressed or filtered or have its severity changed.
            For example, compiler errors are always non-configurable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostic.IsUnsuppressableError">
            <summary>
            Returns true if this is an error diagnostic which cannot be suppressed and is guaranteed to break the build.
            Only diagnostics which have default severity error and are tagged as NotConfigurable fall in this bucket.
            This includes all compiler error diagnostics and specific analyzer error diagnostics that are marked as not configurable by the analyzer author.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostic.IsUnsuppressedError">
            <summary>
            Returns true if this is a unsuppressed diagnostic with an effective error severity.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RequiredLanguageVersion">
            <summary>
            This type is attached to diagnostics for required language version and should only be used
            on such diagnostics, as they are recognized by <see cref="M:Microsoft.CodeAnalysis.Compilation.GetRequiredLanguageVersion(Microsoft.CodeAnalysis.Diagnostic)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticBag">
            <summary>
            Represents a mutable bag of diagnostics. You can add diagnostics to the bag,
            and also get all the diagnostics out of the bag (the bag implements
            IEnumerable&lt;Diagnostics&gt;. Once added, diagnostics cannot be removed, and no ordering
            is guaranteed.
            
            It is ok to Add diagnostics to the same bag concurrently on multiple threads.
            It is NOT ok to Add concurrently with Clear or Free operations.
            </summary>
            <remarks>The bag is optimized to be efficient when containing zero errors.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticBag.IsEmptyWithoutResolution">
            <summary>
            Return true if the bag is completely empty - not even containing void diagnostics.
            </summary>
            <remarks>
            This exists for short-circuiting purposes. Use <see cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})"/>
            to get a resolved Tuple(Of NamedTypeSymbol, ImmutableArray(Of Diagnostic)) (i.e. empty after eliminating void diagnostics).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.HasAnyErrors">
            <summary>
            Returns true if the bag has any diagnostics with DefaultSeverity=Error. Does not consider warnings or informationals
            or warnings promoted to error via /warnaserror.
            </summary>
            <remarks>
            Resolves any lazy diagnostics in the bag.
            
            Generally, this should only be called by the creator (modulo pooling) of the bag (i.e. don't use bags to communicate -
            if you need more info, pass more info).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.HasAnyResolvedErrors">
            <summary>
            Returns true if the bag has any non-lazy diagnostics with DefaultSeverity=Error. Does not consider warnings or informationals
            or warnings promoted to error via /warnaserror.
            </summary>
            <remarks>
            Does not resolve any lazy diagnostics in the bag.
            
            Generally, this should only be called by the creator (modulo pooling) of the bag (i.e. don't use bags to communicate -
            if you need more info, pass more info).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.Add(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Add a diagnostic to the bag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AddRange``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Add multiple diagnostics to the bag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AddRange(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Add multiple diagnostics to the bag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AddRange(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Add another DiagnosticBag to the bag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AddRangeAndFree(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Add another DiagnosticBag to the bag and free the argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.ToReadOnlyAndFree``1">
            <summary>
            Seal the bag so no further errors can be added, while clearing it and returning the old set of errors.
            Return the bag to the pool.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AsEnumerable">
            <remarks>
            Generally, this should only be called by the creator (modulo pooling) of the bag (i.e. don't use bags to communicate -
            if you need more info, pass more info).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.AsEnumerableFiltered">
            <remarks>
            Using an iterator to avoid copying the list.  If perf is a problem,
            create an explicit enumerator type.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticBag.Bag">
            <summary>
            Get the underlying concurrent storage, creating it on demand if needed.
            NOTE: Concurrent Adding to the bag is supported, but concurrent Clearing is not.
                  If one thread adds to the bug while another clears it, the scenario is 
                  broken and we cannot do anything about it here.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticBag.Clear">
            NOTE: Concurrent Adding to the bag is supported, but concurrent Clearing is not.
                  If one thread adds to the bug while another clears it, the scenario is 
                  broken and we cannot do anything about it here.
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticDescriptor">
            <summary>
            Provides a description about a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.Id">
            <summary>
            An unique identifier for the diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.Title">
            <summary>
            A short localizable title describing the diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.Description">
            <summary>
            An optional longer localizable description for the diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.HelpLinkUri">
            <summary>
            An optional hyperlink that provides more detailed information regarding the diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.MessageFormat">
            <summary>
            A localizable format message string, which can be passed as the first argument to <see cref="M:System.String.Format(System.String,System.Object[])"/> when creating the diagnostic message with this descriptor.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.Category">
            <summary>
            The category of the diagnostic (like Design, Naming etc.)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.DefaultSeverity">
            <summary>
            The default severity of the diagnostic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.IsEnabledByDefault">
            <summary>
            Returns true if the diagnostic is enabled by default.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.CustomTags">
            <summary>
            Custom tags for the diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String,System.String,System.String[])">
            <summary>
            Create a DiagnosticDescriptor, which provides description about a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>.
            NOTE: For localizable <paramref name="title"/>, <paramref name="description"/> and/or <paramref name="messageFormat"/>,
            use constructor overload <see cref="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,Microsoft.CodeAnalysis.LocalizableString,System.String,System.String[])"/>.
            </summary>
            <param name="id">A unique identifier for the diagnostic. For example, code analysis diagnostic ID "CA1001".</param>
            <param name="title">A short title describing the diagnostic. For example, for CA1001: "Types that own disposable fields should be disposable".</param>
            <param name="messageFormat">A format message string, which can be passed as the first argument to <see cref="M:System.String.Format(System.String,System.Object[])"/> when creating the diagnostic message with this descriptor.
            For example, for CA1001: "Implement IDisposable on '{0}' because it creates members of the following IDisposable types: '{1}'."</param>
            <param name="category">The category of the diagnostic (like Design, Naming etc.). For example, for CA1001: "Microsoft.Design".</param>
            <param name="defaultSeverity">Default severity of the diagnostic.</param>
            <param name="isEnabledByDefault">True if the diagnostic is enabled by default.</param>
            <param name="description">An optional longer description of the diagnostic.</param>
            <param name="helpLinkUri">An optional hyperlink that provides a more detailed description regarding the diagnostic.</param>
            <param name="customTags">Optional custom tags for the diagnostic. See <see cref="T:Microsoft.CodeAnalysis.WellKnownDiagnosticTags"/> for some well known tags.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.#ctor(System.String,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,Microsoft.CodeAnalysis.LocalizableString,System.String,System.String[])">
            <summary>
            Create a DiagnosticDescriptor, which provides description about a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>.
            </summary>
            <param name="id">A unique identifier for the diagnostic. For example, code analysis diagnostic ID "CA1001".</param>
            <param name="title">A short localizable title describing the diagnostic. For example, for CA1001: "Types that own disposable fields should be disposable".</param>
            <param name="messageFormat">A localizable format message string, which can be passed as the first argument to <see cref="M:System.String.Format(System.String,System.Object[])"/> when creating the diagnostic message with this descriptor.
            For example, for CA1001: "Implement IDisposable on '{0}' because it creates members of the following IDisposable types: '{1}'."</param>
            <param name="category">The category of the diagnostic (like Design, Naming etc.). For example, for CA1001: "Microsoft.Design".</param>
            <param name="defaultSeverity">Default severity of the diagnostic.</param>
            <param name="isEnabledByDefault">True if the diagnostic is enabled by default.</param>
            <param name="description">An optional longer localizable description of the diagnostic.</param>
            <param name="helpLinkUri">An optional hyperlink that provides a more detailed description regarding the diagnostic.</param>
            <param name="customTags">Optional custom tags for the diagnostic. See <see cref="T:Microsoft.CodeAnalysis.WellKnownDiagnosticTags"/> for some well known tags.</param>
            <remarks>Example descriptor for rule CA1001:
                internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(RuleId,
                    new LocalizableResourceString(nameof(FxCopRulesResources.TypesThatOwnDisposableFieldsShouldBeDisposable), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources)),
                    new LocalizableResourceString(nameof(FxCopRulesResources.TypeOwnsDisposableFieldButIsNotDisposable), FxCopRulesResources.ResourceManager, typeof(FxCopRulesResources)),
                    FxCopDiagnosticCategory.Design,
                    DiagnosticSeverity.Warning,
                    isEnabledByDefault: true,
                    helpLinkUri: "http://msdn.microsoft.com/library/ms182172.aspx",
                    customTags: DiagnosticCustomTags.Microsoft);
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.GetEffectiveSeverity(Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Gets the effective severity of diagnostics created based on this descriptor and the given <see cref="T:Microsoft.CodeAnalysis.CompilationOptions"/>.
            </summary>
            <param name="compilationOptions">Compilation options</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.IsNotConfigurable">
            <summary>
            Returns true if diagnostic descriptor is not configurable, i.e. cannot be suppressed or filtered or have its severity changed.
            For example, compiler errors are always non-configurable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticDescriptor.IsCompilerOrNotConfigurable">
            <summary>
            Returns true if diagnostic descriptor is a built-in compiler diagnostic or is not configurable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticFormatter">
            <summary>
            Formats <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> messages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticFormatter.Format(Microsoft.CodeAnalysis.Diagnostic,System.IFormatProvider)">
            <summary>
            Formats the <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> message using the optional <see cref="T:System.IFormatProvider"/>.
            </summary>
            <param name="diagnostic">The diagnostic.</param>
            <param name="formatter">The formatter; or null to use the default formatter.</param>
            <returns>The formatted message.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticInfo">
            <summary>
            A DiagnosticInfo object has information about a diagnostic, but without any attached location information.
            </summary>
            <remarks>
            More specialized diagnostics with additional information (e.g., ambiguity errors) can derive from this class to
            provide access to additional information about the error, such as what symbols were involved in the ambiguity.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.Code">
            <summary>
            The error code, as an integer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.Severity">
            <summary>
            Returns the effective severity of the diagnostic: whether this diagnostic is informational, warning, or error.
            If IsWarningsAsError is true, then this returns <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Error"/>, while <see cref="P:Microsoft.CodeAnalysis.DiagnosticInfo.DefaultSeverity"/> returns <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.DefaultSeverity">
            <summary>
            Returns whether this diagnostic is informational, warning, or error by default, based on the error code.
            To get diagnostic's effective severity, use <see cref="P:Microsoft.CodeAnalysis.DiagnosticInfo.Severity"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.WarningLevel">
            <summary>
            Gets the warning level. This is 0 for diagnostics with severity <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Error"/>,
            otherwise an integer greater than zero.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.IsWarningAsError">
            <summary>
            Returns true if this is a warning treated as an error.
            </summary>
            <remarks>
            True implies <see cref="P:Microsoft.CodeAnalysis.DiagnosticInfo.Severity"/> = <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Error"/> and
            <see cref="P:Microsoft.CodeAnalysis.DiagnosticInfo.DefaultSeverity"/> = <see cref="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.Category">
            <summary>
            Get the diagnostic category for the given diagnostic code.
            Default category is <see cref="F:Microsoft.CodeAnalysis.Diagnostic.CompilerDiagnosticCategory"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.AdditionalLocations">
            <summary>
            If a derived class has additional information about other referenced symbols, it can
            expose the locations of those symbols in a general way, so they can be reported along
            with the error.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticInfo.MessageIdentifier">
            <summary>
            Get the message id (for example "CS1001") for the message. This includes both the error number
            and a prefix identifying the source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticInfo.GetMessage(System.IFormatProvider)">
            <summary>
            Get the text of the message in the given language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DiagnosticInfo.GetResolvedInfo">
            <summary>
            For a DiagnosticInfo that is lazily evaluated, this method evaluates it
            and returns a non-lazy DiagnosticInfo.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticSeverity">
            <summary>
            Describes how severe a diagnostic is.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Hidden">
            <summary>
            Something that is an issue, as determined by some authority,
            but is not surfaced through normal means.
            There may be different mechanisms that act on these issues.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Info">
            <summary>
            Information that does not indicate a problem (i.e. not prescriptive).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning">
            <summary>
            Something suspicious but allowed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticSeverity.Error">
            <summary>
            Something not allowed by the rules of the language or other authority.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InternalDiagnosticSeverity">
            <summary>
            Values for severity that are used internally by the compiler but are not exposed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InternalDiagnosticSeverity.Unknown">
            <summary>
            An unknown severity diagnostic is something whose severity has not yet been determined.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InternalDiagnosticSeverity.Void">
            <summary>
            If an unknown diagnostic is resolved and found to be unnecessary then it is 
            treated as a "Void" diagnostic
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InternalErrorCode">
            <summary>
            Values for ErrorCode/ERRID that are used internally by the compiler but are not exposed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InternalErrorCode.Unknown">
            <summary>
            The code has yet to be determined.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InternalErrorCode.Void">
            <summary>
            The code was lazily determined and does not need to be reported.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticWithInfo">
            <summary>
            A diagnostic (such as a compiler error or a warning), along with the location where it occurred.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticWithInfo.Info">
            <summary>
            Get the information about the diagnostic: the code, severity, message, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticWithInfo.HasLazyInfo">
            <summary>
            True if the DiagnosticInfo for this diagnostic requires (or required - this property
            is immutable) resolution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DiagnosticWithInfo.LazyInfo">
            <summary>
            Usage is unexpected unless <see cref="P:Microsoft.CodeAnalysis.DiagnosticWithInfo.HasLazyInfo"/> is true.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalFileLocation">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FileLinePositionSpan">
            <summary>
            Represents a span of text in a source code file in terms of file name, line number, and offset within line.
            However, the file is actually whatever was passed in when asked to parse; there may not really be a file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.Path">
            <summary>
            Path, or null if the span represents an invalid value.
            </summary>
            <remarks>
            Path may be <see cref="F:System.String.Empty"/> if not available.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.Span">
            <summary>
            Gets the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.HasMappedPath">
            <summary>
            True if the <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.Path"/> is a mapped path.
            </summary>
            <remarks>
            A mapped path is a path specified in source via <c>#line</c> (C#) or <c>#ExternalSource</c> (VB) directives.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.#ctor(System.String,Microsoft.CodeAnalysis.Text.LinePosition,Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Initializes the <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> instance.
            </summary>
            <param name="path">The file identifier - typically a relative or absolute path.</param>
            <param name="start">The start line position.</param>
            <param name="end">The end line position.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.#ctor(System.String,Microsoft.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Initializes the <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> instance.
            </summary>
            <param name="path">The file identifier - typically a relative or absolute path.</param>
            <param name="span">The span.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.StartLinePosition">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> of the start of the span.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.EndLinePosition">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> of the end of the span.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid">
            <summary>
            Returns true if the span represents a valid location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.Equals(Microsoft.CodeAnalysis.FileLinePositionSpan)">
            <summary>
            Determines if two FileLinePositionSpan objects are equal.
            </summary>
            <remarks>
            The path is treated as an opaque string, i.e. a case-sensitive comparison is used.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.Equals(System.Object)">
            <summary>
            Determines if two FileLinePositionSpan objects are equal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.GetHashCode">
            <summary>
            Serves as a hash function for FileLinePositionSpan.
            </summary>
            <returns>The hash code.</returns>
            <remarks>
            The path is treated as an opaque string, i.e. a case-sensitive hash is calculated.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileLinePositionSpan.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/>.
            </summary>
            <returns>The string representation of <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/>.</returns>
            <example>Path: (0,0)-(5,6)</example>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LocalizableResourceString">
            <summary>
            A localizable resource string that may possibly be formatted differently depending on culture.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LocalizableResourceString.#ctor(System.String,System.Resources.ResourceManager,System.Type)">
            <summary>
            Creates a localizable resource string with no formatting arguments.
            </summary>
            <param name="nameOfLocalizableResource">nameof the resource that needs to be localized.</param>
            <param name="resourceManager"><see cref="T:System.Resources.ResourceManager"/> for the calling assembly.</param>
            <param name="resourceSource">Type handling assembly's resource management. Typically, this is the static class generated for the resources file from which resources are accessed.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LocalizableResourceString.#ctor(System.String,System.Resources.ResourceManager,System.Type,System.String[])">
            <summary>
            Creates a localizable resource string that may possibly be formatted differently depending on culture.
            </summary>
            <param name="nameOfLocalizableResource">nameof the resource that needs to be localized.</param>
            <param name="resourceManager"><see cref="T:System.Resources.ResourceManager"/> for the calling assembly.</param>
            <param name="resourceSource">Type handling assembly's resource management. Typically, this is the static class generated for the resources file from which resources are accessed.</param>
            <param name="formatArguments">Optional arguments for formatting the localizable resource string.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LocalizableString">
            <summary>
            A string that may possibly be formatted differently depending on culture.
            NOTE: Types implementing <see cref="T:Microsoft.CodeAnalysis.LocalizableString"/> must be serializable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LocalizableString.FixedLocalizableString.s_empty">
            <summary>
            FixedLocalizableString representing an empty string.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.LocalizableString.OnException">
            <summary>
            Fired when an exception is raised by any of the public methods of <see cref="T:Microsoft.CodeAnalysis.LocalizableString"/>.
            If the exception handler itself throws an exception, that exception is ignored.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LocalizableString.ToString(System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the optionally specified format. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LocalizableString.GetText(System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the optionally specified format.
            Provides the implementation of ToString. ToString will provide a default value
            if this method throws an exception.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LocalizableString.GetHash">
            <summary>
            Provides the implementation of GetHashCode. GetHashCode will provide a default value
            if this method throws an exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LocalizableString.AreEqual(System.Object)">
            <summary>
            Provides the implementation of Equals. Equals will provide a default value
            if this method throws an exception.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LocalizableString.CanThrowExceptions">
            <summary>
            Flag indicating if any methods on this type can throw exceptions from public entrypoints.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Location">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.Kind">
            <summary>
            Location kind (None/SourceFile/MetadataFile).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.IsInSource">
            <summary>
            Returns true if the location represents a specific location in a source code file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.IsInMetadata">
            <summary>
            Returns true if the location is in metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.SourceTree">
            <summary>
            The syntax tree this location is located in or <c>null</c> if not in a syntax tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.MetadataModule">
            <summary>
            Returns the metadata module the location is associated with or <c>null</c> if the module is not available.
            </summary>
            <remarks>
            Might return null even if <see cref="P:Microsoft.CodeAnalysis.Location.IsInMetadata"/> returns true. The module symbol might not be available anymore, 
            for example, if the location is serialized and deserialized.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.SourceSpan">
            <summary>
            The location within the syntax tree that this location is associated with.
            </summary>
            <remarks>
            If <see cref="P:Microsoft.CodeAnalysis.Location.IsInSource"/> returns False this method returns an empty <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> which starts at position 0.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Location.GetLineSpan">
            <summary>
            Gets the location in terms of path, line and column.
            </summary>
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.
            
            Returns an invalid span (see <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid"/>) if the information is not available.
            
            The values are not affected by line mapping directives (#line in C# or #ExternalSource in VB).
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Location.GetMappedLineSpan">
            <summary>
            Gets the location in terms of path, line and column after applying source line mapping directives
            (<c>#line</c> in C# or <c>#ExternalSource</c> in VB).
            </summary>
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains file, line and column information,
            or an invalid span (see <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid"/>) if not available.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Location.None">
            <summary>
            A location of kind LocationKind.None. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Location.Create(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates an instance of a <see cref="T:Microsoft.CodeAnalysis.Location"/> for a span in a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Location.Create(System.String,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Creates an instance of a <see cref="T:Microsoft.CodeAnalysis.Location"/> for a span in a file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LocationKind">
            <summary>
            Specifies the kind of location (source vs. metadata).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LocationKind.None">
            <summary>
            Unspecified location.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LocationKind.SourceFile">
            <summary>
            The location represents a position in a source file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LocationKind.MetadataFile">
            <summary>
            The location represents a metadata file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LocationKind.XmlFile">
            <summary>
            The location represents a position in an XML file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LocationKind.ExternalFile">
            <summary>
            The location in some external file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataLocation">
            <summary>
            A program location in metadata.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NoLocation">
            <summary>
            A class that represents no location at all. Useful for errors in command line options, for example.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ReportDiagnostic">
            <summary>
            Describes how to report a warning diagnostic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Default">
            <summary>
            Report a diagnostic by default.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Error">
            <summary>
            Report a diagnostic as an error.  
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Warn">
            <summary>
            Report a diagnostic as a warning even though /warnaserror is specified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Info">
            <summary>
            Report a diagnostic as an info.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Hidden">
            <summary>
            Report a diagnostic as hidden.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ReportDiagnostic.Suppress">
            <summary>
            Suppress a diagnostic.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceLocation">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SuppressionDescriptor">
            <summary>
            Provides a description about a programmatic suppression of a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> by a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SuppressionDescriptor.Id">
            <summary>
            An unique identifier for the suppression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SuppressionDescriptor.SuppressedDiagnosticId">
            <summary>
            Identifier of the suppressed diagnostic, i.e. <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SuppressionDescriptor.Justification">
            <summary>
            A localizable justification about the suppression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SuppressionDescriptor.#ctor(System.String,System.String,System.String)">
            <summary>
            Create a SuppressionDescriptor, which provides a justification about a programmatic suppression of a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>.
            NOTE: For localizable <paramref name="justification"/>,
            use constructor overload <see cref="M:Microsoft.CodeAnalysis.SuppressionDescriptor.#ctor(System.String,System.String,Microsoft.CodeAnalysis.LocalizableString)"/>.
            </summary>
            <param name="id">A unique identifier for the suppression. For example, suppression ID "SP1001".</param>
            <param name="suppressedDiagnosticId">Identifier of the suppressed diagnostic, i.e. <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/>. For example, compiler warning Id "CS0649".</param>
            <param name="justification">Justification for the suppression. For example: "Suppress CS0649 on fields marked with YYY attribute as they are implicitly assigned.".</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SuppressionDescriptor.#ctor(System.String,System.String,Microsoft.CodeAnalysis.LocalizableString)">
            <summary>
            Create a SuppressionDescriptor, which provides a localizable justification about a programmatic suppression of a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>.
            </summary>
            <param name="id">A unique identifier for the suppression. For example, suppression ID "SP1001".</param>
            <param name="suppressedDiagnosticId">Identifier of the suppressed diagnostic, i.e. <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/>. For example, compiler warning Id "CS0649".</param>
            <param name="justification">Justification for the suppression. For example: "Suppress CS0649 on fields marked with YYY attribute as they are implicitly assigned.".</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SuppressionDescriptor.IsDisabled(Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Returns a flag indicating if the suppression is disabled for the given <see cref="T:Microsoft.CodeAnalysis.CompilationOptions"/>.
            </summary>
            <param name="compilationOptions">Compilation options</param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.Unnecessary">
            <summary>
            Indicates that the diagnostic is related to some unnecessary source code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.EditAndContinue">
            <summary>
            Indicates that the diagnostic is related to edit and continue.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.Build">
            <summary>
            Indicates that the diagnostic is related to build.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.Compiler">
            <summary>
            Indicates that the diagnostic is reported by the compiler.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.Telemetry">
            <summary>
            Indicates that the diagnostic can be used for telemetry
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.NotConfigurable">
            <summary>
            Indicates that the diagnostic is not configurable, i.e. it cannot be suppressed or filtered or have its severity changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.AnalyzerException">
            <summary>
            Indicates that the diagnostic is related to an exception thrown by a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.CustomObsolete">
            <summary>
            Indicates that the diagnostic is an obsolete diagnostic with a custom ID
            specified by the 'DiagnosticId' property on 'ObsoleteAttribute'.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownDiagnosticTags.CompilationEnd">
            <summary>
            Indicates that the diagnostic is a compilation end diagnostic reported
            from a compilation end action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlLocation">
            <summary>
            A program location in an XML file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentationCommentId">
            <summary>
            APIs for constructing documentation comment id's, and finding symbols that match ids.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.CreateDeclarationId(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Creates an id string used by external documentation comment files to identify declarations
            of types, namespaces, methods, properties, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.CreateReferenceId(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Creates an id string used to reference type symbols (not strictly declarations, includes
            arrays, pointers, type parameters, etc.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.GetSymbolsForDeclarationId(System.String,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets all declaration symbols that match the declaration id string
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.TryGetSymbolsForDeclarationId(System.String,Microsoft.CodeAnalysis.Compilation,System.Collections.Generic.List{Microsoft.CodeAnalysis.ISymbol})">
            <summary>
            Try to get all the declaration symbols that match the declaration id string.
            Returns true if at least one symbol matches.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.GetFirstSymbolForDeclarationId(System.String,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets the first declaration symbol that matches the declaration id string, order undefined.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.GetSymbolsForReferenceId(System.String,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets the symbols that match the reference id string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.TryGetSymbolsForReferenceId(System.String,Microsoft.CodeAnalysis.Compilation,System.Collections.Generic.List{Microsoft.CodeAnalysis.ISymbol})">
            <summary>
            Try to get all symbols that match the reference id string.
            Returns true if at least one symbol matches.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentId.GetFirstSymbolForReferenceId(System.String,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets the first symbol that matches the reference id string, order undefined.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentationCommentIncludeCache.CacheMissCount">
            <summary>
            WARN: This is a test hook - do not take a dependency on this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationCommentIncludeCache.MakeValue(Microsoft.CodeAnalysis.XmlReferenceResolver,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.Xml.XmlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentationProvider">
            <summary>
            A class used to provide XML documentation to the compiler for members from metadata. A
            custom implementation of this class should be returned from a DocumentationResolver to provide XML
            documentation comments from custom caches or locations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationProvider.GetDocumentationForSymbol(System.String,System.Globalization.CultureInfo,System.Threading.CancellationToken)">
            <summary>
            Fetches a documentation comment for the given member ID.
            </summary>
            <param name="documentationMemberID">The documentation member ID of the item to fetch.</param>
            <param name="preferredCulture">The preferred culture to receive a comment in. Null if
            there is no preference. This is a preference only, and providers may choose to provide
            results from another culture if the preferred culture was unavailable.</param>
            <param name="cancellationToken">A cancellation token for the search.</param>
            <returns>A DocumentationComment.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationProvider.Equals(System.Object)">
            <summary>
            DocumentationProviders are compared when determining whether an AssemblySymbol can be reused.
            Hence, if multiple instances can represent the same documentation, it is imperative that
            Equals (and GetHashCode) be overridden to capture this fact.  Otherwise, it is possible to end
            up with multiple AssemblySymbols for the same assembly, which plays havoc with the type hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationProvider.GetHashCode">
            <summary>
            DocumentationProviders are compared when determining whether an AssemblySymbol can be reused.
            Hence, if multiple instances can represent the same documentation, it is imperative that
            GetHashCode (and Equals) be overridden to capture this fact.  Otherwise, it is possible to end
            up with multiple AssemblySymbols for the same assembly, which plays havoc with the type hierarchy.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentationProvider.NullDocumentationProvider">
            <summary>
            A trivial DocumentationProvider which never returns documentation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlDocumentationCommentTextReader">
            <summary>
            Used by the DocumentationCommentCompiler(s) to check doc comments for XML parse errors.
            As a performance optimization, this class tries to re-use the same underlying <see cref="T:System.Xml.XmlReader"/> instance
            when possible. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.XmlDocumentationCommentTextReader.Reader._text">
            <summary>
            Current text to validate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.XmlDocumentationCommentTextReader.Reader.maxReadsPastTheEnd">
            <summary>
            We use <see cref="T:System.Xml.XmlReader"/> to validate XML doc comments. Unfortunately it cannot be reset and thus can't be pooled. 
            Each time we need to validate a fragment of XML we "append" it to the underlying text reader, implemented by this class, 
            and advance the reader. By the end of the fragment validation, we keep the reader open in a state 
            that is ready for the next fragment validation unless the fragment was invalid, in which case we need to create a new XmlReader.
            That is why <see cref="M:Microsoft.CodeAnalysis.XmlDocumentationCommentTextReader.Reader.Read(System.Char[],System.Int32,System.Int32)"/> pretends that the stream has extra <see cref="F:Microsoft.CodeAnalysis.XmlDocumentationCommentTextReader.Reader.maxReadsPastTheEnd"/> spaces
            at the end. That should be sufficient for <see cref="T:System.Xml.XmlReader"/> to not reach the end of this reader before the next 
            fragment is appended, unless the current fragment is malformed in one way or another. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentationMode">
            <summary>
            Specifies the different documentation comment processing modes.
            </summary>
            <remarks>
            Order matters: least processing to most processing.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationMode.None">
            <summary>
            Treats documentation comments as regular comments.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationMode.Parse">
            <summary>
            Parses documentation comments as structured trivia, but do not report any diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationMode.Diagnose">
            <summary>
            Parses documentation comments as structured trivia and report diagnostics.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedText">
            <summary>
            Represents text to be embedded in a PDB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedText.CompressionThreshold">
             <summary>
             The maximum number of bytes in to write out uncompressed.
            
             This prevents wasting resources on compressing tiny files with little to negative gain
             in PDB file size.
            
             Chosen as the point at which we start to see > 10% blob size reduction using all
             current source files in corefx and roslyn as sample data. 
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedText.FilePath">
            <summary>
            The path to the file to embed.
            </summary>
            <remarks>See remarks of <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath"/></remarks>
            <remarks>Empty file paths are disallowed, as the debugger finds source by looking up files by their name (and then verifying their signature)</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedText.ChecksumAlgorithm">
            <summary>
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedText.Checksum">
            <summary>
            The <see cref="P:Microsoft.CodeAnalysis.EmbeddedText.ChecksumAlgorithm"/> hash of the uncompressed bytes
            that's saved to the PDB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedText.Blob">
             <summary>
             The content that will be written to the PDB.
             </summary>
             <remarks>
             Internal since this is an implementation detail. The only public
             contract is that you can pass EmbeddedText instances to Emit.
             It just so happened that doing this up-front was most practical
             and efficient, but we don't want to be tied to it.
             
             For efficiency, the format of this blob is exactly as it is written
             to the PDB,which prevents extra copies being made during emit.
            
             The first 4 bytes (little endian int32) indicate the format:
            
                        0: data that follows is uncompressed
                 Positive: data that follows is deflate compressed and value is original, uncompressed size
                 Negative: invalid at this time, but reserved to mark a different format in the future.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedText.FromSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Constructs a <see cref="T:Microsoft.CodeAnalysis.EmbeddedText"/> for embedding the given <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
            <param name="filePath">The file path (pre-normalization) to use in the PDB.</param>
            <param name="text">The source text to embed.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="filePath"/> is null.
            <paramref name="text"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="filePath"/> empty.
            <paramref name="text"/> cannot be embedded (see <see cref="P:Microsoft.CodeAnalysis.Text.SourceText.CanBeEmbedded"/>).
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedText.FromStream(System.String,System.IO.Stream,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Constructs an <see cref="T:Microsoft.CodeAnalysis.EmbeddedText"/> from stream content.
            </summary>
            <param name="filePath">The file path (pre-normalization) to use in the PDB.</param>
            <param name="stream">The stream.</param>
            <param name="checksumAlgorithm">Hash algorithm to use to calculate checksum of the text that's saved to PDB.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="filePath" /> is null.
            <paramref name="stream"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="filePath" /> is empty.
            <paramref name="stream"/> doesn't support reading or seeking.
            <paramref name="checksumAlgorithm"/> is not supported.
            </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <remarks>Reads from the beginning of the stream. Leaves the stream open.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedText.FromBytes(System.String,System.ArraySegment{System.Byte},Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Constructs an <see cref="T:Microsoft.CodeAnalysis.EmbeddedText"/> from bytes.
            </summary>
            <param name="filePath">The file path (pre-normalization) to use in the PDB.</param>
            <param name="bytes">The bytes.</param>
            <param name="checksumAlgorithm">Hash algorithm to use to calculate checksum of the text that's saved to PDB.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="bytes"/> is default-initialized.
            <paramref name="filePath" /> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="filePath" /> is empty.
            <paramref name="checksumAlgorithm"/> is not supported.
            </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <remarks>Reads from the beginning of the stream. Leaves the stream open.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedText.ValidateFilePath(System.String)">
            <exception cref="T:System.ArgumentNullException"><paramref name="filePath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="filePath"/> is empty.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedText.CreateBlob(System.IO.Stream)">
            <summary>
            Creates the blob to be saved to the PDB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.s_utf8Encoding">
            <summary>
            Encoding to use when there is no byte order mark (BOM) on the stream. This encoder may throw a <see cref="T:System.Text.DecoderFallbackException"/>
            if the stream contains invalid UTF-8 bytes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.CreateFallbackEncoding">
            <summary>
            Encoding to use when UTF-8 fails. We try to find the following, in order, if available:
                1. The default ANSI codepage
                2. CodePage 1252.
                3. Latin1.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Create(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the provided stream. This version differs
            from <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)"/> in two ways:
            1. It attempts to minimize allocations by trying to read the stream into a byte array.
            2. If <paramref name="defaultEncoding"/> is null, it will first try UTF-8 and, if that fails, it will
               try CodePage 1252. If CodePage 1252 is not available on the system, then it will try Latin1.
            </summary>
            <param name="stream">The stream containing encoded text.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be Encoding.Default.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <param name="canBeEmbedded">Indicates if the file can be embedded in the PDB.</param>
            <param name="checksumAlgorithm">Hash algorithm used to calculate document checksum.</param>
            <exception cref="T:System.IO.InvalidDataException">
            The stream content can't be decoded using the specified <paramref name="defaultEncoding"/>, or
            <paramref name="defaultEncoding"/> is null and the stream appears to be a binary file.
            </exception>
            <exception cref="T:System.IO.IOException">An IO error occurred while reading from the stream.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Decode(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean,System.Boolean)">
            <summary>
            Try to create a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the given stream using the given encoding.
            </summary>
            <param name="data">The input stream containing the encoded text. The stream will not be closed.</param>
            <param name="encoding">The expected encoding of the stream. The actual encoding used may be different if byte order marks are detected.</param>
            <param name="checksumAlgorithm">The checksum algorithm to use.</param>
            <param name="throwIfBinaryDetected">Throw <see cref="T:System.IO.InvalidDataException"/> if binary (non-text) data is detected.</param>
            <param name="canBeEmbedded">Indicates if the text can be embedded in the PDB.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> decoded from the stream.</returns>
            <exception cref="T:System.Text.DecoderFallbackException">The decoder was unable to decode the stream with the given encoding.</exception>
            <exception cref="T:System.IO.IOException">Error reading from stream.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromStream(System.IO.Stream,System.ArraySegment{System.Byte}@)">
            <summary>
            Some streams are easily represented as bytes.
            </summary>
            <param name="data">The stream</param>
            <param name="bytes">The bytes, if available.</param>
            <returns>
            True if the stream's bytes could easily be read, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromFileStream(System.IO.FileStream,System.ArraySegment{System.Byte}@)">
            <summary>
            Read the contents of a FileStream into a byte array.
            </summary>
            <param name="stream">The FileStream with encoded text.</param>
            <param name="bytes">A byte array filled with the contents of the file.</param>
            <returns>True if a byte array could be created.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.ChangedText.GetLinesCore">
            <summary>
            Computes line starts faster given already computed line starts from text before the change.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.CompositeText">
            <summary>
            A composite of a sequence of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.CompositeText.CheckCopyToArguments(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Validates the arguments passed to <see cref="M:Microsoft.CodeAnalysis.Text.CompositeText.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)"/> against the published contract.
            </summary>
            <returns>True if should bother to proceed with copying.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.CompositeText.ReduceSegmentCountIfNecessary(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Text.SourceText})">
            <summary>
            Reduces the number of segments toward the target number of segments,
            if the number of segments is deemed to be too large (beyond the maximum).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.CompositeText.GetMinimalSegmentSizeToUseForCombining(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Text.SourceText})">
            <summary>
            Determines the segment size to use for call to CombineSegments, that will result in the segment count
            being reduced to less than or equal to the target segment count.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.CompositeText.GetSegmentCountIfCombined(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Text.SourceText},System.Int32)">
            <summary>
            Determines the segment count that would result if the segments of size less than or equal to 
            the specified segment size were to be combined.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.CompositeText.CombineSegments(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Text.SourceText},System.Int32)">
            <summary>
            Combines contiguous segments with lengths that are each less than or equal to the specified segment size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.CompositeText.ComputeLengthAndStorageSize(System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.Text.SourceText},System.Int32@,System.Int32@)">
            <summary>
            Compute total text length and total size of storage buffers held
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.CompositeText.TrimInaccessibleText(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Text.SourceText})">
            <summary>
            Trim excessive inaccessible text.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.LargeText">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> optimized for very large sources. The text is stored as
            a list of chunks (char arrays).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.LargeText.ChunkSize">
            <remarks>
            internal for unit testing
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LargeText.GetLinesCore">
            <summary>
            Called from <see cref="P:Microsoft.CodeAnalysis.Text.SourceText.Lines"/> to initialize the <see cref="T:Microsoft.CodeAnalysis.Text.TextLineCollection"/>. Thereafter,
            the collection is cached.
            </summary>
            <returns>A new <see cref="T:Microsoft.CodeAnalysis.Text.TextLineCollection"/> representing the individual text lines.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LargeTextWriter.AppendChunk(System.Char[])">
            <summary>
            Append chunk to writer (may reuse char array)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.LinePosition">
            <summary>
            Immutable representation of a line number and position within a SourceText instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.LinePosition.Zero">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> that represents position 0 at line 0.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of a <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> with the given line and character.
            </summary>
            <param name="line">
            The line of the line position. The first line in a file is defined as line 0 (zero based line numbering).
            </param>
            <param name="character">
            The character position in the line.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="line"/> or <paramref name="character"/> is less than zero. </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.LinePosition.Line">
            <summary>
            The line number. The first line in a file is defined as line 0 (zero based line numbering).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.LinePosition.Character">
            <summary>
            The character position within the line.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.op_Equality(Microsoft.CodeAnalysis.Text.LinePosition,Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> are the same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.op_Inequality(Microsoft.CodeAnalysis.Text.LinePosition,Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> are different.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.Equals(Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> are the same.
            </summary>
            <param name="other">The object to compare.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.Equals(System.Object)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> are the same.
            </summary>
            <param name="obj">The object to compare.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.GetHashCode">
            <summary>
            Provides a hash function for <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePosition.ToString">
            <summary>
            Provides a string representation for <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/>.
            </summary>
            <example>0,10</example>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.LinePositionSpan">
            <summary>
            Immutable span represented by a pair of line number and index within the line.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePositionSpan.#ctor(Microsoft.CodeAnalysis.Text.LinePosition,Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Text.LinePositionSpan"/>.
            </summary>
            <param name="start">Start position.</param>
            <param name="end">End position.</param>
            <exception cref="T:System.ArgumentException"><paramref name="end"/> precedes <paramref name="start"/>.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.LinePositionSpan.Start">
            <summary>
            Gets the start position of the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.LinePositionSpan.End">
            <summary>
            Gets the end position of the span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.LinePositionSpan.ToString">
            <summary>
            Provides a string representation for <see cref="T:Microsoft.CodeAnalysis.Text.LinePositionSpan"/>.
            </summary>
            <example>(0,0)-(5,6)</example>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.SourceHashAlgorithm">
            <summary>
            Specifies a hash algorithms used for hashing source files.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.None">
            <summary>
            No algorithm specified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.Sha1">
            <summary>
            Secure Hash Algorithm 1.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.Sha256">
            <summary>
            Secure Hash Algorithm 2 with a hash size of 256 bits.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.SourceText">
            <summary>
            An abstraction of source text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.String,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Constructs a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from text in a string.
            </summary>
            <param name="text">Text.</param>
            <param name="encoding">
            Encoding of the file that the <paramref name="text"/> was read from or is going to be saved to.
            <c>null</c> if the encoding is unspecified.
            If the encoding is not specified the resulting <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> isn't debuggable.
            If an encoding-less <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> is written to a file a <see cref="P:System.Text.Encoding.UTF8"/> shall be used as a default.
            </param>
            <param name="checksumAlgorithm">
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="checksumAlgorithm"/> is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.TextReader,System.Int32,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Constructs a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from text in a string.
            </summary>
            <param name="reader">TextReader</param>
            <param name="length">length of content from <paramref name="reader"/></param>
            <param name="encoding">
            Encoding of the file that the <paramref name="reader"/> was read from or is going to be saved to.
            <c>null</c> if the encoding is unspecified.
            If the encoding is not specified the resulting <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> isn't debuggable.
            If an encoding-less <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> is written to a file a <see cref="P:System.Text.Encoding.UTF8"/> shall be used as a default.
            </param>
            <param name="checksumAlgorithm">
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="checksumAlgorithm"/> is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean,System.Boolean)">
            <summary>
            Constructs a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from stream content.
            </summary>
            <param name="stream">Stream. The stream must be seekable.</param>
            <param name="encoding">
            Data encoding to use if the stream doesn't start with Byte Order Mark specifying the encoding.
            <see cref="P:System.Text.Encoding.UTF8"/> if not specified.
            </param>
            <param name="checksumAlgorithm">
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </param>
            <param name="throwIfBinaryDetected">If the decoded text contains at least two consecutive NUL
            characters, then an <see cref="T:System.IO.InvalidDataException"/> is thrown.</param>
            <param name="canBeEmbedded">True if the text can be passed to <see cref="M:Microsoft.CodeAnalysis.EmbeddedText.FromSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)"/> and be embedded in a PDB.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="stream"/> doesn't support reading or seeking.
            <paramref name="checksumAlgorithm"/> is not supported.
            </exception>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use a throwing decoder as a fallback</exception>
            <exception cref="T:System.IO.InvalidDataException">Two consecutive NUL characters were detected in the decoded text and <paramref name="throwIfBinaryDetected"/> was true.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <remarks>Reads from the beginning of the stream. Leaves the stream open.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.Byte[],System.Int32,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean,System.Boolean)">
            <summary>
            Constructs a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from a byte array.
            </summary>
            <param name="buffer">The encoded source buffer.</param>
            <param name="length">The number of bytes to read from the buffer.</param>
            <param name="encoding">
            Data encoding to use if the encoded buffer doesn't start with Byte Order Mark.
            <see cref="P:System.Text.Encoding.UTF8"/> if not specified.
            </param>
            <param name="checksumAlgorithm">
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </param>
            <param name="throwIfBinaryDetected">If the decoded text contains at least two consecutive NUL
            characters, then an <see cref="T:System.IO.InvalidDataException"/> is thrown.</param>
            <returns>The decoded text.</returns>
            <param name="canBeEmbedded">True if the text can be passed to <see cref="M:Microsoft.CodeAnalysis.EmbeddedText.FromSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)"/> and be embedded in a PDB.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="length"/> is negative or longer than the <paramref name="buffer"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="checksumAlgorithm"/> is not supported.</exception>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use a throwing decoder as a fallback</exception>
            <exception cref="T:System.IO.InvalidDataException">Two consecutive NUL characters were detected in the decoded text and <paramref name="throwIfBinaryDetected"/> was true.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.Decode(System.IO.Stream,System.Text.Encoding,System.Text.Encoding@)">
            <summary>
            Decode text from a stream.
            </summary>
            <param name="stream">The stream containing encoded text.</param>
            <param name="encoding">The encoding to use if an encoding cannot be determined from the byte order mark.</param>
            <param name="actualEncoding">The actual encoding used.</param>
            <returns>The decoded text.</returns>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use a throwing decoder as a fallback</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.Decode(System.Byte[],System.Int32,System.Text.Encoding,System.Text.Encoding@)">
            <summary>
            Decode text from a byte array.
            </summary>
            <param name="buffer">The byte array containing encoded text.</param>
            <param name="length">The count of valid bytes in <paramref name="buffer"/>.</param>
            <param name="encoding">The encoding to use if an encoding cannot be determined from the byte order mark.</param>
            <param name="actualEncoding">The actual encoding used.</param>
            <returns>The decoded text.</returns>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use a throwing decoder as a fallback</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.IsBinary(System.ReadOnlySpan{System.Char})">
            <summary>
            Check for occurrence of two consecutive NUL (U+0000) characters.
            This is unlikely to appear in genuine text, so it's a good heuristic
            to detect binary files.
            </summary>
            <remarks>
            internal for unit testing
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.IsBinary(System.String)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Text.SourceText.IsBinary(System.ReadOnlySpan{System.Char})" />
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.ChecksumAlgorithm">
            <summary>
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.Encoding">
            <summary>
            Encoding of the file that the text was read from or is going to be saved to.
            <c>null</c> if the encoding is unspecified.
            </summary>
            <remarks>
            If the encoding is not specified the source isn't debuggable.
            If an encoding-less <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> is written to a file a <see cref="P:System.Text.Encoding.UTF8"/> shall be used as a default.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.Length">
            <summary>
            The length of the text in characters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.StorageSize">
            <summary>
            The size of the storage representation of the text (in characters).
            This can differ from length when storage buffers are reused to represent fragments/subtext.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.CanBeEmbedded">
             <summary>
             Indicates whether this source text can be embedded in the PDB.
             </summary>
             <remarks>
             If this text was constructed via <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.Byte[],System.Int32,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean,System.Boolean)"/> or
             <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean,System.Boolean)"/>, then the canBeEmbedded arg must have
             been true.
            
             Otherwise, <see cref="P:Microsoft.CodeAnalysis.Text.SourceText.Encoding" /> must be non-null.
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.PrecomputedEmbeddedTextBlob">
            <summary>
            If the text was created from a stream or byte[] and canBeEmbedded argument was true, 
            this provides the embedded text blob that was precomputed using the original stream
            or byte[]. The precomputation was required in that case so that the bytes written to
            the PDB match the original bytes exactly (and match the checksum of the original 
            bytes). 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="P:Microsoft.CodeAnalysis.Text.SourceText.Length"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copy a range of characters from this SourceText to a destination array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.Container">
            <summary>
            The container of this <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.GetSubText(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that contains the characters in the specified span of this text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.GetSubText(System.Int32)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that has the contents of this text including and after the start position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.Write(System.IO.TextWriter,System.Threading.CancellationToken)">
            <summary>
            Write this <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> to a text writer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.Write(System.IO.TextWriter,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Write a span of text to a text writer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.ToString">
            <summary>
            Provides a string representation of the SourceText.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets a string containing the characters in specified span.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChange})">
            <summary>
            Constructs a new SourceText from this text with the specified changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(Microsoft.CodeAnalysis.Text.TextChange[])">
            <summary>
            Constructs a new SourceText from this text with the specified changes.
            </summary>        
            <remarks>
            Changes do not have to be in sorted order.  However, <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChange})"/> will
            perform better if they are.
            </remarks>
            <exception cref="T:System.ArgumentException">If any changes are not in bounds of this <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.</exception>
            <exception cref="T:System.ArgumentException">If any changes overlap other changes.</exception>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.Replace(Microsoft.CodeAnalysis.Text.TextSpan,System.String)">
            <summary>
            Returns a new SourceText with the specified span of characters replaced by the new text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.Replace(System.Int32,System.Int32,System.String)">
            <summary>
            Returns a new SourceText with the specified range of characters replaced by the new text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.GetChangeRanges(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the set of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/> that describe how the text changed
            between this text an older version. This may be multiple detailed changes
            or a single change encompassing the entire text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.GetTextChanges(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the set of <see cref="T:Microsoft.CodeAnalysis.Text.TextChange"/> that describe how the text changed
            between this text and an older version. This may be multiple detailed changes 
            or a single change encompassing the entire text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceText.Lines">
            <summary>
            The collection of individual text lines.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.GetLinesCore">
            <summary>
            Called from <see cref="P:Microsoft.CodeAnalysis.Text.SourceText.Lines"/> to initialize the <see cref="T:Microsoft.CodeAnalysis.Text.TextLineCollection"/>. Thereafter,
            the collection is cached.
            </summary>
            <returns>A new <see cref="T:Microsoft.CodeAnalysis.Text.TextLineCollection"/> representing the individual text lines.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.ContentEquals(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Compares the content with content of another <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.ContentEqualsImpl(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Implements equality comparison of the content of two different instances of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.SourceText.TryReadByteOrderMark(System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Detect an encoding by looking for byte order marks.
            </summary>
            <param name="source">A buffer containing the encoded text.</param>
            <param name="length">The length of valid data in the buffer.</param>
            <param name="preambleLength">The length of any detected byte order marks.</param>
            <returns>The detected encoding or null if no recognized byte order mark was present.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.SourceTextContainer">
            <summary>
            An object that contains an instance of a SourceText and raises events when its current instance
            changes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.SourceTextContainer.CurrentText">
            <summary>
            The current text instance.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Text.SourceTextContainer.TextChanged">
            <summary>
            Raised when the current text instance changes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.SourceTextStream">
            <summary>
            A read-only, non-seekable <see cref="T:System.IO.Stream"/> over a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.StringBuilderText">
            <summary>
            Implementation of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> based on a <see cref="T:System.Text.StringBuilder"/> input
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.StringBuilderText._builder">
            <summary>
            Underlying string on which this SourceText instance is based
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringBuilderText.Builder">
            <summary>
            Underlying string which is the source of this SourceText instance
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringBuilderText.Length">
            <summary>
            The length of the text represented by <see cref="T:Microsoft.CodeAnalysis.Text.StringBuilderText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringBuilderText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="P:Microsoft.CodeAnalysis.Text.StringBuilderText.Length"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.StringBuilderText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Provides a string representation of the StringBuilderText located within given span.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.StringText">
            <summary>
            Implementation of SourceText based on a <see cref="T:System.String"/> input
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringText.Source">
            <summary>
            Underlying string which is the source of this <see cref="T:Microsoft.CodeAnalysis.Text.StringText"/>instance
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringText.Length">
            <summary>
            The length of the text represented by <see cref="T:Microsoft.CodeAnalysis.Text.StringText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.StringText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="P:Microsoft.CodeAnalysis.Text.StringText.Length"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.StringText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Provides a string representation of the StringText located within given span.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.SubText">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that represents a subrange of another <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextChange">
            <summary>
            Describes a single change when a particular span is replaced with a new text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChange.Span">
            <summary>
            The original span of the changed text. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChange.NewText">
            <summary>
            The new text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChange.#ctor(Microsoft.CodeAnalysis.Text.TextSpan,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextChange"/>
            </summary>
            <param name="span">The original span of the changed text.</param>
            <param name="newText">The new text.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChange.ToString">
            <summary>
            Provides a string representation for <see cref="T:Microsoft.CodeAnalysis.Text.TextChange"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChange.op_Implicit(Microsoft.CodeAnalysis.Text.TextChange)~Microsoft.CodeAnalysis.Text.TextChangeRange">
            <summary>
            Converts a <see cref="T:Microsoft.CodeAnalysis.Text.TextChange"/> to a <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/>.
            </summary>
            <param name="change"></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChange.NoChanges">
            <summary>
            An empty set of changes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextChangeEventArgs">
            <summary>
            Represents state for a TextChanged event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeEventArgs.#ctor(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeEventArgs"/>.
            </summary>
            <param name="oldText">The text before the change.</param>
            <param name="newText">The text after the change.</param>
            <param name="changes">A set of ranges for the change.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeEventArgs.#ctor(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextChangeRange[])">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeEventArgs"/>.
            </summary>
            <param name="oldText">The text before the change.</param>
            <param name="newText">The text after the change.</param>
            <param name="changes">A set of ranges for the change.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChangeEventArgs.OldText">
            <summary>
            Gets the text before the change.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChangeEventArgs.NewText">
            <summary>
            Gets the text after the change.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChangeEventArgs.Changes">
            <summary>
            Gets the set of ranges for the change.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextChangeRange">
            <summary>
            Represents the change to a span of text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChangeRange.Span">
            <summary>
            The span of text before the edit which is being changed
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChangeRange.NewLength">
            <summary>
            Width of the span after the edit.  A 0 here would represent a delete
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.#ctor(Microsoft.CodeAnalysis.Text.TextSpan,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/>.
            </summary>
            <param name="span"></param>
            <param name="newLength"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.Equals(Microsoft.CodeAnalysis.Text.TextChangeRange)">
            <summary>
            Compares current instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/> to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.Equals(System.Object)">
            <summary>
            Compares current instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/> to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.GetHashCode">
            <summary>
            Provides hash code for current instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.op_Equality(Microsoft.CodeAnalysis.Text.TextChangeRange,Microsoft.CodeAnalysis.Text.TextChangeRange)">
            <summary>
            Determines if two instances of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/> are same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.op_Inequality(Microsoft.CodeAnalysis.Text.TextChangeRange,Microsoft.CodeAnalysis.Text.TextChangeRange)">
            <summary>
            Determines if two instances of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/> are different.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextChangeRange.NoChanges">
            <summary>
            An empty set of changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextChangeRange.Collapse(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Collapse a set of <see cref="T:Microsoft.CodeAnalysis.Text.TextChangeRange"/>s into a single encompassing range.  If
            the set of ranges provided is empty, an empty range is returned.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextLine">
            <summary>
            Information about the character boundaries of a single line of text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLine.FromSpan(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/> instance.
            </summary>
            <param name="text">The source text.</param>
            <param name="span">The span of the line.</param>
            <returns>An instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The span does not represent a text line.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.Text">
            <summary>
            Gets the source text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.LineNumber">
            <summary>
            Gets the zero-based line number.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.Start">
            <summary>
            Gets the start position of the line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.End">
            <summary>
            Gets the end position of the line not including the line break.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.EndIncludingLineBreak">
            <summary>
            Gets the end position of the line including the line break.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.Span">
            <summary>
            Gets the line span not including the line break.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLine.SpanIncludingLineBreak">
            <summary>
            Gets the line span including the line break.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextLineCollection">
            <summary>
            Abstract base class for <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/> collections.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLineCollection.Count">
            <summary>
            The count of <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/> items in the collection
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextLineCollection.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/> item at the specified index.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.IndexOf(System.Int32)">
            <summary>
            The index of the TextLine that encompasses the character position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLineFromPosition(System.Int32)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Text.TextLine"/> that encompasses the character position.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePosition(System.Int32)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> corresponding to a character position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePositionSpan(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Convert a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> to a <see cref="T:Microsoft.CodeAnalysis.Text.LinePositionSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetPosition(Microsoft.CodeAnalysis.Text.LinePosition)">
            <summary>
            Convert a <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> to a position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetTextSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Convert a <see cref="T:Microsoft.CodeAnalysis.Text.LinePositionSpan"/> to <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextSpan">
            <summary>
            Immutable abstract representation of a span of text.  For example, in an error diagnostic that reports a
            location, it could come from a parsed string, text from a tool editor buffer, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a TextSpan instance beginning with the position Start and having the Length
            specified with <paramref name="length" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextSpan.Start">
            <summary>
            Start point of the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextSpan.End">
            <summary>
            End of the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextSpan.Length">
            <summary>
            Length of the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.TextSpan.IsEmpty">
            <summary>
            Determines whether or not the span is empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Contains(System.Int32)">
            <summary>
            Determines whether the position lies within the span.
            </summary>
            <param name="position">
            The position to check.
            </param>
            <returns>
            <c>true</c> if the position is greater than or equal to Start and strictly less 
            than End, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Contains(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> falls completely within this span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the specified span falls completely within this span, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.OverlapsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> overlaps this span. Two spans are considered to overlap 
            if they have positions in common and neither is empty. Empty spans do not overlap with any 
            other span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the spans overlap, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Overlap(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns the overlap with the given span, or null if there is no overlap.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            The overlap of the spans, or null if the overlap is empty.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.IntersectsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> intersects this span. Two spans are considered to 
            intersect if they have positions in common or the end of one span 
            coincides with the start of the other span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the spans intersect, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.IntersectsWith(System.Int32)">
            <summary>
            Determines whether <paramref name="position"/> intersects this span. 
            A position is considered to intersect if it is between the start and
            end positions (inclusive) of this span.
            </summary>
            <param name="position">
            The position to check.
            </param>
            <returns>
            <c>true</c> if the position intersects, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Intersection(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns the intersection with the given span, or null if there is no intersection.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            The intersection of the spans, or null if the intersection is empty.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.FromBounds(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> from <paramref name="start" /> and <paramref
            name="end"/> positions as opposed to a position and length.
            
            The returned TextSpan contains the range with <paramref name="start"/> inclusive, 
            and <paramref name="end"/> exclusive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.op_Equality(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines if two instances of <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> are the same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.op_Inequality(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines if two instances of <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> are different.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Equals(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines if current instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> is equal to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.Equals(System.Object)">
            <summary>
            Determines if current instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> is equal to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.GetHashCode">
            <summary>
            Produces a hash code for <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.ToString">
            <summary>
            Provides a string representation for <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>.
            This representation uses "half-open interval" notation, indicating the endpoint character is not included.
            Example: <c>[10..20)</c>, indicating the text starts at position 10 and ends at position 20 not included.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextSpan.CompareTo(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Compares current instance of <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> with another.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextUtilities">
            <summary>
            Holder for common Text Utility functions and values
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextUtilities.GetStartAndLengthOfLineBreakEndingAt(Microsoft.CodeAnalysis.Text.SourceText,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Return startLineBreak = index-1, lengthLineBreak = 2   if there is a \r\n at index-1
            Return startLineBreak = index,   lengthLineBreak = 1   if there is a 1-char newline at index
            Return startLineBreak = index+1, lengthLineBreak = 0   if there is no newline at index.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextUtilities.IsAnyLineBreakCharacter(System.Char)">
            <summary>
            Determine if the character in question is any line break character
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EnumConstantHelper.OffsetValue(Microsoft.CodeAnalysis.ConstantValue,System.UInt32,Microsoft.CodeAnalysis.ConstantValue@)">
            <summary>
            Generate a ConstantValue of the same integer type as the argument
            and offset by the given non-negative amount. Return ConstantValue.Bad
            if the generated constant would be outside the valid range of the type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileSystemExtensions.Emit(Microsoft.CodeAnalysis.Compilation,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Threading.CancellationToken)">
            <summary>
            Emit the IL for the compilation into the specified stream.
            </summary>
            <param name="compilation">Compilation.</param>
            <param name="outputPath">Path of the file to which the compilation will be written.</param>
            <param name="pdbPath">Path of the file to which the compilation's debug info will be written.
            Also embedded in the output file.  Null to forego PDB generation.
            </param>
            <param name="xmlDocPath">Path of the file to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
            <param name="win32ResourcesPath">Path of the file from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none.</param>
            <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
            <param name="cancellationToken">To cancel the emit process.</param>
            <exception cref="T:System.ArgumentNullException">Compilation or path is null.</exception>
            <exception cref="T:System.ArgumentException">Path is empty or invalid.</exception>
            <exception cref="T:System.IO.IOException">An error occurred while reading or writing a file.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RelativePathResolver.#ctor(System.Collections.Immutable.ImmutableArray{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.RelativePathResolver"/> class.
            </summary>
            <param name="searchPaths">An ordered set of fully qualified 
            paths which are searched when resolving assembly names.</param>
            <param name="baseDirectory">Directory used when resolving relative paths.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation">
            <summary>
            Represents that an intermediate result is being captured.
            This node is produced only as part of a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph" />.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.FlowCapture"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation.Id">
            <summary>
            An id used to match references to the same intermediate result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation.Value">
            <summary>
            Value to be captured.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureReferenceOperation">
            <summary>
            Represents a point of use of an intermediate result captured earlier.
            The fact of capturing the result is represented by <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation" />.
            This node is produced only as part of a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph" />.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.FlowCaptureReference"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureReferenceOperation.Id">
            <summary>
            An id used to match references to the same intermediate result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureReferenceOperation.IsInitialization">
            <summary>
            True if this reference to the capture initializes the capture. Used when the capture is being initialized by being passed as an <code>out</code> parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.IIsNullOperation">
            <summary>
            Represents result of checking whether the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.IIsNullOperation.Operand" /> is null.
            For reference types this checks if the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.IIsNullOperation.Operand" /> is a null reference,
            for nullable types this checks if the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.IIsNullOperation.Operand" /> doesn’t have a value.
            The node is produced as part of a flow graph during rewrite of <see cref="T:Microsoft.CodeAnalysis.Operations.ICoalesceOperation" />
            and <see cref="T:Microsoft.CodeAnalysis.Operations.IConditionalAccessOperation" /> nodes.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.IsNull"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.IIsNullOperation.Operand">
            <summary>
            Value to check.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.ICaughtExceptionOperation">
            <summary>
            Represents a exception instance passed by an execution environment to an exception filter or handler.
            This node is produced only as part of a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph" />.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.CaughtException"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.IStaticLocalInitializationSemaphoreOperation">
            <summary>
            Represents the check during initialization of a VB static local that is initialized on the first call of the function, and never again.
            If the semaphore operation returns true, the static local has not yet been initialized, and the initializer will be run. If it returns
            false, then the local has already been initialized, and the static local initializer region will be skipped.
            This node is produced only as part of a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph" />.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.StaticLocalInitializationSemaphore"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.IStaticLocalInitializationSemaphoreOperation.Local">
            <summary>
            The static local variable that is possibly initialized.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowAnonymousFunctionOperation">
            <summary>
            Represents an anonymous function operation in context of a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph" />.
            <para>
            Current usage:
             (1) C# lambda expression.
             (2) VB anonymous delegate expression.
            </para>
            A <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph" /> for the body of the anonymous function is available from
            the enclosing <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph" />.
            </summary>
            <remarks>
            <para>This node is associated with the following operation kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.OperationKind.FlowAnonymousFunction"/></description></item>
            </list>
            <para>This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.IFlowAnonymousFunctionOperation.Symbol">
            <summary>
            Symbol of the anonymous function.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock">
            <summary>
            Represents a basic block in a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> with a sequence of <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.Operations"/>.
            Once a basic block is entered, all operations in it are always executed.
            Optional <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.BranchValue"/>, if non-null, is evaluated after the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.Operations"/>.
            Control flow leaves the basic block by taking either the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionalSuccessor"/> branch or
            the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.FallThroughSuccessor"/> branch.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.Kind">
            <summary>
            Basic block kind (entry, block, or exit).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.Operations">
            <summary>
            Sequence of operations in the basic block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.BranchValue">
            <summary>
            Optional branch value, which if non-null, is evaluated after <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.Operations"/>.
            For conditional branches, this value is used to represent the condition which determines if
            <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionalSuccessor"/> is taken or not.
            For non-conditional branches, this value is used to represent the return or throw value associated
            with the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.FallThroughSuccessor"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionKind">
            <summary>
            Indicates the condition kind for the branch out of the basic block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.FallThroughSuccessor">
            <summary>
            Optional fall through branch executed at the end of the basic block.
            This branch is null for exit block, and non-null for all other basic blocks.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionalSuccessor">
            <summary>
            Optional conditional branch out of the basic block.
            If non-null, this branch may be taken at the end of the basic block based
            on the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionKind"/> and <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.BranchValue"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.Predecessors">
            <summary>
            List of basic blocks which have a control flow branch (<see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.FallThroughSuccessor"/> or <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionalSuccessor"/>)
            into this basic block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.Ordinal">
            <summary>
            Unique ordinal for each basic block in a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>,
            which can be used to index into <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Blocks"/> array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.IsReachable">
            <summary>
            Indicates if control flow can reach this basic block from the entry block of the graph.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.EnclosingRegion">
            <summary>
            Enclosing region.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockKind">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/> kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockKind.Entry">
            <summary>
            Indicates an entry block for a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>,
            which is always the first block in <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Blocks"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockKind.Exit">
            <summary>
            Indicates an exit block for a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>,
            which is always the last block in <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Blocks"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockKind.Block">
            <summary>
            Indicates an intermediate block for a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.CaptureId">
            <summary>
            Capture Id is an opaque identifier to represent an intermediate result from an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.CaptureId.Equals(Microsoft.CodeAnalysis.FlowAnalysis.CaptureId)">
            <summary>
            Compares <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.CaptureId"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.CaptureId.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.CaptureId.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch">
            <summary>
            Represents a control flow branch from a <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch.Source"/> basic block to a <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch.Destination"/>
            basic block in a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch.Source">
            <summary>
            Source basic block of this branch.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch.Destination">
            <summary>
            Destination basic block of this branch.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch.Semantics">
            <summary>
            Semantics associated with this branch (such as "regular", "return", "throw", etc).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch.IsConditionalSuccessor">
            <summary>
            Indicates if this branch represents <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionalSuccessor"/> of the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch.Source"/> basic block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch.LeavingRegions">
            <summary>
            Regions exited if this branch is taken.
            Ordered from the innermost region to the outermost region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch.EnteringRegions">
            <summary>
            Regions entered if this branch is taken.
            Ordered from the outermost region to the innermost region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch.FinallyRegions">
            <summary>
            The finally regions the control goes through if this branch is taken.
            Ordered in the sequence by which the finally regions are executed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchSemantics">
            <summary>
            Semantics associated with a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchSemantics.None">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch"/> with no associated semantics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchSemantics.Regular">
            <summary>
            Represents a regular <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch"/> from a source basic block to a non-null destination basic block.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchSemantics.Return">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch"/> to the exit block, i.e. the destination block has <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockKind.Exit"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchSemantics.StructuredExceptionHandling">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch"/> with special structured exception handling semantics:
              1. The source basic block is the last block of an enclosing finally or filter region.
              2. The destination basic block is null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchSemantics.ProgramTermination">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch"/> to indicate flow transfer to the end of program execution.
            The destination basic block is null for this branch.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchSemantics.Throw">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch"/> generated for an <see cref="T:Microsoft.CodeAnalysis.Operations.IThrowOperation"/> with an explicit thrown exception.
            The destination basic block is null for this branch.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchSemantics.Rethrow">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch"/> generated for an <see cref="T:Microsoft.CodeAnalysis.Operations.IThrowOperation"/> with in implicit rethrown exception.
            The destination basic block is null for this branch.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchSemantics.Error">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch"/> generated for error cases.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowConditionKind">
            <summary>
            Represents kind of conditional branch from a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowConditionKind.None">
            <summary>
            Indicates no conditional branch from a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/>.
            Associated <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionalSuccessor"/> is null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowConditionKind.WhenFalse">
            <summary>
            Indicates a conditional branch from a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/>,
            with a non-null <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.BranchValue"/> and <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionalSuccessor"/>.
            If <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.BranchValue"/> evaluates to <code>false</code>,
            then the branch <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionalSuccessor"/> is taken.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowConditionKind.WhenTrue">
            <summary>
            Indicates a conditional branch from a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/>,
            with a non-null <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.BranchValue"/> and <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionalSuccessor"/>.
            If <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.BranchValue"/> evaluates to <code>true</code>,
            then the branch <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.ConditionalSuccessor"/> is taken.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph">
            <summary>
            Control flow graph representation for a given executable code block <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.OriginalOperation"/>.
            This graph contains a set of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/>s, with an entry block, zero
            or more intermediate basic blocks and an exit block.
            Each basic block contains zero or more <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.Operations"/> and
            explicit <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch"/>(s) to other basic block(s).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Create(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> for the given executable code block root <paramref name="node"/>.
            </summary>
            <param name="node">Root syntax node for an executable code block.</param>
            <param name="semanticModel">Semantic model for the syntax tree containing the <paramref name="node"/>.</param>
            <param name="cancellationToken">Optional cancellation token.</param>
            <returns>
            Returns null if <see cref="M:Microsoft.CodeAnalysis.SemanticModel.GetOperation(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> returns null for the given <paramref name="node"/> and <paramref name="semanticModel"/>.
            Otherwise, returns a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> for the executable code block.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Create(Microsoft.CodeAnalysis.Operations.IBlockOperation,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> for the given executable code block <paramref name="body"/>.
            </summary>
            <param name="body">Root operation block, which must have a null parent.</param>
            <param name="cancellationToken">Optional cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Create(Microsoft.CodeAnalysis.Operations.IFieldInitializerOperation,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> for the given executable code block <paramref name="initializer"/>.
            </summary>
            <param name="initializer">Root field initializer operation, which must have a null parent.</param>
            <param name="cancellationToken">Optional cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Create(Microsoft.CodeAnalysis.Operations.IPropertyInitializerOperation,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> for the given executable code block <paramref name="initializer"/>.
            </summary>
            <param name="initializer">Root property initializer operation, which must have a null parent.</param>
            <param name="cancellationToken">Optional cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Create(Microsoft.CodeAnalysis.Operations.IParameterInitializerOperation,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> for the given executable code block <paramref name="initializer"/>.
            </summary>
            <param name="initializer">Root parameter initializer operation, which must have a null parent.</param>
            <param name="cancellationToken">Optional cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Create(Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> for the given executable code block <paramref name="constructorBody"/>.
            </summary>
            <param name="constructorBody">Root constructor body operation, which must have a null parent.</param>
            <param name="cancellationToken">Optional cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Create(Microsoft.CodeAnalysis.Operations.IMethodBodyOperation,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> for the given executable code block <paramref name="methodBody"/>.
            </summary>
            <param name="methodBody">Root method body operation, which must have a null parent.</param>
            <param name="cancellationToken">Optional cancellation token.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.OriginalOperation">
            <summary>
            Original operation, representing an executable code block, from which this control flow graph was generated.
            Note that <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.Operations"/> in the control flow graph are not in the same operation tree as
            the original operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Parent">
            <summary>
            Optional parent control flow graph for this graph.
            Non-null for a control flow graph generated for a local function or a lambda.
            Null otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Blocks">
            <summary>
            Basic blocks for the control flow graph.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.Root">
            <summary>
            Root (<see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Root"/>) region for the graph.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.LocalFunctions">
            <summary>
            Local functions declared within <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.OriginalOperation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.GetLocalFunctionControlFlowGraph(Microsoft.CodeAnalysis.IMethodSymbol,System.Threading.CancellationToken)">
            <summary>
            Creates a control flow graph for the given <paramref name="localFunction"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph.GetAnonymousFunctionControlFlowGraph(Microsoft.CodeAnalysis.FlowAnalysis.IFlowAnonymousFunctionOperation,System.Threading.CancellationToken)">
            <summary>
            Creates a control flow graph for the given <paramref name="anonymousFunction"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder">
            <summary>
            Some basic concepts:
            - Basic blocks are sequences of statements/operations with no branching. The only branching
              allowed is at the end of the basic block.
            - Regions group blocks together and represent the lifetime of locals and captures, loosely similar to scopes in C#.
              There are different kinds of regions, <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind"/>.
            - <see cref="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.SpillEvalStack"/> converts values on the stack into captures.
            - Error scenarios from initial binding need to be handled.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.ConditionalAccessOperationTracker.Operations">
            <summary>
            Represents the stack <see cref="P:Microsoft.CodeAnalysis.Operations.IConditionalAccessOperation.Operation"/>s of a tree of conditional accesses. The top of the stack is the
            deepest node, and except in error conditions it should contain a <see cref="T:Microsoft.CodeAnalysis.Operations.IConditionalAccessInstanceOperation"/> that will be visited
            when visiting this node. This is the basic recursion that ensures that the operations are visited at the correct time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.ConditionalAccessOperationTracker.WhenNull">
            <summary>
            The basic block to branch to if the top of the <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.ConditionalAccessOperationTracker.Operations"/> stack is null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.Context">
            <summary>
            This structure is meant to capture a snapshot of the <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder"/> state
            that is needed to build graphs for lambdas and local functions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder._currentImplicitInstance">
            <summary>
            Holds the current object being initialized if we're visiting an object initializer.
            Or the current anonymous type object being initialized if we're visiting an anonymous type object initializer.
            Or the target of a VB With statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.Pack(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.BasicBlockBuilder},Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.RegionBuilder,Microsoft.CodeAnalysis.PooledObjects.PooledDictionary{Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.BasicBlockBuilder,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.RegionBuilder})">
            <summary>
            Do a pass to eliminate blocks without statements that can be merged with predecessor(s) and
            to eliminate regions that can be merged with parents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.MergeSubRegionAndFree(Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.RegionBuilder,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.BasicBlockBuilder},Microsoft.CodeAnalysis.PooledObjects.PooledDictionary{Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.BasicBlockBuilder,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.RegionBuilder},System.Boolean)">
            <summary>
            Merge content of <paramref name="subRegion"/> into its enclosing region and free it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.PackBlocks(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.BasicBlockBuilder},Microsoft.CodeAnalysis.PooledObjects.PooledDictionary{Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.BasicBlockBuilder,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.RegionBuilder})">
            <summary>
            Do a pass to eliminate blocks without statements that can be merged with predecessor(s).
            Returns true if any blocks were eliminated
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.CheckUnresolvedBranches(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.BasicBlockBuilder},Microsoft.CodeAnalysis.PooledObjects.PooledDictionary{Microsoft.CodeAnalysis.ILabelSymbol,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.BasicBlockBuilder})">
            <summary>
            Deal with labeled blocks that were not added to the graph because labels were never found
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.VisitStatementsOneOrAll(Microsoft.CodeAnalysis.IOperation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IOperation},System.Int32)">
            <summary>
            Either visits a single operation, or a using <see cref="T:Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation"/> and all subsequent statements
            </summary>
            <param name="operation">The statement to visit</param>
            <param name="statements">All statements in the block containing this node</param>
            <param name="startIndex">The current statement being visited in <paramref name="statements"/></param>
            <returns>True if this visited all of the statements</returns>
            <remarks>
            The operation being visited is not necessarily equal to statements[startIndex]. 
            When traversing down a set of labels, we set operation to the label.Operation and recurse, but statements[startIndex] still refers to the original parent label 
            as we haven't actually moved down the original statement list
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.EvalStackFrame">
            <summary>
            This class captures information about beginning of stack frame
            and corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.RegionBuilder"/> if one was allocated to
            track <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.CaptureId"/>s used by the stack spilling, etc.
            Do not create instances of this type manually, use <see cref="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.PushStackFrame"/>
            helper instead. Also, do not assign <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.EvalStackFrame.RegionBuilderOpt"/> explicitly.
            Let the builder machinery do this when appropriate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.VisitConditionalBranchCore(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.BasicBlockBuilder@,System.Boolean)">
            <summary>
            This function does not change the current region. The stack should be spilled before calling it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.NullCheckAndConvertCoalesceValue(Microsoft.CodeAnalysis.Operations.ICoalesceOperation,Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.BasicBlockBuilder)">
            <summary>
            Returns converted test expression.
            Caller is responsible for spilling the stack and pushing a stack frame before calling this helper.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.PushTargetAndUnwrapTupleIfNecessary(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Recursively push nexted values onto the stack for visiting
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.PopTargetAndWrapTupleIfNecessary(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Recursively pop nested tuple values off the stack after visiting
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.ImplicitInstanceInfo">
            <summary>
            Holds the current object being initialized if we're visiting an object initializer.
            Or the current anonymous type object being initialized if we're visiting an anonymous type object initializer.
            Or the target of a VB With statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.ImplicitInstanceInfo.ImplicitInstance">
            <summary>
            Holds the current object instance being initialized if we're visiting an object initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.ImplicitInstanceInfo.AnonymousType">
            <summary>
            Holds the current anonymous type instance being initialized if we're visiting an anonymous object initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder.ImplicitInstanceInfo.AnonymousTypePropertyValues">
            <summary>
            Holds the captured values for initialized anonymous type properties in an anonymous object initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphExtensions.GetLocalFunctionControlFlowGraphInScope(Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph,Microsoft.CodeAnalysis.IMethodSymbol,System.Threading.CancellationToken)">
            <summary>
            Gets or creates a control flow graph for the given <paramref name="localFunction"/> defined in
            the given <paramref name="controlFlowGraph"/> or any of it's parent control flow graphs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphExtensions.GetAnonymousFunctionControlFlowGraphInScope(Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph,Microsoft.CodeAnalysis.FlowAnalysis.IFlowAnonymousFunctionOperation,System.Threading.CancellationToken)">
            <summary>
            Gets or creates a control flow graph for the given <paramref name="anonymousFunction"/> defined in
            the given <paramref name="controlFlowGraph"/> or any of it's parent control flow graphs.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion">
            <summary>
            Encapsulates information about regions of <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/>s in a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>.
            Regions can overlap, but never cross each other boundaries.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion.Kind">
            <summary>
            Region's kind
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion.EnclosingRegion">
            <summary>
            Enclosing region. Null for <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Root"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion.ExceptionType">
            <summary>
            Target exception type for <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Filter"/>, <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Catch"/>, 
            <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.FilterAndHandler"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion.FirstBlockOrdinal">
            <summary>
            Ordinal (<see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.Ordinal"/>) of the first <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/> within the region. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion.LastBlockOrdinal">
            <summary>
            Ordinal (<see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock.Ordinal"/>) of the last <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/> within the region. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion.NestedRegions">
            <summary>
            Regions nested within this region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion.Locals">
            <summary>
            Locals for which this region represent the life-time.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion.LocalFunctions">
            <summary>
            Local functions declared within the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion.CaptureIds">
            <summary>
            Capture Ids used for intermediate results within the region.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind">
            <summary>
            Defines kinds of regions that can be present in a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Root">
            <summary>
            A root region encapsulating all <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/>s in a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.LocalLifetime">
            <summary>
            Region with the only purpose to represent the life-time of locals, intermediate results, and nested methods (local functions, lambdas).
            The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it.
            The lifetime of a nested method is the portion of program execution within which the method can be referenced.
            The lifetime of an intermediate result (capture) is the portion of program execution within which the result can be referenced.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Try">
            <summary>
            Region representing a try region. For example, <see cref="P:Microsoft.CodeAnalysis.Operations.ITryOperation.Body"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Filter">
            <summary>
            Region representing <see cref="P:Microsoft.CodeAnalysis.Operations.ICatchClauseOperation.Filter"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Catch">
            <summary>
            Region representing <see cref="P:Microsoft.CodeAnalysis.Operations.ICatchClauseOperation.Handler"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.FilterAndHandler">
            <summary>
            Region representing a union of a <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Filter"/> and the corresponding catch <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Catch"/> regions. 
            Doesn't contain any <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/>s directly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.TryAndCatch">
            <summary>
            Region representing a union of a <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Try"/> and all corresponding catch <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Catch"/>
            and <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.FilterAndHandler"/> regions. Doesn't contain any <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/>s directly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Finally">
            <summary>
            Region representing <see cref="P:Microsoft.CodeAnalysis.Operations.ITryOperation.Finally"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.TryAndFinally">
            <summary>
            Region representing a union of a <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Try"/> and corresponding finally <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Finally"/>
            region. Doesn't contain any <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/>s directly.
            
            An <see cref="T:Microsoft.CodeAnalysis.Operations.ITryOperation"/> that has a set of <see cref="P:Microsoft.CodeAnalysis.Operations.ITryOperation.Catches"/> and a <see cref="P:Microsoft.CodeAnalysis.Operations.ITryOperation.Finally"/> 
            at the same time is mapped to a <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.TryAndFinally"/> region with <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.TryAndCatch"/> region inside its <see cref="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.Try"/> region.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.StaticLocalInitializer">
            <summary>
            Region representing the initialization for a VB <code>Static</code> local variable. This region will only be executed
            the first time a function is called.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind.ErroneousBody">
            <summary>
            Region representing erroneous block of code that is unreachable from the entry block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.OperationKind">
            <summary>
            All of the kinds of operations, including statements and expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.None">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.IOperation"/> for a construct that is not implemented yet.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Invalid">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInvalidOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Block">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IBlockOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.VariableDeclarationGroup">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Switch">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ISwitchOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Loop">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ILoopOperation"/>. This is further differentiated by <see cref="P:Microsoft.CodeAnalysis.Operations.ILoopOperation.LoopKind"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Labeled">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ILabeledOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Branch">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IBranchOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Empty">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IEmptyOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Return">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IReturnOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.YieldBreak">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IReturnOperation"/>. This has yield break semantics.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Lock">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ILockOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Try">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ITryOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Using">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IUsingOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.YieldReturn">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IReturnOperation"/>. This has yield return semantics.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ExpressionStatement">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IExpressionStatementOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.LocalFunction">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ILocalFunctionOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Stop">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IStopOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.End">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IEndOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.RaiseEvent">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IRaiseEventOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Literal">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ILiteralOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Conversion">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IConversionOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Invocation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInvocationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ArrayElementReference">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IArrayElementReferenceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.LocalReference">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ILocalReferenceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ParameterReference">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IParameterReferenceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.FieldReference">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IFieldReferenceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.MethodReference">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IMethodReferenceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.PropertyReference">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IPropertyReferenceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.EventReference">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IEventReferenceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Unary">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IUnaryOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.UnaryOperator">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IUnaryOperation"/>. Use <see cref="F:Microsoft.CodeAnalysis.OperationKind.Unary"/> instead.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Binary">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IBinaryOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.BinaryOperator">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IBinaryOperation"/>. Use <see cref="F:Microsoft.CodeAnalysis.OperationKind.Binary"/> instead.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Conditional">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IConditionalOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Coalesce">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ICoalesceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.AnonymousFunction">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousFunctionOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ObjectCreation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IObjectCreationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.TypeParameterObjectCreation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ITypeParameterObjectCreationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ArrayCreation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IArrayCreationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.InstanceReference">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInstanceReferenceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.IsType">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IIsTypeOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Await">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IAwaitOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.SimpleAssignment">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ISimpleAssignmentOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.CompoundAssignment">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Parenthesized">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IParenthesizedOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.EventAssignment">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IEventAssignmentOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ConditionalAccess">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IConditionalAccessOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ConditionalAccessInstance">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IConditionalAccessInstanceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedString">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.AnonymousObjectCreation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousObjectCreationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ObjectOrCollectionInitializer">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IObjectOrCollectionInitializerOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.MemberInitializer">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IMemberInitializerOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.CollectionElementInitializer">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ICollectionElementInitializerOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.NameOf">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.INameOfOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Tuple">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ITupleOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.DynamicObjectCreation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.DynamicMemberReference">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDynamicMemberReferenceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.DynamicInvocation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.DynamicIndexerAccess">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.TranslatedQuery">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ITranslatedQueryOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.DelegateCreation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.DefaultValue">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDefaultValueOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.TypeOf">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ITypeOfOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.SizeOf">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ISizeOfOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.AddressOf">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IAddressOfOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.IsPattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IIsPatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Increment">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation"/>. This is used as an increment operator</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Throw">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IThrowOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Decrement">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation"/>. This is used as a decrement operator</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.DeconstructionAssignment">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDeconstructionAssignmentOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.DeclarationExpression">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDeclarationExpressionOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.OmittedArgument">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IOmittedArgumentOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.FieldInitializer">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IFieldInitializerOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.VariableInitializer">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IVariableInitializerOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.PropertyInitializer">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IPropertyInitializerOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ParameterInitializer">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IParameterInitializerOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ArrayInitializer">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IArrayInitializerOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.VariableDeclarator">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.VariableDeclaration">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Argument">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IArgumentOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.CatchClause">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ICatchClauseOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.SwitchCase">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ISwitchCaseOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.CaseClause">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ICaseClauseOperation"/>. This is further differentiated by <see cref="P:Microsoft.CodeAnalysis.Operations.ICaseClauseOperation.CaseKind"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringText">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringTextOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Interpolation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ConstantPattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IConstantPatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.DeclarationPattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDeclarationPatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.TupleBinary">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ITupleBinaryOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.TupleBinaryOperator">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ITupleBinaryOperation"/>. Use <see cref="F:Microsoft.CodeAnalysis.OperationKind.TupleBinary"/> instead.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.MethodBody">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IMethodBodyOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.MethodBodyOperation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IMethodBodyOperation"/>. Use <see cref="F:Microsoft.CodeAnalysis.OperationKind.MethodBody"/> instead.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ConstructorBody">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ConstructorBodyOperation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation"/>. Use <see cref="F:Microsoft.CodeAnalysis.OperationKind.ConstructorBody"/> instead.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Discard">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDiscardOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.FlowCapture">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.FlowCaptureReference">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureReferenceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.IsNull">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IIsNullOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.CaughtException">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ICaughtExceptionOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.StaticLocalInitializationSemaphore">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IStaticLocalInitializationSemaphoreOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.FlowAnonymousFunction">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowAnonymousFunctionOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.CoalesceAssignment">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ICoalesceAssignmentOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Range">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IRangeOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ReDim">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IReDimOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ReDimClause">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IReDimClauseOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.RecursivePattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IRecursivePatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.DiscardPattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IDiscardPatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.SwitchExpression">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ISwitchExpressionOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.SwitchExpressionArm">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ISwitchExpressionArmOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.PropertySubpattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IPropertySubpatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.UsingDeclaration">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IUsingDeclarationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.NegatedPattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.INegatedPatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.BinaryPattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IBinaryPatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.TypePattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ITypePatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.RelationalPattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IRelationalPatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.With">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IWithOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringHandlerCreation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerCreationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringAddition">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAdditionOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringAppendLiteral">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAppendOperation"/>. This append is of a literal component</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringAppendFormatted">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAppendOperation"/>. This append is of an interpolation component</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringAppendInvalid">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringAppendOperation"/>. This append is invalid</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.InterpolatedStringHandlerArgumentPlaceholder">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IInterpolatedStringHandlerArgumentPlaceholderOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.FunctionPointerInvocation">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IFunctionPointerInvocationOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ListPattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IListPatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.SlicePattern">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.ISlicePatternOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.ImplicitIndexerReference">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IImplicitIndexerReferenceOperation"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OperationKind.Utf8String">
            <summary>Indicates an <see cref="T:Microsoft.CodeAnalysis.Operations.IUtf8StringOperation"/>.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2">
            <summary>
            Cache with a fixed size that evicts the least recently used members.
            Thread-safe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Create cache from an array. The cache capacity will be the size
            of the array. All elements of the array will be added to the 
            cache. If any duplicate keys are found in the array a
            <see cref="T:System.ArgumentException"/> will be thrown.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2.TestingEnumerable">
            <summary>
            For testing. Very expensive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2.UnsafeEvictLastNode">
            <summary>
            Expects non-empty cache. Does not lock.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2.UnsafeAdd(`0,`1,System.Boolean)">
            <summary>
            Doesn't lock.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2.UnsafeTryGetValue(`0,`1@)">
            <summary>
            Doesn't lock.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FailFast.Handler">
            <summary>
            A pre-created delegate to assign to <see cref="T:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler" /> if needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FailFast.DumpStackTrace(System.Exception,System.String)">
            <summary>
            Dumps the stack trace of the exception and the handler to the console. This is useful
            for debugging unit tests that hit a fatal exception
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FailFast.Assert(System.Boolean,System.String)">
            <summary>
            Checks for the given <paramref name="condition"/>; if the <paramref name="condition"/> is <c>true</c>, 
            immediately terminates the process without running any pending <c>finally</c> blocks or finalizers
            and causes a crash dump to be collected (if the system is configured to do so). 
            Otherwise, the process continues normally.
            </summary>
            <param name="condition">The conditional expression to evaluate.</param>
            <param name="message">An optional message to be recorded in the dump in case of failure. Can be <c>null</c>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ErrorReporting.OperationCanceledIgnoringCallerTokenException">
            <summary>
            Thrown when async code must cancel the current execution but does not have access to the <see cref="T:System.Threading.CancellationTokenSource"/> of the <see cref="T:System.Threading.CancellationToken"/> passed to the code.
            Should be used in very rare cases where the <see cref="T:System.Threading.CancellationTokenSource"/> is out of our control (e.g. owned but not exposed by JSON RPC in certain call-back scenarios).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler">
            <summary>
            Set by the host to handle an error report; this may crash the process or report telemetry.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.OverwriteHandler(Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler)">
            <summary>
            Same as setting the Handler property except that it avoids the assert.  This is useful in
            test code which needs to verify the handler is called in specific cases and will continually
            overwrite this value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.CopyHandlerTo(System.Reflection.Assembly)">
            <summary>
            Copies the handler in this instance to the linked copy of this type in this other assembly.
            </summary>
            <remarks>
            This file is in linked into multiple layers, but we want to ensure that all layers have the same copy.
            This lets us copy the handler in this instance into the same in another instance.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagate(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
            <summary>
            Use in an exception filter to report an error without catching the exception.
            The error is reported by calling <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler"/>.
            </summary>
            <returns><see langword="false"/> to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagateUnlessCanceled(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
            <summary>
            Use in an exception filter to report an error (by calling <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler"/>), unless the
            operation has been cancelled. The exception is never caught.
            </summary>
            <returns><see langword="false"/> to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagateUnlessCanceled(System.Exception,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
             <summary>
             <para>Use in an exception filter to report an error (by calling <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler"/>), unless the
             operation has been cancelled at the request of <paramref name="contextCancellationToken"/>. The exception is
             never caught.</para>
            
             <para>Cancellable operations are only expected to throw <see cref="T:System.OperationCanceledException"/> if the
             applicable <paramref name="contextCancellationToken"/> indicates cancellation is requested by setting
             <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/>. Unexpected cancellation, i.e. an
             <see cref="T:System.OperationCanceledException"/> which occurs without <paramref name="contextCancellationToken"/>
             requesting cancellation, is treated as an error by this method.</para>
            
             <para>This method does not require <see cref="P:System.OperationCanceledException.CancellationToken"/> to match
             <paramref name="contextCancellationToken"/>, provided cancellation is expected per the previous
             paragraph.</para>
             </summary>
             <param name="contextCancellationToken">A <see cref="T:System.Threading.CancellationToken"/> which will have
             <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> set if cancellation is expected.</param>
             <returns><see langword="false"/> to avoid catching the exception.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity">
            <summary>
            The severity of the error, see the enum members for a description of when to use each. This is metadata that's included
            in a non-fatal fault report, which we can take advantage of on the backend to automatically triage bugs. For example,
            a critical severity issue we can open with a lower bug count compared to a low priority one.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.Uncategorized">
            <summary>
            The severity hasn't been categorized. Don't use this in new code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.Diagnostic">
            <summary>
            Something failed, but the user is unlikely to notice. Especially useful for background things that we can silently recover
            from, like bugs in caching systems.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.General">
            <summary>
            Something failed, and the user might notice, but they're still likely able to carry on. For example, if the user
            asked for some information from the IDE (find references, completion, etc.) and we were able to give partial results.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.Critical">
            <summary>
            Something failed, and the user likely noticed. For example, the user pressed a button to do an action, and
            we threw an exception so we completely failed to do that in an unrecoverable way. This may also be used
            for back-end systems where a failure is going to result in a highly broken experience, for example if parsing a file
            catastrophically failed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LittleEndianReader">
            <summary>
            A Span-compatible version of <see cref="T:System.IO.BinaryReader"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.StackGuard.EnsureSufficientExecutionStack(System.Int32)">
            <summary>
                Ensures that the remaining stack space is large enough to execute
                the average function.
            </summary>
            <param name="recursionDepth">how many times the calling function has recursed</param>
            <exception cref="T:System.InsufficientExecutionStackException">
                The available stack space is insufficient to execute
                the average function.
            </exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ThreeState">
            <summary>
            Represents an optional bool as a single byte.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IReferenceOrISignature">
            <summary>
            Used to devirtualize ConcurrentDictionary for EqualityComparer{T}.Default and ReferenceEquals
            
            This type is to enable fast-path devirtualization in the Jit. Dictionary{K, V}, HashTable{T}
            and ConcurrentDictionary{K, V} will devirtualize (and potentially inline) the IEquatable{T}.Equals
            method for a struct when the Comparer is unspecified in .NET Core, .NET 5; whereas specifying
            a Comparer will make .Equals and GetHashcode slower interface calls.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IVTConclusion">
            <summary>
            The result of <see cref="M:Microsoft.CodeAnalysis.ISymbolExtensions.PerformIVTCheck(Microsoft.CodeAnalysis.AssemblyIdentity,System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte})"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IVTConclusion.Match">
            <summary>
            This indicates that friend access should be granted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IVTConclusion.OneSignedOneNot">
             <summary>
             This indicates that friend access should be granted for the purposes of error recovery,
             but the program is wrong.
            
             That's because this indicates that a strong-named assembly has referred to a weak-named assembly 
             which has extended friend access to the strong-named assembly. This will ultimately 
             result in an error because strong-named assemblies may not refer to weak-named assemblies. 
             In Roslyn we give a new error, CS7029, before emit time. In the dev10 compiler we error at 
             emit time.
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IVTConclusion.PublicKeyDoesntMatch">
            <summary>
            This indicates that friend access should not be granted because the other assembly grants
            friend access to a strong-named assembly, and either this assembly is weak-named, or
            it is strong-named and the names don't match.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IVTConclusion.NoRelationshipClaimed">
            <summary>
            This indicates that friend access should not be granted because the other assembly 
            does not name this assembly as a friend in any way whatsoever.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuntimeMembers.MemberDescriptor">
            <summary>
            Structure that describes a member of a type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RuntimeMembers.MemberDescriptor.DeclaringTypeId">
            <summary>
            Id/token of containing type, usually value from some enum.
            For example from SpecialType enum.
            I am not using SpecialType as the type for this field because
            VB runtime types are not part of SpecialType.
            
            So, the implication is that any type ids we use outside of the SpecialType 
            (either for the VB runtime classes, or types like System.Task etc.) will need 
            to use IDs that are all mutually disjoint. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RuntimeMembers.MemberDescriptor.Signature">
            <summary>
            Signature of the field or method, similar to metadata signature, 
            but with the following exceptions:
               1) Truncated on the left, for methods starts at [ParamCount], for fields at [Type]
               2) Type tokens are not compressed
               3) BOOLEAN | CHAR | I1 | U1 | I2 | U2 | I4 | U4 | I8 | U8 | R4 | R8 | I | U | Void types are encoded by 
                  using VALUETYPE+typeId notation.
               4) array bounds are not included.
               5) modifiers are not included.
               6) (CLASS | VALUETYPE) are omitted after GENERICINST
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuntimeMembers.MemberDescriptor.ParametersCount">
            <summary>
            Applicable only to properties and methods, throws otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.MemberDescriptor.ReadTypeId(System.IO.Stream)">
            <summary>
            The type Id may be:
                (1) encoded in a single byte (for types below 255)
                (2) encoded in two bytes (255 + extension byte) for types below 512
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.MemberDescriptor.ParseTypeHandle(System.Collections.Immutable.ImmutableArray{System.Byte}.Builder,System.IO.Stream)">
            <summary>
            Read a type Id from the stream and copy it into the builder.
            This may copy one or two bytes depending on the first one.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5">
            <summary>
            Helper class to match signatures in format of 
            MemberDescriptor.Signature to members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.MatchFieldSignature(`1,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Returns true if signature matches signature of the field.
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.MatchPropertySignature(`2,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Returns true if signature matches signature of the property.
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.MatchMethodSignature(`0,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Returns true if signature matches signature of the method.
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.MatchType(`3,System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32@)">
            <summary>
            Does pretty much the same thing as MetadataDecoder.DecodeType only instead of 
            producing a type symbol it compares encoded type to the target.
            
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.ReadTypeId(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32@)">
            <summary>
            Read a type Id from the signature.
            This may consume one or two bytes, and therefore increment the position correspondingly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.GetGenericTypeArgument(`3,System.Int32)">
            <summary>
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.GetGenericTypeDefinition(`3)">
            <summary>
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.GetPointedToType(`3)">
            <summary>
            Should only accept Pointer types.
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.GetSZArrayElementType(`3)">
            <summary>
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.MatchArrayRank(`3,System.Int32)">
            <summary>
            Should only accept multi-dimensional arrays.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5.GetMDArrayElementType(`3)">
            <summary>
            Should only accept multi-dimensional arrays.
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeTypeOrThrow(System.Reflection.Metadata.BlobReader@,System.Boolean@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeTypeOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SignatureTypeCode,System.Boolean@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetSymbolForTypeHandleOrThrow(System.Reflection.Metadata.EntityHandle,System.Boolean@,System.Boolean,System.Boolean)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetTypeByNameOrThrow(Microsoft.CodeAnalysis.MetadataTypeName@,System.Reflection.Metadata.EntityHandle,System.Boolean@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeModifiersOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SignatureTypeCode@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeLocalSignatureOrThrow(System.Reflection.Metadata.BlobReader@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded local variable type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeLocalVariableOrThrow(System.Reflection.Metadata.BlobReader@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded local variable type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeLocalVariableTypeOrThrow(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Used to decode signatures of local constants returned by SymReader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetLocalInfo(System.Reflection.Metadata.StandaloneSignatureHandle)">
            <summary>
            Returns the local info for all locals indexed by slot.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeParameterOrThrow(System.Reflection.Metadata.BlobReader@,Microsoft.CodeAnalysis.ParamInfo{`1}@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded parameter type is invalid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetSignatureCountsOrThrow(Microsoft.CodeAnalysis.PEModule,System.Reflection.Metadata.MethodDefinitionHandle,System.Int32@,System.Int32@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeParameterTypeOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SerializationTypeCode@,`1@,System.Reflection.Metadata.SerializationTypeCode@,`1@,System.Boolean)">
            <summary>
            Decodes attribute parameter type from method signature.
            </summary>
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded parameter type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeFieldOrPropTypeOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SerializationTypeCode@,`1@,System.Reflection.Metadata.SerializationTypeCode@,`1@,System.Boolean)">
            <summary>
            Decodes attribute argument type from attribute blob (called FieldOrPropType in the spec).
            </summary>
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded argument type is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeFixedArgumentOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.BlobReader@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded attribute argument is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeElementOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SerializationTypeCode,`1)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded attribute argument is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeElementArrayOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SerializationTypeCode,`1,`1)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded attribute argument is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributePrimitiveElementOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SerializationTypeCode,`1)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the given <paramref name="typeCode"/> is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeCustomAttributeNamedArgumentOrThrow(System.Reflection.Metadata.BlobReader@)">
            <exception cref="T:Microsoft.CodeAnalysis.UnsupportedSignatureContent">If the encoded named argument is invalid.</exception>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeMethodSpecTypeArgumentsOrThrow(System.Reflection.Metadata.BlobHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeSignatureHeaderOrThrow(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.SignatureHeader@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeSignatureHeaderOrThrow(Microsoft.CodeAnalysis.PEModule,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.SignatureHeader@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DecodeSignatureParametersOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SignatureHeader,System.Int32@,System.Boolean,System.Boolean)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetSignatureCountsOrThrow(System.Reflection.Metadata.BlobReader@,System.Reflection.Metadata.SignatureHeader,System.Int32@,System.Int32@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetExplicitlyOverriddenMethods(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle,`1)">
            <summary>
            Find the methods that a given method explicitly overrides.
            </summary>
            <remarks>
            Methods may be on class or interfaces.
            Containing classes/interfaces will be supertypes of the implementing type.
            </remarks>
            <param name="implementingTypeDef">TypeDef handle of the implementing type.</param>
            <param name="implementingMethodDef">MethodDef handle of the implementing method.</param>
            <param name="implementingTypeSymbol">The type symbol for the implementing type.</param>
            <returns>Array of implemented methods.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.FindMethodSymbolInSuperType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
            <summary>
            Search for the <typeparamref name="MethodSymbol"/> corresponding to the given MethodDef token. Search amongst
            the supertypes (classes and interfaces) of a designated type.
            </summary>
            <remarks>
            Generally, the type will be a type that explicitly implements an interface and the method will be the
            implemented method (i.e. on the interface).
            </remarks>
            <param name="searchTypeDef">TypeDef token of the type from which the search should begin.</param>
            <param name="targetMethodDef">MethodDef token of the target method.</param>
            <returns>Corresponding <typeparamref name="MethodSymbol"/> or null, if none is found.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.EnqueueTypeDefInterfacesAndBaseTypeOrThrow(System.Collections.Generic.Queue{System.Reflection.Metadata.TypeDefinitionHandle},System.Collections.Generic.Queue{`1},System.Reflection.Metadata.TypeDefinitionHandle)">
            <summary>
            Enqueue the interfaces implemented and the type extended by a given TypeDef.
            </summary>
            <param name="typeDefsToSearch">Queue of TypeDefs to search.</param>
            <param name="typeSymbolsToSearch">Queue of TypeSymbols (representing typeRefs to search).</param>
            <param name="searchTypeDef">Handle of the TypeDef for which we want to enqueue supertypes.</param>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.EnqueueTypeToken(System.Collections.Generic.Queue{System.Reflection.Metadata.TypeDefinitionHandle},System.Collections.Generic.Queue{`1},System.Reflection.Metadata.EntityHandle)">
            <summary>
            Helper method for enqueuing a type token in the right queue.
            Def -> typeDefsToSearch
            Ref -> typeSymbolsToSearch
            null -> neither
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.EnqueueTypeSymbolInterfacesAndBaseTypes(System.Collections.Generic.Queue{System.Reflection.Metadata.TypeDefinitionHandle},System.Collections.Generic.Queue{`1},`1)">
            <summary>
            Enqueue the interfaces implemented and the type extended by a given TypeDef.
            </summary>
            <param name="typeDefsToSearch">Queue of TypeDefs to search.</param>
            <param name="typeSymbolsToSearch">Queue of TypeSymbols (representing typeRefs to search).</param>
            <param name="typeSymbol">Symbol for which we want to enqueue supertypes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.EnqueueTypeSymbol(System.Collections.Generic.Queue{System.Reflection.Metadata.TypeDefinitionHandle},System.Collections.Generic.Queue{`1},`1)">
            <summary>
            Enqueue the given type as either a def or a ref.
            </summary>
            <param name="typeDefsToSearch">Queue of TypeDefs to search.</param>
            <param name="typeSymbolsToSearch">Queue of TypeSymbols (representing typeRefs to search).</param>
            <param name="typeSymbol">Symbol to enqueue.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.FindMethodSymbolInType(`1,System.Reflection.Metadata.MethodDefinitionHandle)">
            <summary>
            Search the members of a TypeSymbol to find the one that matches a given MethodDef token.
            </summary>
            <param name="type">Type to search for method.</param>
            <param name="methodDef">MethodDef handle of the method to find.</param>
            <returns>The corresponding MethodSymbol or null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.FindFieldSymbolInType(`1,System.Reflection.Metadata.FieldDefinitionHandle)">
            <summary>
            Search the members of a TypeSymbol to find the one that matches a given FieldDef token.
            </summary>
            <param name="type">Type to search for field.</param>
            <param name="fieldDef">FieldDef handle of the field to find.</param>
            <returns>The corresponding FieldSymbol or null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetSymbolForMemberRef(System.Reflection.Metadata.MemberReferenceHandle,`1,System.Boolean)">
            <summary>
            Given a MemberRef token for a method, we can find a corresponding MethodSymbol by
            searching for the name and signature.
            </summary>
            <param name="memberRef">A MemberRef token for a method.</param>
            <param name="implementingTypeSymbol">Scope the search to supertypes of the implementing type.</param>
            <param name="methodsOnly">True to only return method symbols, null if the token resolves to a field.</param>
            <returns>The corresponding MethodSymbol or null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetMethodHandle(`2)">
            <summary>
            Given a method symbol, return the MethodDef token, if it is defined in
            this module, or a nil token, otherwise.
            </summary>
            <param name="method">The method symbol for which to return a MethodDef token.</param>
            <returns>A MethodDef token or nil.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetSymbolForILToken(System.Reflection.Metadata.EntityHandle)">
            <summary>
            Returns a symbol that given token resolves to or null of the token represents an entity that isn't represented by a symbol,
            such as vararg MemberRef.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.GetMemberRefTypeSymbol(System.Reflection.Metadata.MemberReferenceHandle)">
            <summary>
            Given a MemberRef token, return the TypeSymbol for its Class field.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DoPropertySignaturesMatch(Microsoft.CodeAnalysis.ParamInfo{`1}[],Microsoft.CodeAnalysis.ParamInfo{`1}[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Checks whether signatures match where the signatures are either from a property
            and an accessor or two accessors. When comparing a property or getter to setter, the
            setter signature must be the second argument and 'comparingToSetter' must be true.
            </summary>
            <param name="signature1">
            Signature of the property containing the accessor, or the getter (type, then parameters).
            </param>
            <param name="signature2">
            Signature of the accessor when comparing property and accessor,
            or the setter when comparing getter and setter (return type and then parameters).
            </param>
            <param name="comparingToSetter">
            True when comparing a property or getter to a setter, false otherwise.
            </param>
            <param name="compareParamByRef">
            True if differences in IsByRef for parameters should be treated as significant.
            </param>
            <param name="compareReturnType">
            True if differences in return type (or value parameter for setter) should be treated as significant.
            </param>
            <returns>True if the accessor signature is appropriate for the containing property.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataDecoder`5.DoesSignatureMatchEvent(`1,Microsoft.CodeAnalysis.ParamInfo{`1}[])">
            <summary>
            Check whether an event accessor has an appropriate signature.
            </summary>
            <param name="eventType">Type of the event containing the accessor.</param>
            <param name="methodParams">Signature of the accessor (return type and then parameters).</param>
            <returns>True if the accessor signature is appropriate for the containing event.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataHelpers.AssemblyQualifiedTypeName.ArrayRanks">
            <summary>
            Rank equal 0 is used to denote an SzArray, rank equal 1 denotes multi-dimensional array of rank 1.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataHelpers.SerializedTypeDecoder">
            <summary>
            Decodes a serialized type name in its canonical form. The canonical name is its full type name, followed
            optionally by the assembly where it is defined, its version, culture and public key token.  If the assembly
            name is omitted, the type name is in the current assembly otherwise it is in the referenced assembly. The
            full type name is the fully qualified metadata type name. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.SerializedTypeDecoder.DecodeTypeName(System.Boolean,System.Boolean)">
            <summary>
            Decodes a type name.  A type name is a string which is terminated by the end of the string or one of the
            delimiters '+', ',', '[', ']'. '+' separates nested classes. '[' and ']'
            enclosed generic type arguments.  ',' separates types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.SerializedTypeDecoder.DecodeGenericName(System.Int32)">
            <summary>
            Decodes a generic name.  This is a type name followed optionally by a type parameter count
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.SerializedTypeDecoder.DecodeArrayShape(System.Text.StringBuilder,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Int32}@)">
            <summary>
            Rank equal 0 is used to denote an SzArray, rank equal 1 denotes multi-dimensional array of rank 1.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataHelpers.s_splitQualifiedNameSystem">
            <summary>
            An ImmutableArray representing the single string "System"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.GetInfoForImmediateNamespaceMembers(System.Boolean,System.Int32,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}},System.StringComparer,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}}@,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}}}}@)">
            <summary>
            Calculates information about types and namespaces immediately contained within a namespace.
            </summary>
            <param name="isGlobalNamespace">
            Is current namespace a global namespace?
            </param>
            <param name="namespaceNameLength">
            Length of the fully-qualified name of this namespace.
            </param>
            <param name="typesByNS">
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids must be grouped by the 
            fully-qualified namespace name in case-sensitive manner. 
            Key of each IGrouping is a fully-qualified namespace name, which starts with the name of 
            this namespace. There could be multiple groups for each fully-qualified namespace name.
            
            The groups must be sorted by the keys in a manner consistent with comparer passed in as
            nameComparer. Therefore, all types immediately contained within THIS namespace, if any, 
            must be in several IGrouping at the very beginning of the sequence.
            </param>
            <param name="nameComparer">
            Equality comparer to compare namespace names.
            </param>
            <param name="types">
            Output parameter, never null:
            A sequence of groups of TypeDef row ids for types immediately contained within this namespace.
            </param>
            <param name="namespaces">
            Output parameter, never null:
            A sequence with information about namespaces immediately contained within this namespace.
            For each pair:
              Key - contains simple name of a child namespace.
              Value - contains a sequence similar to the one passed to this function, but
                      calculated for the child namespace. 
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.ExtractSimpleNameOfChildNamespace(System.Int32,System.String)">
            <summary>
            Extract a simple name of a top level child namespace from potentially qualified namespace name.
            </summary>
            <param name="parentNamespaceNameLength">
            Parent namespace name length plus the dot.
            </param>
            <param name="fullName">
            Fully qualified namespace name.
            </param>
            <returns>
            Simple name of a top level child namespace, the left-most name following parent namespace name 
            in the fully qualified name.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.IsValidMetadataIdentifier(System.String)">
            <summary>
            Determines whether given string can be used as a non-empty metadata identifier (a NUL-terminated UTF-8 string).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.IsValidUnicodeString(System.String)">
            <summary>
            True if the string doesn't contain incomplete surrogates.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.IsValidMetadataFileName(System.String)">
            <summary>
            Checks that the specified name is a valid metadata String and a file name.
            The specification isn't entirely consistent and complete but it mentions:
            
            22.19.2: "Name shall index a non-empty string in the String heap. It shall be in the format {filename}.{extension} (e.g., 'goo.dll', but not 'c:\utils\goo.dll')."
            22.30.2: "The format of Name is {file name}.{file extension} with no path or drive letter; on POSIX-compliant systems Name contains no colon, no forward-slash, no backslash."
                     As Microsoft specific constraint.
            
            A reasonable restriction seems to be a valid UTF-8 non-empty string that doesn't contain '\0', '\', '/', ':' characters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.SplitNameEqualsFullyQualifiedName(System.String,System.String,System.String)">
            <summary>
            Determine if the given namespace and type names combine to produce the given fully qualified name.
            </summary>
            <param name="namespaceName">The namespace part of the split name.</param>
            <param name="typeName">The type name part of the split name.</param>
            <param name="fullyQualified">The fully qualified name to compare with.</param>
            <returns>true if the combination of <paramref name="namespaceName"/> and <paramref name="typeName"/> equals the fully-qualified name given by <paramref name="fullyQualified"/></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataHelpers.MangleForTypeNameIfNeeded(System.String)">
            <summary>
            Given an input string changes it to be acceptable as a part of a type name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataImportOptions">
            <summary>
            Specifies what symbols to import from metadata.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataImportOptions.Public">
            <summary>
            Only import public and protected symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataImportOptions.Internal">
            <summary>
            Import public, protected and internal symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataImportOptions.All">
            <summary>
            Import all symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReaderExtensions.ReadAssemblyIdentityOrThrow(System.Reflection.Metadata.MetadataReader)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReaderExtensions.GetReferencedAssembliesOrThrow(System.Reflection.Metadata.MetadataReader)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReaderExtensions.GetModuleVersionIdOrThrow(System.Reflection.Metadata.MetadataReader)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReaderExtensions.CreateAssemblyIdentityOrThrow(System.Reflection.Metadata.MetadataReader,System.Version,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Boolean)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReaderExtensions.IsPublicNonInterfaceType(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinition,System.String,System.String)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataTypeName">
            <summary>
            Helper structure to encapsulate/cache various information about metadata name of a type and 
            name resolution options.
            Also, allows us to stop using strings in the APIs that accept only metadata names, 
            making usage of them less bug prone.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName._fullName">
            <summary>
            Full metadata name of a type, includes namespace name for top level types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName._namespaceName">
            <summary>
            Namespace name for top level types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName._typeName">
            <summary>
            Name of the type without namespace prefix, but possibly with generic arity mangling present.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName._unmangledTypeName">
            <summary>
            Name of the type without namespace prefix and without generic arity mangling.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName._inferredArity">
            <summary>
            Arity of the type inferred based on the name mangling. It doesn't have to match the actual
            arity of the type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName._forcedArity">
            <summary>
            While resolving the name, consider only types with this arity.
            (-1) means allow any arity.
            If forcedArity >= 0 and useCLSCompliantNameArityEncoding, lookup may
            fail because forcedArity doesn't match the one encoded in the name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName._useCLSCompliantNameArityEncoding">
            <summary>
            While resolving the name, consider only types following 
            CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
            I.e. arity is inferred from the name and matching type must have the same
            emitted name and arity.
            TODO: PERF: Encode this field elsewhere to save 4 bytes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataTypeName._namespaceSegments">
            <summary>
            Individual parts of qualified namespace name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.FullName">
            <summary>
            Full metadata name of a type, includes namespace name for top level types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.NamespaceName">
            <summary>
            Namespace name for top level types, empty string for nested types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.TypeName">
            <summary>
            Name of the type without namespace prefix, but possibly with generic arity mangling present.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.UnmangledTypeName">
            <summary>
            Name of the type without namespace prefix and without generic arity mangling.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.InferredArity">
            <summary>
            Arity of the type inferred based on the name mangling. It doesn't have to match the actual
            arity of the type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.IsMangled">
            <summary>
            Does name include arity mangling suffix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.UseCLSCompliantNameArityEncoding">
            <summary>
            While resolving the name, consider only types following 
            CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
            I.e. arity is inferred from the name and matching type must have the same
            emitted name and arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.ForcedArity">
            <summary>
            While resolving the name, consider only types with this arity.
            (-1) means allow any arity.
            If ForcedArity >= 0 and UseCLSCompliantNameArityEncoding, lookup may
            fail because ForcedArity doesn't match the one encoded in the name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataTypeName.NamespaceSegments">
            <summary>
            Individual parts of qualified namespace name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataTypeName.Key">
            <summary>
            A digest of MetadataTypeName's fully qualified name which can be used as the key in a dictionary
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleExtensions.ShouldImportNestedType(Microsoft.CodeAnalysis.PEModule,System.Reflection.Metadata.TypeDefinitionHandle)">
            <summary>
            Returns true if the nested type should be imported. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleExtensions.ShouldImportField(Microsoft.CodeAnalysis.PEModule,System.Reflection.Metadata.FieldDefinitionHandle,Microsoft.CodeAnalysis.MetadataImportOptions)">
            <summary>
            Returns true if the field should be imported. Visibility
            and the value of <paramref name="importOptions"/> are considered
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleExtensions.ShouldImportField(System.Reflection.FieldAttributes,Microsoft.CodeAnalysis.MetadataImportOptions)">
            <summary>
            Returns true if the flags represent a field that should be imported.
            Visibility and the value of <paramref name="importOptions"/> are considered
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleExtensions.ShouldImportMethod(Microsoft.CodeAnalysis.PEModule,System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle,Microsoft.CodeAnalysis.MetadataImportOptions)">
            <summary>
            Returns true if the method should be imported. Returns false for private methods that are not
            explicit interface implementations. For other methods, visibility and the value of
            <paramref name="importOptions"/> are considered.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleExtensions.GetVTableGapSize(System.String)">
            <summary>
            Returns 0 if method name doesn't represent a v-table gap.
            Otherwise, returns the gap size.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEAssembly.AssemblyReferences">
            <summary>
            All assemblies this assembly references.
            </summary>
            <remarks>
            A concatenation of assemblies referenced by each module in the order they are listed in <see cref="F:Microsoft.CodeAnalysis.PEAssembly._modules"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEAssembly.ModuleReferenceCounts">
            <summary>
            The number of assemblies referenced by each module in <see cref="F:Microsoft.CodeAnalysis.PEAssembly._modules"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEAssembly._identity">
            <summary>
            Assembly identity read from Assembly table, or null if the table is empty.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEAssembly._lazyContainsNoPiaLocalTypes">
            <summary>
            Using <see cref="T:Microsoft.CodeAnalysis.ThreeState"/> for atomicity.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEAssembly._owner">
            <summary>
            We need to store reference to the assembly metadata to keep the metadata alive while 
            symbols have reference to PEAssembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEAssembly.#ctor(Microsoft.CodeAnalysis.AssemblyMetadata,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.PEModule})">
            <exception cref="T:System.BadImageFormatException"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PEModule">
            <summary>
            A set of helpers for extracting elements from metadata.
            This type is not responsible for managing the underlying storage
            backing the PE image.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEModule._owner">
            <summary>
            We need to store reference to the module metadata to keep the metadata alive while 
            symbols have reference to PEModule.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEModule._lazyForwardedTypesToAssemblyIndexMap">
            <summary>
            This is a tuple for optimization purposes. In valid cases, we need to store
            only one assembly index per type. However, if we found more than one, we
            keep a second one as well to use it for error reporting.
            We use -1 in case there was no forward.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEModule._lazyContainsNoPiaLocalTypes">
            <summary>
            Using <see cref="T:Microsoft.CodeAnalysis.ThreeState"/> as a type for atomicity.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEModule._lazyNoPiaLocalTypeCheckBitMap">
            <summary>
            If bitmap is not null, each bit indicates whether a TypeDef 
            with corresponding RowId has been checked if it is a NoPia 
            local type. If the bit is 1, local type will have an entry 
            in m_lazyTypeDefToTypeIdentifierMap.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PEModule._lazyTypeDefToTypeIdentifierMap">
            <summary>
            For each TypeDef that has 1 in m_lazyNoPiaLocalTypeCheckBitMap,
            this map stores corresponding TypeIdentifier AttributeInfo. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PEModule.Machine">
            <summary>
            Target architecture of the machine.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PEModule.Bit32Required">
            <summary>
            Indicates that this PE file makes Win32 calls. See CorPEKind.pe32BitRequired for more information (http://msdn.microsoft.com/en-us/library/ms230275.aspx).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetModuleVersionIdOrThrow">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMetadataModuleNamesOrThrow">
            <summary>
            Returns the names of linked managed modules.
            </summary>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetReferencedManagedModulesOrThrow">
            <summary>
            Returns names of referenced modules.
            </summary>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetModuleRefNameOrThrow(System.Reflection.Metadata.ModuleReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMemoryReaderOrThrow(System.Reflection.Metadata.BlobHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFullNameOrThrow(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.ReadAssemblyIdentityOrThrow">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetContainingTypeOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefNameOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefNamespaceOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefExtendsOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefFlagsOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefGenericParamsOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.HasGenericParametersOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefPropsOrThrow(System.Reflection.Metadata.TypeDefinitionHandle,System.String@,System.String@,System.Reflection.TypeAttributes@,System.Reflection.Metadata.EntityHandle@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.IsNestedTypeDefOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.IsNestedTypeDefOrThrow(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.IsInterfaceOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeDefsOrThrow(System.Boolean)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GroupTypesByNamespaceOrThrow(System.StringComparer)">
            <summary>
            The function groups types defined in the module by their fully-qualified namespace name.
            The case-sensitivity of the grouping depends upon the provided StringComparer.
            
            The sequence is sorted by name by using provided comparer. Therefore, if there are multiple 
            groups for a namespace name (e.g. because they differ in case), the groups are going to be 
            adjacent to each other. 
            
            Empty string is used as namespace name for types in the Global namespace. Therefore, all types 
            in the Global namespace, if any, should be in the first group (assuming a reasonable StringComparer).
            </summary>
            Comparer to sort the groups.
            <param name="nameComparer">
            </param>
            <returns>A sorted list of TypeDef row ids, grouped by fully-qualified namespace name.</returns>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeNamespaceNamesOrThrow(System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Reflection.Metadata.TypeDefinitionHandle}})">
            <summary>
            Groups together the RowIds of types in a given namespaces.  The types considered are
            those defined in this module.
            </summary>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetForwardedTypeNamespaceNamesOrThrow(System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Reflection.Metadata.TypeDefinitionHandle}})">
            <summary>
            Supplements the namespace-to-RowIDs map with the namespaces of forwarded types.
            These types will not have associated row IDs (represented as null, for efficiency).
            These namespaces are important because we want lookups of missing forwarded types
            to succeed far enough that we can actually find the type forwarder and provide
            information about the target assembly.
            
            For example, consider the following forwarded type:
            
            .class extern forwarder Namespace.Type {}
            
            If this type is referenced in source as "Namespace.Type", then dev10 reports
            
            error CS1070: The type name 'Namespace.Name' could not be found. This type has been 
            forwarded to assembly 'pe2, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'. 
            Consider adding a reference to that assembly.
            
            If we did not include "Namespace" as a child of the global namespace of this module
            (the forwarding module), then Roslyn would report that the type "Namespace" was not
            found and say nothing about "Name" (because of the diagnostic already attached to 
            the qualifier).
            </summary>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetNestedTypeDefsOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodImplementationsOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetInterfaceImplementationsOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <summary>
            Returns a collection of interfaces implemented by given type.
            </summary>
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodsOfTypeOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetPropertiesOfTypeOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetEventsOfTypeOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFieldsOfTypeOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetBaseTypeOfTypeOrThrow(System.Reflection.Metadata.TypeDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMemberNotNullAttributeValues(System.Reflection.Metadata.EntityHandle)">
            <summary>
            Find the MemberNotNull attribute(s) and extract the list of referenced member names
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMemberNotNullWhenAttributeValues(System.Reflection.Metadata.EntityHandle)">
            <summary>
            Find the MemberNotNullWhen attribute(s) and extract the list of referenced member names
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.CrackObsoleteProperties(System.Reflection.Metadata.BlobReader@,Microsoft.CodeAnalysis.IAttributeNamedArgumentDecoder)">
            <summary>
            Gets the well-known optional named properties on ObsoleteAttribute, if present.
            Both 'diagnosticId' and 'urlFormat' may be present, or only one, or neither.
            </summary>
            <remarks>
            Failure to find any of these properties does not imply failure to decode the ObsoleteAttribute,
            so we don't return a value indicating success or failure.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetParamArrayCountOrThrow(System.Reflection.Metadata.EntityHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.IsTypeIdentifierAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
            <summary>
            Determine if custom attribute application is 
            NoPia TypeIdentifier.
            </summary>
            <returns>
            An index of the target constructor signature in 
            signaturesOfTypeIdentifierAttribute array, -1 if
            this is not NoPia TypeIdentifier.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.IsTargetAttribute(System.Reflection.Metadata.CustomAttributeHandle,System.String,System.String,System.Reflection.Metadata.EntityHandle@,System.Boolean)">
            <summary>
            Determines if a custom attribute matches a namespace and name.
            </summary>
            <param name="customAttribute">Handle of the custom attribute.</param>
            <param name="namespaceName">The custom attribute's namespace in metadata format (case sensitive)</param>
            <param name="typeName">The custom attribute's type name in metadata format (case sensitive)</param>
            <param name="ctor">Constructor of the custom attribute.</param>
            <param name="ignoreCase">Should case be ignored for name comparison?</param>
            <returns>true if match is found</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.IsTargetAttribute(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.CustomAttributeHandle,System.String,System.String,System.Reflection.Metadata.EntityHandle@,System.Boolean)">
            <summary>
            Determines if a custom attribute matches a namespace and name.
            </summary>
            <param name="metadataReader">The metadata reader.</param>
            <param name="customAttribute">Handle of the custom attribute.</param>
            <param name="namespaceName">The custom attribute's namespace in metadata format (case sensitive)</param>
            <param name="typeName">The custom attribute's type name in metadata format (case sensitive)</param>
            <param name="ctor">Constructor of the custom attribute.</param>
            <param name="ignoreCase">Should case be ignored for name comparison?</param>
            <returns>true if match is found</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetAssemblyRef(System.String)">
            <summary>
            Returns MetadataToken for assembly ref matching name
            </summary>
            <param name="assemblyName">The assembly name in metadata format (case sensitive)</param>
            <returns>Matching assembly ref token or nil (0)</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeRef(System.Reflection.Metadata.EntityHandle,System.String,System.String)">
            <summary>
            Returns MetadataToken for type ref matching resolution scope and name
            </summary>
            <param name="resolutionScope">The resolution scope token</param>
            <param name="namespaceName">The namespace name in metadata format (case sensitive)</param>
            <param name="typeName">The type name in metadata format (case sensitive)</param>
            <returns>Matching type ref token or nil (0)</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeRefPropsOrThrow(System.Reflection.Metadata.TypeReferenceHandle,System.String@,System.String@,System.Reflection.Metadata.EntityHandle@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTargetAttributeSignatureIndex(System.Reflection.Metadata.CustomAttributeHandle,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Determine if custom attribute matches the target attribute.
            </summary>
            <param name="customAttribute">
            Handle of the custom attribute.
            </param>
            <param name="description">The attribute to match.</param>
            <returns>
            An index of the target constructor signature in
            signatures array, -1 if
            this is not the target attribute.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTargetAttributeSignatureIndex(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.CustomAttributeHandle,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Determine if custom attribute matches the target attribute.
            </summary>
            <param name="metadataReader">
            The metadata reader.
            </param>
            <param name="customAttribute">
            Handle of the custom attribute.
            </param>
            <param name="description">The attribute to match.</param>
            <returns>
            An index of the target constructor signature in
            signatures array, -1 if
            this is not the target attribute.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeAndConstructor(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.EntityHandle@,System.Reflection.Metadata.EntityHandle@)">
            <summary>
            Given a token for a constructor, return the token for the constructor's type and the blob containing the
            constructor's signature.
            </summary>
            <returns>True if the function successfully returns the type and signature.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeAndConstructor(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.EntityHandle@,System.Reflection.Metadata.EntityHandle@)">
            <summary>
            Given a token for a constructor, return the token for the constructor's type and the blob containing the
            constructor's signature.
            </summary>
            <returns>True if the function successfully returns the type and signature.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetAttributeNamespaceAndName(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle@,System.Reflection.Metadata.StringHandle@)">
            <summary>
            Given a token for a type, return the type's name and namespace.  Only works for top level types. 
            namespaceHandle will be NamespaceDefinitionHandle for defs and StringHandle for refs. 
            </summary>
            <returns>True if the function successfully returns the name and namespace.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetAttributeNamespaceAndName(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle@,System.Reflection.Metadata.StringHandle@)">
            <summary>
            Given a token for a type, return the type's name and namespace.  Only works for top level types. 
            namespaceHandle will be NamespaceDefinitionHandle for defs and StringHandle for refs. 
            </summary>
            <returns>True if the function successfully returns the name and namespace.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.PretendThereArentNoPiaLocalTypes">
            <summary>
            For testing purposes only!!!
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetTypeSpecificationSignatureReaderOrThrow(System.Reflection.Metadata.TypeSpecificationHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodSpecificationOrThrow(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.EntityHandle@,System.Reflection.Metadata.BlobHandle@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetGenericParamPropsOrThrow(System.Reflection.Metadata.GenericParameterHandle,System.String@,System.Reflection.GenericParameterAttributes@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodDefNameOrThrow(System.Reflection.Metadata.MethodDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodSignatureOrThrow(System.Reflection.Metadata.MethodDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodSignatureOrThrow(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.MethodDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodSignatureOrThrow(System.Reflection.Metadata.EntityHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodSignatureOrThrow(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodDefFlagsOrThrow(System.Reflection.Metadata.MethodDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.FindContainingTypeOrThrow(System.Reflection.Metadata.MethodDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.FindContainingTypeOrThrow(System.Reflection.Metadata.FieldDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetContainingTypeOrThrow(System.Reflection.Metadata.MemberReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodDefPropsOrThrow(System.Reflection.Metadata.MethodDefinitionHandle,System.String@,System.Reflection.MethodImplAttributes@,System.Reflection.MethodAttributes@,System.Int32@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodImplPropsOrThrow(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.EntityHandle@,System.Reflection.Metadata.EntityHandle@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetGenericParametersForMethodOrThrow(System.Reflection.Metadata.MethodDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetParametersOfMethodOrThrow(System.Reflection.Metadata.MethodDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMemberRefNameOrThrow(System.Reflection.Metadata.MemberReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMemberRefNameOrThrow(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.MemberReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetSignatureOrThrow(System.Reflection.Metadata.MemberReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetSignatureOrThrow(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.MemberReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMemberRefPropsOrThrow(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.EntityHandle@,System.String@,System.Byte[]@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetParamPropsOrThrow(System.Reflection.Metadata.ParameterHandle,System.String@,System.Reflection.ParameterAttributes@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetParamNameOrThrow(System.Reflection.Metadata.ParameterHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetParameterSequenceNumberOrThrow(System.Reflection.Metadata.ParameterHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetPropertyDefNameOrThrow(System.Reflection.Metadata.PropertyDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetPropertySignatureOrThrow(System.Reflection.Metadata.PropertyDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetPropertyDefPropsOrThrow(System.Reflection.Metadata.PropertyDefinitionHandle,System.String@,System.Reflection.PropertyAttributes@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetEventDefNameOrThrow(System.Reflection.Metadata.EventDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetEventDefPropsOrThrow(System.Reflection.Metadata.EventDefinitionHandle,System.String@,System.Reflection.EventAttributes@,System.Reflection.Metadata.EntityHandle@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFieldDefNameOrThrow(System.Reflection.Metadata.FieldDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFieldSignatureOrThrow(System.Reflection.Metadata.FieldDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFieldDefFlagsOrThrow(System.Reflection.Metadata.FieldDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetFieldDefPropsOrThrow(System.Reflection.Metadata.FieldDefinitionHandle,System.String@,System.Reflection.FieldAttributes@)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetCustomAttributesOrThrow(System.Reflection.Metadata.EntityHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetCustomAttributeValueOrThrow(System.Reflection.Metadata.CustomAttributeHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMarshallingDescriptorHandleOrThrow(System.Reflection.Metadata.EntityHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetConstantValueOrThrow(System.Reflection.Metadata.ConstantHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetPropertyMethodsOrThrow(System.Reflection.Metadata.PropertyDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetEventMethodsOrThrow(System.Reflection.Metadata.EventDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetAssemblyReferenceIndexOrThrow(System.Reflection.Metadata.AssemblyReferenceHandle)">
            <exception cref="T:System.BadImageFormatException">An exception from metadata reader.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PEModule.HasIL">
            <summary>
            Returns true if method IL can be retrieved from the module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PEModule.IsEntireImageAvailable">
            <summary>
            Returns true if the full image of the module is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PEModule.GetMethodBodyOrThrow(System.Reflection.Metadata.MethodDefinitionHandle)">
            <exception cref="T:System.BadImageFormatException">Invalid metadata.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolFactory`2.MakeUnboundIfGeneric(`0,`1)">
            <summary>
            Produce unbound generic type symbol if the type is a generic type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolFactory`2.SubstituteTypeParameters(`0,`1,System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{`1,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ModifierInfo{`1}}}},System.Collections.Immutable.ImmutableArray{System.Boolean})">
            <summary>
            Produce constructed type symbol.
            </summary>
            <param name="moduleSymbol"></param>
            <param name="generic">
            Symbol for generic type.
            </param>
            <param name="arguments">
            Generic type arguments, including those for containing types.
            </param>
            <param name="refersToNoPiaLocalType">
            Flags for arguments. Each item indicates whether corresponding argument refers to NoPia local types.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TypeAttributesExtensions.ToCharSet(System.Reflection.TypeAttributes)">
            <summary>
            Extracts <see cref="T:System.Runtime.InteropServices.CharSet"/> information from TypeDef flags.
            Returns 0 if the value is invalid.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TypeNameDecoder`2.LookupTopLevelTypeDefSymbol(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean@)">
            <summary>
            Lookup a type defined in this module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TypeNameDecoder`2.LookupTopLevelTypeDefSymbol(System.Int32,Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a type defined in referenced assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TypeNameDecoder`2.GetIndexOfReferencedAssembly(Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Given the identity of an assembly referenced by this module, finds
            the index of that assembly in the list of assemblies referenced by
            the current module.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyIdentity">
            <summary>
            Represents an identity of an assembly as defined by CLI metadata specification.
            </summary>
            <remarks>
            May represent assembly definition or assembly reference identity.
            </remarks>
            <summary>
            Represents an identity of an assembly as defined by CLI metadata specification.
            </summary>
            <remarks>
            May represent assembly definition or assembly reference identity.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.#ctor(System.String,System.Version,System.String,System.Collections.Immutable.ImmutableArray{System.Byte},System.Boolean,System.Boolean,System.Reflection.AssemblyContentType)">
            <summary>
            Constructs an <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/> from its constituent parts.
            </summary>
            <param name="name">The simple name of the assembly.</param>
            <param name="version">The version of the assembly.</param>
            <param name="cultureName">
            The name of the culture to associate with the assembly. 
            Specify null, <see cref="F:System.String.Empty"/>, or "neutral" (any casing) to represent <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            The name can be an arbitrary string that doesn't contain NUL character, the legality of the culture name is not validated.
            </param>
            <param name="publicKeyOrToken">The public key or public key token of the assembly.</param>
            <param name="hasPublicKey">Indicates whether <paramref name="publicKeyOrToken"/> represents a public key.</param>
            <param name="isRetargetable">Indicates whether the assembly is retargetable.</param>
            <param name="contentType">Specifies the binding model for how this object will be treated in comparisons.</param>
            <exception cref="T:System.ArgumentException">If <paramref name="name"/> is null, empty or contains a NUL character.</exception>
            <exception cref="T:System.ArgumentException">If <paramref name="cultureName"/> contains a NUL character.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="contentType"/> is not a value of the <see cref="T:System.Reflection.AssemblyContentType"/> enumeration.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="version"/> contains values that are not greater than or equal to zero and less than or equal to ushort.MaxValue.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="hasPublicKey"/> is true and <paramref name="publicKeyOrToken"/> is not set.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="hasPublicKey"/> is false and <paramref name="publicKeyOrToken"/> 
            contains a value that is not the size of a public key token, 8 bytes.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.Name">
            <summary>
            The simple name of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.Version">
            <summary>
            The version of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.CultureName">
            <summary>
            The culture name of the assembly, or empty if the culture is neutral.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.Flags">
            <summary>
            The AssemblyNameFlags.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.ContentType">
            <summary>
            Specifies assembly binding model for the assembly definition or reference;
            that is how assembly references are matched to assembly definitions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.HasPublicKey">
            <summary>
            True if the assembly identity includes full public key.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.PublicKey">
            <summary>
            Full public key or empty.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.PublicKeyToken">
            <summary>
            Low 8 bytes of SHA1 hash of the public key, or empty.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.IsStrongName">
            <summary>
            True if the assembly identity has a strong name, ie. either a full public key or a token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyIdentity.IsRetargetable">
            <summary>
            Gets the value which specifies if the assembly is retargetable. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.op_Equality(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/> instances are equal.
            </summary>
            <param name="left">The operand appearing on the left side of the operator.</param>
            <param name="right">The operand appearing on the right side of the operator.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.op_Inequality(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/> instances are not equal.
            </summary>
            <param name="left">The operand appearing on the left side of the operator.</param>
            <param name="right">The operand appearing on the right side of the operator.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.Equals(Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Determines whether the specified instance is equal to the current instance.
            </summary>
            <param name="obj">The object to be compared with the current instance.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.Equals(System.Object)">
            <summary>
            Determines whether the specified instance is equal to the current instance.
            </summary>
            <param name="obj">The object to be compared with the current instance.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.GetHashCode">
            <summary>
            Returns the hash code for the current instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.MemberwiseEqual(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Returns true (false) if specified assembly identities are (not) equal 
            regardless of unification, retargeting or other assembly binding policies. 
            Returns null if these policies must be consulted to determine name equivalence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.FromAssemblyDefinition(System.Reflection.Assembly)">
            <summary>
            Retrieves assembly definition identity from given runtime assembly.
            </summary>
            <param name="assembly">The runtime assembly.</param>
            <returns>Assembly definition identity.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.GetDisplayName(System.Boolean)">
            <summary>
            Returns the display name of the assembly identity.
            </summary>
            <param name="fullKey">True if the full public key should be included in the name. Otherwise public key token is used.</param>
            <returns>The display name.</returns>
            <remarks>
            Characters ',', '=', '"', '\'', '\' occurring in the simple name are escaped by backslash in the display name.
            Any character '\t' is replaced by two characters '\' and 't',
            Any character '\n' is replaced by two characters '\' and 'n',
            Any character '\r' is replaced by two characters '\' and 'r',
            The assembly name in the display name is enclosed in double quotes if it starts or ends with 
            a whitespace character (' ', '\t', '\r', '\n').
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.ToString">
            <summary>
            Returns the display name of the current instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentity.TryParseDisplayName(System.String,Microsoft.CodeAnalysis.AssemblyIdentity@,Microsoft.CodeAnalysis.AssemblyIdentityParts@)">
            <summary>
            Parses display name filling defaults for any basic properties that are missing.
            </summary>
            <param name="displayName">Display name.</param>
            <param name="identity">A full assembly identity.</param>
            <param name="parts">
            Parts of the assembly identity that were specified in the display name, 
            or 0 if the parsing failed.
            </param>
            <returns>True if display name parsed correctly.</returns>
            <remarks>
            The simple name has to be non-empty.
            A partially specified version might be missing build and/or revision number. The default value for these is 65535.
            The default culture is neutral (<see cref="P:Microsoft.CodeAnalysis.AssemblyIdentity.CultureName"/> is <see cref="F:System.String.Empty"/>.
            If neither public key nor token is specified the identity is considered weak.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="displayName"/> is null.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyIdentityComparer">
            <summary>
            Compares assembly identities. 
            Derived types may implement platform specific unification and portability policies.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult">
            <summary>
            A set of possible outcomes of <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/> comparison.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult.NotEquivalent">
            <summary>
            Reference doesn't match definition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult.Equivalent">
            <summary>
            Strongly named reference matches strongly named definition (strong identity is identity with public key or token),
            Or weak reference matches weak definition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult.EquivalentIgnoringVersion">
            <summary>
            Reference matches definition except for version (reference version is lower or higher than definition version).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ReferenceMatchesDefinition(System.String,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Compares assembly reference name (possibly partial) with definition identity.
            </summary>
            <param name="referenceDisplayName">Partial or full assembly display name.</param>
            <param name="definition">Full assembly display name.</param>
            <returns>True if the reference name matches the definition identity.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ReferenceMatchesDefinition(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Compares assembly reference identity with definition identity.
            </summary>
            <param name="reference">Reference assembly identity.</param>
            <param name="definition">Full assembly display name.</param>
            <returns>True if the reference identity matches the definition identity.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.Compare(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Compares reference assembly identity with definition identity and returns their relationship.
            </summary>
            <param name="reference">Reference identity.</param>
            <param name="definition">Definition identity.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyIdentityMap`1">
            <summary>
            Implements a map from an assembly identity to a value. The map allows to look up the value by an identity
            that either exactly matches the original identity key, or corresponds to a key with the lowest version among identities
            with higher version than the requested identity key.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AssemblyMetadata">
            <summary>
            Represents an immutable snapshot of assembly CLI metadata.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AssemblyMetadata._moduleFactoryOpt">
            <summary>
            Factory that provides the <see cref="T:Microsoft.CodeAnalysis.ModuleMetadata"/> for additional modules (other than <see cref="F:Microsoft.CodeAnalysis.AssemblyMetadata._initialModules"/>) of the assembly.
            Shall only throw <see cref="T:System.BadImageFormatException"/> or <see cref="T:System.IO.IOException"/>.
            Null of all modules were specified at construction time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AssemblyMetadata._initialModules">
            <summary>
            Modules the <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata"/> was created with, in case they are eagerly allocated.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AssemblyMetadata.CachedSymbols">
            <summary>
            Cached assembly symbols.
            </summary>
            <remarks>
            Guarded by <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="peImage">
            Manifest module image.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="peImage">
            Manifest module image.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is null.</exception>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="peStream">Manifest module PE image stream.</param>
            <param name="leaveOpen">False to close the stream upon disposal of the metadata.</param>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="peStream">Manifest module PE image stream.</param>
            <param name="options">False to close the stream upon disposal of the metadata.</param>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)">
            <summary>
            Finds all modules of an assembly on a specified path and builds an instance of <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata"/> that represents them.
            </summary>
            <param name="path">The full path to the assembly on disk.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">Error reading file <paramref name="path"/>. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
            <exception cref="T:System.NotSupportedException">Reading from a file path is not supported by the platform.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(Microsoft.CodeAnalysis.ModuleMetadata)">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="module">
            Manifest module.
            </param>
            <remarks>This object disposes <paramref name="module"/> it when it is itself disposed.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ModuleMetadata})">
            <summary>
            Creates a multi-module assembly.
            </summary>
            <param name="modules">
            Modules comprising the assembly. The first module is the manifest module of the assembly.</param>
            <remarks>This object disposes the elements of <paramref name="modules"/> it when it is itself <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose"/>.</remarks>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is default value.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="modules"/> contains null elements.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is empty or contains a module that doesn't own its image (was created via <see cref="M:Microsoft.CodeAnalysis.Metadata.Copy"/>).</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ModuleMetadata})">
            <summary>
            Creates a multi-module assembly.
            </summary>
            <param name="modules">
            Modules comprising the assembly. The first module is the manifest module of the assembly.</param>
            <remarks>This object disposes the elements of <paramref name="modules"/> it when it is itself <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose"/>.</remarks>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is default value.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="modules"/> contains null elements.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is empty or contains a module that doesn't own its image (was created via <see cref="M:Microsoft.CodeAnalysis.Metadata.Copy"/>).</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(Microsoft.CodeAnalysis.ModuleMetadata[])">
            <summary>
            Creates a multi-module assembly.
            </summary>
            <param name="modules">Modules comprising the assembly. The first module is the manifest module of the assembly.</param>
            <remarks>This object disposes the elements of <paramref name="modules"/> it when it is itself <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose"/>.</remarks>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is default value.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="modules"/> contains null elements.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is empty or contains a module that doesn't own its image (was created via <see cref="M:Microsoft.CodeAnalysis.Metadata.Copy"/>).</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Copy">
            <summary>
            Creates a shallow copy of contained modules and wraps them into a new instance of <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata"/>.
            </summary>
            <remarks>
            The resulting copy shares the metadata images and metadata information read from them with the original.
            It doesn't own the underlying metadata images and is not responsible for its disposal.
            
            This is used, for example, when a metadata cache needs to return the cached metadata to its users
            while keeping the ownership of the cached metadata object.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetModules">
            <summary>
            Modules comprising this assembly. The first module is the manifest module.
            </summary>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
            <exception cref="T:System.IO.IOException">IO error reading the metadata. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetAssembly">
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
            <exception cref="T:System.IO.IOException">IO error while reading the metadata. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetOrCreateData">
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
            <exception cref="T:System.IO.IOException">IO error while reading the metadata. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose">
            <summary>
            Disposes all modules contained in the assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.IsValidAssembly">
            <summary>
            Checks if the first module has a single row in Assembly table and that all other modules have none.
            </summary>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
            <exception cref="T:System.IO.IOException">IO error reading the metadata. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AssemblyMetadata.Kind">
            <summary>
            Returns the metadata kind. <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)">
            <summary>
            Creates a reference to the assembly metadata.
            </summary>
            <param name="documentation">Provider of XML documentation comments for the metadata symbols contained in the module.</param>
            <param name="aliases">Aliases that can be used to refer to the assembly from source code (see "extern alias" directive in C#).</param>
            <param name="embedInteropTypes">True to embed interop types from the referenced assembly to the referencing compilation. Must be false for a module.</param>
            <param name="filePath">Path describing the location of the metadata, or null if the metadata have no location.</param>
            <param name="display">Display string used in error messages to identity the reference.</param>
            <returns>A reference to the assembly metadata.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CompilationReference">
            <summary>
            Reference to another C# or VB compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationReference.WithAliases(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns an instance of the reference with specified aliases.
            </summary>
            <param name="aliases">The new aliases for the reference.</param>
            <exception cref="T:System.ArgumentException">Alias is invalid for the metadata kind.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationReference.WithAliases(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Returns an instance of the reference with specified aliases.
            </summary>
            <param name="aliases">The new aliases for the reference.</param>
            <exception cref="T:System.ArgumentException">Alias is invalid for the metadata kind.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationReference.WithEmbedInteropTypes(System.Boolean)">
            <summary>
            Returns an instance of the reference with specified interop types embedding.
            </summary>
            <param name="value">The new value for <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes"/>.</param>
            <exception cref="T:System.ArgumentException">Interop types can't be embedded from modules.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)">
            <summary>
            Returns an instance of the reference with specified properties, or this instance if properties haven't changed.
            </summary>
            <param name="properties">The new properties for the reference.</param>
            <exception cref="T:System.ArgumentException">Specified values not valid for this reference.</exception> 
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataId">
            <summary>
            An Id that can be used to identify a metadata instance.  If two metadata instances 
            have the same id then they are guaranteed to have the same content.  If two metadata
            instances have different ids, then the contents may or may not be the same.  As such,
            the id is useful as a key in a cache when a client wants to share data for a metadata
            reference as long as it has not changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Metadata">
            <summary>
            Represents immutable assembly or module CLI metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Metadata.Id">
            <summary>
            The id for this metadata instance.  If two metadata instances have the same id, then 
            they have the same content.  If they have different ids they may or may not have the
            same content.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Metadata.Kind">
            <summary>
            Retrieves the <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind"/> for this instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Metadata.Dispose">
            <summary>
            Releases any resources associated with this instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Metadata.Copy">
            <summary>
            Creates a copy of this object.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataImageKind">
            <summary>
            The kind of metadata a PE file image contains.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataImageKind.Assembly">
            <summary>
            The PE file is an assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataImageKind.Module">
            <summary>
            The PE file is a module.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataImageReference">
            <summary>
            Represents an in-memory Portable-Executable image.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataReference">
            <summary>
            Represents metadata image reference.
            </summary>
            <remarks>
            Represents a logical location of the image, not the content of the image. 
            The content might change in time. A snapshot is taken when the compiler queries the reference for its metadata.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReference.Display">
            <summary>
            Path or name used in error messages to identity the reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReference.IsUnresolved">
            <summary>
            Returns true if this reference is an unresolved reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReference.WithAliases(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns an instance of the reference with specified aliases.
            </summary>
            <param name="aliases">The new aliases for the reference.</param>
            <exception cref="T:System.ArgumentException">Alias is invalid for the metadata kind.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReference.WithEmbedInteropTypes(System.Boolean)">
            <summary>
            Returns an instance of the reference with specified interop types embedding.
            </summary>
            <param name="value">The new value for <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes"/>.</param>
            <exception cref="T:System.ArgumentException">Interop types can't be embedded from modules.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReference.WithAliases(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Returns an instance of the reference with specified aliases.
            </summary>
            <param name="aliases">The new aliases for the reference.</param>
            <exception cref="T:System.ArgumentException">Alias is invalid for the metadata kind.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)">
            <summary>
            Returns an instance of the reference with specified properties, or this instance if properties haven't changed.
            </summary>
            <param name="properties">The new properties for the reference.</param>
            <exception cref="T:System.ArgumentException">Specified values not valid for this reference.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte},Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)">
            <summary>
            Creates a reference to a single-module assembly or a standalone module stored in memory.
            </summary>
            <param name="peImage">Assembly image.</param>
            <param name="properties">Reference properties (extern aliases, type embedding, <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind"/>).</param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <param name="filePath">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>
            <remarks>
            Performance considerations: 
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})"/> or <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})"/> 
            API when creating multiple references to the same metadata.
            Reusing <see cref="T:Microsoft.CodeAnalysis.Metadata"/> object to create multiple references allows for sharing data across these references.
            </para> 
            <para>
            The method pins <paramref name="peImage"/> in managed heap. The pinned memory is released 
            when the resulting reference becomes unreachable and GC collects it. To control the lifetime of the pinned memory 
            deterministically use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})"/> 
            to create an <see cref="T:System.IDisposable"/> metadata object and 
            <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)"/> to get a reference to it.
            </para>
            <para>
            The method creates a reference to a single-module assembly. To create a reference to a multi-module assembly or a stand-alone module use 
            <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})"/> and <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.String,System.String)"/>.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromImage(System.Collections.Generic.IEnumerable{System.Byte},Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)">
            <summary>
            Creates a reference to a single-module assembly or a standalone module stored in memory.
            </summary>
            <param name="peImage">Assembly image.</param>
            <param name="properties">Reference properties (extern aliases, type embedding, <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind"/>).</param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <param name="filePath">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>
            <remarks>
            Performance considerations: 
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(System.Collections.Generic.IEnumerable{System.Byte})"/> or <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.Collections.Generic.IEnumerable{System.Byte})"/> 
            API when creating multiple references to the same metadata.
            Reusing <see cref="T:Microsoft.CodeAnalysis.Metadata"/> object to create multiple references allows for sharing data across these references.
            </para> 
            <para>
            The method makes a copy of the data and pins it. To avoid making a copy use an overload that takes an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.
            The pinned memory is released when the resulting reference becomes unreachable and GC collects it. To control the lifetime of the pinned memory 
            deterministically use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)"/> 
            to create an <see cref="T:System.IDisposable"/> metadata object and 
            <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)"/> to get a reference to it.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromStream(System.IO.Stream,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)">
            <summary>
            Creates a reference to a single-module assembly or a stand-alone module from data in specified stream. 
            Reads the content of the stream into memory and closes the stream upon return.
            </summary>
            <param name="peStream">Assembly image.</param>
            <param name="properties">Reference properties (extern aliases, type embedding, <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind"/>).</param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <param name="filePath">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>
            <exception cref="T:System.ArgumentException"><paramref name="peStream"/> doesn't support read and seek operations.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
            <exception cref="T:System.IO.IOException">An error occurred while reading the stream.</exception>
            <remarks>
            Performance considerations: 
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)"/> or <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)"/> 
            API when creating multiple references to the same metadata.
            Reusing <see cref="T:Microsoft.CodeAnalysis.Metadata"/> object to create multiple references allows for sharing data across these references.
            </para> 
            <para>
            The method eagerly reads the entire content of <paramref name="peStream"/> into native heap. The native memory block is released 
            when the resulting reference becomes unreachable and GC collects it. To decrease memory footprint of the reference and/or manage
            the lifetime deterministically use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)"/> 
            to create an <see cref="T:System.IDisposable"/> metadata object and 
            <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)"/>
            to get a reference to it.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)">
            <summary>
            Creates a reference to an assembly or standalone module stored in a file.
            Reads the content of the file into memory.
            </summary>
            <param name="path">Path to the assembly file.</param>
            <param name="properties">Reference properties (extern aliases, type embedding, <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind"/>).</param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">An error occurred while reading the file.</exception>
            <remarks>
            Performance considerations:
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)"/> or <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromFile(System.String)"/> 
            API when creating multiple references to the same file.
            Reusing <see cref="T:Microsoft.CodeAnalysis.Metadata"/> object allows for sharing data across these references.
            </para> 
            <para>
            The method eagerly reads the entire content of the file into native heap. The native memory block is released 
            when the resulting reference becomes unreachable and GC collects it. To decrease memory footprint of the reference and/or manage
            the lifetime deterministically use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)"/> 
            to create an <see cref="T:System.IDisposable"/> metadata object and 
            <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)"/> 
            to get a reference to it.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly(System.Reflection.Assembly)">
            <summary>
            Creates a reference to a loaded assembly.
            </summary>
            <param name="assembly">Path to the module file.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="assembly"/> is dynamic, doesn't have a location, or the platform doesn't support reading from the location.</exception>
            <remarks>
            Performance considerations:
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)"/> API when creating multiple references to the same assembly.
            Reusing <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata"/> object allows for sharing data across these references.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly(System.Reflection.Assembly,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)">
            <summary>
            Creates a reference to a loaded assembly.
            </summary>
            <param name="assembly">Path to the module file.</param>
            <param name="properties">Reference properties (extern aliases, type embedding).</param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="properties"/>.<see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind"/> is not <see cref="F:Microsoft.CodeAnalysis.MetadataImageKind.Assembly"/>.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="assembly"/> is dynamic, doesn't have a location, or the platform doesn't support reading from the location.</exception>
            <remarks>
            Performance considerations:
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)"/> API when creating multiple references to the same assembly.
            Reusing <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata"/> object allows for sharing data across these references.
            </para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataReferenceProperties">
            <summary>
            Information about a metadata reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Module">
            <summary>
            Default properties for a module reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Assembly">
            <summary>
            Default properties for an assembly reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReferenceProperties.#ctor(Microsoft.CodeAnalysis.MetadataImageKind,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean)">
            <summary>
            Initializes reference properties.
            </summary>
            <param name="kind">The image kind - assembly or module.</param>
            <param name="aliases">Assembly aliases. Can't be set for a module.</param>
            <param name="embedInteropTypes">True to embed interop types from the referenced assembly to the referencing compilation. Must be false for a module.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReferenceProperties.WithAliases(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.MetadataReferenceProperties"/> with specified aliases.
            </summary>
            <exception cref="T:System.ArgumentException">
            <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind"/> is <see cref="F:Microsoft.CodeAnalysis.MetadataImageKind.Module"/>, as modules can't be aliased.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReferenceProperties.WithAliases(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.MetadataReferenceProperties"/> with specified aliases.
            </summary>
            <exception cref="T:System.ArgumentException">
            <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind"/> is <see cref="F:Microsoft.CodeAnalysis.MetadataImageKind.Module"/>, as modules can't be aliased.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReferenceProperties.WithEmbedInteropTypes(System.Boolean)">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.MetadataReferenceProperties"/> with <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes"/> set to specified value.
            </summary>
            <exception cref="T:System.ArgumentException"><see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind"/> is <see cref="F:Microsoft.CodeAnalysis.MetadataImageKind.Module"/>, as interop types can't be embedded from modules.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReferenceProperties.WithRecursiveAliases(System.Boolean)">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.MetadataReferenceProperties"/> with <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.HasRecursiveAliases"/> set to specified value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind">
            <summary>
            The image kind (assembly or module) the reference refers to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.GlobalAlias">
            <summary>
            Alias that represents a global declaration space.
            </summary>
            <remarks>
            Namespaces in references whose <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Aliases"/> contain <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.GlobalAlias"/> are available in global declaration space.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Aliases">
            <summary>
            Aliases for the metadata reference. Empty if the reference has no aliases.
            </summary>
            <remarks>
            In C# these aliases can be used in "extern alias" syntax to disambiguate type names. 
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes">
            <summary>
            True if interop types defined in the referenced metadata should be embedded into the compilation referencing the metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.HasRecursiveAliases">
            <summary>
            True to apply <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Aliases"/> recursively on the target assembly and on all its transitive dependencies.
            False to apply <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Aliases"/> only on the target assembly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataReferenceResolver">
            <summary>
            Resolves references to metadata specified in the source (#r directives).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataReferenceResolver.ResolveMissingAssemblies">
            <summary>
            True to instruct the compiler to invoke <see cref="M:Microsoft.CodeAnalysis.MetadataReferenceResolver.ResolveMissingAssembly(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.AssemblyIdentity)"/> for each assembly reference that
            doesn't match any of the assemblies explicitly referenced by the <see cref="T:Microsoft.CodeAnalysis.Compilation"/> (via <see cref="P:Microsoft.CodeAnalysis.Compilation.ExternalReferences"/>, or #r directives.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataReferenceResolver.ResolveMissingAssembly(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Resolves a missing assembly reference.
            </summary>
            <param name="definition">The metadata definition (assembly or module) that declares assembly reference <paramref name="referenceIdentity"/> in its list of dependencies.</param>
            <param name="referenceIdentity">Identity of the assembly reference that couldn't be resolved against metadata references explicitly specified to in the compilation.</param>
            <returns>Resolved reference or null if the identity can't be resolved.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ModuleMetadata">
            <summary>
            Represents an immutable snapshot of module CLI metadata.
            </summary>
            <remarks>This object may allocate significant resources or lock files depending upon how it is constructed.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ModuleMetadata._onDispose">
            <summary>
            Optional action to invoke when this metadata is disposed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromMetadata(System.IntPtr,System.Int32)">
            <summary>
            Create metadata module from a raw memory pointer to metadata directory of a PE image or .cormeta section of an object file.
            Only manifest modules are currently supported.
            </summary>
            <param name="metadata">Pointer to the start of metadata block.</param>
            <param name="size">The size of the metadata block.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadata"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size"/> is not positive.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromMetadata(System.IntPtr,System.Int32,System.Action)">
            <summary>
            Create metadata module from a raw memory pointer to metadata directory of a PE image or .cormeta section of an object file.
            Only manifest modules are currently supported.
            </summary>
            <param name="metadata">Pointer to the start of metadata block.</param>
            <param name="size">The size of the metadata block.</param>
            <param name="onDispose">Action to run when the metadata module is disposed.  This will only be called then
            this actual metadata instance is disposed.  Any instances created from this using <see
            cref="M:Microsoft.CodeAnalysis.Metadata.Copy"/> will not call this when they are disposed.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="onDispose"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.IntPtr,System.Int32)">
            <summary>
            Create metadata module from a raw memory pointer to a PE image or an object file.
            </summary>
            <param name="peImage">Pointer to the DOS header ("MZ") of a portable executable image.</param>
            <param name="size">The size of the image pointed to by <paramref name="peImage"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size"/> is not positive.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Create metadata module from a sequence of bytes.
            </summary>
            <param name="peImage">The portable executable image beginning with the DOS header ("MZ").</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Create metadata module from a byte array.
            </summary>
            <param name="peImage">Portable executable image beginning with the DOS header ("MZ").</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(System.IO.Stream,System.Boolean)">
            <summary>
            Create metadata module from a stream.
            </summary>
            <param name="peStream">Stream containing portable executable image. Position zero should contain the first byte of the DOS header ("MZ").</param>
            <param name="leaveOpen">
            False to close the stream upon disposal of the metadata (the responsibility for disposal of the stream is transferred upon entry of the constructor
            unless the arguments given are invalid).
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
            <exception cref="T:System.ArgumentException">The stream doesn't support seek operations.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
            <summary>
            Create metadata module from a stream.
            </summary>
            <param name="peStream">Stream containing portable executable image. Position zero should contain the first byte of the DOS header ("MZ").</param>
            <param name="options">
            Options specifying how sections of the PE image are read from the stream.
            Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is specified, the responsibility for disposal of the stream is transferred upon entry of the constructor
            unless the arguments given are invalid.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
            <exception cref="T:System.ArgumentException">The stream doesn't support read and seek operations.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options"/> has an invalid value.</exception>
            <exception cref="T:System.BadImageFormatException">
            <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage"/> is specified and the PE headers of the image are invalid.
            </exception>
            <exception cref="T:System.IO.IOException">
            <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage"/> is specified and an error occurs while reading the stream.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromFile(System.String)">
            <summary>
            Creates metadata module from a file containing a portable executable image.
            </summary>
            <param name="path">File path.</param>
            <remarks>
            The file might remain mapped (and read-locked) until this object is disposed.
            The memory map is only created for large files. Small files are read into memory.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is invalid.</exception>
            <exception cref="T:System.IO.IOException">Error opening file <paramref name="path"/>. See <see cref="P:System.Exception.InnerException"/> for details.</exception>
            <exception cref="T:System.IO.FileNotFoundException">File <paramref name="path"/> not found.</exception>
            <exception cref="T:System.NotSupportedException">Reading from a file path is not supported by the platform.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.Copy">
            <summary>
            Creates a shallow copy of this object.
            </summary>
            <remarks>
            The resulting copy shares the metadata image and metadata information read from it with the original.
            It doesn't own the underlying metadata image and is not responsible for its disposal.
            
            This is used, for example, when a metadata cache needs to return the cached metadata to its users
            while keeping the ownership of the cached metadata object.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.Dispose">
            <summary>
            Frees memory and handles allocated for the module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ModuleMetadata.IsDisposed">
            <summary>
            True if the module has been disposed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ModuleMetadata.Name">
            <summary>
            Name of the module.
            </summary>
            <exception cref="T:System.BadImageFormatException">Invalid metadata.</exception>
            <exception cref="T:System.ObjectDisposedException">Module has been disposed.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.GetModuleVersionId">
            <summary>
            Version of the module content.
            </summary>
            <exception cref="T:System.BadImageFormatException">Invalid metadata.</exception>
            <exception cref="T:System.ObjectDisposedException">Module has been disposed.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ModuleMetadata.Kind">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind"/> for this instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.GetModuleNames">
            <summary>
            Returns the file names of linked managed modules.
            </summary>
            <exception cref="T:System.BadImageFormatException">When an invalid module name is encountered.</exception>
            <exception cref="T:System.ObjectDisposedException">Module has been disposed.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.GetMetadataReader">
            <summary>
            Returns the metadata reader.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Module has been disposed.</exception>
            <exception cref="T:System.BadImageFormatException">When an invalid module name is encountered.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ModuleMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.String,System.String)">
            <summary>
            Creates a reference to the module metadata.
            </summary>
            <param name="documentation">Provider of XML documentation comments for the metadata symbols contained in the module.</param>
            <param name="filePath">Path describing the location of the metadata, or null if the metadata have no location.</param>
            <param name="display">Display string used in error messages to identity the reference.</param>
            <returns>A reference to the module metadata.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PortableExecutableReference">
            <summary>
            Reference to metadata stored in the standard ECMA-335 metadata format.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PortableExecutableReference.Display">
            <summary>
            Display string used in error messages to identity the reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PortableExecutableReference.FilePath">
            <summary>
            Path describing the location of the metadata, or null if the metadata have no location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PortableExecutableReference.DocumentationProvider">
            <summary>
            XML documentation comments provider for the reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PortableExecutableReference.CreateDocumentationProvider">
            <summary>
            Create documentation provider for the reference.
            </summary>
            <remarks>
            Called when the compiler needs to read the documentation for the reference. 
            This method can be called multiple times from different threads.  The result of one of the calls
            is cached on the reference object.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PortableExecutableReference.WithAliases(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns an instance of the reference with specified aliases.
            </summary>
            <param name="aliases">The new aliases for the reference.</param>
            <exception cref="T:System.ArgumentException">Alias is invalid for the metadata kind.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.PortableExecutableReference.WithAliases(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Returns an instance of the reference with specified aliases.
            </summary>
            <param name="aliases">The new aliases for the reference.</param>
            <exception cref="T:System.ArgumentException">Alias is invalid for the metadata kind.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.PortableExecutableReference.WithEmbedInteropTypes(System.Boolean)">
            <summary>
            Returns an instance of the reference with specified interop types embedding.
            </summary>
            <param name="value">The new value for <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes"/>.</param>
            <exception cref="T:System.ArgumentException">Interop types can't be embedded from modules.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.PortableExecutableReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)">
            <summary>
            Returns an instance of the reference with specified properties, or this instance if properties haven't changed.
            </summary>
            <param name="properties">The new properties for the reference.</param>
            <exception cref="T:System.ArgumentException">Specified values not valid for this reference.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.PortableExecutableReference.WithPropertiesImpl(Microsoft.CodeAnalysis.MetadataReferenceProperties)">
            <summary>
            Returns an instance of the reference with specified properties.
            </summary>
            <param name="properties">The new properties for the reference.</param>
            <exception cref="T:System.NotSupportedException">Specified values not supported.</exception> 
            <remarks>Only invoked if the properties changed.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadataImpl">
             <summary>
             Get metadata representation for the PE file.
             </summary>
             <exception cref="T:System.BadImageFormatException">If the PE image format is invalid.</exception>
             <exception cref="T:System.IO.IOException">The metadata image content can't be read.</exception>
             <exception cref="T:System.IO.FileNotFoundException">The metadata image is stored in a file that can't be found.</exception>
             <remarks>
             Called when the <see cref="T:Microsoft.CodeAnalysis.Compilation"/> needs to read the reference metadata.
             
             The listed exceptions are caught and converted to compilation diagnostics.
             Any other exception is considered an unexpected error in the implementation and is not caught.
            
             <see cref="T:Microsoft.CodeAnalysis.Metadata"/> objects may cache information decoded from the PE image.
             Reusing <see cref="T:Microsoft.CodeAnalysis.Metadata"/> instances across metadata references will result in better performance.
             
             The calling <see cref="T:Microsoft.CodeAnalysis.Compilation"/> doesn't take ownership of the <see cref="T:Microsoft.CodeAnalysis.Metadata"/> objects returned by this method.
             The implementation needs to retrieve the object from a provider that manages their lifetime (such as metadata cache).
             The <see cref="T:Microsoft.CodeAnalysis.Metadata"/> object is kept alive by the <see cref="T:Microsoft.CodeAnalysis.Compilation"/> that called <see cref="M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadataNoCopy"/>
             and by all compilations created from it via calls to With- factory methods on <see cref="T:Microsoft.CodeAnalysis.Compilation"/>, 
             other than <see cref="M:Microsoft.CodeAnalysis.Compilation.WithReferences(Microsoft.CodeAnalysis.MetadataReference[])"/> overloads. A compilation created using 
             <see cref="M:Microsoft.CodeAnalysis.Compilation.WithReferences(Microsoft.CodeAnalysis.MetadataReference[])"/> will call to <see cref="M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadataNoCopy"/> again.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadata">
            <summary>
            Returns a copy of the <see cref="T:Microsoft.CodeAnalysis.Metadata"/> object this <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>
            contains.  This copy does not need to be <see cref="M:System.IDisposable.Dispose"/>d.
            </summary>
            <exception cref="T:System.BadImageFormatException">If the PE image format is invalid.</exception>
            <exception cref="T:System.IO.IOException">The metadata image content can't be read.</exception>
            <exception cref="T:System.IO.FileNotFoundException">The metadata image is stored in a file that can't be found.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadataId">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.MetadataId"/> for this reference's <see cref="T:Microsoft.CodeAnalysis.Metadata"/>.
            This will be equivalent to calling <see cref="M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadata"/>.<see cref="P:Microsoft.CodeAnalysis.Metadata.Id"/>,
            but can be done more efficiently.
            </summary>
            <exception cref="T:System.BadImageFormatException">If the PE image format is invalid.</exception>
            <exception cref="T:System.IO.IOException">The metadata image content can't be read.</exception>
            <exception cref="T:System.IO.FileNotFoundException">The metadata image is stored in a file that can't be found.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ReferenceDirective">
            <summary>
            Represents the value of #r reference along with its source location.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnresolvedMetadataReference">
            <summary>
            Represents a metadata reference that can't be or is not yet resolved.
            </summary>
            <remarks>
            For error reporting only, can't be used to reference a metadata file.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IOperation">
            <summary>
            Root type for representing the abstract semantics of C# and VB statements and expressions.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IOperation.Parent">
            <summary>
            IOperation that has this operation as a child. Null for the root.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IOperation.Kind">
            <summary>
            Identifies the kind of the operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IOperation.Syntax">
            <summary>
            Syntax that was analyzed to produce the operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IOperation.Type">
            <summary>
            Result type of the operation, or null if the operation does not produce a result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IOperation.ConstantValue">
            <summary>
            If the operation is an expression that evaluates to a constant value, <see cref="P:Microsoft.CodeAnalysis.Optional`1.HasValue"/> is true and <see cref="P:Microsoft.CodeAnalysis.Optional`1.Value"/> is the value of the expression. Otherwise, <see cref="P:Microsoft.CodeAnalysis.Optional`1.HasValue"/> is false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IOperation.Children">
            <summary>
            An array of child operations for this operation. Deprecated: please use <see cref="P:Microsoft.CodeAnalysis.IOperation.ChildOperations"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IOperation.ChildOperations">
            <summary>
            An enumerable of child operations for this operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IOperation.Language">
            <summary>
            The source language of the IOperation. Possible values are <see cref="F:Microsoft.CodeAnalysis.LanguageNames.CSharp"/> and <see cref="F:Microsoft.CodeAnalysis.LanguageNames.VisualBasic"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IOperation.IsImplicit">
            <summary>
            Set to True if compiler generated /implicitly computed by compiler code
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IOperation.SemanticModel">
            <summary>
            Optional semantic model that was used to generate this operation.
            Non-null for operations generated from source with <see cref="M:Microsoft.CodeAnalysis.SemanticModel.GetOperation(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> API
            and operation callbacks made to analyzers.
            Null for operations inside a <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IOperation.OperationList">
            <summary>
            Implements a struct-based collection of <see cref="T:Microsoft.CodeAnalysis.Operation"/> nodes. This collection is ordered, but
            random access into the collection is not provided.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator">
            <summary>
            Implements a struct-based enumerator for <see cref="T:Microsoft.CodeAnalysis.Operation"/> nodes. This type is not hardened
            to <code>default(Enumerator)</code>, and will null reference in these cases. Calling <see cref="P:Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator.Current"/> after
            <see cref="M:Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator.MoveNext"/> has returned false will throw an <see cref="T:System.InvalidOperationException"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator._operation">
            <summary>
            Implementation of the <see cref="M:Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator.MoveNext"/> and <see cref="P:Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator.Current"/>
            members are delegated to the virtual <see cref="M:Microsoft.CodeAnalysis.Operation.MoveNext(System.Int32,System.Int32)"/> and
            <see cref="M:Microsoft.CodeAnalysis.Operation.GetCurrent(System.Int32,System.Int32)"/> methods, respectively.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator._currentSlot">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IOperation.OperationList.Reversed">
            <summary>
            Implements a reverse-order struct-based collection of <see cref="T:Microsoft.CodeAnalysis.Operation"/> nodes.
            This collection is ordered, but random access into the collection is not provided.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.Enumerator">
            <summary>
            Implements a reverse-order struct-based enumerator for <see cref="T:Microsoft.CodeAnalysis.Operation"/> nodes. This type is not hardened
            to <code>default(Enumerator)</code>, and will null reference in these cases. Calling <see cref="P:Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.Enumerator.Current"/> after
            <see cref="M:Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.Enumerator.MoveNext"/> has returned false will throw an <see cref="T:System.InvalidOperationException"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Operation">
            <summary>
            Root type for representing the abstract semantics of C# and VB statements and expressions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operation.Parent">
            <summary>
            IOperation that has this operation as a child
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operation.IsImplicit">
            <summary>
            Set to True if compiler generated /implicitly computed by compiler code
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operation.Kind">
            <summary>
            Identifies the kind of the operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operation.Syntax">
            <summary>
            Syntax that was analyzed to produce the operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operation.Type">
            <summary>
            Result type of the operation, or null if the operation does not produce a result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operation.Language">
            <summary>
            The source language of the IOperation. Possible values are <see cref="F:Microsoft.CodeAnalysis.LanguageNames.CSharp"/> and <see cref="F:Microsoft.CodeAnalysis.LanguageNames.VisualBasic"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operation.ConstantValue">
            <summary>
            If the operation is an expression that evaluates to a constant value, <see cref="P:Microsoft.CodeAnalysis.Optional`1.HasValue"/> is true and <see cref="P:Microsoft.CodeAnalysis.Optional`1.Value"/> is the value of the expression. Otherwise, <see cref="P:Microsoft.CodeAnalysis.Optional`1.HasValue"/> is false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operation.ChildOperations">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operation.MoveNext(System.Int32,System.Int32)">
            <summary>
            A slot of -1 means start at the beginning.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Operation.MoveNextReversed(System.Int32,System.Int32)">
            <summary>
            A slot of int.MaxValue means start from the end.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operation.OwningSemanticModel">
            <summary>
            Gets the owning semantic model for this operation node.
            Note that this may be different than <see cref="P:Microsoft.CodeAnalysis.IOperation.SemanticModel"/>, which
            is the semantic model on which <see cref="M:Microsoft.CodeAnalysis.SemanticModel.GetOperation(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> was invoked
            to create this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.OperationMapBuilder.AddToMap(Microsoft.CodeAnalysis.IOperation,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.IOperation})">
            <summary>
            Populates a empty dictionary of SyntaxNode->IOperation, where every key corresponds to an explicit IOperation node.
            If there is a SyntaxNode with more than one explicit IOperation, this will throw.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Optional`1">
            <summary>
            Combines a value, <see cref="P:Microsoft.CodeAnalysis.Optional`1.Value"/>, and a flag, <see cref="P:Microsoft.CodeAnalysis.Optional`1.HasValue"/>, 
            indicating whether or not that value is meaningful.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Optional`1.#ctor(`0)">
            <summary>
            Constructs an <see cref="T:Microsoft.CodeAnalysis.Optional`1"/> with a meaningful value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Optional`1.HasValue">
            <summary>
            Returns <see langword="true"/> if the <see cref="P:Microsoft.CodeAnalysis.Optional`1.Value"/> will return a meaningful value.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Optional`1.Value">
            <summary>
            Gets the value of the current object.  Not meaningful unless <see cref="P:Microsoft.CodeAnalysis.Optional`1.HasValue"/> returns <see langword="true"/>.
            </summary>
            <remarks>
            <para>Unlike <see cref="P:System.Nullable`1.Value"/>, this property does not throw an exception when
            <see cref="P:Microsoft.CodeAnalysis.Optional`1.HasValue"/> is <see langword="false"/>.</para>
            </remarks>
            <returns>
            <para>The value if <see cref="P:Microsoft.CodeAnalysis.Optional`1.HasValue"/> is <see langword="true"/>; otherwise, the default value for type
            <typeparamref name="T"/>.</para>
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Optional`1.op_Implicit(`0)~Microsoft.CodeAnalysis.Optional{`0}">
            <summary>
            Creates a new object initialized to a meaningful value. 
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Optional`1.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.OutputKind">
            <summary>
            Specifies output assembly kinds generated by compiler.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.ConsoleApplication">
            <summary>
            An .exe with an entry point and a console.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.WindowsApplication">
            <summary>
            An .exe with an entry point but no console.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.DynamicallyLinkedLibrary">
            <summary>
            A .dll file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.NetModule">
            <summary>
            A .netmodule file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.WindowsRuntimeMetadata">
            <summary>
            A .winmdobj file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OutputKind.WindowsRuntimeApplication">
            <summary>
            An .exe that can run in an app container.
            <para>
            Equivalent to a WindowsApplication, but with an extra bit set in the Portable Executable file
            so that the application can only be run in an app container.
            Also known as a "Windows Store app".
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RealParser">
            <summary>
            A set of utilities for converting from a decimal floating-point literal string to its IEEE float
            or double representation, which considers all digits significant and correctly rounds according to
            the IEEE round-to-nearest-ties-to-even mode. This code does not support a leading sign character,
            as that is not part of the C# or VB floating-point literal lexical syntax.
            
            If you change this code, please run the set of long-running random tests in the solution
            RandomRealParserTests.sln. That solution is not included in Roslyn.sln as it is Windows-specific.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.TryParseDouble(System.String,System.Double@)">
            <summary>
            Try parsing a correctly-formatted double floating-point literal into the nearest representable double
            using IEEE round-to-nearest-ties-to-even rounding mode. Behavior is not defined for inputs that are
            not valid C# floating-point literals.
            </summary>
            <param name="s">The decimal floating-point constant's string</param>
            <param name="d">The nearest double value, if conversion succeeds</param>
            <returns>True if the input was converted; false if there was an overflow</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.TryParseFloat(System.String,System.Single@)">
            <summary>
            Try parsing a correctly-formatted float floating-point literal into the nearest representable float
            using IEEE round-to-nearest-ties-to-even rounding mode. Behavior is not defined for inputs that are
            not valid C# floating-point literals.
            </summary>
            <param name="s">The float floating-point constant's string</param>
            <param name="f">The nearest float value, if conversion succeeds</param>
            <returns>True if the input was converted; false if there was an overflow</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RealParser.FloatingPointType">
            <summary>
            Properties of an IEEE floating-point representation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.FloatingPointType.AssembleFloatingPointValue(System.UInt64,System.Int32,System.Boolean,System.UInt64@)">
            <summary>
            Converts the floating point value 0.mantissa * 2^exponent into the  
            correct form for the FloatingPointType and stores the bits of the resulting value  
            into the result object.  
            The caller must ensure that the mantissa and exponent are correctly computed  
            such that either [1] the most significant bit of the mantissa is in the  
            correct position for the FloatingType, or [2] the exponent has been correctly  
            adjusted to account for the shift of the mantissa that will be required.  
             
            This function correctly handles range errors and stores a zero or infinity in  
            the result object on underflow and overflow errors, respectively.  This  
            function correctly forms denormal numbers when required.  
             
            If the provided mantissa has more bits of precision than can be stored in the  
            result object, the mantissa is rounded to the available precision.  Thus, if  
            possible, the caller should provide a mantissa with at least one more bit of  
            precision than is required, to ensure that the mantissa is correctly rounded.  
            (The caller should not round the mantissa before calling this function.)  
            </summary>
            <param name="initialMantissa">The bits of the mantissa</param>
            <param name="initialExponent">The exponent</param>
            <param name="hasZeroTail">Whether there are any nonzero bits past the supplied mantissa</param>
            <param name="result">Where the bits of the floating-point number are stored</param>
            <returns>A status indicating whether the conversion succeeded and why</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RealParser.FloatFloatingPointType">
            <summary>
            Properties of a C# float.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RealParser.DoubleFloatingPointType">
            <summary>
            Properties of a C# double.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RealParser.DecimalFloatingPointString">
            <summary>
            This type is used to hold a partially-parsed string representation of a  
            floating point number.  The number is stored in the following form:  
             <pre>
                0.Mantissa * 10^Exponent
             </pre>
            The Mantissa buffer stores the mantissa digits as characters in a string.  
            The MantissaCount gives the number of digits present in the Mantissa buffer.
            There shall be neither leading nor trailing zero digits in the Mantissa.
            Note that this represents only nonnegative floating-point literals; the
            negative sign in C# and VB is actually a separate unary negation operator.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.DecimalFloatingPointString.FromSource(System.String)">
            <summary>
            Create a DecimalFloatingPointString from a string representing a floating-point literal.
            </summary>
            <param name="source">The text of the floating-point literal</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.ConvertDecimalToFloatingPointBits(Microsoft.CodeAnalysis.RealParser.DecimalFloatingPointString,Microsoft.CodeAnalysis.RealParser.FloatingPointType,System.UInt64@)">
            <summary>
            Convert a DecimalFloatingPointString to the bits of the given floating-point type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.ConvertBigIntegerToFloatingPointBits(System.Byte[],System.UInt32,System.Boolean,Microsoft.CodeAnalysis.RealParser.FloatingPointType,System.UInt64@)">
            <summary>
            This function is part of the fast track for integer floating point strings.  
            It takes an integer stored as an array of bytes (lsb first) and converts the value into its FloatingType  
            representation, storing the bits into "result".  If the value is not  
            representable, +/-infinity is stored and overflow is reported (since this  
            function only deals with integers, underflow is impossible).  
            </summary>
            <param name="integerValueAsBytes">the bits of the integer, least significant bits first</param>
            <param name="integerBitsOfPrecision">the number of bits of precision in integerValueAsBytes</param>
            <param name="hasNonzeroFractionalPart">whether there are nonzero digits after the decimal</param>
            <param name="type">the kind of real number to build</param>
            <param name="result">the result</param>
            <returns>An indicator of the kind of result</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.AccumulateDecimalDigitsIntoBigInteger(Microsoft.CodeAnalysis.RealParser.DecimalFloatingPointString,System.UInt32,System.UInt32)">
            <summary>
            Parse a sequence of digits into a BigInteger.
            </summary>
            <param name="data">The DecimalFloatingPointString containing the digits in its Mantissa</param>
            <param name="integer_first_index">The index of the first digit to convert</param>
            <param name="integer_last_index">The index just past the last digit to convert</param>
            <returns>The BigInteger result</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.CountSignificantBits(System.UInt64)">
            <summary>
            Return the number of significant bits set. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.CountSignificantBits(System.Byte)">
            <summary>
            Return the number of significant bits set. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.CountSignificantBits(System.Numerics.BigInteger,System.Byte[]@)">
            <summary>
            Return the number of significant bits set. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.CountSignificantBits(System.Numerics.BigInteger)">
            <summary>
            Return the number of significant bits set. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.RightShiftWithRounding(System.UInt64,System.Int32,System.Boolean)">
            <summary>
            Computes value / 2^shift, then rounds the result according to the current  
            rounding mode.  By the time we call this function, we will already have  
            discarded most digits.  The caller must pass true for has_zero_tail if  
            all discarded bits were zeroes.  
            </summary>
            <param name="value">The value to shift</param>
            <param name="shift">The amount of shift</param>
            <param name="hasZeroTail">Whether there are any less significant nonzero bits in the value</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.ShouldRoundUp(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Determines whether a mantissa should be rounded up in the  
            round-to-nearest-ties-to-even mode given [1] the value of the least  
            significant bit of the mantissa, [2] the value of the next bit after  
            the least significant bit (the "round" bit) and [3] whether any  
            trailing bits after the round bit are set.  
             
            The mantissa is treated as an unsigned integer magnitude.  
             
            For this function, "round up" is defined as "increase the magnitude" of the  
            mantissa.
            </summary>
            <param name="lsbBit">the least-significant bit of the representable value</param>
            <param name="roundBit">the bit following the least-significant bit</param>
            <param name="hasTailBits">true if there are any (less significant) bits set following roundBit</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.ShiftLeft(System.Numerics.BigInteger@,System.UInt32)">
            <summary>
            Multiply a BigInteger by the given power of two.
            </summary>
            <param name="number">The BigInteger to multiply by a power of two and replace with the product</param>
            <param name="shift">The power of two to multiply it by</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.MultiplyByPowerOfTen(System.Numerics.BigInteger@,System.UInt32)">
            <summary>
            Multiply a BigInteger by the given power of ten.
            </summary>
            <param name="number">The BigInteger to multiply by a power of ten and replace with the product</param>
            <param name="power">The power of ten to multiply it by</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.FloatToInt32Bits(System.Single)">
            <summary>
            Convert a float value to the bits of its representation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RealParser.Int32BitsToFloat(System.UInt32)">
            <summary>
            Convert the bits of its representation to a float
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RealParser.FloatUnion">
            <summary>
            A union used to convert between a float and the bits of its representation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2">
            <summary>
            The base class for language specific assembly managers.
            </summary>
            <typeparam name="TCompilation">Language specific representation for a compilation</typeparam>
            <typeparam name="TAssemblySymbol">Language specific representation for an assembly symbol.</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData">
            <summary>
            Information about an assembly, used as an input for the Binder class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.Identity">
            <summary>
            Identity of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.AssemblyReferences">
            <summary>
            Identity of assemblies referenced by this assembly.
            References should always be returned in the same order.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.AvailableSymbols">
            <summary>
            The sequence of AssemblySymbols the Binder can choose from.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.IsMatchingAssembly(`1)">
            <summary>
            Check if provided AssemblySymbol is created for assembly described by this instance. 
            This method is expected to return true for every AssemblySymbol returned by 
            AvailableSymbols property.
            </summary>
            <param name="assembly">
            The AssemblySymbol to check.
            </param>
            <returns>Boolean.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.BindAssemblyReferences(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData},Microsoft.CodeAnalysis.AssemblyIdentityComparer)">
            <summary>
            Resolve assembly references against assemblies described by provided AssemblyData objects. 
            In other words, match assembly identities returned by AssemblyReferences property against 
            assemblies described by provided AssemblyData objects.
            </summary>
            <param name="assemblies">An array of AssemblyData objects to match against.</param>
            <param name="assemblyIdentityComparer">Used to compare assembly identities.</param>
            <returns>
            For each assembly referenced by this assembly (<see cref="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.AssemblyReferences"/>) 
            a description of how it binds to one of the input assemblies.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.SourceCompilation">
            <summary>
            Get the source compilation backing this assembly, if one exists.
            Returns null otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding">
            <summary>
            Result of binding an AssemblyRef to an AssemblyDef. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.#ctor(Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Failed binding.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.#ctor(Microsoft.CodeAnalysis.AssemblyIdentity,System.Int32,System.Int32)">
            <summary>
            Successful binding.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.BoundToAssemblyBeingBuilt">
            <summary>
            Returns true if the reference was matched with the identity of the assembly being built.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.IsBound">
            <summary>
            True if the definition index is available (reference was successfully matched with the definition).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.VersionDifference">
            <summary>
             0 if the reference is equivalent to the definition.
            -1 if version of the matched definition is lower than version of the reference, but the reference otherwise matches the definition.
            +1 if version of the matched definition is higher than version of the reference, but the reference otherwise matches the definition.
              
            Undefined unless <see cref="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.IsBound"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.DefinitionIndex">
            <summary>
            Index into assembly definition list.
            Undefined unless <see cref="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceBinding.IsBound"/> is true.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceCandidate">
            <summary>
            Private helper class to capture information about AssemblySymbol instance we 
            should check for suitability. Used by the Bind method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceCandidate.DefinitionIndex">
            <summary>
            An index of the AssemblyData object in the input array. AssemblySymbol instance should 
            be checked for suitability against assembly described by that object, taking into account 
            assemblies described by other AssemblyData objects in the input array.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceCandidate.AssemblySymbol">
            <summary>
            AssemblySymbol instance to check for suitability.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyReferenceCandidate.#ctor(System.Int32,`1)">
            <summary>
            Convenience constructor to initialize fields of this structure.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.BoundInputAssembly">
            <summary>
            Result of binding an input assembly and its references. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.BoundInputAssembly.AssemblySymbol">
            <summary>
            Suitable AssemblySymbol instance for the corresponding assembly, 
            null reference if none is available/found.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.BoundInputAssembly.ReferenceBinding">
            <summary>
            For each AssemblyRef of this AssemblyDef specifies which AssemblyDef matches the reference.
            </summary>
            <remarks>
            Result of resolving assembly references of the corresponding assembly 
            against provided set of assemblies. Essentially, this is an array returned by
            AssemblyData.BindAssemblyReferences method. 
            
            Each element describes the assembly the corresponding reference of the input assembly 
            is bound to.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.Bind(`0,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.PEModule},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.MetadataReference},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.ResolvedReference},Microsoft.CodeAnalysis.MetadataReferenceResolver,Microsoft.CodeAnalysis.MetadataImportOptions,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.ReferencedAssemblyIdentity}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.MetadataReference}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.ResolvedReference}@,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.PortableExecutableReference}@,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@,System.Int32@)">
             <summary>
             For the given set of AssemblyData objects, do the following:
                1) Resolve references from each assembly against other assemblies in the set.
                2) Choose suitable AssemblySymbol instance for each AssemblyData object.
            
             The first element (index==0) of the assemblies array represents the assembly being built.
             One can think about the rest of the items in assemblies array as assembly references given to the compiler to
             build executable for the assembly being built. 
             </summary>
             <param name="compilation">Compilation.</param>
             <param name="explicitAssemblies">
             An array of <see cref="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData"/> objects describing assemblies, for which this method should
             resolve references and find suitable AssemblySymbols. The first slot contains the assembly being built.
             </param>
             <param name="explicitModules">
             An array of <see cref="T:Microsoft.CodeAnalysis.PEModule"/> objects describing standalone modules referenced by the compilation.
             </param>
             <param name="explicitReferences">
             An array of references passed to the compilation and resolved from #r directives.
             May contain references that were skipped during resolution (they don't have a corresponding explicit assembly).
             </param>
             <param name="explicitReferenceMap">
             Maps index to <paramref name="explicitReferences"/> to an index of a resolved assembly or module in <paramref name="explicitAssemblies"/> or modules.
             </param>
             <param name="resolverOpt">
             Reference resolver used to look up missing assemblies.
             </param>
             <param name="supersedeLowerVersions">
             Hide lower versions of dependencies that have multiple versions behind an alias.
             </param>
             <param name="assemblyReferencesBySimpleName">
             Used to filter out assemblies that have the same strong or weak identity.
             Maps simple name to a list of identities. The highest version of each name is the first.
             </param>
             <param name="importOptions">
             Import options applied to implicitly resolved references.
             </param>
             <param name="allAssemblies">
             Updated array <paramref name="explicitAssemblies"/> with resolved implicitly referenced assemblies appended.
             </param>
             <param name="implicitlyResolvedReferences">
             Implicitly resolved references.
             </param>
             <param name="implicitlyResolvedReferenceMap">
             Maps indices of implicitly resolved references to the corresponding indices of resolved assemblies in <paramref name="allAssemblies"/> (explicit + implicit).
             </param>
             <param name="implicitReferenceResolutions">
             Map of implicit reference resolutions performed in the preceding script compilation. 
             Output contains additional implicit resolutions performed during binding of this script compilation references.
             </param>
             <param name="resolutionDiagnostics">
             Any diagnostics reported while resolving missing assemblies.
             </param>
             <param name="hasCircularReference">
             True if the assembly being compiled is indirectly referenced through some of its own references.
             </param>
             <param name="corLibraryIndex">
             The definition index of the COR library.
             </param>
             <return>
             An array of <see cref="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.BoundInputAssembly"/> structures describing the result. It has the same amount of items as
             the input assemblies array, <see cref="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.BoundInputAssembly"/> for each input AssemblyData object resides
             at the same position.
             
             Each <see cref="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.BoundInputAssembly"/> contains the following data:
             
             -    Suitable AssemblySymbol instance for the corresponding assembly, 
                 null reference if none is available/found. Always null for the first element, which corresponds to the assembly being built.
            
             -    Result of resolving assembly references of the corresponding assembly 
                 against provided set of assembly definitions. Essentially, this is an array returned by
                 <see cref="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssemblyData.BindAssemblyReferences(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData},Microsoft.CodeAnalysis.AssemblyIdentityComparer)"/> method.
             </return>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.TryResolveMissingReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.AssemblyIdentity,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.PortableExecutableReference}@,Microsoft.CodeAnalysis.MetadataReferenceResolver,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.AssemblyIdentity@,Microsoft.CodeAnalysis.AssemblyMetadata@,Microsoft.CodeAnalysis.PortableExecutableReference@)">
            <summary>
            Resolve <paramref name="referenceIdentity"/> using a given <paramref name="resolver"/>.
            
            We make sure not to query the resolver for the same identity multiple times (across submissions).
            Doing so ensures that we don't create multiple assembly symbols within the same chain of script compilations 
            for the same implicitly resolved identity. Failure to do so results in cast errors like "can't convert T to T".
            
            The method only records successful resolution results by updating <paramref name="implicitReferenceResolutions"/>.
            Failures are only recorded after all resolution attempts have been completed.
            
            This approach addresses the following scenario. Consider a script:
            <code>
              #r "dir1\a.dll"
              #r "dir2\b.dll"
            </code>
            where both a.dll and b.dll reference x.dll, which is present only in dir2. Let's assume the resolver first 
            attempts to resolve "x" referenced from "dir1\a.dll". The resolver may fail to find the dependency if it only
            looks up the directory containing the referencing assembly (dir1). If we recorded and this failure immediately
            we would not call the resolver to resolve "x" within the context of "dir2\b.dll" (or any other referencing assembly). 
            
            This behavior would ensure consistency and if the types from x.dll do leak thru to the script compilation, but it 
            would result in a missing assembly error. By recording the failure after all resolution attempts are complete
            we also achieve a consistent behavior but are able to bind the reference to "x.dll". Besides, this approach
            also avoids dependency on the order in which we evaluate the assembly references in the scenario above.
            In general, the result of the resolution may still depend on the order of #r - if there are different assemblies 
            of the same identity in different directories.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.InternalsMayBeVisibleToAssemblyBeingCompiled(System.String,Microsoft.CodeAnalysis.PEAssembly)">
            <summary>
            Determines if it is possible that <paramref name="assembly"/> gives internals
            access to assembly <paramref name="compilationName"/>. It does not make a conclusive
            determination of visibility because the compilation's strong name key is not supplied.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.GetActualBoundReferencesUsedBy(`1,System.Collections.Generic.List{`1})">
            <summary>
            Compute AssemblySymbols referenced by the input AssemblySymbol and fill in <paramref name="referencedAssemblySymbols"/> with the result.
            The AssemblySymbols must correspond 
            to the AssemblyNames returned by AssemblyData.AssemblyReferences property. If reference is not 
            resolved, null reference should be returned in the corresponding item. 
            </summary>
            <param name="assemblySymbol">The target AssemblySymbol instance.</param>
            <param name="referencedAssemblySymbols">A list which will be filled in with
            AssemblySymbols referenced by the input AssemblySymbol. The caller is expected to clear
            the list before calling this method.
            Implementer may not cache the list; the caller may mutate it.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.GetNoPiaResolutionAssemblies(`1)">
            <summary>
            Return collection of assemblies involved in canonical type resolution of
            NoPia local types defined within target assembly. In other words, all 
            references used by previous compilation referencing the target assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.IsLinked(`1)">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.GetCorLibrary(`1)">
            <summary>
            Get Assembly used as COR library for the candidate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.CheckPropertiesConsistency(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Checks if the properties of <paramref name="duplicateReference"/> are compatible with properties of <paramref name="primaryReference"/>.
            Reports inconsistencies to the given diagnostic bag.
            </summary>
            <returns>True if the properties are compatible and hence merged, false if the duplicate reference should not merge it's properties with primary reference.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.WeakIdentityPropertiesEquivalent(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Called to compare two weakly named identities with the same name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolvedReference.AliasesOpt">
            <summary>
            Aliases that should be applied to the referenced assembly. 
            Empty array means {"global"} (all namespaces and types in the global namespace of the assembly are accessible without qualification).
            Null if not applicable (the reference only has recursive aliases).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolvedReference.RecursiveAliasesOpt">
            <summary>
            Aliases that should be applied recursively to all dependent assemblies. 
            Empty array means {"global"} (all namespaces and types in the global namespace of the assembly are accessible without qualification).
            Null if not applicable (the reference only has simple aliases).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolvedReference.IsSkipped">
            <summary>
            default(<see cref="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolvedReference"/>) is considered skipped.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolvedReference.Index">
            <summary>
            Index into an array of assemblies (not including the assembly being built) or an array of modules, depending on <see cref="P:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolvedReference.Kind"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.ReferencedAssemblyIdentity.RelativeAssemblyIndex">
            <summary>
            non-negative: Index into the array of all (explicitly and implicitly) referenced assemblies.
            negative: ExplicitlyReferencedAssemblies.Count + RelativeAssemblyIndex is an index into the array of assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolveMetadataReferences(`0,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.ReferencedAssemblyIdentity}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.MetadataReference}@,System.Collections.Generic.IDictionary{System.ValueTuple{System.String,System.String},Microsoft.CodeAnalysis.MetadataReference}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.MetadataReference}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.PEModule}@,Microsoft.CodeAnalysis.DiagnosticBag)">
             <summary>
             Resolves given metadata references to assemblies and modules.
             </summary>
             <param name="compilation">The compilation whose references are being resolved.</param>
             <param name="assemblyReferencesBySimpleName">
             Used to filter out assemblies that have the same strong or weak identity.
             Maps simple name to a list of identities. The highest version of each name is the first.
             </param>
             <param name="references">List where to store resolved references. References from #r directives will follow references passed to the compilation constructor.</param>
             <param name="boundReferenceDirectiveMap">Maps #r values to successfully resolved metadata references. Does not contain values that failed to resolve.</param>
             <param name="boundReferenceDirectives">Unique metadata references resolved from #r directives.</param>
             <param name="assemblies">List where to store information about resolved assemblies to.</param>
             <param name="modules">List where to store information about resolved modules to.</param>
             <param name="diagnostics">Diagnostic bag where to report resolution errors.</param>
             <returns>
             Maps index to <paramref name="references"/> to an index of a resolved assembly or module in <paramref name="assemblies"/> or <paramref name="modules"/>, respectively.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.GetMetadata(Microsoft.CodeAnalysis.PortableExecutableReference,Microsoft.CodeAnalysis.CommonMessageProvider,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Creates or gets metadata for PE reference.
            </summary>
            <remarks>
            If any of the following exceptions: <see cref="T:System.BadImageFormatException"/>, <see cref="T:System.IO.FileNotFoundException"/>, <see cref="T:System.IO.IOException"/>,
            are thrown while reading the metadata file, the exception is caught and an appropriate diagnostic stored in <paramref name="diagnostics"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReferenceManager`2.MetadataReferenceEqualityComparer">
            <summary>
            Determines whether references are the same. Compilation references are the same if they refer to the same compilation.
            Otherwise, references are represented by their object identities.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.MergeReferenceProperties(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MergedAliases}@)">
            <summary>
            Merges aliases of the first observed reference (<paramref name="primaryReference"/>) with aliases specified for an equivalent reference (<paramref name="newReference"/>).
            Empty alias list is considered to be the same as a list containing "global", since in both cases C# allows unqualified access to the symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AddAssembly(Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData,System.Int32,Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.ResolvedReference[],Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData})">
            <remarks>
            Caller is responsible for freeing any allocated ArrayBuilders.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AddModule(Microsoft.CodeAnalysis.PEModule,System.Int32,Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.ResolvedReference[],Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.PEModule}@)">
            <remarks>
            Caller is responsible for freeing any allocated ArrayBuilders.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.TryAddAssembly(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.MetadataReference,System.Int32,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.Location,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.ReferencedAssemblyIdentity}},System.Boolean)">
            <summary>
            Returns null if an assembly of an equivalent identity has not been added previously, otherwise returns the reference that added it.
            Two identities are considered equivalent if
            - both assembly names are strong (have keys) and are either equal or FX unified 
            - both assembly names are weak (no keys) and have the same simple name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolveReferenceDirective(System.String,Microsoft.CodeAnalysis.Location,`0)">
            <summary>
            For each given directive return a bound PE reference, or null if the binding fails.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.ResolveReferencedAssembly(Microsoft.CodeAnalysis.AssemblyIdentity,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CommonReferenceManager{`0,`1}.AssemblyData},System.Int32,Microsoft.CodeAnalysis.AssemblyIdentityComparer)">
            <summary>
            Used to match AssemblyRef with AssemblyDef.
            </summary>
            <param name="definitions">Array of definition identities to match against.</param>
            <param name="definitionStartIndex">An index of the first definition to consider, <paramref name="definitions"/> preceding this index are ignored.</param>
            <param name="reference">Reference identity to resolve.</param>
            <param name="assemblyIdentityComparer">Assembly identity comparer.</param>
            <returns>
            Returns an index the reference is bound.
            </returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.SimpleAssemblyName">
            <summary>
            If the compilation being built represents an assembly its assembly name.
            If the compilation being built represents a module, the name of the 
            containing assembly or <see cref="F:Microsoft.CodeAnalysis.Compilation.UnspecifiedModuleAssemblyName"/>
            if not specified (/moduleassemblyname command line option).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.IdentityComparer">
            <summary>
            Used to compares assembly identities. 
            May implement unification and portability policies specific to the target platform.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.ObservedMetadata">
            <summary>
            Metadata observed by the compiler.
            May be shared across multiple Reference Managers.
            Access only under lock(<see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.ObservedMetadata"/>).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._isBound">
            <summary>
            Once this is non-zero the state of the manager is fully initialized and immutable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyHasCircularReference">
            <summary>
            True if the compilation has a reference that refers back to the assembly being compiled.
            </summary>
            <remarks>
            If we have a circular reference the bound references can't be shared with other compilations.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedAssembliesMap">
            <summary>
            A map from a metadata reference to an index to <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedAssemblies"/> array. Do not access
            directly, use <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedAssembliesMap"/> property instead.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedModuleIndexMap">
            <summary>
            A map from a net-module metadata reference to the index of the corresponding module
            symbol in the source assembly symbol for the current compilation.
            </summary>
            <remarks>
            Subtract one from the index (for the manifest module) to find the corresponding elements
            of <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedModules"/> and <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedModulesReferences"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferenceDirectiveMap">
            <summary>
            Maps (containing syntax tree file name, reference string) of #r directive to a resolved metadata reference.
            If multiple #r's in the same tree use the same value as a reference the resolved metadata reference is the same as well.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyDirectiveReferences">
            <summary>
            Array of unique bound #r references.
            </summary>
            <remarks>
            The references are in the order they appear in syntax trees. This order is currently preserved 
            as syntax trees are added or removed, but we might decide to share reference manager between compilations
            with different order of #r's. It doesn't seem this would be an issue since all #r's within the compilation
            have the same "priority" with respect to each other.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyImplicitReferenceResolutions">
            <summary>
            Stores the results of implicit reference resolutions.
            If <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceResolver.ResolveMissingAssemblies"/> is true the reference manager attempts to resolve assembly identities,
            that do not match any explicit metadata references passed to the compilation (or specified via #r directive).
            For each such assembly identity <see cref="M:Microsoft.CodeAnalysis.MetadataReferenceResolver.ResolveMissingAssembly(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.AssemblyIdentity)"/> is called
            and its result is captured in this map.
            The map also stores failures - the reference is null if the assembly of the given identity is not found by the resolver.
            This is important to maintain consistency, especially across multiple submissions (e.g. the reference is not found during compilation of the first submission
            but then it is available when the second submission is compiled).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyDiagnostics">
            <summary>
            Diagnostics produced during reference resolution and binding.
            </summary>
            <remarks>
            When reporting diagnostics be sure not to include any information that can't be shared among 
            compilations that share the same reference manager (such as full identity of the compilation, 
            simple assembly name is ok).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyCorLibraryOpt">
            <summary>
            COR library symbol, or null if the compilation itself is the COR library.
            </summary>
            <remarks>
            If the compilation being built is the COR library we don't want to store its source assembly symbol 
            here since we wouldn't be able to share the state among subsequent compilations that are derived from it
            (each of them has its own source assembly symbol).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedModules">
            <summary>
            Standalone modules referenced by the compilation (doesn't include the manifest module of the compilation).
            </summary>
            <remarks>
            <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedModules"/>[i] corresponds to <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedModulesReferences"/>[i].
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedModulesReferences">
            <summary>
            References of standalone modules referenced by the compilation (doesn't include the manifest module of the compilation).
            </summary>
            <remarks>
            <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedModules"/>[i] corresponds to <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedModulesReferences"/>[i].
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedAssemblies">
            <summary>
            Assemblies referenced directly by the source module of the compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyAliasesOfReferencedAssemblies">
            <summary>
            Aliases used by assemblies referenced directly by the source module of the compilation.
            </summary>
            <remarks>
            Aliases <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyAliasesOfReferencedAssemblies"/>[i] are of an assembly <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedAssemblies"/>[i].
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyMergedAssemblyReferencesMap">
            <summary>
            A map capturing <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/>s that were "merged" to a single referenced assembly
            associated with a key in the map.
            The keys are a subset of keys from <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyReferencedAssembliesMap"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2._lazyUnifiedAssemblies">
            <summary>
            Unified assemblies referenced directly by the source module of the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.AssertUnbound">
            <summary>
            Call only while holding <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.InitializeNoLock(System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.MetadataReference,System.Int32},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.MetadataReference,System.Int32},System.Collections.Generic.IDictionary{System.ValueTuple{System.String,System.String},Microsoft.CodeAnalysis.MetadataReference},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.MetadataReference},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.MetadataReference},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.PortableExecutableReference},System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},`1,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.PEModule},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ModuleReferences{`1}},System.Collections.Immutable.ImmutableArray{`1},System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{System.String}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UnifiedAssembly{`1}},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.MetadataReference,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.MetadataReference}})">
            <summary>
            Call only while holding <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.s_supersededAlias">
            <summary>
            Global namespaces of assembly references that have been superseded by an assembly reference with a higher version are 
            hidden behind <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager`2.s_supersededAlias"/> to avoid ambiguity when they are accessed from source.
            All existing aliases of a superseded assembly are discarded.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.GetAssemblyReferenceIdentityBaselineMap(System.Collections.Immutable.ImmutableArray{`1},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AssemblyIdentity})">
            <summary>
            Calculates map from the identities of specified symbols to the corresponding identities in the original EnC baseline metadata.
            The map only includes an entry for identities that differ, i.e. for symbols representing assembly references of the current compilation that have different identities 
            than the corresponding identity in baseline metadata AssemblyRef table. The key comparer of the map ignores build and revision parts of the version number, 
            since these might change if the original version included wildcard.
            </summary>
            <param name="symbols">Assembly symbols for references of the current compilation.</param>
            <param name="originalIdentities">Identities in the baseline. <paramref name="originalIdentities"/>[i] corresponds to <paramref name="symbols"/>[i].</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager`2.GetMetadataReference(Microsoft.CodeAnalysis.Symbols.IAssemblySymbolInternal)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/> that corresponds to the assembly symbol. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard">
            <summary>
            Must be acquired whenever the following data are about to be modified:
            - Compilation.lazyAssemblySymbol
            - Compilation.referenceManager
            - ReferenceManager state
            - <see cref="F:Microsoft.CodeAnalysis.AssemblyMetadata.CachedSymbols"/>
            - <see cref="P:Microsoft.CodeAnalysis.Compilation.RetargetingAssemblySymbols"/>
            
            All the above data should be updated at once while holding this lock.
            Once lazyAssemblySymbol is set the Compilation.referenceManager field and ReferenceManager
            state should not change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager.GetReferencedAssemblies">
            <summary>
            Enumerates all referenced assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommonReferenceManager.GetReferencedAssemblyAliases">
            <summary>
            Enumerates all referenced assemblies and their aliases.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MergedAliases.Merge(Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Adds aliases of a specified reference to the merged set of aliases.
            Consider the following special cases:
            
            o {} + {} = {} 
              If neither reference has any aliases then the result has no aliases.
            
            o {A} + {} = {A, global}
              {} + {A} = {A, global}
              
              If one and only one of the references has aliases we add the global alias since the 
              referenced declarations should now be accessible both via existing aliases 
              as well as unqualified.
              
            o {A, A} + {A, B, B} = {A, A, B, B}
              We preserve dups in each alias array, but avoid making more dups when merging.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ModuleReferences`1">
            <summary>
            A record of the assemblies referenced by a module (their identities, symbols, and unification).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ModuleReferences`1.Identities">
            <summary>
            Identities of referenced assemblies (those that are or will be emitted to metadata).
            </summary>
            <remarks>
            Names[i] is the identity of assembly Symbols[i].
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ModuleReferences`1.Symbols">
            <summary>
            Assembly symbols that the identities are resolved against.
            </summary>
            <remarks>
            Names[i] is the identity of assembly Symbols[i].
            Unresolved references are represented as MissingAssemblySymbols.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ModuleReferences`1.UnifiedAssemblies">
            <summary>
            A subset of <see cref="F:Microsoft.CodeAnalysis.ModuleReferences`1.Symbols"/> that correspond to references with non-matching (unified) 
            version along with unification details.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedAssembly`1">
            <summary>
            Assembly symbol referenced by a AssemblyRef for which we couldn't find a matching 
            compilation reference but we found one that differs in version. 
            Created only for assemblies that require runtime binding redirection policy,
            i.e. not for Framework assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UnifiedAssembly`1.OriginalReference">
            <summary>
            Original reference that was unified to the identity of the <see cref="F:Microsoft.CodeAnalysis.UnifiedAssembly`1.TargetAssembly"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ResourceDescription">
            <summary>
            Representation of a resource whose contents are to be embedded in the output assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ResourceDescription.#ctor(System.String,System.Func{System.IO.Stream},System.Boolean)">
            <summary>
            Creates a representation of a resource whose contents are to be embedded in the output assembly.
            </summary>
            <param name="resourceName">Resource name.</param>
            <param name="dataProvider">The callers will dispose the result after use.
            This allows the resources to be opened and read one at a time.
            </param>
            <param name="isPublic">True if the resource is public.</param>
            <remarks>
            Returns a stream of the data to embed.
            </remarks> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.ResourceDescription.#ctor(System.String,System.String,System.Func{System.IO.Stream},System.Boolean)">
            <summary>
            Creates a representation of a resource whose file name will be recorded in the assembly.
            </summary>
            <param name="resourceName">Resource name.</param>
            <param name="fileName">File name with an extension to be stored in metadata.</param>
            <param name="dataProvider">The callers will dispose the result after use.
            This allows the resources to be opened and read one at a time.
            </param>
            <param name="isPublic">True if the resource is public.</param>
            <remarks>
            Function returning a stream of the resource content (used to calculate hash).
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InvalidRuleSetException">
            <summary>
            Represents errors that occur while parsing RuleSet files.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuleSet">
            <summary>
            Represents a set of rules as specified in a ruleset file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.FilePath">
            <summary>
            The file path of the ruleset file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.GeneralDiagnosticOption">
            <summary>
            The global option specified by the IncludeAll tag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.SpecificDiagnosticOptions">
            <summary>
            Individual rule ids and their associated actions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSet.Includes">
            <summary>
            List of rulesets included by this ruleset.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.#ctor(System.String,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RuleSetInclude})">
            <summary>
            Create a RuleSet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.WithEffectiveAction(Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Create a RuleSet with a global effective action applied on it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveRuleSet(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Get the effective ruleset after resolving all the included rulesets.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveIncludes">
            <summary>
            Get all the files involved in resolving this ruleset.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.IsStricterThan(Microsoft.CodeAnalysis.ReportDiagnostic,Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Returns true if the action1 is stricter than action2.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.LoadEffectiveRuleSetFromFile(System.String)">
            <summary>
            Load the ruleset from the specified file. This ruleset will contain
            all the rules resolved from the includes specified in the ruleset file
            as well. See also: <see cref="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveIncludesFromFile(System.String)" />.
            </summary>
            <returns>
            A ruleset that contains resolved rules or null if there were errors.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetEffectiveIncludesFromFile(System.String)">
            <summary>
            Get the paths to all files contributing rules to the ruleset from the specified file.
            See also: <see cref="M:Microsoft.CodeAnalysis.RuleSet.LoadEffectiveRuleSetFromFile(System.String)" />.
            </summary>
            <returns>
            The full paths to included files, or an empty array if there were errors.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSet.GetDiagnosticOptionsFromRulesetFile(System.String,System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic}@)">
            <summary>
            Parses the ruleset file at the given <paramref name="rulesetFileFullPath"/> and returns the following diagnostic options from the parsed file:
            1) A map of <paramref name="specificDiagnosticOptions"/> from rule ID to <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> option.
            2) A global <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> option for all rules in the ruleset file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuleSetInclude">
            <summary>
            Represents a Include tag in a RuleSet file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSetInclude.IncludePath">
            <summary>
            The path of the included file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RuleSetInclude.Action">
            <summary>
            The effective action to apply on this included ruleset.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetInclude.#ctor(System.String,Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Create a RuleSetInclude given the include path and the effective action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetInclude.LoadRuleSet(Microsoft.CodeAnalysis.RuleSet)">
            <summary>
            Gets the RuleSet associated with this ruleset include
            </summary>
            <param name="parent">The parent of this ruleset include</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetInclude.GetIncludePath(Microsoft.CodeAnalysis.RuleSet)">
            <summary>
            Returns a full path to the include file. Relative paths are expanded relative to the current rule set file.
            </summary>
            <param name="parent">The parent of this rule set include</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RuleSetProcessor">
            <summary>
            This type is responsible for parsing a ruleset xml file and producing a <see cref="T:Microsoft.CodeAnalysis.RuleSet"/> object.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.LoadFromFile(System.String)">
            <summary>
            Creates and loads the rule set from a file
            </summary>
            <param name="filePath">The file path to load the rule set</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRuleSet(System.Xml.Linq.XElement,System.String)">
            <summary>
            Load the rule set from the XML node
            </summary>
            <param name="ruleSetNode">The rule set node from which to create a rule set object</param>
            <param name="filePath">The file path to the rule set file</param>
            <returns>A rule set object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRules(System.Xml.Linq.XElement)">
            <summary>
            Load the rules from the XML node
            </summary>
            <param name="rulesNode">The rules node from which to loop through each child rule node</param>
            <returns>A list of rule objects with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRule(System.Xml.Linq.XElement,System.String,System.String)">
            <summary>
            Load the rule from the XML node
            </summary>
            <param name="ruleNode">The rule node from which to create a rule object</param>
            <param name="analyzer">The analyzer this rule belongs to</param>
            <param name="space">The namespace this rule belongs to</param>
            <returns>A rule object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadRuleSetInclude(System.Xml.Linq.XElement)">
            <summary>
            Load the included rule set from the XML node
            </summary>
            <param name="includeNode">The include node from which to create a RuleSetInclude object</param>
            <returns>A RuleSetInclude object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadAction(System.Xml.Linq.XElement,System.Boolean)">
            <summary>
            Reads the action from the given node
            </summary>
            <param name="node">The node to read the action, it can be a rule node or an include node.</param>
            <param name="allowDefault">Whether or not the default value is allowed.</param>
            <returns>The rule action</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadIncludeAll(System.Xml.Linq.XElement)">
            <summary>
            Load the IncludedAll from the XML node
            </summary>
            <param name="includeAllNode">The IncludeAll node from which to create a IncludeAll object</param>
            <returns>A IncludeAll object with data from the given XML node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.ReadNonEmptyAttribute(System.Xml.Linq.XElement,System.String)">
            <summary>
            Reads an attribute from a node and validates that it is not empty.
            </summary>
            <param name="node">The XML node that contains the attribute</param>
            <param name="attributeName">The name of the attribute to read</param>
            <returns>The attribute value</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RuleSetProcessor.GetDefaultXmlReaderSettings">
            <summary>
            Gets the default settings to read the ruleset xml file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceCodeKind">
            <summary>
            Specifies the C# or VB source code kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SourceCodeKind.Regular">
            <summary>
            No scripting. Used for .cs/.vb file parsing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SourceCodeKind.Script">
            <summary>
            Allows top-level statements, declarations, and optional trailing expression. 
            Used for parsing .csx/.vbx and interactive submissions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SourceCodeKind.Interactive">
            <summary>
            The same as <see cref="F:Microsoft.CodeAnalysis.SourceCodeKind.Script"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceFileResolver">
            <summary>
            Resolves references to source files specified in source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratedSourceText">
            <summary>
            A source text created by an <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratedSyntaxTree">
            <summary>
            A syntax tree created by a <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceGeneratorAdaptor">
            <summary>
            Adapts an ISourceGenerator to an incremental generator that
            by providing an execution environment that matches the old one
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorAttribute">
            <summary>
            Place this attribute onto a type to cause it to be considered a source generator
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorAttribute.Languages">
            <summary>
            The source languages to which this generator applies. See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorAttribute.#ctor">
            <summary>
            Attribute constructor used to specify the attached class is a source generator that provides CSharp sources.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorAttribute.#ctor(System.String,System.String[])">
            <summary>
            Attribute constructor used to specify the attached class is a source generator and indicate which language(s) it supports.
            </summary>
            <param name="firstLanguage">One language to which the generator applies.</param>
            <param name="additionalLanguages">Additional languages to which the generator applies. See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorExecutionContext">
            <summary>
            Context passed to a source generator when <see cref="M:Microsoft.CodeAnalysis.ISourceGenerator.Execute(Microsoft.CodeAnalysis.GeneratorExecutionContext)"/> is called
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.Compilation">
            <summary>
            Get the current <see cref="T:Microsoft.CodeAnalysis.Compilation"/> at the time of execution.
            </summary>
            <remarks>
            This compilation contains only the user supplied code; other generated code is not
            available. As user code can depend on the results of generation, it is possible that
            this compilation will contain errors.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.ParseOptions">
            <summary>
            Get the <see cref="T:Microsoft.CodeAnalysis.ParseOptions"/> that will be used to parse any added sources.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.AdditionalFiles">
            <summary>
            A set of additional non-code text files that can be used by generators.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.AnalyzerConfigOptions">
            <summary>
            Allows access to options provided by an analyzer config
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.SyntaxReceiver">
            <summary>
            If the generator registered an <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/> during initialization, this will be the instance created for this generation pass.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.SyntaxContextReceiver">
            <summary>
            If the generator registered an <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/> during initialization, this will be the instance created for this generation pass.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.CancellationToken">
            <summary>
            A <see cref="T:System.Threading.CancellationToken"/> that can be checked to see if the generation should be cancelled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorExecutionContext.AddSource(System.String,System.String)">
            <summary>
            Adds source code in the form of a <see cref="T:System.String"/> to the compilation.
            </summary>
            <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator</param>
            <param name="source">The source code to add to the compilation</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorExecutionContext.AddSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Adds a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> to the compilation
            </summary>
            <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator</param>
            <param name="sourceText">The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> to add to the compilation</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorExecutionContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Adds a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> to the users compilation 
            </summary>
            <param name="diagnostic">The diagnostic that should be added to the compilation</param>
            <remarks>
            The severity of the diagnostic may cause the compilation to fail, depending on the <see cref="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.Compilation"/> settings.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorInitializationContext">
            <summary>
            Context passed to a source generator when <see cref="M:Microsoft.CodeAnalysis.ISourceGenerator.Initialize(Microsoft.CodeAnalysis.GeneratorInitializationContext)"/> is called
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorInitializationContext.CancellationToken">
            <summary>
            A <see cref="T:System.Threading.CancellationToken"/> that can be checked to see if the initialization should be cancelled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorInitializationContext.RegisterForSyntaxNotifications(Microsoft.CodeAnalysis.SyntaxReceiverCreator)">
            <summary>
            Register a <see cref="T:Microsoft.CodeAnalysis.SyntaxReceiverCreator"/> for this generator, which can be used to create an instance of an <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/>.
            </summary>
            <remarks>
            This method allows generators to be 'syntax aware'. Before each generation the <paramref name="receiverCreator"/> will be invoked to create
            an instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/>. This receiver will have its <see cref="M:Microsoft.CodeAnalysis.ISyntaxReceiver.OnVisitSyntaxNode(Microsoft.CodeAnalysis.SyntaxNode)"/> 
            invoked for each syntax node in the compilation, allowing the receiver to build up information about the compilation before generation occurs.
            
            During <see cref="M:Microsoft.CodeAnalysis.ISourceGenerator.Execute(Microsoft.CodeAnalysis.GeneratorExecutionContext)"/> the generator can obtain the <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/> instance that was
            created by accessing the <see cref="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.SyntaxReceiver"/> property. Any information that was collected by the receiver can be
            used to generate the final output.
            
            A new instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/> is created per-generation, meaning there is no need to manage the lifetime of the 
            receiver or its contents.
            </remarks>
            <param name="receiverCreator">A <see cref="T:Microsoft.CodeAnalysis.SyntaxReceiverCreator"/> that can be invoked to create an instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorInitializationContext.RegisterForSyntaxNotifications(Microsoft.CodeAnalysis.SyntaxContextReceiverCreator)">
            <summary>
            Register a <see cref="T:Microsoft.CodeAnalysis.SyntaxContextReceiverCreator"/> for this generator, which can be used to create an instance of an <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/>.
            </summary>
            <remarks>
            This method allows generators to be 'syntax aware'. Before each generation the <paramref name="receiverCreator"/> will be invoked to create
            an instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/>. This receiver will have its <see cref="M:Microsoft.CodeAnalysis.ISyntaxContextReceiver.OnVisitSyntaxNode(Microsoft.CodeAnalysis.GeneratorSyntaxContext)"/> 
            invoked for each syntax node in the compilation, allowing the receiver to build up information about the compilation before generation occurs.
            
            During <see cref="M:Microsoft.CodeAnalysis.ISourceGenerator.Execute(Microsoft.CodeAnalysis.GeneratorExecutionContext)"/> the generator can obtain the <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/> instance that was
            created by accessing the <see cref="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.SyntaxContextReceiver"/> property. Any information that was collected by the receiver can be
            used to generate the final output.
            
            A new instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/> is created prior to every call to <see cref="M:Microsoft.CodeAnalysis.ISourceGenerator.Execute(Microsoft.CodeAnalysis.GeneratorExecutionContext)"/>, 
            meaning there is no need to manage the lifetime of the receiver or its contents.
            </remarks>
            <param name="receiverCreator">A <see cref="T:Microsoft.CodeAnalysis.SyntaxContextReceiverCreator"/> that can be invoked to create an instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorInitializationContext.RegisterForPostInitialization(System.Action{Microsoft.CodeAnalysis.GeneratorPostInitializationContext})">
            <summary>
            Register a callback that is invoked after initialization.
            </summary>
            <remarks>
            This method allows a generator to opt-in to an extra phase in the generator lifecycle called PostInitialization. After being initialized
            any generators that have opted in will have their provided callback invoked with a <see cref="T:Microsoft.CodeAnalysis.GeneratorPostInitializationContext"/> instance
            that can be used to alter the compilation that is provided to subsequent generator phases.
            
            For example a generator may choose to add sources during PostInitialization. These will be added to the compilation before execution and
            will be visited by a registered <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/> and available for semantic analysis as part of the <see cref="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.Compilation"/>
            
            Note that any sources added during PostInitialization <i>will</i> be visible to the later phases of other generators operating on the compilation. 
            </remarks>
            <param name="callback">An <see cref="T:System.Action`1"/> that accepts a <see cref="T:Microsoft.CodeAnalysis.GeneratorPostInitializationContext"/> that will be invoked after initialization.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorSyntaxContext">
            <summary>
            Context passed to an <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/> when <see cref="M:Microsoft.CodeAnalysis.ISyntaxContextReceiver.OnVisitSyntaxNode(Microsoft.CodeAnalysis.GeneratorSyntaxContext)"/> is called
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorSyntaxContext.Node">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> currently being visited
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorSyntaxContext.SemanticModel">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.SemanticModel" /> that can be queried to obtain information about <see cref="P:Microsoft.CodeAnalysis.GeneratorSyntaxContext.Node"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorPostInitializationContext">
            <summary>
            Context passed to a source generator when it has opted-in to PostInitialization via <see cref="M:Microsoft.CodeAnalysis.GeneratorInitializationContext.RegisterForPostInitialization(System.Action{Microsoft.CodeAnalysis.GeneratorPostInitializationContext})"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorPostInitializationContext.CancellationToken">
            <summary>
            A <see cref="T:System.Threading.CancellationToken"/> that can be checked to see if the PostInitialization should be cancelled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorPostInitializationContext.AddSource(System.String,System.String)">
            <summary>
            Adds source code in the form of a <see cref="T:System.String"/> to the compilation that will be available during subsequent phases
            </summary>
            <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator</param>
            <param name="source">The source code to add to the compilation</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorPostInitializationContext.AddSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Adds a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> to the compilation that will be available during subsequent phases
            </summary>
            <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator</param>
            <param name="sourceText">The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> to add to the compilation</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorDriver">
            <summary>
            Responsible for orchestrating a source generation pass
            </summary>
            <remarks>
            GeneratorDriver is an immutable class that can be manipulated by returning a mutated copy of itself.
            In the compiler we only ever create a single instance and ignore the mutated copy. The IDE may perform 
            multiple edits, or generation passes of the same driver, re-using the state as needed.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorDriverCache.AddOrUpdateMostRecentlyUsed(System.String,Microsoft.CodeAnalysis.GeneratorDriver)">
            <summary>
            Attempts to find a driver based on <paramref name="cacheKey"/>. If a matching driver is found in the 
            cache, or explicitly passed via <paramref name="driver"/>, the cache is updated so that it is at the
            head of the list.
            </summary>
            <param name="cacheKey">The key to lookup the driver by in the cache</param>
            <param name="driver">An optional driver that should be cached, if not already found in the cache</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorDriverOptions">
            <summary>
            Options passed to a <see cref="T:Microsoft.CodeAnalysis.GeneratorDriver"/> during creation
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GeneratorDriverState.Generators">
            <summary>
            The set of <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/>s associated with this state.
            </summary>
            <remarks>
            This is the set of generators that will run on next generation.
            If there are any states present in <see cref="F:Microsoft.CodeAnalysis.GeneratorDriverState.GeneratorStates" />, they were produced by a subset of these generators.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GeneratorDriverState.IncrementalGenerators">
            <summary>
            The set of <see cref="T:Microsoft.CodeAnalysis.IIncrementalGenerator"/>s associated with this state.
            </summary>
            <remarks>
            This is the 'internal' representation of the <see cref="F:Microsoft.CodeAnalysis.GeneratorDriverState.Generators"/> collection. There is a 1-to-1 mapping
            where each entry is either the unwrapped incremental generator or a wrapped <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GeneratorDriverState.GeneratorStates">
            <summary>
            The last run state of each generator, by the generator that created it
            </summary>
            <remarks>
            There will be a 1-to-1 mapping for each generator. If a generator has yet to
            be initialized or failed during initialization it's state will be <c>default(GeneratorState)</c>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GeneratorDriverState.AdditionalTexts">
            <summary>
            The set of <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/>s available to source generators during a run
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GeneratorDriverState.OptionsProvider">
            <summary>
            Gets a provider for analyzer options
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GeneratorDriverState.ParseOptions">
            <summary>
            ParseOptions to use when parsing generator provided source.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GeneratorDriverState.DisabledOutputs">
            <summary>
            A bit field containing the output kinds that should not be produced by this generator driver.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GeneratorDriverState.ParseOptionsChanged">
            <summary>
            Tracks if the <see cref="F:Microsoft.CodeAnalysis.GeneratorDriverState.ParseOptions"/> have been changed meaning post init trees will need to be re-parsed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorExtensions.GetGeneratorType(Microsoft.CodeAnalysis.ISourceGenerator)">
            <summary>
            Returns the underlying type of a given generator
            </summary>
            <remarks>
            For <see cref="T:Microsoft.CodeAnalysis.IIncrementalGenerator"/>s a wrapper is created that also implements
            <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/>. This method will unwrap and return the underlying type
            in those cases.
            </remarks>
            <param name="generator">The generator to get the type of</param>
            <returns>The underlying generator type</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorExtensions.AsSourceGenerator(Microsoft.CodeAnalysis.IIncrementalGenerator)">
            <summary>
            Converts an <see cref="T:Microsoft.CodeAnalysis.IIncrementalGenerator"/> into an <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> object that can be used when constructing a <see cref="T:Microsoft.CodeAnalysis.GeneratorDriver"/>
            </summary>
            <param name="incrementalGenerator">The incremental generator to wrap</param>
            <returns>A wrapped generator that can be passed to a generator driver</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorState">
            <summary>
            Represents the current state of a generator
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorState.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.GeneratedSyntaxTree},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxInputNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IIncrementalGeneratorOutputNode})">
            <summary>
            Creates a new generator state that contains information, constant trees and an execution pipeline
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceGeneration.GlobalAliases">
            <summary>
            Simple wrapper class around an immutable array so we can have the value-semantics needed for the incremental
            generator to know when a change actually happened and it should run later transform stages.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IIncrementalGenerator">
            <summary>
            The base interface required to implement an incremental generator
            </summary>
            <remarks>
            The lifetime of a generator is controlled by the compiler.
            State should not be stored directly on the generator, as there
            is no guarantee that the same instance will be used on a 
            subsequent generation pass.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IIncrementalGenerator.Initialize(Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext)">
            <summary>
            Called to initialize the generator and register generation steps via callbacks
            on the <paramref name="context"/>
            </summary>
            <param name="context">The <see cref="T:Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext"/> to register callbacks on</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext">
            <summary>
            Context passed to an incremental generator when <see cref="M:Microsoft.CodeAnalysis.IIncrementalGenerator.Initialize(Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext)"/> is called
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IncrementalGeneratorPostInitializationContext">
            <summary>
            Context passed to an incremental generator when it has registered an output via <see cref="M:Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext.RegisterPostInitializationOutput(System.Action{Microsoft.CodeAnalysis.IncrementalGeneratorPostInitializationContext})"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IncrementalGeneratorPostInitializationContext.CancellationToken">
            <summary>
            A <see cref="T:System.Threading.CancellationToken"/> that can be checked to see if the PostInitialization should be cancelled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IncrementalGeneratorPostInitializationContext.AddSource(System.String,System.String)">
            <summary>
            Adds source code in the form of a <see cref="T:System.String"/> to the compilation that will be available during subsequent phases
            </summary>
            <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator</param>
            <param name="source">The source code to add to the compilation</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IncrementalGeneratorPostInitializationContext.AddSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Adds a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> to the compilation that will be available during subsequent phases
            </summary>
            <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator</param>
            <param name="sourceText">The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> to add to the compilation</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceProductionContext">
            <summary>
            Context passed to an incremental generator when it has registered an output via <see cref="M:Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext.RegisterSourceOutput``1(Microsoft.CodeAnalysis.IncrementalValueProvider{``0},System.Action{Microsoft.CodeAnalysis.SourceProductionContext,``0})"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceProductionContext.AddSource(System.String,System.String)">
            <summary>
            Adds source code in the form of a <see cref="T:System.String"/> to the compilation.
            </summary>
            <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator</param>
            <param name="source">The source code to add to the compilation</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceProductionContext.AddSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Adds a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> to the compilation
            </summary>
            <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator</param>
            <param name="sourceText">The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> to add to the compilation</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceProductionContext.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Adds a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> to the users compilation 
            </summary>
            <param name="diagnostic">The diagnostic that should be added to the compilation</param>
            <remarks>
            The severity of the diagnostic may cause the compilation to fail, depending on the <see cref="T:Microsoft.CodeAnalysis.Compilation"/> settings.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IncrementalGeneratorRunStep">
            <summary>
            A description of a step of an incremental generator that was executed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IncrementalStepRunReason">
            <summary>
            The state of the output of a given executed incremental source generator step.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IncrementalStepRunReason.New">
            <summary>
            The output of this step is a new output produced from a new input.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IncrementalStepRunReason.Modified">
            <summary>
            The input to this step was modified from a previous run, and it produced a different value than the previous run.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IncrementalStepRunReason.Unchanged">
            <summary>
            The input to this step was modified from a previous run, but it produced an equal value to the previous run.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IncrementalStepRunReason.Cached">
            <summary>
            The output of this step was pulled from this step's cache since the inputs was unchanged from the previous run.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IncrementalStepRunReason.Removed">
            <summary>
            The input that this output is generated from was removed from the input step's outputs, so this value will be removed from the output step results.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IncrementalValueProvider`1">
            <summary>
            Represents a provider of a single value that can be transformed as part of constructing an execution pipeline
            </summary>
            <remarks>
            This is an opaque type that cannot be used directly. Instead an <see cref="T:Microsoft.CodeAnalysis.IIncrementalGenerator" />
            will receive a set of value providers when constructing its execution pipeline. A set of extension methods
            are then used to create transforms over the data that creates the actual pipeline.
            </remarks>
            <typeparam name="TValue">The type of value that this source provides access to</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IncrementalValuesProvider`1">
            <summary>
            Represents a provider of multiple values that can be transformed to construct an execution pipeline
            </summary>
            <remarks>
            This is an opaque type that cannot be used directly. Instead an <see cref="T:Microsoft.CodeAnalysis.IIncrementalGenerator" />
            will receive a set of value providers when constructing its execution pipeline. A set of extension methods
            are then used to create transforms over the data that creates the actual pipeline.
            </remarks>
            <typeparam name="TValues">The type of value that this source provides access to</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IncrementalGeneratorWrapper">
            <summary>
            Wraps an incremental generator in a dummy <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> interface.
            </summary>
            <remarks>
            Allows us to treat both generator types as ISourceGenerator externally and not change the public API.
            Inside the driver we unwrap and use the actual generator instance.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ISourceGenerator">
            <summary>
            The base interface required to implement a source generator
            </summary>
            <remarks>
            The lifetime of a generator is controlled by the compiler.
            State should not be stored directly on the generator, as there
            is no guarantee that the same instance will be used on a 
            subsequent generation pass.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISourceGenerator.Initialize(Microsoft.CodeAnalysis.GeneratorInitializationContext)">
            <summary>
            Called before generation occurs. A generator can use the <paramref name="context"/>
            to register callbacks required to perform generation.
            </summary>
            <param name="context">The <see cref="T:Microsoft.CodeAnalysis.GeneratorInitializationContext"/> to register callbacks on</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISourceGenerator.Execute(Microsoft.CodeAnalysis.GeneratorExecutionContext)">
            <summary>
            Called to perform source generation. A generator can use the <paramref name="context"/>
            to add source files via the <see cref="M:Microsoft.CodeAnalysis.GeneratorExecutionContext.AddSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)"/> 
            method.
            </summary>
            <param name="context">The <see cref="T:Microsoft.CodeAnalysis.GeneratorExecutionContext"/> to add source to</param>
            <remarks>
            This call represents the main generation step. It is called after a <see cref="T:Microsoft.CodeAnalysis.Compilation"/> is 
            created that contains the user written code. 
            
            A generator can use the <see cref="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.Compilation"/> property to
            discover information about the users compilation and make decisions on what source to 
            provide. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISyntaxHelper.AddAliases(Microsoft.CodeAnalysis.GreenNode,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.ValueTuple{System.String,System.String}},System.Boolean)">
            <summary>
            <paramref name="node"/> must be a compilation unit or namespace block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ISyntaxReceiver">
            <summary>
            Receives notifications of each <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> in the compilation before generation runs
            </summary>
            <remarks>
            A <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> can provide an instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/>
            via a <see cref="T:Microsoft.CodeAnalysis.SyntaxReceiverCreator"/>.
            
            The compiler will invoke the <see cref="T:Microsoft.CodeAnalysis.SyntaxReceiverCreator"/> prior to generation to 
            obtain an instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/>. This instance will have its 
            <see cref="M:Microsoft.CodeAnalysis.ISyntaxReceiver.OnVisitSyntaxNode(Microsoft.CodeAnalysis.SyntaxNode)"/> called for every syntax node in the compilation.
            
            The <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/> can record any information about the nodes visited. During
            <see cref="M:Microsoft.CodeAnalysis.ISourceGenerator.Execute(Microsoft.CodeAnalysis.GeneratorExecutionContext)"/> the generator can obtain the 
            created instance via the <see cref="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.SyntaxReceiver"/> property. The
            information contained can be used to perform final generation.
            
            A new instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/> is created per-generation, meaning the instance
            is free to store state without worrying about lifetime or reuse.
            
            An <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> may provide only a single <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/> or
            <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver" />, not both.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISyntaxReceiver.OnVisitSyntaxNode(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Called for each <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> in the compilation
            </summary>
            <param name="syntaxNode">The current <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> being visited</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxReceiverCreator">
            <summary>
            Allows a generator to provide instances of an <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/>
            </summary>
            <returns>An instance of an <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver">
            <summary>
            Receives notifications of each <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> in the compilation, along with a  
            <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> that can be queried to obtain more information, before generation
            runs.
            </summary>
            <remarks>
            A <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> can provide an instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/>
            via a <see cref="T:Microsoft.CodeAnalysis.SyntaxReceiverCreator"/>.
            
            The compiler will invoke the <see cref="T:Microsoft.CodeAnalysis.SyntaxReceiverCreator"/> prior to generation to 
            obtain an instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/>. This instance will have its 
            <see cref="M:Microsoft.CodeAnalysis.ISyntaxContextReceiver.OnVisitSyntaxNode(Microsoft.CodeAnalysis.GeneratorSyntaxContext)"/> called for every syntax node
            in the compilation.
            
            The <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/> can record any information about the nodes visited. 
            During <see cref="M:Microsoft.CodeAnalysis.ISourceGenerator.Execute(Microsoft.CodeAnalysis.GeneratorExecutionContext)"/> the generator can obtain the 
            created instance via the <see cref="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.SyntaxContextReceiver"/> property. The
            information contained can be used to perform final generation.
            
            A new instance of <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/> is created per-generation, meaning the instance
            is free to store state without worrying about lifetime or reuse. 
            
            An <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> may provide only a single <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/> or
            <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver" />, not both.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxContextReceiverCreator">
            <summary>
            Allows a generator to provide instances of an <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/>
            </summary>
            <returns>An instance of an <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IIncrementalGeneratorNode`1">
            <summary>
            Represents a node in the execution pipeline of an incremental generator
            </summary>
            <typeparam name="T">The type of value this step operates on</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IIncrementalGeneratorOutputNode">
            <summary>
            Internal representation of an incremental output
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IncrementalGeneratorOutputKind">
            <summary>
            Represents the various output kinds of an <see cref="T:Microsoft.CodeAnalysis.IIncrementalGenerator"/>. 
            </summary>
            <remarks>
            Can be passed as a bit field when creating a <see cref="T:Microsoft.CodeAnalysis.GeneratorDriver"/> to selectively disable outputs.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IncrementalGeneratorOutputKind.None">
            <summary>
            Represents no output kinds. Can be used when creating a driver to indicate that no outputs should be disabled.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IncrementalGeneratorOutputKind.Source">
            <summary>
            A regular source output, registered via <see cref="M:Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext.RegisterSourceOutput``1(Microsoft.CodeAnalysis.IncrementalValueProvider{``0},System.Action{Microsoft.CodeAnalysis.SourceProductionContext,``0})"/> 
            or <see cref="M:Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext.RegisterSourceOutput``1(Microsoft.CodeAnalysis.IncrementalValuesProvider{``0},System.Action{Microsoft.CodeAnalysis.SourceProductionContext,``0})"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IncrementalGeneratorOutputKind.PostInit">
            <summary>
            A post-initialization output, which will be visible to later phases, registered via <see cref="M:Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext.RegisterPostInitializationOutput(System.Action{Microsoft.CodeAnalysis.IncrementalGeneratorPostInitializationContext})"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.IncrementalGeneratorOutputKind.Implementation">
            <summary>
            An Implementation only source output, registered via <see cref="M:Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext.RegisterImplementationSourceOutput``1(Microsoft.CodeAnalysis.IncrementalValueProvider{``0},System.Action{Microsoft.CodeAnalysis.SourceProductionContext,``0})"/>
            or <see cref="M:Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext.RegisterImplementationSourceOutput``1(Microsoft.CodeAnalysis.IncrementalValuesProvider{``0},System.Action{Microsoft.CodeAnalysis.SourceProductionContext,``0})"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InputNode`1">
            <summary>
            Input nodes are the 'root' nodes in the graph, and get their values from the inputs of the driver state table
            </summary>
            <typeparam name="T">The type of the input</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NodeStateTable`1">
            <summary>
            A data structure that tracks the inputs and output of an execution node
            </summary>
            <typeparam name="T">The type of the items tracked by this table</typeparam>
        </member>
        <member name="P:Microsoft.CodeAnalysis.NodeStateTable`1.IsCached">
            <summary>
            Indicates if every entry in this table has a state of <see cref="F:Microsoft.CodeAnalysis.EntryState.Cached"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NodeStateTable`1.TableEntry._states">
            <summary>
            Represents the corresponding state of each item in <see cref="F:Microsoft.CodeAnalysis.NodeStateTable`1.TableEntry._items"/>, or contains a single state when
            <see cref="F:Microsoft.CodeAnalysis.NodeStateTable`1.TableEntry._items"/> is populated or when every state of <see cref="F:Microsoft.CodeAnalysis.NodeStateTable`1.TableEntry._items"/> has the same value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SharedInputNodes">
            <summary>
            Holds input nodes that are shared between generators and always exist
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxValueProvider">
            <summary>
            Allows a user to create Syntax based input nodes for incremental generation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxValueProvider.CreateSyntaxProvider``1(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.GeneratorSyntaxContext,System.Threading.CancellationToken,``0})">
            <summary>
            Creates an <see cref="T:Microsoft.CodeAnalysis.IncrementalValueProvider`1"/> that can provide a transform over <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s
            </summary>
            <typeparam name="T">The type of the value the syntax node is transformed into</typeparam>
            <param name="predicate">A function that determines if the given <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> should be transformed</param>
            <param name="transform">A function that performs the transform, when <paramref name="predicate"/>returns <c>true</c> for a given node</param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.IncrementalValueProvider`1"/> that provides the results of the transformation</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxValueProvider.CreateSyntaxReceiverProvider(Microsoft.CodeAnalysis.SyntaxContextReceiverCreator)">
            <summary>
            Creates a syntax receiver input node. Only used for back compat in <see cref="T:Microsoft.CodeAnalysis.SourceGeneratorAdaptor"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxValueProvider.ForAttributeWithMetadataName``1(System.String,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext,System.Threading.CancellationToken,``0})">
            <summary>
            Creates an <see cref="T:Microsoft.CodeAnalysis.IncrementalValuesProvider`1"/> that can provide a transform over all <see
            cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>s if that node has an attribute on it that binds to a <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> with the
            same fully-qualified metadata as the provided <paramref name="fullyQualifiedMetadataName"/>. <paramref
            name="fullyQualifiedMetadataName"/> should be the fully-qualified, metadata name of the attribute, including the
            <c>Attribute</c> suffix.  For example <c>"System.CLSCompliantAttribute</c> for <see
            cref="T:System.CLSCompliantAttribute"/>.
            </summary>
            <param name="predicate">A function that determines if the given <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> attribute target (<see
            cref="P:Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext.TargetNode"/>) should be transformed.  Nodes that do not pass this
            predicate will not have their attributes looked at at all.</param>
            <param name="transform">A function that performs the transform. This will only be passed nodes that return <see
            langword="true"/> for <paramref name="predicate"/> and which have a matching <see cref="T:Microsoft.CodeAnalysis.AttributeData"/> whose
            <see cref="P:Microsoft.CodeAnalysis.AttributeData.AttributeClass"/> has the same fully qualified, metadata name as <paramref
            name="fullyQualifiedMetadataName"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxValueProvider.ForAttributeWithSimpleName(System.String,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken,System.Boolean})">
            <summary>
            Returns all syntax nodes of that match <paramref name="predicate"/> if that node has an attribute on it that
            could possibly bind to the provided <paramref name="simpleName"/>. <paramref name="simpleName"/> should be the
            simple, non-qualified, name of the attribute, including the <c>Attribute</c> suffix, and not containing any
            generics, containing types, or namespaces.  For example <c>CLSCompliantAttribute</c> for <see
            cref="T:System.CLSCompliantAttribute"/>.
            <para/> This provider understands <see langword="using"/> (<c>Import</c> in Visual Basic) aliases and will find
            matches even when the attribute references an alias name.  For example, given:
            <code>
            using XAttribute = System.CLSCompliantAttribute;
            [X]
            class C { }
            </code>
            Then
            <c>context.SyntaxProvider.CreateSyntaxProviderForAttribute(nameof(CLSCompliantAttribute), (node, c) => node is ClassDeclarationSyntax)</c>
            will find the <c>C</c> class.
            </summary>
            <remarks>
            Note: a 'Values'-provider of arrays are returned.  Each array provides all the matching nodes from a single <see
            cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext.TargetNode">
            <summary>
            The syntax node the attribute is attached to.  For example, with <c>[CLSCompliant] class C { }</c> this would
            the class declaration node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext.TargetSymbol">
            <summary>
            The symbol that the attribute is attached to.  For example, with <c>[CLSCompliant] class C { }</c> this would be
            the <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for <c>"C"</c>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext.SemanticModel">
            <summary>
            Semantic model for the file that <see cref="P:Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext.TargetNode"/> is contained within.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext.Attributes">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.AttributeData"/>s for any matching attributes on <see cref="P:Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext.TargetSymbol"/>.  Always non-empty.  All
            these attributes will have an <see cref="P:Microsoft.CodeAnalysis.AttributeData.AttributeClass"/> whose fully qualified name metadata
            name matches the name requested in <see cref="M:Microsoft.CodeAnalysis.SyntaxValueProvider.ForAttributeWithMetadataName``1(System.String,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext,System.Threading.CancellationToken,``0})"/>.
            <para>
            To get the entire list of attributes, use <see cref="M:Microsoft.CodeAnalysis.ISymbol.GetAttributes"/> on <see cref="P:Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext.TargetSymbol"/>.
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorDriverRunResult">
            <summary>
            Represents the results of running a generation pass over a set of <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/>s.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorDriverRunResult.Results">
            <summary>
            The individual result of each <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> that was run in this generator pass, one per generator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorDriverRunResult.ElapsedTime">
            <summary>
            The wall clock time that this generator pass took to execute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorDriverRunResult.Diagnostics">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s produced by all generators run during this generation pass.
            </summary>
            <remarks>
            This is equivalent to the union of all <see cref="P:Microsoft.CodeAnalysis.GeneratorRunResult.Diagnostics"/> in <see cref="P:Microsoft.CodeAnalysis.GeneratorDriverRunResult.Results"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorDriverRunResult.GeneratedTrees">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>s produced during this generation pass by parsing each <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> added by each generator.
            </summary>
            <remarks>
            This is equivalent to the union of all <see cref="P:Microsoft.CodeAnalysis.GeneratedSourceResult.SyntaxTree"/>s in each <see cref="P:Microsoft.CodeAnalysis.GeneratorRunResult.GeneratedSources"/> in each <see cref="P:Microsoft.CodeAnalysis.GeneratorDriverRunResult.Results"/>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorRunResult">
            <summary>
            Represents the results of a single <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> generation pass.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorRunResult.Generator">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> that produced this result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorRunResult.GeneratedSources">
            <summary>
            The sources that were added by <see cref="P:Microsoft.CodeAnalysis.GeneratorRunResult.Generator"/> during the generation pass this result represents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorRunResult.Diagnostics">
            <summary>
            A collection of <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s reported by <see cref="P:Microsoft.CodeAnalysis.GeneratorRunResult.Generator"/> 
            </summary>
            <remarks>
            When generation fails due to an <see cref="P:Microsoft.CodeAnalysis.GeneratorRunResult.Exception"/> being thrown, a single diagnostic is added
            to represent the failure. Any generator reported diagnostics up to the failure point are not included.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorRunResult.Exception">
            <summary>
            An <see cref="T:System.Exception"/> instance that was thrown by the generator, or <c>null</c> if the generator completed without error.
            </summary>
            <remarks>
            When this property has a value, <see cref="P:Microsoft.CodeAnalysis.GeneratorRunResult.GeneratedSources"/> property is guaranteed to be empty, and the <see cref="P:Microsoft.CodeAnalysis.GeneratorRunResult.Diagnostics"/>
            collection will contain a single diagnostic indicating that the generator failed.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorRunResult.ElapsedTime">
            <summary>
            The wall clock time that elapsed while this generator was running.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorRunResult.TrackedSteps">
            <summary>
            A collection of the named incremental steps executed during the generator pass this result represents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorRunResult.TrackedOutputSteps">
            <summary>
            A collection of the named incremental steps executed during the generator pass this result represents.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratedSourceResult">
            <summary>
            Represents the results of an <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> calling <see cref="M:Microsoft.CodeAnalysis.GeneratorExecutionContext.AddSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)"/>.
            </summary>
            <remarks>
            This contains the original <see cref="P:Microsoft.CodeAnalysis.GeneratedSourceResult.SourceText"/> added by the generator, along with the parsed representation of that text in <see cref="P:Microsoft.CodeAnalysis.GeneratedSourceResult.SyntaxTree"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratedSourceResult.SyntaxTree">
            <summary>
            The <see cref="P:Microsoft.CodeAnalysis.GeneratedSourceResult.SyntaxTree"/> that was produced from parsing the <see cref="P:Microsoft.CodeAnalysis.GeneratedSourceResult.SourceText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratedSourceResult.SourceText">
            <summary>
            The <see cref="P:Microsoft.CodeAnalysis.GeneratedSourceResult.SourceText"/> that was added by the generator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratedSourceResult.HintName">
            <summary>
            An identifier provided by the generator that identifies the added <see cref="P:Microsoft.CodeAnalysis.GeneratedSourceResult.SourceText"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorDriverTimingInfo">
            <summary>
            Contains timing information for a full generation pass.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorDriverTimingInfo.ElapsedTime">
            <summary>
            The wall clock time that the entire generation pass took.
            </summary>
            <remarks>
            This can be more than the sum of times in <see cref="P:Microsoft.CodeAnalysis.GeneratorDriverTimingInfo.GeneratorTimes"/> as it includes other costs such as setup.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorDriverTimingInfo.GeneratorTimes">
            <summary>
            Individual timings per generator.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorTimingInfo">
            <summary>
            Contains timing information for a single generator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorTimingInfo.Generator">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/> that was running during the recorded time.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.GeneratorTimingInfo.ElapsedTime">
            <summary>
            The wall clock time the generator spent running.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxContextReceiverAdaptor">
            <summary>
            Wraps an <see cref="T:Microsoft.CodeAnalysis.ISyntaxReceiver"/> in an <see cref="T:Microsoft.CodeAnalysis.ISyntaxContextReceiver"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxStore.Builder.GetRuntimeAdjustment(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxInputNode})">
            <summary>
            Gets the adjustment to wall clock time that should be applied for a set of input nodes.
            </summary>
            <remarks>
            The syntax store updates all input nodes in parallel the first time an input node is asked to update,
            so that it can share the semantic model between multiple nodes and improve perf. 
            
            Unfortunately that means that the first generator to request the results of a syntax node will incorrectly 
            have its wall clock time contain the time of all other syntax nodes. And conversely other input nodes will 
            not have the true time taken.
            
            This method gets the adjustment that should be applied to the wall clock time for a set of input nodes
            so that the correct time is attributed to each.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WellKnownGeneratorInputs">
            <summary>
            Well known incremental generator input step names.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WellKnownGeneratorOutputs">
            <summary>
            Well known incremental generator output step names.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SpecialType">
            <summary>
            Specifies the Ids of special runtime types.
            </summary>
            <remarks>
            Only types explicitly mentioned in "Co-located core types" spec 
            (https://github.com/dotnet/roslyn/blob/main/docs/compilers/Co-located%20core%20types.md)
            can be in this enum.
            The following things should be in sync:
                1) SpecialType enum
                2) names in SpecialTypes.EmittedNames array.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.None">
            <summary>
            Indicates a non-special type (default value).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Object">
            <summary>
            Indicates that the type is <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Enum">
            <summary>
            Indicates that the type is <see cref="T:System.Enum"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_MulticastDelegate">
            <summary>
            Indicates that the type is <see cref="T:System.MulticastDelegate"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Delegate">
            <summary>
            Indicates that the type is <see cref="T:System.Delegate"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_ValueType">
            <summary>
            Indicates that the type is <see cref="T:System.ValueType"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Void">
            <summary>
            Indicates that the type is <see cref="T:System.Void"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Boolean">
            <summary>
            Indicates that the type is <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Char">
            <summary>
            Indicates that the type is <see cref="T:System.Char"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_SByte">
            <summary>
            Indicates that the type is <see cref="T:System.SByte"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Byte">
            <summary>
            Indicates that the type is <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Int16">
            <summary>
            Indicates that the type is <see cref="T:System.Int16"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_UInt16">
            <summary>
            Indicates that the type is <see cref="T:System.UInt16"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Int32">
            <summary>
            Indicates that the type is <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_UInt32">
            <summary>
            Indicates that the type is <see cref="T:System.UInt32"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Int64">
            <summary>
            Indicates that the type is <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_UInt64">
            <summary>
            Indicates that the type is <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Decimal">
            <summary>
            Indicates that the type is <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Single">
            <summary>
            Indicates that the type is <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Double">
            <summary>
            Indicates that the type is <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_String">
            <summary>
            Indicates that the type is <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_IntPtr">
            <summary>
            Indicates that the type is <see cref="T:System.IntPtr" />.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_UIntPtr">
            <summary>
            Indicates that the type is <see cref="T:System.UIntPtr"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Array">
            <summary>
            Indicates that the type is <see cref="T:System.Array"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerable">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.IEnumerable"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerable_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IList_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_ICollection_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_IEnumerator">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.IEnumerator"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IEnumerator_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IReadOnlyList_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Collections_Generic_IReadOnlyCollection_T">
            <summary>
            Indicates that the type is <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Nullable_T">
            <summary>
            Indicates that the type is <see cref="T:System.Nullable`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_DateTime">
            <summary>
            Indicates that the type is <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Runtime_CompilerServices_IsVolatile">
            <summary>
            Indicates that the type is <see cref="T:System.Runtime.CompilerServices.IsVolatile"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_IDisposable">
            <summary>
            Indicates that the type is <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_TypedReference">
            <summary>
            Indicates that the type is <see cref="T:System.TypedReference"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_ArgIterator">
            <summary>
            Indicates that the type is <see cref="T:System.ArgIterator"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_RuntimeArgumentHandle">
            <summary>
            Indicates that the type is <see cref="T:System.RuntimeArgumentHandle"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_RuntimeFieldHandle">
            <summary>
            Indicates that the type is <see cref="T:System.RuntimeFieldHandle"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_RuntimeMethodHandle">
            <summary>
            Indicates that the type is <see cref="T:System.RuntimeMethodHandle"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_RuntimeTypeHandle">
            <summary>
            Indicates that the type is <see cref="T:System.RuntimeTypeHandle"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_IAsyncResult">
            <summary>
            Indicates that the type is <see cref="T:System.IAsyncResult"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_AsyncCallback">
            <summary>
            Indicates that the type is <see cref="T:System.AsyncCallback"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Runtime_CompilerServices_RuntimeFeature">
            <summary>
            Indicates that the type is System.Runtime.CompilerServices.RuntimeFeature.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.System_Runtime_CompilerServices_PreserveBaseOverridesAttribute">
            <summary>
            An attribute that is placed on each method with a 'methodimpl" aka ".override" in metadata.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialType.Count">
            <summary>
            Count of special types. This is not a count of enum members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsClrInteger(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is considered a "built-in integral" by CLR.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsBlittable(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is a primitive of a fixed size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsPrimitiveRecursiveStruct(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            These special types are structs that contain fields of the same type
            (e.g. System.Int32 contains a field of type System.Int32).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsIntegralType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is considered a "built-in integral" by CLR.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.VBForToShiftBits(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            For signed integer types return number of bits for their representation minus 1. 
            I.e. 7 for Int8, 31 for Int32, etc.
            Used for checking loop end condition for VB for loop.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SpecialTypes.s_emittedNames">
            <summary>
            Array of names for types from Cor Library.
            The names should correspond to ids from TypeId enum so
            that we could use ids to index into the array
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypes.GetMetadataName(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Gets the name of the special type as it would appear in metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CryptoBlobParser.TryParseKey(System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Nullable{System.Security.Cryptography.RSAParameters}@)">
            <summary>
            Try to retrieve the public key from a crypto blob.
            </summary>
            <remarks>
            Can be either a PUBLICKEYBLOB or PRIVATEKEYBLOB. The BLOB must be unencrypted.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CryptoBlobParser.ToRSAParameters(System.ReadOnlySpan{System.Byte},System.Boolean)">
            <summary>
            Helper for RsaCryptoServiceProvider.ExportParameters()
            Copied from https://github.com/dotnet/corefx/blob/5fe5f9aae7b2987adc7082f90712b265bee5eefc/src/System.Security.Cryptography.Csp/src/System/Security/Cryptography/CapiHelper.Shared.cs
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CryptoBlobParser.ExponentAsBytes(System.UInt32)">
            <summary>
            Helper for converting a UInt32 exponent to bytes.
            Copied from https://github.com/dotnet/corefx/blob/5fe5f9aae7b2987adc7082f90712b265bee5eefc/src/System.Security.Cryptography.Csp/src/System/Security/Cryptography/CapiHelper.Shared.cs
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CryptoBlobParser.ReadReversed(System.IO.BinaryReader,System.Int32)">
            <summary>
            Read in a byte array in reverse order.
            Copied from https://github.com/dotnet/corefx/blob/5fe5f9aae7b2987adc7082f90712b265bee5eefc/src/System.Security.Cryptography.Csp/src/System/Security/Cryptography/CapiHelper.Shared.cs
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DesktopStrongNameProvider">
            <summary>
            Provides strong name and signs source assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.#ctor(System.Collections.Immutable.ImmutableArray{System.String},System.String)">
            <summary>
            Creates an instance of <see cref="T:Microsoft.CodeAnalysis.DesktopStrongNameProvider"/>.
            </summary>
            <param name="tempPath">Path to use for any temporary file generation.</param>
            <param name="keyFileSearchPaths">An ordered set of fully qualified paths which are searched when locating a cryptographic key file.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.ResolveStrongNameKeyFile(System.String,Microsoft.CodeAnalysis.StrongNameFileSystem,System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Resolves assembly strong name key file path.
            </summary>
            <returns>Normalized key file path or null if not found.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesktopStrongNameProvider.Sign(System.String,System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.StrongNameFileSystem">
            <summary>
            This is an abstraction over the file system which allows for us to do more thorough unit testing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.KeyPair">
            <summary>
            The strong name key associated with the identity of this assembly. 
            This contains the contents of the user-supplied key file exactly as extracted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.PublicKey">
            <summary>
            Determines source assembly identity.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.PrivateKey">
            <summary> 
            The Private key information that will exist if it was a private key file that was parsed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.DiagnosticOpt">
            <summary>
            A diagnostic created in the process of determining the key.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.KeyContainer">
            <summary>
            The CSP key container containing the public key used to produce the key,
            or null if the key was retrieved from <see cref="F:Microsoft.CodeAnalysis.StrongNameKeys.KeyFilePath"/>.
            </summary>
            <remarks>
            The original value as specified by <see cref="T:System.Reflection.AssemblyKeyNameAttribute"/> or 
            <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyContainer"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.KeyFilePath">
            <summary>
            Original key file path, or null if the key is provided by the <see cref="F:Microsoft.CodeAnalysis.StrongNameKeys.KeyContainer"/>.
            </summary>
            <remarks>
            The original value as specified by <see cref="T:System.Reflection.AssemblyKeyFileAttribute"/> or 
            <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.CryptoKeyFile"/>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StrongNameKeys.HasCounterSignature">
            <summary>
            True when the assembly contains a <see cref="T:System.Reflection.AssemblySignatureKeyAttribute"/> value 
            and hence signing requires counter signature verification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.StrongNameKeys.CanSign">
            <summary>
            True if the compilation can be signed using these keys.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.StrongNameKeys.CanProvideStrongName">
            <summary>
            True if a strong name can be created for the compilation using these keys.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.StrongNameProvider">
            <summary>
            Provides strong name and signs source assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.StrongNameProvider.SignFile(Microsoft.CodeAnalysis.StrongNameKeys,System.String)">
            <summary>
            Signs the <paramref name="filePath"/> value using <paramref name="keys"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.StrongNameProvider.SignBuilder(Microsoft.Cci.ExtendedPEBuilder,System.Reflection.Metadata.BlobBuilder,System.Security.Cryptography.RSAParameters)">
            <summary>
            Signs the contents of <paramref name="peBlob"/> using <paramref name="peBuilder"/> and <paramref name="privateKey"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.StrongNameProvider.CreateKeys(System.String,System.String,System.Boolean,Microsoft.CodeAnalysis.CommonMessageProvider)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.StrongNameKeys"/> for the provided information.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SwitchConstantValueHelper">
            <summary>
            Contains helper methods for switch statement label constants
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SwitchConstantValueHelper.CompareSwitchCaseLabelConstants(Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            Method used to compare ConstantValues for switch statement case labels
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns>A value that indicates the relative order of the objects being compared. The return value has these meanings:
            Less than zero:     first instance precedes second in the sort order.
            Zero:               first instance occurs in the same position in the sort order as second.
            Greater than zero:  first instance follows second in the sort order.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplay.AbstractSymbolDisplayVisitor.AddNonNullConstantValue(Microsoft.CodeAnalysis.ITypeSymbol,System.Object,System.Boolean)">
            <summary>
            Append a default argument (i.e. the default argument of an optional parameter).
            Assumed to be non-null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplay.AbstractSymbolDisplayVisitor.IsFlagsEnum(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Check if the given type is an enum with System.FlagsAttribute.
            </summary>
            <remarks>
            TODO: Can/should this be done using WellKnownAttributes?
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FormattedSymbol">
            <summary>
            This class associates a symbol with particular format for display.
            It can be passed as an argument for an error message in place where symbol display should go, 
            which allows to defer building strings and doing many other things (like loading metadata) 
            associated with that until the error message is actually requested.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ObjectDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.ObjectDisplayOptions,Microsoft.CodeAnalysis.ObjectDisplayOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.ObjectDisplayOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ObjectDisplayOptions">
            <summary>
            Specifies the options for how generics are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ObjectDisplayOptions.None">
            <summary>
            Format object using default options.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ObjectDisplayOptions.IncludeCodePoints">
            <summary>
            In C#, include the numeric code point before character literals.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ObjectDisplayOptions.IncludeTypeSuffix">
            <summary>
            Whether or not to include type suffix for applicable integral literals.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ObjectDisplayOptions.UseHexadecimalNumbers">
            <summary>
            Whether or not to display integral literals in hexadecimal.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ObjectDisplayOptions.UseQuotes">
            <summary>
            Whether or not to quote character and string literals.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ObjectDisplayOptions.EscapeNonPrintableCharacters">
            <summary>
            In C#, replace non-printable (e.g. control) characters with dedicated (e.g. \t) or unicode (\u0001) escape sequences.
            In Visual Basic, replace non-printable characters with calls to ChrW and vb* constants.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.UseMetadataMethodNames">
            <summary>
            ".ctor" instead of "Goo"
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes">
            <summary>
            "List`1" instead of "List&lt;T&gt;" ("List(of T)" in VB). Overrides GenericsOptions on
            types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes">
            <summary>
            Append "[Missing]" to missing Metadata types (for testing).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.IncludeScriptType">
            <summary>
            Include the Script type when qualifying type names.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers">
            <summary>
            Include custom modifiers (e.g. modopt([mscorlib]System.Runtime.CompilerServices.IsConst)) on
            the member (return) type and parameters.
            </summary>
            <remarks>
            CONSIDER: custom modifiers are part of the public API, so we might want to move this to SymbolDisplayMemberOptions.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.ReverseArrayRankSpecifiers">
            <summary>
            For a type written as "int[][,]" in C#, then
              a) setting this option will produce "int[,][]", and
              b) not setting this option will produce "int[][,]".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.UseValueTuple">
            <summary>
            Display `System.ValueTuple` instead of tuple syntax `(...)`.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType">
            <summary>
            Display `System.[U]IntPtr` instead of `n[u]int`.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.UsePlusForNestedTypes">
            <summary>
            Separate out nested types from containing types using <c>+</c> instead of <c>.</c> (dot).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.IncludeScoped">
            <summary>
            Includes the <c>scoped</c> keyword.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions.IncludeContainingFileForFileTypes">
            <summary>
            Display `MyType@File.cs` instead of `MyType`.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle">
            <summary>
            Specifies how to display delegates (just the name or the name with the signature).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle.NameOnly">
            <summary>
            Shows only the name of the delegate (e.g. "SomeDelegate").
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle.NameAndParameters">
            <summary>
            Shows the name and the parameters of the delegate (e.g. "SomeDelegate(int x)").  
            <para>
            The format of the parameters will be determined by the other flags passed.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle.NameAndSignature">
            <summary>
            Shows the name and the signature of the delegate (e.g. "void SomeDelegate(int x)").
            <para>
            The format of the signature will be determined by the other flags passed.
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle">
            <summary>
            Specifies how to display extension methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle.Default">
            <summary>
            Displays the extension method based on its <see cref="T:Microsoft.CodeAnalysis.MethodKind"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle.InstanceMethod">
            <summary>
            Displays the extension method in the form of an instance method. 
            For example, IEnumerable&lt;TSource&gt;.ElementAt&lt;TSource&gt;(int index).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle.StaticMethod">
            <summary>
            Displays the extension method as a static method. 
            For example, Enumerable.ElementAt&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, int index).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayExtensions">
            <summary>
            Exposes extension methods for displaying symbol descriptions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.ToDisplayString(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SymbolDisplayPart})">
            <summary>
            Converts an immutable array of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayPart"/>s to a string.
            </summary>
            <param name="parts">The array of parts.</param>
            <returns>The concatenation of the parts into a single string.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions,Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions,Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions,Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions,Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions,Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayKindOptions,Microsoft.CodeAnalysis.SymbolDisplayKindOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.IncludesOption(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions,Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayFormat">
            <summary>
            Describes the formatting rules that should be used when displaying symbols.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat">
            <summary>
            Formats a symbol description as in a C# compiler error message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpShortErrorMessageFormat">
            <summary>
            Formats a symbol description as in a C# compiler short error message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.VisualBasicErrorMessageFormat">
            <summary>
            Formats a symbol description as in a Visual Basic compiler error message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.VisualBasicShortErrorMessageFormat">
            <summary>
            Formats a symbol description as in a Visual Basic compiler short error message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.FullyQualifiedFormat">
            <summary>
            Formats the names of all types and namespaces in a fully qualified style (including the global alias).
            </summary>
            <remarks>
            The current behavior will not output the fully qualified style as expected for member symbols (such as properties) because memberOptions is not set.
            For example, MyNamespace.MyClass.MyPublicProperty will return as MyPublicProperty.
            The current behavior displayed here will be maintained for backwards compatibility.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.MinimallyQualifiedFormat">
            <summary>
            Formats a symbol description in a form that suits <see cref="M:Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayString(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.TestFormat">
            <summary>
            A verbose format for displaying symbols (useful for testing).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.TestFormatWithConstraints">
            <summary>
            A verbose format for displaying symbols (useful for testing).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.QualifiedNameOnlyFormat">
            <summary>
            this.QualifiedNameOnly = containingSymbol.QualifiedNameOnly + "." + this.Name
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.QualifiedNameArityFormat">
            <summary>
            this.QualifiedNameArity = containingSymbol.QualifiedNameArity + "." + this.Name + "`" + this.Arity
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.ShortFormat">
            <summary>
            A succinct format for displaying symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.ILVisualizationFormat">
            <summary>
            The format used for displaying symbols when visualizing IL.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayFormat.ExplicitInterfaceImplementationFormat">
            <summary>
            Used to normalize explicit interface implementation member names.
            Only expected to be applied to interface types (and their type arguments).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.GlobalNamespaceStyle">
            <summary>
            Determines how the global namespace is displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.TypeQualificationStyle">
            <summary>
            Determines how types are qualified (e.g. Nested vs Containing.Nested vs Namespace.Containing.Nested).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.GenericsOptions">
            <summary>
            Determines how generics (on types and methods) should be described (i.e. the level of detail).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.MemberOptions">
            <summary>
            Determines how fields, properties, events, and methods are displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.ParameterOptions">
            <summary>
            Determines how parameters (of methods, properties/indexers, and delegates) are displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.DelegateStyle">
            <summary>
            Determines how delegates are displayed (e.g. name vs full signature).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.ExtensionMethodStyle">
            <summary>
            Determines how extension methods are displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.PropertyStyle">
            <summary>
            Determines how properties are displayed. 
            For example, "Prop" vs "Prop { get; set; }" in C# or "Prop" vs. "ReadOnly Prop" in Visual Basic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.LocalOptions">
            <summary>
            Determines how local variables are displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.KindOptions">
            <summary>
            Determines which kind keywords should be included when displaying symbols.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.MiscellaneousOptions">
            <summary>
            Determines other characteristics of how symbols are displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CompilerInternalOptions">
            <summary>
            Flags that can only be set within the compiler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.#ctor(Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle,Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle,Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions,Microsoft.CodeAnalysis.SymbolDisplayMemberOptions,Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle,Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle,Microsoft.CodeAnalysis.SymbolDisplayParameterOptions,Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle,Microsoft.CodeAnalysis.SymbolDisplayLocalOptions,Microsoft.CodeAnalysis.SymbolDisplayKindOptions,Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)">
            <summary>
            Constructs a new instance of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayFormat"/> accepting a variety of optional parameters.
            </summary>
            <param name="globalNamespaceStyle">
            The settings that determine how the global namespace is displayed.
            </param>
            <param name="typeQualificationStyle">
            The settings that determine how types are qualified (e.g. Nested vs Containing.Nested vs Namespace.Containing.Nested).
            </param>
            <param name="genericsOptions">
            The settings that determine how generics (on types and methods) should be described (i.e. the level of detail).
            </param>
            <param name="memberOptions">
            The settings that determine how fields, properties, events, and methods are displayed.
            </param>
            <param name="delegateStyle">
            The settings that determine how delegates are displayed (e.g. name vs full signature).
            </param>
            <param name="extensionMethodStyle">
            The settings that determine how extension methods are displayed.
            </param>
            <param name="parameterOptions">
            The settings that determine how parameters (of methods, properties/indexers, and delegates) are displayed.
            </param>
            <param name="propertyStyle">
            The settings that determine how properties are displayed. 
            For example, "Prop" vs "Prop { get; set; }" in C# or "Prop" vs. "ReadOnly Prop" in Visual Basic.
            </param>
            <param name="localOptions">
            The settings that determine how local variables are displayed.
            </param>
            <param name="kindOptions">
            The settings that determine which kind keywords should be included when displaying symbols.
            </param>
            <param name="miscellaneousOptions">
            The settings that determine other characteristics of how symbols are displayed.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.#ctor(Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions,Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle,Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle,Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions,Microsoft.CodeAnalysis.SymbolDisplayMemberOptions,Microsoft.CodeAnalysis.SymbolDisplayParameterOptions,Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle,Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle,Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle,Microsoft.CodeAnalysis.SymbolDisplayLocalOptions,Microsoft.CodeAnalysis.SymbolDisplayKindOptions,Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)">
            <summary>
            This version also accepts <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/>.
            </summary>
            <param name="options">
            An object representing how miscellaneous symbols will be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters for how miscellaneous symbols will be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat without the specified <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/>.
            </summary>
            <param name="options">
            An object specifying which parameters should not be applied to how miscellaneous symbols will be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, without the specified <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/>.
            </summary>
            <param name="options">
            An object specifying how generic symbols will be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters for how generic symbols will be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with a set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/> stripped away from the original object.
            </summary>
            <param name="options">
            An object specifying which parameters should not be applied to how generic symbols will be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with a set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions"/> stripped away from the original object.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/>.
            </summary>
            <param name="options">
            An object specifying how members will be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters for how members will be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with a set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/> stripped away from the original object.
            </summary>
            <param name="options">
            An object specifying which parameters should not be applied to how members will be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with a set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/> stripped away from the original object.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/>.
            </summary>
            <param name="options">
            An object specifying parameters with which symbols belonging to kind keywords should be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with a replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters with which symbols belonging to kind keywords should be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with a set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/> stripped away from the original object.
            </summary>
            <param name="options">
            The settings that determine other characteristics of how symbols are displayed.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with a set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions"/> stripped away from the original object.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/>.
            </summary>
            <param name="options">
            An object specifying how parameters should be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters on how parameters should be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with a set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/> stripped away from the original object.
            </summary>
            <param name="options">
            An object specifying parameters that should not be applied when formatting parameters.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with a set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/> stripped away from the original object.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithGlobalNamespaceStyle(Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle"/>.
            </summary>
            <param name="style">
            An object specifying parameters on how namespace symbols should be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions"/>.
            </summary>
            <param name="options">
            An object specifying parameters on how symbols belonging to locals should be formatted.
            </param>
            <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions"/>.
            </summary>
            <param name="options">
            An object specifying additional parameters on how symbols belonging to locals should be formatted.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with an additional set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with a set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions"/> stripped away from the original object.
            </summary>
            <param name="options">
            An object specifying parameters that should not be applied when formatting symbols belonging to locals.
            </param>
            <returns>
            A duplicate of the SymbolDisplayFormat, with a set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions"/> stripped away from the original object.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddCompilerInternalOptions(Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with added set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithCompilerInternalOptions(Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions)">
            <summary>
            Creates a copy of the SymbolDisplayFormat but with replaced set of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions">
            <summary>
            Specifies the options for how generics are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions.None">
            <summary>
            Omits the type parameter list entirely.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions.IncludeTypeParameters">
            <summary>
            Includes the type parameters. 
            For example, "Goo&lt;T&gt;" in C# or "Goo(Of T)" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions.IncludeTypeConstraints">
            <summary>
            Includes type parameters and constraints.
            For example, "where T : new()" in C# or "Of T as New" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions.IncludeVariance">
            <summary>
            Includes <c>in</c> or <c>out</c> keywords before variant type parameters.
            For example, "Goo&lt;out T&gt;" in C# or (Goo Of Out T" in Visual Basic.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle">
            <summary>
            Specifies the options for how to display the global namespace in the description of a symbol.
            </summary>
            <remarks>
            Any of these styles may be overridden by <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle.Omitted">
            <summary>
            Omits the global namespace, unconditionally.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining">
            <summary>
            Omits the global namespace if it is being displayed as a containing symbol (i.e. not on its own).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle.Included">
            <summary>
            Include the global namespace, unconditionally.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions">
            <summary>
            Specifies which kind keywords should be included when displaying symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayKindOptions.None">
            <summary>
            Omits all kind keywords.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayKindOptions.IncludeNamespaceKeyword">
            <summary>
            Includes the <c>namespace</c> keyword before namespaces.
            For example, "namespace System", rather than "System".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayKindOptions.IncludeTypeKeyword">
            <summary>
            Includes the type keyword before types.
            For example, "class C" in C# or "Structure S" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayKindOptions.IncludeMemberKeyword">
            <summary>
            Include the member keyword before members (if one exists).
            For example, "event D E" in C# or "Function MyFun()" in Visual Basic.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions">
            <summary>
            Specifies the options for how locals are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions.None">
            <summary>
            Shows only the name of the local.
            For example, "x".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions.IncludeType">
            <summary>
            Shows the type of the local in addition to its name.
            For example, "int x" in C# or "x As Integer" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions.IncludeConstantValue">
            <summary>
            Shows the constant value of the local, if there is one, in addition to its name.
            For example "x = 1".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions.IncludeRef">
            <summary>
            Includes the <c>ref</c> keyword for ref-locals.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions">
            <summary>
            Specifies the options for how members are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.None">
            <summary>
            Includes only the name of the member.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeType">
            <summary>
            Includes the (return) type of the method/field/property/event.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeModifiers">
            <summary>
            Includes the modifiers of the member. For example, "static readonly" in C# or "Shared ReadOnly" in Visual Basic.
            <para>
            Accessibility modifiers are controlled separately by <see cref="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeAccessibility"/>.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeAccessibility">
            <summary>
            Includes the accessibility modifiers of the member. For example, "public" in C# or "Public" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeExplicitInterface">
            <summary>
            Includes the name of corresponding interface on members that explicitly implement interface members. For example, "IGoo.Bar { get; }".        
            <para>
            This option has no effect in Visual Basic.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeParameters">
            <summary>
            Includes the parameters of methods and properties/indexers.        
            <para>
            See <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions"/> for finer-grained settings.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeContainingType">
            <summary>
            Includes the name of the type containing the member.        
            <para>
            The format of the containing type is determined by <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle"/>.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeConstantValue">
            <summary>
            Includes the value of the member if is a constant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeRef">
            <summary>
            Includes the <c>ref</c>, <c>ref readonly</c>, <c>ByRef</c> keywords for ref-returning methods and properties/indexers.
            Also includes the <c>readonly</c> keyword on methods, properties/indexers, and events due to the keyword
            changing the <c>this</c> parameter's ref kind from <c>ref</c> to <c>ref readonly</c>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions">
            <summary>
            Specifies miscellaneous options about the format of symbol descriptions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.None">
            <summary>
            Specifies that no miscellaneous options should be applied.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.UseSpecialTypes">
            <summary>
            Uses keywords for predefined types. 
            For example, "int" instead of "System.Int32" in C#
            or "Integer" instead of "System.Integer" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers">
            <summary>
            Escapes identifiers that are also keywords.
            For example, "@true" instead of "true" in C# or
            "[True]" instead of "True" in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.UseAsterisksInMultiDimensionalArrays">
            <summary>
            Displays asterisks between commas in multi-dimensional arrays.
            For example, "int[][*,*]" instead of "int[][,]" in C# or
            "Integer()(*,*)" instead of "Integer()(*,*) in Visual Basic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName">
            <summary>
            Displays "?" for erroneous types that lack names (perhaps due to faulty metadata).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix">
            <summary>
            Displays attributes names without the "Attribute" suffix, if possible.
            <para>
            Has no effect outside <see cref="M:Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayString(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)"/> and only applies
            if the context location is one where an attribute ca be referenced without the suffix.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.ExpandNullable">
            <summary>
            Displays <see cref="T:System.Nullable`1"/> as a normal generic type, rather than with
            the special question mark syntax.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier">
            <summary>
            Append '?' to nullable reference types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.AllowDefaultLiteral">
            <summary>
            Allow the use of <c>default</c> instead of <c>default(T)</c> where applicable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier">
            <summary>
            Append '!' to non-nullable reference types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions.CollapseTupleTypes">
            <summary>
            Insert a tuple into the display parts as a single part instead of multiple parts (similar
            to how anonymous types are inserted).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions">
            <summary>
            Specifies how parameters are displayed in the description of a (member, property/indexer, or delegate) symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.None">
            <summary>
            Omits parameters from symbol descriptions.    
            <para>
            If this option is combined with <see cref="F:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions.IncludeParameters"/>, then only
            the parentheses will be shown (e.g. M()).
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeExtensionThis">
            <summary>
            Includes the <c>this</c> keyword before the first parameter of an extension method in C#. 
            <para>
            This option has no effect in Visual Basic.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeParamsRefOut">
            <summary>
            Includes the <c>params</c>, <c>ref</c>, <c>in</c>, <c>out</c>, <c>ByRef</c>, <c>ByVal</c> keywords before parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeType">
            <summary>
            Includes parameter types in symbol descriptions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeName">
            <summary>
            Includes parameter names in symbol descriptions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeDefaultValue">
            <summary>
            Includes parameter default values in symbol descriptions.
            <para>Ignored if <see cref="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeName"/> is not set.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions.IncludeOptionalBrackets">
            <summary>
            Includes square brackets around optional parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayPart">
            <summary>
            A single element of a symbol description.  For example, a keyword, a punctuation character or
            a class name.
            </summary>
            <seealso cref="M:Microsoft.CodeAnalysis.ISymbol.ToDisplayParts(Microsoft.CodeAnalysis.SymbolDisplayFormat)"/>
            <seealso cref="M:Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayParts(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)"/>
            <seealso cref="T:Microsoft.CodeAnalysis.SymbolDisplayPartKind"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayPart.Kind">
            <summary>
            Gets the kind of this display part.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolDisplayPart.Symbol">
            <summary>
            Gets the symbol associated with this display part, if there is one.
            For example, the <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/> associated with a class name.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayPart.#ctor(Microsoft.CodeAnalysis.SymbolDisplayPartKind,Microsoft.CodeAnalysis.ISymbol,System.String)">
            <summary>
            Construct a non-formattable <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayPart"/> (i.e. with a fixed string value).
            </summary>
            <param name="kind">The kind of the display part.</param>
            <param name="symbol">An optional associated symbol.</param>
            <param name="text">The fixed string value of the part.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolDisplayPart.ToString">
            <summary>
            Returns the string value of this symbol display part.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayPartKind">
            <summary>
            Specifies the kinds of a piece of classified text (SymbolDisplayPart).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.AliasName">
            <summary>The name of an alias.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.AssemblyName">
            <summary>The name of an assembly.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.ClassName">
            <summary>The name of a class.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.DelegateName">
            <summary>The name of a delegate.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.EnumName">
            <summary>The name of an enum.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.ErrorTypeName">
            <summary>The name of an error type.</summary>
            <seealso cref="T:Microsoft.CodeAnalysis.IErrorTypeSymbol"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.EventName">
            <summary>The name of an event.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.FieldName">
            <summary>The name of a field.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.InterfaceName">
            <summary>The name of an interface.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Keyword">
            <summary>A language keyword.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.LabelName">
            <summary>The name of a label.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.LineBreak">
            <summary>A line-break (i.e. whitespace).</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.NumericLiteral">
            <summary>A numeric literal.
            <para>Typically for the default values of parameters and the constant values of fields.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.StringLiteral">
            <summary>A string literal.
            <para>Typically for the default values of parameters and the constant values of fields.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.LocalName">
            <summary>The name of a local.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.MethodName">
            <summary>The name of a method.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.ModuleName">
            <summary>The name of a module.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.NamespaceName">
            <summary>The name of a namespace.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Operator">
            <summary>The symbol of an operator (e.g. "+").</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.ParameterName">
            <summary>The name of a parameter.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.PropertyName">
            <summary>The name of a property.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Punctuation">
            <summary>A punctuation character (e.g. "(", ".", ",") other than an <see cref="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Operator"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Space">
            <summary>A single space character.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.StructName">
            <summary>The name of a struct (structure in Visual Basic).</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.AnonymousTypeIndicator">
            <summary>A keyword-like part for anonymous types (not actually a keyword).</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.Text">
            <summary>An unclassified part.
            <para>Never returned - only set in user-constructed parts.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.TypeParameterName">
            <summary>The name of a type parameter.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.RangeVariableName">
            <summary>The name of a query range variable.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.EnumMemberName">
            <summary>The name of an enum member.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.ExtensionMethodName">
            <summary>The name of a reduced extension method.
            <para>
            When an extension method is in it's non-reduced form it will be will be marked as MethodName.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.ConstantName">
            <summary>The name of a field or local constant.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.RecordClassName">
            <summary>The name of a record class.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPartKind.RecordStructName">
            <summary>The name of a record struct.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle">
            <summary>
            Specifies the options for how properties are displayed in symbol descriptions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle.NameOnly">
            <summary>
            Shows only the names of properties.
            <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle.ShowReadWriteDescriptor">
            <summary>
            Indicates whether the property is readable and/or writable.
            In C#, this is accomplished by including accessors.
            In Visual Basic, this is accomplished by including the <c>ReadOnly</c> or <c>WriteOnly</c>
            keyword, as appropriate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle">
            <summary>
            Specifies how much qualification is used in symbol descriptions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle.NameOnly">
            <summary>
            Shows only the name of the symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle.NameAndContainingTypes">
            <summary>
            Shows the name of the symbol and the names of all containing types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces">
            <summary>
            Shows the name of the symbol the names of all containing types and namespaces.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Accessibility">
            <summary>
            Enumeration for common accessibility combinations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Accessibility.NotApplicable">
            <summary>
            No accessibility specified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Accessibility.ProtectedAndInternal">
            <summary>
            Only accessible where both protected and internal members are accessible
            (more restrictive than <see cref="F:Microsoft.CodeAnalysis.Accessibility.Protected"/>, <see cref="F:Microsoft.CodeAnalysis.Accessibility.Internal"/> and <see cref="F:Microsoft.CodeAnalysis.Accessibility.ProtectedOrInternal"/>).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Accessibility.ProtectedAndFriend">
            <summary>
            Only accessible where both protected and friend members are accessible
            (more restrictive than <see cref="F:Microsoft.CodeAnalysis.Accessibility.Protected"/>, <see cref="F:Microsoft.CodeAnalysis.Accessibility.Friend"/> and <see cref="F:Microsoft.CodeAnalysis.Accessibility.ProtectedOrFriend"/>).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Accessibility.ProtectedOrInternal">
            <summary>
            Accessible wherever either protected or internal members are accessible
            (less restrictive than <see cref="F:Microsoft.CodeAnalysis.Accessibility.Protected"/>, <see cref="F:Microsoft.CodeAnalysis.Accessibility.Internal"/> and <see cref="F:Microsoft.CodeAnalysis.Accessibility.ProtectedAndInternal"/>).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Accessibility.ProtectedOrFriend">
            <summary>
            Accessible wherever either protected or friend members are accessible
            (less restrictive than <see cref="F:Microsoft.CodeAnalysis.Accessibility.Protected"/>, <see cref="F:Microsoft.CodeAnalysis.Accessibility.Friend"/> and <see cref="F:Microsoft.CodeAnalysis.Accessibility.ProtectedAndFriend"/>).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Symbols.CommonAnonymousTypeManager._templatesSealed">
            <summary>
            We should not see new anonymous types from source after we finished emit phase. 
            If this field is true, the collection is sealed; in DEBUG it also is used to check the assertion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.CommonAnonymousTypeManager.AreTemplatesSealed">
            <summary>
            Collection of anonymous type templates is sealed 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.IAssemblySymbolInternal.Identity">
            <summary>
            Gets the name of this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.IFieldSymbolInternal.IsVolatile">
            <summary>
            Returns true if this field was declared as "volatile". 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.IMethodSymbolInternal.IsIterator">
            <summary>
            True if the method is a source method implemented as an iterator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.IMethodSymbolInternal.IsAsync">
            <summary>
            Returns true if this method is an async method
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Symbols.IMethodSymbolInternal.Construct(Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal[])">
            <summary>
            Returns a constructed method given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the method.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.INamedTypeSymbolInternal.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.INamespaceSymbolInternal.IsGlobalNamespace">
            <summary>
            Returns whether this namespace is the unnamed, global namespace that is 
            at the root of all namespaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISourceAssemblySymbolInternal.SignatureKey">
            <summary>
            The contents of the AssemblySignatureKeyAttribute
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Symbols.ISymbolInternal">
            <summary>
            Interface implemented by the compiler's internal representation of a symbol.
            An object implementing this interface might also implement <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> (as is done in VB),
            or the compiler's symbols might be wrapped to implement ISymbol (as is done in C#).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.Kind">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/> indicating what kind of symbol it is.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.Name">
            <summary>
            Gets the symbol name. Returns the empty string if unnamed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.Equals(Microsoft.CodeAnalysis.Symbols.ISymbolInternal,Microsoft.CodeAnalysis.TypeCompareKind)">
            <summary>
            Allows a symbol to support comparisons that involve child type symbols
            </summary>
            <remarks>
            Because TypeSymbol equality can differ based on e.g. nullability, any symbols that contain TypeSymbols can also differ in the same way
            This call allows the symbol to accept a comparison kind that should be used when comparing its contained types
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.ContainingSymbol">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Symbols.ISymbolInternal"/> for the immediately containing symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.ContainingAssembly">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Symbols.IAssemblySymbolInternal"/> for the containing assembly. Returns null if the
            symbol is shared across multiple assemblies.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.ContainingModule">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Symbols.IModuleSymbolInternal"/> for the containing module. Returns null if the
            symbol is shared across multiple modules.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.ContainingType">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Symbols.INamedTypeSymbolInternal"/> for the containing type. Returns null if the
            symbol is not contained within a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.ContainingNamespace">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Symbols.INamespaceSymbolInternal"/> for the nearest enclosing namespace. Returns null if the
            symbol isn't contained in a namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.IsDefinition">
            <summary>
            Gets a value indicating whether the symbol is the original definition. Returns false
            if the symbol is derived from another symbol, by type substitution for instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.Locations">
            <summary>
            Gets the locations where the symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.IsImplicitlyDeclared">
            <summary>
            Returns true if this symbol was automatically created by the compiler, and does not have
            an explicit corresponding source code declaration. 
            </summary> 
            <remarks>
            This is intended for symbols that are ordinary symbols in the language sense, and may be
            used by code, but that are simply declared implicitly rather than with explicit language
            syntax.
            
            <para>
            Examples include (this list is not exhaustive):
            <list type="bullet">
            <item><description>The default constructor for a class or struct that is created if one is not provided.</description></item>
            <item><description>The BeginInvoke/Invoke/EndInvoke methods for a delegate.</description></item>
            <item><description>The generated backing field for an auto property or a field-like event.</description></item>
            <item><description>The "this" parameter for non-static methods.</description></item>
            <item><description>The "value" parameter for a property setter.</description></item>
            <item><description>The parameters on indexer accessor methods (not on the indexer itself).</description></item>
            <item><description>Methods in anonymous types.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.DeclaredAccessibility">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Accessibility"/> indicating the declared accessibility for the symbol.
            Returns NotApplicable if no accessibility is declared.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.IsStatic">
            <summary>
            Gets a value indicating whether the symbol is static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.IsVirtual">
            <summary>
            Gets a value indicating whether the symbol is virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.IsOverride">
            <summary>
            Gets a value indicating whether the symbol is an override of a base class symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.IsAbstract">
            <summary>
            Gets a value indicating whether the symbol is abstract.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.GetISymbol">
            <summary>
            Returns an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> instance associated with this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.GetCciAdapter">
            <summary>
            Returns an <see cref="T:Microsoft.Cci.IReference"/> instance associated with this symbol.
            In general, this API is not safe to use. Transition from symbols to Cci interfaces
            should be handled by PEModuleBuilder translation layer. One relatively safe scenario
            is to use it on a symbol that is a definition.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Symbols.ISynthesizedMethodBodyImplementationSymbol">
            <summary>
            Synthesized symbol that implements a method body feature (iterator, async, lambda, etc.)
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISynthesizedMethodBodyImplementationSymbol.Method">
            <summary>
            The symbol whose body lowering produced this synthesized symbol, 
            or null if the symbol is synthesized based on declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency">
            <summary>
            True if this symbol body needs to be updated when the <see cref="P:Microsoft.CodeAnalysis.Symbols.ISynthesizedMethodBodyImplementationSymbol.Method"/> body is updated.
            False if <see cref="P:Microsoft.CodeAnalysis.Symbols.ISynthesizedMethodBodyImplementationSymbol.Method"/> is null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.TypeKind">
            <summary>
            An enumerated value that identifies whether this type is an array, pointer, enum, and so on.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.SpecialType">
            <summary>
            An enumerated value that identifies certain 'special' types such as <see cref="T:System.Object"/>. 
            Returns <see cref="F:Microsoft.CodeAnalysis.SpecialType.None"/> if the type is not special.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.IsReferenceType">
            <summary>
            True if this type is known to be a reference type. It is never the case that
            <see cref="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.IsValueType"/> both return true. However, for an unconstrained type
            parameter, <see cref="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.IsValueType"/> will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.IsValueType">
            <summary>
            True if this type is known to be a value type. It is never the case that
            <see cref="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.IsValueType"/> both return true. However, for an unconstrained type
            parameter, <see cref="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.IsValueType"/> will both return false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal.GetITypeSymbol">
            <summary>
            Returns an <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/> instance associated with this symbol.
            This API and <see cref="M:Microsoft.CodeAnalysis.Symbols.ISymbolInternal.GetISymbol"/> should return the same object.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AttributeUsageInfo.Default">
            <summary>
            Default attribute usage for attribute types:
            (a) Valid targets: AttributeTargets.All
            (b) AllowMultiple: false
            (c) Inherited: true
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonAssemblyWellKnownAttributeData`1">
            <summary>
            Information decoded from well-known custom attributes applied on an assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonAssemblyWellKnownAttributeData`1.AssemblyVersionAttributeSetting">
            <summary>
            Raw assembly version as specified in the AssemblyVersionAttribute, or Nothing if none specified.
            If the string passed to AssemblyVersionAttribute contains * the version build and/or revision numbers are set to <see cref="F:System.UInt16.MaxValue"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonAssemblyWellKnownAttributeData`1.SecurityInformation">
            <summary>
            Returns data decoded from security attributes or null if there are no security attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AttributeData.AttributeClass">
            <summary>
            The attribute class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AttributeData.AttributeConstructor">
            <summary>
            The constructor on the attribute class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AttributeData.ConstructorArguments">
            <summary>
            Constructor arguments on the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AttributeData.NamedArguments">
            <summary>
            Named (property value) arguments on the attribute. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AttributeData.IsConditionallyOmitted">
            <summary>
            Attribute is conditionally omitted if it is a source attribute and both the following are true:
            (a) It has at least one applied conditional attribute AND
            (b) None of conditional symbols are true at the attribute source location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AttributeData.IsTargetEarlyAttribute(Microsoft.CodeAnalysis.Symbols.INamedTypeSymbolInternal,System.Int32,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Checks if an applied attribute with the given attributeType matches the namespace name and type name of the given early attribute's description
            and the attribute description has a signature with parameter count equal to the given attributeArgCount.
            NOTE: We don't allow early decoded attributes to have optional parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AttributeData.GetConstructorArgument``1(System.Int32,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Returns the value of a constructor argument as type <typeparamref name="T"/>.
            Throws if no constructor argument exists or the argument cannot be converted to the type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AttributeData.DecodeNamedArgument``1(System.String,Microsoft.CodeAnalysis.SpecialType,``0)">
            <summary>
            Returns named attribute argument with the given <paramref name="name"/> as type <typeparamref name="T"/>.
            If there is more than one named argument with this name, it returns the last one.
            If no named argument is found then the <paramref name="defaultValue"/> is returned.
            </summary>
            <param name="name">The metadata property or field name. This name is case sensitive (both VB and C#).</param>
            <param name="specialType">SpecialType of the named argument.</param>
            <param name="defaultValue">Default value for the named argument.</param>
            <remarks>
            For user defined attributes VB allows duplicate named arguments and uses the last value.
            Dev11 reports an error for pseudo-custom attributes when emitting metadata. We don't.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AttributeData.DecodeObsoleteAttribute">
            <summary>
            Decode the arguments to ObsoleteAttribute. ObsoleteAttribute can have 0, 1 or 2 arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AttributeData.DecodeDeprecatedAttribute">
            <summary>
            Decode the arguments to DeprecatedAttribute. DeprecatedAttribute can have 3 or 4 arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AttributeData.DecodeExperimentalAttribute">
            <summary>
            Decode the arguments to ExperimentalAttribute. ExperimentalAttribute has 0 arguments.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonAttributeDataComparer">
            <summary>
            Used to determine if two <see cref="T:Microsoft.CodeAnalysis.AttributeData"/> instances are identical,
            i.e. they have the same attribute type, attribute constructor and have identical arguments.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonEventEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on an event.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonEventWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on an event.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonFieldEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a field.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonFieldWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonFieldWellKnownAttributeData.MarshallingInformation">
            <summary>
            Returns marshalling data or null of MarshalAs attribute isn't applied on the field.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonMethodEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonMethodWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonMethodWellKnownAttributeData.SecurityInformation">
            <summary>
            Returns data decoded from security attributes or null if there are no security attributes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonModuleWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a module.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonParameterEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonParameterWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonParameterWellKnownAttributeData.MarshallingInformation">
            <summary>
            Returns marshalling data or null of MarshalAs attribute isn't applied on the parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonPropertyEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonPropertyWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonReturnTypeWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a method return value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonReturnTypeWellKnownAttributeData.MarshallingInformation">
            <summary>
            Returns marshalling data or null of MarshalAs attribute isn't applied on the return value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonTypeEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CommonTypeWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CommonTypeWellKnownAttributeData.SecurityInformation">
            <summary>
            Returns data decoded from security attributes or null if there are no security attributes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CustomAttributesBag`1">
            <summary>
            Represents a bag of custom attributes and the associated decoded well-known attribute data.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.Empty">
            <summary>
            Instance representing sealed custom attribute bag with no attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.WithEmptyData">
            <summary>
            Returns a non-sealed custom attribute bag with null initialized <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1._earlyDecodedWellKnownAttributeData"/>, null initialized <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1._decodedWellKnownAttributeData"/> and uninitialized <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1._customAttributes"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.SetEarlyDecodedWellKnownAttributeData(Microsoft.CodeAnalysis.EarlyWellKnownAttributeData)">
            <summary>
            Sets the early decoded well-known attribute data on the bag in a thread safe manner.
            Stored early decoded data is immutable and cannot be updated further.
            </summary>
            <returns>Returns true if early decoded data were stored into the bag on this thread.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.SetDecodedWellKnownAttributeData(Microsoft.CodeAnalysis.WellKnownAttributeData)">
            <summary>
            Sets the decoded well-known attribute data (except the early data) on the bag in a thread safe manner. 
            Stored decoded data is immutable and cannot be updated further.
            </summary>
            <returns>Returns true if decoded data were stored into the bag on this thread.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.SetAttributes(System.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Sets the bound attributes on the bag in a thread safe manner.
            If store succeeds, it seals the bag and makes the bag immutable.
            </summary>
            <returns>Returns true if bound attributes were stored into the bag on this thread.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.Attributes">
            <summary>
            Gets the stored bound attributes in the bag.
            </summary>
            <remarks>This property can only be accessed on a sealed bag.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.DecodedWellKnownAttributeData">
            <summary>
            Gets the decoded well-known attribute data (except the early data) in the bag. 
            </summary>
            <remarks>This property can only be accessed on the bag after <see cref="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.SetDecodedWellKnownAttributeData(Microsoft.CodeAnalysis.WellKnownAttributeData)"/> has been invoked.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.EarlyDecodedWellKnownAttributeData">
            <summary>
            Gets the early decoded well-known attribute data in the bag. 
            </summary>
            <remarks>This property can only be accessed on the bag after <see cref="M:Microsoft.CodeAnalysis.CustomAttributesBag`1.SetEarlyDecodedWellKnownAttributeData(Microsoft.CodeAnalysis.EarlyWellKnownAttributeData)"/> has been invoked.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.IsEarlyDecodedWellKnownAttributeDataComputed">
            <summary>
            Return whether early decoded attribute data has been computed and stored on the bag and it is safe to access <see cref="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.EarlyDecodedWellKnownAttributeData"/> from this bag.
            Return value of true doesn't guarantee that bound attributes or remaining decoded attribute data has also been initialized.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.IsDecodedWellKnownAttributeDataComputed">
            <summary>
            Return whether all decoded attribute data has been computed and stored on the bag and it is safe to access <see cref="P:Microsoft.CodeAnalysis.CustomAttributesBag`1.DecodedWellKnownAttributeData"/> from this bag.
            Return value of true doesn't guarantee that bound attributes have also been initialized.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart">
            <summary>
            Enum representing the current state of attribute binding/decoding for a corresponding CustomAttributeBag.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.None">
            <summary>
            Bag has been created, but no decoded data or attributes have been stored.
            CustomAttributeBag is in this state during early decoding phase.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.EarlyDecodedWellKnownAttributeData">
            <summary>
            Early decoded attribute data has been computed and stored on the bag, but bound attributes or remaining decoded attribute data is not stored.
            Only <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.EarlyDecodedWellKnownAttributeData"/> can be accessed from this bag.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.DecodedWellKnownAttributeData">
            <summary>
            All decoded attribute data has been computed and stored on the bag, but bound attributes are not yet stored.
            Both <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.EarlyDecodedWellKnownAttributeData"/> and <see cref="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.DecodedWellKnownAttributeData"/> can be accessed from this bag.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.Attributes">
            <summary>
            Bound attributes have been computed and stored on this bag.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CustomAttributesBag`1.CustomAttributeBagCompletionPart.All">
            <summary>
            CustomAttributeBag is completely initialized and immutable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3">
            <summary>
            Contains common arguments to Symbol.DecodeWellKnownAttribute method in both the language compilers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3._lazyDecodeData">
            <summary>
            Object to store the decoded data from bound well-known attributes.
            Created lazily only when some decoded data needs to be stored, null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.GetOrCreateData``1">
            <summary>
            Gets or creates the decoded data object.
            </summary>
            <remarks>
            This method must be called only when some decoded data will be stored into it subsequently.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.HasDecodedData">
            <summary>
            Returns true if some decoded data has been stored into <see cref="F:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3._lazyDecodeData"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.DecodedData">
            <summary>
            Gets the stored decoded data.
            </summary>
            <remarks>
            Assumes <see cref="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.HasDecodedData"/> is true.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.AttributeSyntaxOpt">
            <summary>
            Syntax of the attribute to decode. Might be null when the attribute information is not coming 
            from syntax. For example, an assembly attribute propagated from added module to the resulting assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.Attribute">
            <summary>
            Bound attribute to decode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.Index">
            <summary>
            The index of the attribute in the list of attributes to decode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.AttributesCount">
            <summary>
            Total count of attributes to decode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.Diagnostics">
            <summary>
            Diagnostic bag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3.SymbolPart">
            <summary>
            Specific part of the symbol to which the attributes apply, or AttributeLocation.None if the attributes apply to the symbol itself.
            Used e.g. for return type attributes of a method symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4">
            <summary>
            Contains common arguments to Symbol.EarlyDecodeWellKnownAttribute method in both the language compilers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4._lazyDecodeData">
            <summary>
            Object to store the decoded data from early bound well-known attributes.
            Created lazily only when some decoded data needs to be stored, null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.GetOrCreateData``1">
            <summary>
            Gets or creates the decoded data object.
            </summary>
            <remarks>
            This method must be called only when some decoded data will be stored into it subsequently.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.HasDecodedData">
            <summary>
            Returns true if some decoded data has been stored into <see cref="F:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4._lazyDecodeData"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.DecodedData">
            <summary>
            Gets the stored decoded data.
            </summary>
            <remarks>
            Assumes <see cref="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.HasDecodedData"/> is true.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.Binder">
            <summary>
            Binder to bind early well-known attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.AttributeType">
            <summary>
            Bound type of the attribute to decode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.AttributeSyntax">
            <summary>
            Syntax of the attribute to decode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4.SymbolPart">
            <summary>
            Specific part of the symbol to which the attributes apply, or AttributeLocation.None if the attributes apply to the symbol itself.
            Used e.g. for return type attributes of a method symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EarlyWellKnownAttributeData">
            <summary>
            Base class for storing information decoded from early well-known custom attributes.
            </summary>
            <remarks>
            CONSIDER: Should we remove this class and let the sub-classes derived from WellKnownAttributeData?
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MarshalPseudoCustomAttributeData">
            <summary>
            Information decoded from <see cref="T:System.Runtime.InteropServices.MarshalAsAttribute"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MarshalPseudoCustomAttributeData.WithTranslatedTypes``2(System.Func{``0,``1,``0},``1)">
            <summary>
            Returns an instance of <see cref="T:Microsoft.CodeAnalysis.MarshalPseudoCustomAttributeData"/> with all types replaced by types returned by specified translator.
            Returns this instance if it doesn't hold on any types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ObsoleteAttributeData">
            <summary>
            Information decoded from <see cref="T:System.ObsoleteAttribute"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ObsoleteAttributeData.IsError">
            <summary>
            True if an error should be thrown for the <see cref="T:System.ObsoleteAttribute"/>. Default is false in which case
            a warning is thrown.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ObsoleteAttributeData.Message">
            <summary>
            The message that will be shown when an error/warning is created for <see cref="T:System.ObsoleteAttribute"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ObsoleteAttributeData.DiagnosticId">
            <summary>
            The custom diagnostic ID to use for obsolete diagnostics.
            If null, diagnostics are produced using the compiler default diagnostic IDs.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ObsoleteAttributeData.UrlFormat">
            <summary>
            <para>
            The custom help URL format string for obsolete diagnostics.
            Expected to contain zero or one format items.
            </para>
            <para>
            When specified, the obsolete diagnostic's <see cref="P:Microsoft.CodeAnalysis.DiagnosticDescriptor.HelpLinkUri"/> will be produced
            by formatting this string using the <see cref="F:Microsoft.CodeAnalysis.ObsoleteAttributeData.DiagnosticId"/> as the single argument.
            </para>
            
            <example>
            e.g. with a <see cref="F:Microsoft.CodeAnalysis.ObsoleteAttributeData.DiagnosticId"/> value <c>"TEST1"</c>,
            and a <see cref="F:Microsoft.CodeAnalysis.ObsoleteAttributeData.UrlFormat"/> value <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/{0}/"/>,<br/>
            the diagnostic will have the HelpLinkUri <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/TEST1/"/>.
            </example>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SecurityWellKnownAttributeData">
            <summary>
            Information decoded from security attributes, i.e. attributes derived from well-known SecurityAttribute, applied on a method/type/assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SecurityWellKnownAttributeData.GetSecurityAttributes``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Used for retrieving applied source security attributes, i.e. attributes derived from well-known SecurityAttribute.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WellKnownAttributeData">
            <summary>
            Base class for storing information decoded from well-known custom attributes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownAttributeData.StringMissingValue">
            <summary>
            Used to distinguish cases when attribute is applied with null value and when attribute is not applied.
            For some well-known attributes, the latter case will return string stored in <see cref="F:Microsoft.CodeAnalysis.WellKnownAttributeData.StringMissingValue"/>
            field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomModifier.IsOptional">
            <summary>
            If true, a language may use the modified storage location without 
            being aware of the meaning of the modification, modopt vs. modreq. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CustomModifier.Modifier">
            <summary>
            A type used as a tag that indicates which type of modification applies.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IAliasSymbol">
            <summary>
            Represents a using alias (Imports alias in Visual Basic).
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAliasSymbol.Target">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol"/> for the
            namespace or type referenced by the alias.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IArrayTypeSymbol">
            <summary>
            Represents an array.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.Rank">
            <summary>
            Gets the number of dimensions of this array. A regular single-dimensional array
            has rank 1, a two-dimensional array has rank 2, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.IsSZArray">
            <summary>
            Is this a zero-based one-dimensional array, i.e. SZArray in CLR terms.
            SZArray is an array type encoded in metadata with ELEMENT_TYPE_SZARRAY (always single-dim array with 0 lower bound).
            Non-SZArray type is encoded in metadata with ELEMENT_TYPE_ARRAY and with optional sizes and lower bounds. Even though 
            non-SZArray can also be a single-dim array with 0 lower bound, the encoding of these types in metadata is distinct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.LowerBounds">
            <summary>
            Specified lower bounds for dimensions, by position. The length can be less than <see cref="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.Rank"/>,
            meaning that some trailing dimensions don't have the lower bound specified.
            The most common case is all dimensions are zero bound - a default (Nothing in VB) array is returned in this case.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.Sizes">
            <summary>
            Specified sizes for dimensions, by position. The length can be less than <see cref="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.Rank"/>,
            meaning that some trailing dimensions don't have the size specified.
            The most common case is none of the dimensions have the size specified - an empty array is returned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.ElementType">
            <summary>
            Gets the type of the elements stored in the array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.ElementNullableAnnotation">
            <summary>
            Gets the top-level nullability of the elements stored in the array. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.CustomModifiers">
            <summary>
            Custom modifiers associated with the array type, or an empty array if there are none.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IAssemblySymbol">
            <summary>
            Represents a .NET assembly, consisting of one or more modules.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.IsInteractive">
            <summary>
            True if the assembly contains interactive code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.Identity">
            <summary>
            Gets the name of this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.GlobalNamespace">
            <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.Modules">
            <summary>
            Gets the modules in this assembly. (There must be at least one.) The first one is the main module
            that holds the assembly manifest.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.TypeNames">
            <summary>
            Gets the set of type identifiers from this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.NamespaceNames">
            <summary>
            Gets the set of namespace names from this assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAssemblySymbol.GivesAccessTo(Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            Gets a value indicating whether this assembly gives 
            <paramref name="toAssembly"/> access to internal symbols</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAssemblySymbol.GetTypeByMetadataName(System.String)">
            <summary>
            Lookup a type within the assembly using the canonical CLR metadata name of the type.
            </summary>
            <param name="fullyQualifiedMetadataName">Type name.</param>
            <returns>Symbol for the type or null if type cannot be found or is ambiguous. </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IAssemblySymbol.MightContainExtensionMethods">
            <summary>
            Determines if the assembly might contain extension methods.
            If false, the assembly does not contain extension methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAssemblySymbol.ResolveForwardedType(System.String)">
            <summary>
            Returns the type symbol for a forwarded type based its canonical CLR metadata name.
            The name should refer to a non-nested type. If type with this name is not forwarded,
            null is returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAssemblySymbol.GetForwardedTypes">
            <summary>
            Returns type symbols for top-level (non-nested) types forwarded by this assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAssemblySymbol.GetMetadata">
            <summary>
            If this symbol represents a metadata assembly returns the underlying <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata"/>.
            
            Otherwise, this returns <see langword="null"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IDiscardSymbol">
            <summary>
            A symbol representing a discarded value, e.g. a symbol in the result of
            GetSymbolInfo for <c>_</c> in <c>M(out _)</c> or <c>(x, _) = e</c>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IDiscardSymbol.Type">
            <summary>
            The type of the discarded value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IDiscardSymbol.NullableAnnotation">
            <summary>
            The top-level nullability of the discarded value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IDynamicTypeSymbol">
            <summary>
            Represents the 'dynamic' type in C#.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IErrorTypeSymbol">
            <summary>
            An IErrorTypeSymbol is used when the compiler cannot determine a symbol object to return because
            of an error. For example, if a field is declared "Goo x;", and the type "Goo" cannot be
            found, an IErrorTypeSymbol is returned when asking the field "x" what it's type is.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IErrorTypeSymbol.CandidateSymbols">
            <summary>
            When constructing this type, there may have been symbols that seemed to
            be what the user intended, but were unsuitable. For example, a type might have been
            inaccessible, or ambiguous. This property returns the possible symbols that the user
            might have intended. It will return no symbols if no possible symbols were found.
            See the CandidateReason property to understand why the symbols were unsuitable.
            </summary>
            <remarks>
            This only applies if this INamedTypeSymbol has TypeKind TypeKind.Error.
            If not, an empty ImmutableArray is returned.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IErrorTypeSymbol.CandidateReason">
            <summary>
             If CandidateSymbols returns one or more symbols, returns the reason that those
             symbols were not chosen. Otherwise, returns None.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IEventSymbol">
            <summary>
            Represents an event.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.Type">
            <summary>
            The type of the event. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.NullableAnnotation">
            <summary>
            The top-level nullability of the event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.IsWindowsRuntimeEvent">
            <summary>
            Returns true if the event is a WinRT type event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.AddMethod">
            <summary>
            The 'add' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.RemoveMethod">
            <summary>
            The 'remove' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.RaiseMethod">
            <summary>
            The 'raise' accessor of the event.  Null if there is no raise method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.OriginalDefinition">
            <summary>
            The original definition of the event. If the event is constructed from another
            symbol by type substitution, OriginalDefinition gets the original symbol, as it was 
            defined in source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.OverriddenEvent">
            <summary>
            Returns the overridden event, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IEventSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface properties explicitly implemented by this event.
            </summary>
            <remarks>
            Properties imported from metadata can explicitly implement more than one event.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IFieldSymbol">
            <summary>
            Represents a field in a class, struct or enum.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.AssociatedSymbol">
            <summary>
            If this field serves as a backing variable for an automatically generated
            property or a field-like event, returns that 
            property/event. Otherwise returns null.
            Note, the set of possible associated symbols might be expanded in the future to 
            reflect changes in the languages.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.IsConst">
            <summary>
            Returns true if this field was declared as "const" (i.e. is a constant declaration).
            Also returns true for an enum member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.IsReadOnly">
            <summary>
            Returns true if this field was declared as "readonly". 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.IsVolatile">
            <summary>
            Returns true if this field was declared as "volatile". 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.IsRequired">
            <summary>
            True if this field is required to be set in an object initializer during construction.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.IsFixedSizeBuffer">
            <summary>
            Returns true if this field was declared as "fixed".
            Note that for a fixed-size buffer declaration, this.Type will be a pointer type, of which
            the pointed-to type will be the declared element type of the fixed-size buffer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.FixedSize">
            <summary>
            If IsFixedSizeBuffer is true, the value between brackets in the fixed-size-buffer declaration.
            If IsFixedSizeBuffer is false or there is an error (such as a bad constant value in source), FixedSize is 0.
            Note that for fixed-size buffer declaration, this.Type will be a pointer type, of which
            the pointed-to type will be the declared element type of the fixed-size buffer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.RefKind">
            <summary>
            Returns the RefKind of the field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.RefCustomModifiers">
            <summary>
            Custom modifiers associated with the ref modifier, or an empty array if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.Type">
            <summary>
            Gets the type of this field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.NullableAnnotation">
            <summary>
            Gets the top-level nullability of this field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.ConstantValue">
            <summary>
            Gets the constant value of this field
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.CustomModifiers">
            <summary>
            Returns custom modifiers associated with the field, or an empty array if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.CorrespondingTupleField">
            <summary>
            If this field represents a tuple element, returns a corresponding default element field.
            Otherwise returns null.
            </summary>
            <remarks>
            A tuple type will always have default elements such as Item1, Item2, Item3...
            This API allows matching a field that represents a named element, such as "Alice" 
            to the corresponding default element field such as "Item1"
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFieldSymbol.IsExplicitlyNamedTupleElement">
            <summary>
            Returns true if this field represents a tuple element which was given an explicit name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IFunctionPointerTypeSymbol">
            <summary>
            Represents a function pointer type such as "delegate*&lt;void&gt;".
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IFunctionPointerTypeSymbol.Signature">
            <summary>
            Gets the signature of the function pointed to by an instance of the function pointer type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ILabelSymbol">
            <summary>
            Represents a label in method body
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILabelSymbol.ContainingMethod">
            <summary>
            Gets the immediately containing <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> of this <see cref="T:Microsoft.CodeAnalysis.ILocalSymbol"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ILocalSymbol">
            <summary>
            Represents a local variable in method body.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.Type">
            <summary>
            Gets the type of this local variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.NullableAnnotation">
            <summary>
            Gets the top-level nullability of this local variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.IsConst">
            <summary>
            Returns true if this local variable was declared as "const" (i.e. is a constant declaration).
            Also returns true for an enum member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.IsRef">
            <summary>
            Returns true if this local is a ref local or a ref readonly local.
            Use <see cref="P:Microsoft.CodeAnalysis.ILocalSymbol.RefKind"/> to get more detailed information.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.RefKind">
            <summary>
            Whether the variable is a ref or ref readonly local.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.ScopedKind">
            <summary>
            Returns the scoped kind of the local.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.HasConstantValue">
            <summary>
            Returns false if the local variable wasn't declared as "const", or constant value was omitted or erroneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.ConstantValue">
            <summary>
            Gets the constant value of this local variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.IsFunctionValue">
            <summary>
            Returns true if this local variable is function return variable whose name is the function's name, 
            whose type is the return type of the function and whose initial value is the default of its type. 
            </summary>
            <remarks>
            Is always false for the C# local variable
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.IsFixed">
            <summary>
            Returns true if the local variable is declared with fixed-pointer-initializer (in unsafe context).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.IsForEach">
            <summary>
            Returns true if this local variable is declared as iteration variable
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ILocalSymbol.IsUsing">
            <summary>
            Returns true if the local variable is declared in resource-acquisition of a 'using statement';
            otherwise false
            </summary>
            <example>
            <code>
                using (var localVariable = new StreamReader(path)) { ... } 
            </code>
            </example>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IMethodSymbol">
            <summary>
            Represents a method or method-like symbol (including constructor,
            destructor, operator, or property/event accessor).
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.MethodKind">
            <summary>
            Gets what kind of method this is. There are several different kinds of things in the
            C# language that are represented as methods. This property allow distinguishing those things
            without having to decode the name of the method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.Arity">
            <summary>
            Returns the arity of this method, or the number of type parameters it takes.
            A non-generic method has zero arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsGenericMethod">
            <summary>
            Returns whether this method is generic; i.e., does it have any type parameters?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsExtensionMethod">
            <summary>
            Returns true if this method is an extension method. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsAsync">
            <summary>
            Returns true if this method is an async method
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsVararg">
             <summary>
             Returns whether this method is using CLI VARARG calling convention. This is used for
             C-style variable argument lists. This is used extremely rarely in C# code and is
             represented using the undocumented "__arglist" keyword.
            
             Note that methods with "params" on the last parameter are indicated with the "IsParams"
             property on ParameterSymbol, and are not represented with this property.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsCheckedBuiltin">
            <summary>
            Returns whether this built-in operator checks for integer overflow.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.HidesBaseMethodsByName">
            <summary>
            Returns true if this method hides base methods by name. This cannot be specified directly
            in the C# language, but can be true for methods defined in other languages imported from
            metadata. The equivalent of the "hidebyname" flag in metadata. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReturnsVoid">
            <summary>
            Returns true if this method has no return type; i.e., returns "void".
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReturnsByRef">
            <summary>
            Returns true if this method returns by reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReturnsByRefReadonly">
            <summary>
            Returns true if this method returns by ref readonly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.RefKind">
            <summary>
            Returns the RefKind of the method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReturnType">
            <summary>
            Gets the return type of the method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReturnNullableAnnotation">
            <summary>
            Gets the top-level nullability of the return type of the method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a given type parameter,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.TypeArgumentNullableAnnotations">
            <summary>
            Returns the top-level nullability of the type arguments that have been substituted
            for the type parameters. If nothing has been substituted for a given type parameter,
            then <see cref="F:Microsoft.CodeAnalysis.NullableAnnotation.None"/> is returned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.TypeParameters">
            <summary>
            Get the type parameters on this method. If the method has not generic,
            returns an empty list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.Parameters">
            <summary>
            Gets the parameters of this method. If this method has no parameters, returns
            an empty list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ConstructedFrom">
            <summary>
            Returns the method symbol that this method was constructed from. The resulting
            method symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsReadOnly">
            <summary>
            Indicates whether the method is readonly,
            i.e. whether the 'this' receiver parameter is 'ref readonly'.
            Returns true for readonly instance methods and accessors
            and for reduced extension methods with a 'this in' parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsInitOnly">
            <summary>
            Returns true for 'init' set accessors, and false otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.OverriddenMethod">
            <summary>
            If this method overrides another method (because it both had the override modifier
            and there correctly was a method to override), returns the overridden method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReceiverType">
            <summary>
            If this method can be applied to an object, returns the type of object it is applied to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReceiverNullableAnnotation">
            <summary>
            If this method can be applied to an object, returns the top-level nullability of the object it is applied to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReducedFrom">
            <summary>
            If this method is a reduced extension method, returns the definition of extension
            method from which this was reduced. Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IMethodSymbol.GetTypeInferredDuringReduction(Microsoft.CodeAnalysis.ITypeParameterSymbol)">
            <summary>
            If this method is a reduced extension method, returns a type inferred during reduction process for the type parameter. 
            </summary>
            <param name="reducedFromTypeParameter">Type parameter of the corresponding <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.ReducedFrom"/> method.</param>
            <returns>Inferred type or Nothing if nothing was inferred.</returns>
            <exception cref="T:System.InvalidOperationException">If this is not a reduced extension method.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="reducedFromTypeParameter"/> is null.</exception>
            <exception cref="T:System.ArgumentException">If <paramref name="reducedFromTypeParameter"/> doesn't belong to the corresponding <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.ReducedFrom"/> method.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IMethodSymbol.ReduceExtensionMethod(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            If this is an extension method that can be applied to a receiver of the given type,
            returns a reduced extension method symbol thus formed. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface methods explicitly implemented by this method.
            </summary>
            <remarks>
            Methods imported from metadata can explicitly implement more than one method, 
            that is why return type is ImmutableArray.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.ReturnTypeCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the return type. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.RefCustomModifiers">
            <summary>
            Custom modifiers associated with the ref modifier, or an empty array if there are none.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IMethodSymbol.GetReturnTypeAttributes">
            <summary>
            Returns the list of custom attributes, if any, associated with the returned value. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.CallingConvention">
            <summary>
            The calling convention enum of the method symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.UnmanagedCallingConventionTypes">
            <summary>
            Modifier types that are considered part of the calling convention of this method, if the <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.MethodKind"/> is <see cref="F:Microsoft.CodeAnalysis.MethodKind.FunctionPointerSignature"/>
            and the <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.CallingConvention"/> is <see cref="F:System.Reflection.Metadata.SignatureCallingConvention.Unmanaged"/>. If this is not a function pointer signature or the calling convention is
            not unmanaged, this is an empty array. Order and duplication of these modifiers reflect source/metadata order and duplication, whichever this symbol came from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.AssociatedSymbol">
            <summary>
            Returns a symbol (e.g. property, event, etc.) associated with the method.
            </summary>
            <remarks>
            If this method has <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.MethodKind"/> of <see cref="F:Microsoft.CodeAnalysis.MethodKind.PropertyGet"/> or <see cref="F:Microsoft.CodeAnalysis.MethodKind.PropertySet"/>,
            returns the property that this method is the getter or setter for.
            If this method has <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.MethodKind"/> of <see cref="F:Microsoft.CodeAnalysis.MethodKind.EventAdd"/> or <see cref="F:Microsoft.CodeAnalysis.MethodKind.EventRemove"/>,
            returns the event that this method is the adder or remover for.
            Note, the set of possible associated symbols might be expanded in the future to 
            reflect changes in the languages.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IMethodSymbol.Construct(Microsoft.CodeAnalysis.ITypeSymbol[])">
            <summary>
            Returns a constructed method given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the method.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IMethodSymbol.Construct(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.NullableAnnotation})">
            <summary>
            Returns a constructed method given its type arguments and type argument nullable annotations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.PartialDefinitionPart">
            <summary>
            If this is a partial method implementation part, returns the corresponding
            definition part.  Otherwise null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.PartialImplementationPart">
            <summary>
            If this is a partial method declaration without a body, and the method is
            implemented with a body, returns that implementing definition.  Otherwise
            null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.MethodImplementationFlags">
            <summary>
            Returns the implementation flags for the given method symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsPartialDefinition">
            <summary>
            Return true if this is a partial method definition without a body. If there
            is an implementing body, it can be retrieved with <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.PartialImplementationPart"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IMethodSymbol.GetDllImportData">
            <summary>
            Platform invoke information, or null if the method isn't a P/Invoke.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.AssociatedAnonymousDelegate">
            <summary>
            If this method is a Lambda method (MethodKind = MethodKind.LambdaMethod) and 
            there is an anonymous delegate associated with it, returns this delegate.
            
            Returns null if the symbol is not a lambda or if it does not have an
            anonymous delegate associated with it.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IMethodSymbol.IsConditional">
            <summary>
            Returns a flag indicating whether this symbol has at least one applied/inherited conditional attribute.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IModuleSymbol">
            <summary>
            Represents a module within an assembly. Every assembly contains one or more modules.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IModuleSymbol.GlobalNamespace">
            <summary>
            Returns a NamespaceSymbol representing the global (root) namespace, with
            module extent, that can be used to browse all of the symbols defined in this module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IModuleSymbol.GetModuleNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)">
            <summary>
            Given a namespace symbol, returns the corresponding module specific namespace symbol
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IModuleSymbol.ReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from ReferencedAssemblies and from ReferencedAssemblySymbols 
            correspond to each other.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IModuleSymbol.ReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from ReferencedAssemblies and 
            from ReferencedAssemblySymbols correspond to each other.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IModuleSymbol.GetMetadata">
            <summary>
            If this symbol represents a metadata module returns the underlying <see cref="T:Microsoft.CodeAnalysis.ModuleMetadata"/>.
            
            Otherwise, this returns <see langword="null"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.INamedTypeSymbol">
            <summary>
            Represents a type other than an array, a pointer, a type parameter.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.Arity">
            <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsGenericType">
            <summary>
            True if this type or some containing type has type parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsUnboundGenericType">
            <summary>
            True if this is a reference to an <em>unbound</em> generic type. A generic type is
            considered <em>unbound</em> if all of the type argument lists in its fully qualified
            name are empty. Note that the type arguments of an unbound generic type will be
            returned as error types because they do not really have type arguments.  An unbound
            generic type yields null for its BaseType and an empty result for its Interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsScriptClass">
            <summary>
            Returns true if the type is a Script class. 
            It might be an interactive submission class or a Script class in a csx file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsImplicitClass">
            <summary>
            Returns true if the type is the implicit class that holds onto invalid global members (like methods or
            statements in a non script file).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsComImport">
            <summary>
            Specifies that the class or interface is imported from another module.  See
            <see cref="F:System.Reflection.TypeAttributes.Import"/> and <see cref="T:System.Runtime.InteropServices.ComImportAttribute"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsFileLocal">
            <summary>
            Indicates the type is declared in source and is only visible in the file it is declared in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.MemberNames">
            <summary>
            Returns collection of names of members declared within this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeParameters">
            <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ImmutableArray.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a given type parameter,
            then the type parameter itself is considered the type argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArgumentNullableAnnotations">
            <summary>
            Returns the top-level nullability of the type arguments that have been substituted
            for the type parameters. If nothing has been substituted for a given type parameter,
            then <see cref="F:Microsoft.CodeAnalysis.NullableAnnotation.None"/> is returned for that type argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamedTypeSymbol.GetTypeArgumentCustomModifiers(System.Int32)">
            <summary>
            Returns custom modifiers for the type argument that has been substituted for the type parameter. 
            The modifiers correspond to the type argument at the same ordinal within the <see cref="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArguments"/>
            array. Returns an empty array if there are no modifiers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this type symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.DelegateInvokeMethod">
            <summary>
            For delegate types, gets the delegate's invoke method.  Returns null on
            all other kinds of types.  Note that it is possible to have an ill-formed
            delegate type imported from metadata which does not have an Invoke method.
            Such a type will be classified as a delegate but its DelegateInvokeMethod
            would be null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.ConstructedFrom">
            <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamedTypeSymbol.Construct(Microsoft.CodeAnalysis.ITypeSymbol[])">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamedTypeSymbol.Construct(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.NullableAnnotation})">
            <summary>
            Returns a constructed type given its type arguments and type argument nullable annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamedTypeSymbol.ConstructUnboundGenericType">
            <summary>
            Returns an unbound generic type of this named type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.InstanceConstructors">
            <summary>
            Get the instance constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.StaticConstructors">
            <summary>
            Get the static constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.Constructors">
            <summary>
            Get the both instance and static constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.AssociatedSymbol">
            <summary>
            For implicitly declared delegate types returns the EventSymbol that caused this
            delegate type to be generated.
            For all other types returns null.
            Note, the set of possible associated symbols might be expanded in the future to 
            reflect changes in the languages.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.MightContainExtensionMethods">
            <summary>
            Determines if the symbol might contain extension methods. 
            If false, the symbol does not contain extension methods. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TupleUnderlyingType">
            <summary>
            If this is a tuple type with element names, returns the symbol for the tuple type without names.
            Otherwise, returns null.
            The type argument corresponding to the type of the extension field (VT[8].Rest),
            which is at the 8th (one based) position is always a symbol for another tuple, 
            rather than its underlying type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TupleElements">
             <summary>
             Returns fields that represent tuple elements for types that are tuples.
            
             If this type is not a tuple, then returns default.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsSerializable">
            <summary>
            True if the type is serializable (has Serializable metadata flag).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamedTypeSymbol.NativeIntegerUnderlyingType">
            <summary>
            If this is a native integer, returns the symbol for the underlying type,
            either <see cref="T:System.IntPtr"/> or <see cref="T:System.UIntPtr"/>.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol">
            <summary>
            Represents either a namespace or a type.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ImmutableArray. Never returns Null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ImmutableArray. Never returns Null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.IsNamespace">
            <summary>
            Returns true if this symbol is a namespace. If it is not a namespace, it must be a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.IsType">
            <summary>
            Returns true if this symbols is a type. If it is not a type, it must be a namespace.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.INamespaceSymbol">
            <summary>
            Represents a namespace.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamespaceSymbol.GetNamespaceMembers">
            <summary>
            Get all the members of this symbol that are namespaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceSymbol.IsGlobalNamespace">
            <summary>
            Returns whether this namespace is the unnamed, global namespace that is 
            at the root of all namespaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceSymbol.NamespaceKind">
            <summary>
            The kind of namespace: Module, Assembly or Compilation.
            Module namespaces contain only members from the containing module that share the same namespace name.
            Assembly namespaces contain members for all modules in the containing assembly that share the same namespace name.
            Compilation namespaces contain all members, from source or referenced metadata (assemblies and modules) that share the same namespace name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceSymbol.ContainingCompilation">
            <summary>
            The containing compilation for compilation namespaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.INamespaceSymbol.ConstituentNamespaces">
            <summary>
            If a namespace is an assembly or compilation namespace, it may be composed of multiple
            namespaces that are merged together. If so, ConstituentNamespaces returns
            all the namespaces that were merged. If this namespace was not merged, returns
            an array containing only this namespace.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IParameterSymbol">
            <summary>
            Represents a parameter of a method or property.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.RefKind">
            <summary>
            Whether the parameter passed by value or by reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.ScopedKind">
            <summary>
            Returns the scoped kind of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.IsParams">
            <summary>
            Returns true if the parameter was declared as a parameter array. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.IsOptional">
            <summary>
            Returns true if the parameter is optional.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.IsThis">
            <summary>
            Returns true if the parameter is the hidden 'this' ('Me' in Visual Basic) parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.IsDiscard">
            <summary>
            Returns true if the parameter is a discard parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.Type">
            <summary>
            Gets the type of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.NullableAnnotation">
            <summary>
            Gets the top-level nullability of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.CustomModifiers">
            <summary>
            Custom modifiers associated with the parameter type, or an empty array if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.RefCustomModifiers">
            <summary>
            Custom modifiers associated with the ref modifier, or an empty array if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.Ordinal">
            <summary>
            Gets the ordinal position of the parameter. The first parameter has ordinal zero.
            The 'this' parameter ('Me' in Visual Basic) has ordinal -1.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.HasExplicitDefaultValue">
            <summary>
            Returns true if the parameter specifies a default value to be passed
            when no value is provided as an argument to a call. The default value
            can be obtained with the <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.ExplicitDefaultValue"/> property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.ExplicitDefaultValue">
            <summary>
            Returns the default value of the parameter. 
            </summary>
            <remarks>
            Returns null if the parameter type is a struct and the default value of the parameter
            is the default value of the struct type.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The parameter has no default value.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IParameterSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IPointerTypeSymbol">
            <summary>
            Represents a pointer type such as "int *". Pointer types
            are used only in unsafe code.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPointerTypeSymbol.PointedAtType">
            <summary>
            Gets the type of the storage location that an instance of the pointer type points to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPointerTypeSymbol.CustomModifiers">
            <summary>
            Custom modifiers associated with the pointer type, or an empty array if there are none.
            </summary>
            <remarks>
            Some managed languages may represent special information about the pointer type
            as a custom modifier on either the pointer type or the element type, or
            both.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IPreprocessingSymbol">
            <summary>
            Represents a preprocessing conditional compilation symbol.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IPropertySymbol">
            <summary>
            Represents a property or indexer.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.IsIndexer">
            <summary>
            Returns whether the property is really an indexer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.IsReadOnly">
            <summary>
            True if this is a read-only property; that is, a property with no set accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.IsWriteOnly">
            <summary>
            True if this is a write-only property; that is, a property with no get accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.IsRequired">
            <summary>
            True if this property is required to be set in an object initializer during construction.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.IsWithEvents">
            <summary>
            Returns true if this property is an auto-created WithEvents property that takes place of
            a field member when the field is marked as WithEvents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.ReturnsByRef">
            <summary>
            Returns true if this property returns by reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.ReturnsByRefReadonly">
            <summary>
            Returns true if this property returns by reference a readonly variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.RefKind">
            <summary>
            Returns the RefKind of the property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.Type">
            <summary>
            The type of the property. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.Parameters">
            <summary>
            The parameters of this property. If this property has no parameters, returns
            an empty list. Parameters are only present on indexers, or on some properties
            imported from a COM interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.GetMethod">
            <summary>
            The 'get' accessor of the property, or null if the property is write-only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.SetMethod">
            <summary>
            The 'set' accessor of the property, or null if the property is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.OriginalDefinition">
            <summary>
            The original definition of the property. If the property is constructed from another
            symbol by type substitution, OriginalDefinition gets the original symbol, as it was 
            defined in source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.OverriddenProperty">
            <summary>
            Returns the overridden property, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface properties explicitly implemented by this property.
            </summary>
            <remarks>
            Properties imported from metadata can explicitly implement more than one property.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.RefCustomModifiers">
            <summary>
            Custom modifiers associated with the ref modifier, or an empty array if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IPropertySymbol.TypeCustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the type of the property. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IRangeVariableSymbol">
            <summary>
            Represents a range variable in a query expression.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ISourceAssemblySymbol">
            <summary>
            Represents a source assembly symbol exposed by the compiler.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ISymbol">
            <summary>
            Represents a symbol (namespace, class, method, parameter, etc.)
            exposed by the compiler.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.Kind">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/> indicating what kind of symbol it is.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.Language">
            <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.Name">
            <summary>
            Gets the symbol name. Returns the empty string if unnamed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.MetadataName">
            <summary>
            Gets the name of a symbol as it appears in metadata. Most of the time, this
            is the same as the Name property, with the following exceptions:
            <list type="number">
            <item>
            <description>The metadata name of generic types includes the "`1", "`2" etc. suffix that
            indicates the number of type parameters (it does not include, however, names of
            containing types or namespaces). </description>
            </item>
            <item>
            <description>The metadata name of explicit interface names have spaces removed, compared to
            the name property.</description>
            </item>
            <item>
            <description>The length of names is limited to not exceed metadata restrictions.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.MetadataToken">
            <summary>
            Gets the metadata token associated with this symbol, or 0 if the symbol is not loaded from metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> for the immediately containing symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.ContainingAssembly">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> for the containing assembly. Returns null if the
            symbol is shared across multiple assemblies.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.ContainingModule">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/> for the containing module. Returns null if the
            symbol is shared across multiple modules.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.ContainingType">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> for the containing type. Returns null if the
            symbol is not contained within a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.ContainingNamespace">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/> for the nearest enclosing namespace. Returns null if the
            symbol isn't contained in a namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsDefinition">
            <summary>
            Gets a value indicating whether the symbol is the original definition. Returns false
            if the symbol is derived from another symbol, by type substitution for instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsStatic">
            <summary>
            Gets a value indicating whether the symbol is static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsVirtual">
            <summary>
            Gets a value indicating whether the symbol is virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsOverride">
            <summary>
            Gets a value indicating whether the symbol is an override of a base class symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsAbstract">
            <summary>
            Gets a value indicating whether the symbol is abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsSealed">
            <summary>
            Gets a value indicating whether the symbol is sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsExtern">
            <summary>
            Gets a value indicating whether the symbol is defined externally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.IsImplicitlyDeclared">
            <summary>
            Returns true if this symbol was automatically created by the compiler, and does not have
            an explicit corresponding source code declaration.
            </summary> 
            <remarks>
            This is intended for symbols that are ordinary symbols in the language sense, and may be
            used by code, but that are simply declared implicitly rather than with explicit language
            syntax.
            
            <para>
            Examples include (this list is not exhaustive):
            <list type="bullet">
            <item><description>The default constructor for a class or struct that is created if one is not provided.</description></item>
            <item><description>The BeginInvoke/Invoke/EndInvoke methods for a delegate.</description></item>
            <item><description>The generated backing field for an auto property or a field-like event.</description></item>
            <item><description>The "this" parameter for non-static methods.</description></item>
            <item><description>The "value" parameter for a property setter.</description></item>
            <item><description>The parameters on indexer accessor methods (not on the indexer itself).</description></item>
            <item><description>Methods in anonymous types.</description></item>
            </list>
            </para>
            <para>
            The class and entry point method for top-level statements are not considered as implicitly declared.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.CanBeReferencedByName">
            <summary>
            Returns true if this symbol can be referenced by its name in code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.Locations">
            <summary>
            Gets the locations where the symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.DeclaringSyntaxReferences">
            <summary>
            Get the syntax node(s) where this symbol was declared in source. Some symbols (for example,
            partial classes) may be defined in more than one location. This property should return
            one or more syntax nodes only if the symbol was declared in source code and also was
            not implicitly declared (see the IsImplicitlyDeclared property). 
            
            <para>
            Note that for namespace symbol, the declaring syntax might be declaring a nested namespace.
            For example, the declaring syntax node for N1 in "namespace N1.N2 {...}" is the entire
            NamespaceDeclarationSyntax for N1.N2. For the global namespace, the declaring syntax will
            be the CompilationUnitSyntax.
            </para>
            </summary>
            <returns>
            The syntax node(s) that declared the symbol. If the symbol was declared in metadata
            or was implicitly declared, returns an empty read-only array.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.GetAttributes">
            <summary>
            Gets the attributes for the symbol. Returns an empty <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            if there are no attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.DeclaredAccessibility">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Accessibility"/> indicating the declared accessibility for the symbol.
            Returns NotApplicable if no accessibility is declared.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.OriginalDefinition">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> for the original definition of the symbol.
            If this symbol is derived from another symbol, by type substitution for instance,
            this gets the original symbol, as it was defined in source or metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.GetDocumentationCommentId">
            <summary>
            Returns the Documentation Comment ID for the symbol, or null if the symbol doesn't
            support documentation comments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.GetDocumentationCommentXml(System.Globalization.CultureInfo,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets the XML (as text) for the comment associated with the symbol.
            </summary>
            <param name="preferredCulture">Preferred culture or null for the default.</param>
            <param name="expandIncludes">Optionally, expand &lt;include&gt; elements.  No impact on non-source documentation comments.</param>
            <param name="cancellationToken">Token allowing cancellation of request.</param>
            <returns>The XML that would be written to the documentation file for the symbol.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.ToDisplayString(Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Converts the symbol to a string representation.
            </summary>
            <param name="format">Format or null for the default.</param>
            <returns>A formatted string representation of the symbol.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.ToDisplayParts(Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. Useful for
            colorizing the display string.
            </summary>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.ErrorMessageFormat.</param>
            <returns>A read-only array of string parts.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayString(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to a string that can be displayed to the user. May be tailored to a
            specific location in the source code.
            </summary>
            <param name="semanticModel">Binding information (for determining names appropriate to
            the context).</param>
            <param name="position">A position in the source code (context).</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.MinimallyQualifiedFormat.</param>
            <returns>A formatted string that can be displayed to the user.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayParts(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. May be tailored
            to a specific location in the source code. Useful for colorizing the display string.
            </summary>
            <param name="semanticModel">Binding information (for determining names appropriate to
            the context).</param>
            <param name="position">A position in the source code (context).</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.MinimallyQualifiedFormat.</param>
            <returns>A read-only array of string parts.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ISymbol.HasUnsupportedMetadata">
            <summary>
            Indicates that this symbol uses metadata that cannot be supported by the language.
            
            <para>
            Examples include:
            <list type="bullet">
            <item><description>Pointer types in VB</description></item>
            <item><description>ByRef return type</description></item>
            <item><description>Required custom modifiers</description></item>
            </list>
            </para>
            
            <para>
            This is distinguished from, for example, references to metadata symbols defined in assemblies that weren't referenced.
            Symbols where this returns true can never be used successfully, and thus should never appear in any IDE feature.
            </para>
            
            <para>
            This is set for metadata symbols, as follows:
            <list type="bullet">
            <item><description>Type - if a type is unsupported (for example, a pointer type)</description></item>
            <item><description>Method - parameter or return type is unsupported</description></item>
            <item><description>Field - type is unsupported</description></item>
            <item><description>Event - type is unsupported</description></item>
            <item><description>Property - type is unsupported</description></item>
            <item><description>Parameter - type is unsupported</description></item>
            </list>
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbol.Equals(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SymbolEqualityComparer)">
            <summary>
            Determines if this symbol is equal to another, according to the rules of the provided <see cref="T:Microsoft.CodeAnalysis.SymbolEqualityComparer"/>
            </summary>
            <param name="other">The other symbol to compare against</param>
            <param name="equalityComparer">The <see cref="T:Microsoft.CodeAnalysis.SymbolEqualityComparer"/> to use when comparing symbols</param>
            <returns>True if the symbols are equivalent.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbolExtensions.GetConstructedReducedFrom(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Returns the constructed form of the ReducedFrom property,
            including the type arguments that were either inferred during reduction or supplied at the call site.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbolExtensions.IsDefaultTupleElement(Microsoft.CodeAnalysis.IFieldSymbol)">
            <summary>
            Returns true if a given field is a default tuple element
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbolExtensions.IsTupleElement(Microsoft.CodeAnalysis.IFieldSymbol)">
            <summary>
            Returns true if a given field is a tuple element
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbolExtensions.ProvidedTupleElementNameOrNull(Microsoft.CodeAnalysis.IFieldSymbol)">
            <summary>
            Return the name of the field if the field is an explicitly named tuple element.
            Otherwise returns null.
            </summary>
            <remarks>
            Note that it is possible for an element to be both "Default" and to have a user provided name.
            That could happen if the provided name matches the default name such as "Item10"
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbolExtensions.PerformIVTCheck(Microsoft.CodeAnalysis.AssemblyIdentity,System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Given that an assembly with identity assemblyGrantingAccessIdentity granted access to assemblyWantingAccess,
            check the public keys to ensure the internals-visible-to check should succeed. This is used by both the
            C# and VB implementations as a helper to implement `bool IAssemblySymbol.GivesAccessTo(IAssemblySymbol toAssembly)`.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ITypeParameterSymbol">
            <summary>
            Represents a type parameter in a generic type or generic method.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.Ordinal">
            <summary>
            The ordinal position of the type parameter in the parameter list which declares
            it. The first type parameter has ordinal zero.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.Variance">
            <summary>
            The variance annotation, if any, of the type parameter declaration. Type parameters may be 
            declared as covariant (<c>out</c>), contravariant (<c>in</c>), or neither.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.TypeParameterKind">
            <summary>
            The type parameter kind of this type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringMethod">
            <summary>
            The method that declares the type parameter, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringType">
            <summary>
            The type that declares the type parameter, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasReferenceTypeConstraint">
            <summary>
            True if the reference type constraint (<c>class</c>) was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.ReferenceTypeConstraintNullableAnnotation">
            <summary>
            If <see cref="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasReferenceTypeConstraint"/> is true, returns the top-level nullability of the
            <c>class</c> constraint that was specified for the type parameter. If there was no <c>class</c>
            constraint, this returns <see cref="F:Microsoft.CodeAnalysis.NullableAnnotation.None"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasValueTypeConstraint">
            <summary>
            True if the value type constraint (<c>struct</c>) was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasUnmanagedTypeConstraint">
            <summary>
            True if the value type constraint (<c>unmanaged</c>) was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasNotNullConstraint">
            <summary>
            True if the notnull constraint (<c>notnull</c>) was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasConstructorConstraint">
            <summary>
            True if the parameterless constructor constraint (<c>new()</c>) was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.ConstraintTypes">
            <summary>
            The types that were directly specified as constraints on the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.ConstraintNullableAnnotations">
            <summary>
            The top-level nullabilities that were directly specified as constraints on the
            constraint types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this type symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.ReducedFrom">
            <summary>
            If this is a type parameter of a reduced extension method, gets the type parameter definition that
            this type parameter was reduced from. Otherwise, returns Nothing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ITypeSymbol">
            <summary>
            Represents a type.
            </summary>
            <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.TypeKind">
            <summary>
            An enumerated value that identifies whether this type is an array, pointer, enum, and so on.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.BaseType">
            <summary>
            The declared base type of this type, or null. The object type, interface types,
            and pointer types do not have a base type. The base type of a type parameter
            is its effective base class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces">
            <summary>
            Gets the set of interfaces that this type directly implements. This set does not include
            interfaces that are base interfaces of directly implemented interfaces. This does
            include the interfaces declared as constraints on type parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces">
            <summary>
            The list of all interfaces of which this type is a declared subtype, excluding this type
            itself. This includes all declared base interfaces, all declared base interfaces of base
            types, and all declared base interfaces of those results (recursively). This also is the effective
            interface set of a type parameter. Each result
            appears exactly once in the list. This list is topologically sorted by the inheritance
            relationship: if interface type A extends interface type B, then A precedes B in the
            list. This is not quite the same as "all interfaces of which this type is a proper
            subtype" because it does not take into account variance: AllInterfaces for
            IEnumerable&lt;string&gt; will not include IEnumerable&lt;object&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsReferenceType">
            <summary>
            True if this type is known to be a reference type. It is never the case that
            <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsValueType"/> both return true. However, for an unconstrained type
            parameter, <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsValueType"/> will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsValueType">
            <summary>
            True if this type is known to be a value type. It is never the case that
            <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsValueType"/> both return true. However, for an unconstrained type
            parameter, <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsReferenceType"/> and <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.IsValueType"/> will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsAnonymousType">
            <summary>
            Is this a symbol for an anonymous type (including anonymous VB delegate).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsTupleType">
            <summary>
            Is this a symbol for a tuple .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsNativeIntegerType">
            <summary>
            True if the type represents a native integer. In C#, the types represented
            by language keywords 'nint' and 'nuint'.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.OriginalDefinition"/> gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.SpecialType">
            <summary>
            An enumerated value that identifies certain 'special' types such as <see cref="T:System.Object"/>. 
            Returns <see cref="F:Microsoft.CodeAnalysis.SpecialType.None"/> if the type is not special.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ITypeSymbol.FindImplementationForInterfaceMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns the corresponding symbol in this type or a base type that implements 
            interfaceMember (either implicitly or explicitly), or null if no such symbol exists
            (which might be either because this type doesn't implement the container of
            interfaceMember, or this type doesn't supply a member that successfully implements
            interfaceMember).
            </summary>
            <param name="interfaceMember">
            Must be a non-null interface property, method, or event.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsRefLikeType">
            <summary>
            True if the type is ref-like, meaning it follows rules similar to CLR by-ref variables. False if the type
            is not ref-like or if the language has no concept of ref-like types.
            </summary>
            <remarks>
            <see cref="T:System.Span`1" /> is a commonly used ref-like type.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsUnmanagedType">
            <summary>
            True if the type is unmanaged according to language rules. False if managed or if the language
            has no concept of unmanaged types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsReadOnly">
            <summary>
            True if the type is readonly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.IsRecord">
            <summary>
            True if the type is a record.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ITypeSymbol.ToDisplayString(Microsoft.CodeAnalysis.NullableFlowState,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Converts an <c>ITypeSymbol</c> and a nullable flow state to a string representation.
            </summary>
            <param name="topLevelNullability">The top-level nullability to use for formatting.</param>
            <param name="format">Format or null for the default.</param>
            <returns>A formatted string representation of the symbol with the given nullability.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ITypeSymbol.ToDisplayParts(Microsoft.CodeAnalysis.NullableFlowState,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Converts a symbol to an array of string parts, each of which has a kind. Useful
            for colorizing the display string.
            </summary>
            <param name="topLevelNullability">The top-level nullability to use for formatting.</param>
            <param name="format">Format or null for the default.</param>
            <returns>A read-only array of string parts.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ITypeSymbol.ToMinimalDisplayString(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.NullableFlowState,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Converts a symbol to a string that can be displayed to the user. May be tailored to a
            specific location in the source code.
            </summary>
            <param name="semanticModel">Binding information (for determining names appropriate to
            the context).</param>
            <param name="topLevelNullability">The top-level nullability to use for formatting.</param>
            <param name="position">A position in the source code (context).</param>
            <param name="format">Formatting rules - null implies <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.MinimallyQualifiedFormat"/></param>
            <returns>A formatted string that can be displayed to the user.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ITypeSymbol.ToMinimalDisplayParts(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.NullableFlowState,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. May be tailored
            to a specific location in the source code. Useful for colorizing the display string.
            </summary>
            <param name="semanticModel">Binding information (for determining names appropriate to
            the context).</param>
            <param name="topLevelNullability">The top-level nullability to use for formatting.</param>
            <param name="position">A position in the source code (context).</param>
            <param name="format">Formatting rules - null implies <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.MinimallyQualifiedFormat"/></param>
            <returns>A read-only array of string parts.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITypeSymbol.NullableAnnotation">
            <summary>
            Nullable annotation associated with the type, or <see cref="F:Microsoft.CodeAnalysis.NullableAnnotation.None"/> if there are none.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ITypeSymbol.WithNullableAnnotation(Microsoft.CodeAnalysis.NullableAnnotation)">
            <summary>
            Returns the same type as this type but with the given nullable annotation.
            </summary>
            <param name="nullableAnnotation">The nullable annotation to use</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageNames">
            <summary>
            A class that provides constants for common language names.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageNames.CSharp">
            <summary>
            The common name used for the C# language.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageNames.VisualBasic">
            <summary>
            The common name used for the Visual Basic language.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageNames.FSharp">
            <summary>
            The common name used for the F# language.
            </summary>
            <remarks>
            F# is not a supported compile target for the Roslyn compiler.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ManagedKind">
            <summary>
            Enumeration of the possible "degrees of managed" for a type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MethodKind">
            <summary>
            Enumeration for possible kinds of method symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.AnonymousFunction">
            <summary>
            An anonymous method or lambda expression
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.LambdaMethod">
            <summary>
            <inheritdoc cref="F:Microsoft.CodeAnalysis.MethodKind.AnonymousFunction"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.Constructor">
            <summary>
            Method is a constructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.Conversion">
            <summary>
            Method is a conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.DelegateInvoke">
            <summary>
            Method is a delegate invoke.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.Destructor">
            <summary>
            Method is a destructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.EventAdd">
            <summary>
            Method is an event add.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.EventRaise">
            <summary>
            Method is an event raise.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.EventRemove">
            <summary>
            Method is an event remove.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.ExplicitInterfaceImplementation">
            <summary>
            Method is an explicit interface implementation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.UserDefinedOperator">
            <summary>
            Method is an operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.Ordinary">
            <summary>
            Method is an ordinary method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.PropertyGet">
            <summary>
            Method is a property get.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.PropertySet">
            <summary>
            Method is a property set.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.ReducedExtension">
            <summary>
            An extension method with the "this" parameter removed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.StaticConstructor">
            <summary>
            Method is a static constructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.SharedConstructor">
            <summary>
            <inheritdoc cref="F:Microsoft.CodeAnalysis.MethodKind.StaticConstructor"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.BuiltinOperator">
            <summary>
            A built-in operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.DeclareMethod">
            <summary>
            Declare Sub or Function.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction">
            <summary>
            Method is declared inside of another method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MethodKind.FunctionPointerSignature">
            <summary>
            Method represents the signature of a function pointer type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NamespaceKind">
            <summary>
            Describes the kind of the namespace extent.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.NullabilityInfo.Annotation">
            <summary>
            The nullable annotation of the expression represented by the syntax node. This represents
            the nullability of expressions that can be assigned to this expression, if this expression
            can be used as an lvalue.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.NullabilityInfo.FlowState">
            <summary>
            The nullable flow state of the expression represented by the syntax node. This represents
            the compiler's understanding of whether this expression can currently contain null, if
            this expression can be used as an rvalue.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NullableAnnotation">
            <summary>
            Represents the nullability of values that can be assigned
            to an expression used as an lvalue.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableAnnotation.None">
            <summary>
            The expression has not been analyzed, or the syntax is
            not an expression (such as a statement).
            <para>There are a few different reasons the expression could have not been analyzed:
            </para>
            <list type="number">
            <item><description>The symbol producing the expression comes from a method that has not been annotated, such as invoking a C# 7.3 or earlier method, or a method in this compilation that is in a disabled context.</description></item>
            <item><description>Nullable is completely disabled in this compilation.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableAnnotation.NotAnnotated">
            <summary>
            The expression is not annotated (does not have a ?).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableAnnotation.Annotated">
            <summary>
            The expression is annotated (does have a ?).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NullableFlowState">
            <summary>
            Represents the compiler's analysis of whether an expression may be null
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableFlowState.None">
            <summary>
            Syntax is not an expression, or was not analyzed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableFlowState.NotNull">
            <summary>
            Expression is not null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NullableFlowState.MaybeNull">
            <summary>
            Expression may be null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NullableFlowStateExtensions.ToAnnotation(Microsoft.CodeAnalysis.NullableFlowState)">
            <summary>
            This method directly converts a <see cref="T:Microsoft.CodeAnalysis.NullableFlowState"/> to a <see cref="T:Microsoft.CodeAnalysis.NullableAnnotation"/>,
            ignoring the <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/> to which it is attached. It should only be used when converting
            an RValue flow state to an RValue annotation for returning via the public API. For general use, please
            use Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState.ToTypeWithAnnotations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DllImportData">
            <summary>
            Information that describes how a method from the underlying Platform is to be invoked.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.ModuleName">
            <summary>
            Module name. Null if value specified in the attribute is not valid.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.EntryPointName">
            <summary>
            Name of the native entry point or null if not specified (the effective name is the same as the name of the target method).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.ExactSpelling">
            <summary>
            Controls whether the <see cref="P:Microsoft.CodeAnalysis.DllImportData.CharacterSet"/> field causes the common language runtime 
            to search an unmanaged DLL for entry-point names other than the one specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.CharacterSet">
            <summary>
            Indicates how to marshal string parameters and controls name mangling.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.SetLastError">
            <summary>
            Indicates whether the callee calls the SetLastError Win32 API function before returning from the attributed method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.CallingConvention">
            <summary>
            Indicates the calling convention of an entry point.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.BestFitMapping">
            <summary>
            Enables or disables best-fit mapping behavior when converting Unicode characters to ANSI characters.
            Null if not specified (the setting for the containing type or assembly should be used, <see cref="T:System.Runtime.InteropServices.BestFitMappingAttribute"/>).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DllImportData.ThrowOnUnmappableCharacter">
            <summary>
            Enables or disables the throwing of an exception on an unmappable Unicode character that is converted to an ANSI "?" character.
            Null if not specified.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RefKind">
            <summary>
            Denotes the kind of reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RefKind.None">
            <summary>
            Indicates a "value" parameter or return type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RefKind.Ref">
            <summary>
            Indicates a "ref" parameter or return type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RefKind.Out">
            <summary>
            Indicates an "out" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RefKind.In">
            <summary>
            Indicates an "in" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RefKind.RefReadOnly">
            <summary>
            Indicates a "ref readonly" return type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ScopedKind">
            <summary>
            Enumeration for kinds of scoped modifiers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ScopedKind.None">
            <summary>
            Not scoped.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ScopedKind.ScopedRef">
            <summary>
            A ref scoped to the enclosing block or method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ScopedKind.ScopedValue">
            <summary>
            A value scoped to the enclosing block or method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolEqualityComparer">
            <summary>
            Allows for the comparison of two <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> instances
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolEqualityComparer.Default">
            <summary>
            Compares two <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> instances based on the default comparison rules, equivalent to calling <see cref="M:System.IEquatable`1.Equals(`0)"/>.
            </summary>
            <remarks>
            Comparing <c>string</c> and <c>string?</c> will return equal. Use <see cref="F:Microsoft.CodeAnalysis.SymbolEqualityComparer.IncludeNullability"/> if you don't want them to be considered equal.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolEqualityComparer.IncludeNullability">
            <summary>
            Compares  two <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> instances, considering that a reference type and the same nullable reference type are not equal.
            </summary>
            <remarks>
            Comparing <c>string</c> and <c>string?</c> will not return equal. Use <see cref="F:Microsoft.CodeAnalysis.SymbolEqualityComparer.Default"/> if you want them to be considered equal.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolEqualityComparer.Equals(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if two <see cref="T:Microsoft.CodeAnalysis.ISymbol" /> instances are equal according to the rules of this comparer
            </summary>
            <param name="x">The first symbol to compare</param>
            <param name="y">The second symbol to compare</param>
            <returns>True if the symbols are equivalent</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolKind">
            <summary>
            Specifies the possible kinds of symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Alias">
            <summary>
            Symbol is an alias.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.ArrayType">
            <summary>
            Symbol is an array type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Assembly">
            <summary>
            Symbol is an assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.DynamicType">
            <summary>
            Symbol is a dynamic type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.ErrorType">
            <summary>
            Symbol that represents an error 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Event">
            <summary>
            Symbol is an Event.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Field">
            <summary>
            Symbol is a field.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Label">
            <summary>
            Symbol is a label.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Local">
            <summary>
            Symbol is a local.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Method">
            <summary>
            Symbol is a method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.NetModule">
            <summary>
            Symbol is a netmodule.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.NamedType">
            <summary>
            Symbol is a named type (e.g. class).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Namespace">
            <summary>
            Symbol is a namespace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Parameter">
            <summary>
            Symbol is a parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.PointerType">
            <summary>
            Symbol is a pointer type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Property">
            <summary>
            Symbol is a property.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.RangeVariable">
            <summary>
            Symbol is a range variable of a query expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.TypeParameter">
            <summary>
            Symbol is a type parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Preprocessing">
            <summary>
            Symbol is a preprocessing/conditional compilation constant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.Discard">
            <summary>
            Symbol represents a value that is discarded, e.g. in M(out _)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKind.FunctionPointerType">
            <summary>
            Symbol represents a function pointer type
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKindInternal.FunctionType">
            <summary>
            Internal Symbol representing the inferred signature of
            a lambda expression or method group.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypeCompareKind">
            <summary>
            Specifies the different kinds of comparison between types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypedConstant">
            <summary>
            Represents a constant value used as an argument to a custom attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstant.Kind">
            <summary>
            The kind of the constant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstant.Type">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/> of the constant, 
            or null if the type can't be determined (error).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstant.IsNull">
            <summary>
            True if the constant represents a null reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstant.Value">
            <summary>
            The value for a non-array constant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstant.ValueInternal">
            <summary>
            Unlike <see cref="P:Microsoft.CodeAnalysis.TypedConstant.Value"/> returns <see cref="T:Microsoft.CodeAnalysis.Symbols.ISymbolInternal"/> when the value is a symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstant.Values">
            <summary>
            The value for a <see cref="T:Microsoft.CodeAnalysis.TypedConstant"/> array. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TypedConstant.GetTypedConstantKind(Microsoft.CodeAnalysis.Symbols.ITypeSymbolInternal,Microsoft.CodeAnalysis.Compilation)">
            <remarks>
            TypedConstant isn't computing its own kind from the type symbol because it doesn't
            have a way to recognize the well-known type System.Type.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypedConstantKind">
            <summary>
            Represents the kind of a TypedConstant.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypedConstantValue">
            <summary>
            Represents a simple value or a read-only array of <see cref="T:Microsoft.CodeAnalysis.TypedConstant"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypedConstantValue.IsNull">
            <summary>
            True if the constant represents a null literal.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypeKind">
            <summary>
            Enumeration for possible kinds of type symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Unknown">
            <summary>
            Type's kind is undefined.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Array">
            <summary>
            Type is an array type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Class">
            <summary>
            Type is a class.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Delegate">
            <summary>
            Type is a delegate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Dynamic">
            <summary>
            Type is dynamic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Enum">
            <summary>
            Type is an enumeration.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Error">
            <summary>
            Type is an error type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Interface">
            <summary>
            Type is an interface.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Module">
            <summary>
            Type is a module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Pointer">
            <summary>
            Type is a pointer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Struct">
            <summary>
            Type is a C# struct or VB Structure
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Structure">
            <summary>
            Type is a C# struct or VB Structure
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.TypeParameter">
            <summary>
            Type is a type parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.Submission">
            <summary>
            Type is an interactive submission.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKind.FunctionPointer">
            <summary>
            Type is a function pointer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeKindInternal.FunctionType">
            <summary>
            Internal Symbol representing the inferred signature of
            a lambda expression or method group.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypeLayout">
            <summary>
            Type layout information.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeLayout.Kind">
            <summary>
            Layout kind (Layout flags in metadata).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeLayout.Alignment">
            <summary>
            Field alignment (PackingSize field in metadata).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TypeLayout.Size">
            <summary>
            Size of the type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TypeParameterKind">
            <summary>
            Represents the different kinds of type parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeParameterKind.Type">
            <summary>
            Type parameter of a named type. For example: <c>T</c> in <c><![CDATA[List<T>]]></c>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeParameterKind.Method">
            <summary>
            Type parameter of a method. For example: <c>T</c> in <c><![CDATA[void M<T>()]]></c>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeParameterKind.Cref">
            <summary>
            Type parameter in a <c>cref</c> attribute in XML documentation comments. For example: <c>T</c> in <c><![CDATA[<see cref="List{T}"/>]]></c>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.VarianceKind">
            <summary>
            An enumeration declaring the kinds of variance supported for generic type parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VarianceKind.None">
            <summary>
            Invariant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VarianceKind.Out">
            <summary>
            Covariant (<c>out</c>).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VarianceKind.In">
            <summary>
            Contravariant (<c>in</c>).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WellKnownMemberNames">
            <summary>
            Specifies the member names known to the compiler (such as <c>.ctor</c> or <c>op_Explicit</c>).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.EnumBackingFieldName">
            <summary>
            Name of the enum backing field.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.InstanceConstructorName">
            <summary>
            The name assigned to an instance constructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.StaticConstructorName">
            <summary>
            The name assigned to the static constructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.Indexer">
            <summary>
            The symbol name assigned to all indexers, other than explicit interface implementations.
            </summary>
            <remarks>
            Will not correspond to the name that appears in metadata.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DestructorName">
            <summary>
            The name assigned to the destructor.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DelegateInvokeName">
            <summary>
            The name assigned to the delegate <c>Invoke</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DelegateBeginInvokeName">
            <summary>
            The name assigned to the delegate <c>BeginInvoke</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DelegateEndInvokeName">
            <summary>
            The name assigned to the delegate <c>EndInvoke</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.EntryPointMethodName">
            <summary>
            The name of an entry point method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DefaultScriptClassName">
            <summary>
            The default fully qualified name of a <c>Script</c> class.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ObjectToString">
            <summary>
            The name assigned to <c>Object.ToString</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ObjectEquals">
            <summary>
            The name assigned to <c>Object.Equals</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ObjectGetHashCode">
            <summary>
            The name assigned to <c>Object.GetHashCode</c> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ImplicitConversionName">
            <summary>
            The name assigned to an implicit (widening) conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ExplicitConversionName">
            <summary>
            The name assigned to an explicit (narrowing) conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CheckedExplicitConversionName">
            <summary>
            The name assigned to a checked explicit (narrowing) conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.AdditionOperatorName">
            <summary>
            The name assigned to the Addition operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CheckedAdditionOperatorName">
            <summary>
            The name assigned to the checked Addition operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.BitwiseAndOperatorName">
            <summary>
            The name assigned to the BitwiseAnd operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.BitwiseOrOperatorName">
            <summary>
            The name assigned to the BitwiseOr operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DecrementOperatorName">
            <summary>
            The name assigned to the Decrement operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CheckedDecrementOperatorName">
            <summary>
            The name assigned to the checked Decrement operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DivisionOperatorName">
            <summary>
            The name assigned to the Division operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CheckedDivisionOperatorName">
            <summary>
            The name assigned to the checked Division operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.EqualityOperatorName">
            <summary>
            The name assigned to the Equality operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ExclusiveOrOperatorName">
            <summary>
            The name assigned to the ExclusiveOr operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.FalseOperatorName">
            <summary>
            The name assigned to the False operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.GreaterThanOperatorName">
            <summary>
            The name assigned to the GreaterThan operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.GreaterThanOrEqualOperatorName">
            <summary>
            The name assigned to the GreaterThanOrEqual operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.IncrementOperatorName">
            <summary>
            The name assigned to the Increment operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CheckedIncrementOperatorName">
            <summary>
            The name assigned to the checked Increment operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.InequalityOperatorName">
            <summary>
            The name assigned to the Inequality operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LeftShiftOperatorName">
            <summary>
            The name assigned to the LeftShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.UnsignedLeftShiftOperatorName">
            <summary>
            The name assigned to the UnsignedLeftShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LessThanOperatorName">
            <summary>
            The name assigned to the LessThan operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LessThanOrEqualOperatorName">
            <summary>
            The name assigned to the LessThanOrEqual operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LogicalNotOperatorName">
            <summary>
            The name assigned to the LogicalNot operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LogicalOrOperatorName">
            <summary>
            The name assigned to the LogicalOr operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LogicalAndOperatorName">
            <summary>
            The name assigned to the LogicalAnd operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ModulusOperatorName">
            <summary>
            The name assigned to the Modulus operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.MultiplyOperatorName">
            <summary>
            The name assigned to the Multiply operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CheckedMultiplyOperatorName">
            <summary>
            The name assigned to the checked Multiply operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.OnesComplementOperatorName">
            <summary>
            The name assigned to the OnesComplement operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.RightShiftOperatorName">
            <summary>
            The name assigned to the RightShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.UnsignedRightShiftOperatorName">
            <summary>
            The name assigned to the UnsignedRightShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.SubtractionOperatorName">
            <summary>
            The name assigned to the Subtraction operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CheckedSubtractionOperatorName">
            <summary>
            The name assigned to the checked Subtraction operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.TrueOperatorName">
            <summary>
            The name assigned to the True operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.UnaryNegationOperatorName">
            <summary>
            The name assigned to the UnaryNegation operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CheckedUnaryNegationOperatorName">
            <summary>
            The name assigned to the checked UnaryNegation operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.UnaryPlusOperatorName">
            <summary>
            The name assigned to the UnaryPlus operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ConcatenateOperatorName">
            <summary>
            The name assigned to the Concatenate operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ExponentOperatorName">
            <summary>
            The name assigned to the Exponent operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.IntegerDivisionOperatorName">
            <summary>
            The name assigned to the IntegerDivision operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LikeOperatorName">
            <summary>
            The name assigned to the <c>Like</c> operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.GetEnumeratorMethodName">
            <summary>
            The required name for the <c>GetEnumerator</c> method used in a ForEach statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.GetAsyncEnumeratorMethodName">
            <summary>
            The required name for the <c>GetAsyncEnumerator</c> method used in a ForEach statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.MoveNextAsyncMethodName">
            <summary>
            The required name for the <c>MoveNextAsync</c> method used in a ForEach-await statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DeconstructMethodName">
            <summary>
            The required name for the <c>Deconstruct</c> method used in a deconstruction.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.MoveNextMethodName">
            <summary>
            The required name for the <c>MoveNext</c> method used in a ForEach statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CurrentPropertyName">
            <summary>
            The required name for the <c>Current</c> property used in a ForEach statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.ValuePropertyName">
            <summary>
            The required name for the <see cref="P:System.Nullable`1.Value"/> property used in
            a ForEach statement when the collection is a nullable struct.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CollectionInitializerAddMethodName">
            <summary>
            The name for the <c>Add</c> method to be invoked for each element in a collection initializer expression
            (see C# Specification, §7.6.10.3 Collection initializers).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.GetAwaiter">
            <summary>
            The required name for the <c>GetAwaiter</c> method used to obtain an awaiter for a task
            (see C# Specification, §7.7.7.1 Awaitable expressions).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.IsCompleted">
            <summary>
            The required name for the <c>IsCompleted</c> property used to determine if a task is already complete
            (see C# Specification, §7.7.7.1 Awaitable expressions).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.GetResult">
            <summary>
            The required name for the <c>GetResult</c> method used to obtain the outcome of a task once it is complete
            (see C# Specification, §7.7.7.1 Awaitable expressions).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.OnCompleted">
            <summary>
            The name of the <see cref="M:System.Runtime.CompilerServices.INotifyCompletion.OnCompleted(System.Action)"/> method used to register a resumption delegate
            (see C# Specification, §7.7.7.1 Awaitable expressions).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DisposeMethodName">
            <summary>
            The required name for the <c>Dispose</c> method used in a Using statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.DisposeAsyncMethodName">
            <summary>
            The required name for the <c>DisposeAsync</c> method used in an await using statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.CountPropertyName">
            <summary>
            The required name for the <c>Count</c> property used in a pattern-based Index or Range indexer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.LengthPropertyName">
            <summary>
            The required name for the <c>Length</c> property used in a pattern-based Index or Range indexer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.SliceMethodName">
            <summary>
            The required name for the <c>Slice</c> method used in a pattern-based Range indexer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.PrintMembersMethodName">
            <summary>
            The required name for the <c>PrintMembers</c> method that is synthesized in a record.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.TopLevelStatementsEntryPointMethodName">
            <summary>
            The name of an entry point method synthesized for top-level statements.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownMemberNames.TopLevelStatementsEntryPointTypeName">
            <summary>
            The name of a type synthesized for a top-level statements entry point method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Syntax.AbstractWarningStateMap`1._warningStateMapEntries">
            <summary>
            List of entries sorted in source order, each of which captures a
            position in the supplied syntax tree and the set of diagnostics (warnings)
            whose reporting should either be suppressed or enabled at this position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Syntax.AbstractWarningStateMap`1.CreateWarningStateMapEntries(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns list of entries sorted in source order, each of which captures a
            position in the supplied syntax tree and the set of diagnostics (warnings)
            whose reporting should either be suppressed or enabled at this position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Syntax.AbstractWarningStateMap`1.GetWarningState(System.String,System.Int32)">
            <summary>
            Returns the reporting state for the supplied diagnostic id at the supplied position
            in the associated syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Syntax.AbstractWarningStateMap`1.GetEntryAtOrBeforePosition(System.Int32)">
            <summary>
            Gets the entry with the largest position less than or equal to supplied position.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Syntax.AbstractWarningStateMap`1.WarningStateMapEntry">
            <summary>
            Struct that represents an entry in the warning state map. Sorts by position in the associated syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
            <summary>
            Gets the separator at the given index in this list.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxListBuilder`1.UnderlyingBuilder">
            <summary>
            WARN WARN WARN: This should be used with extreme caution - the underlying builder does
            not give any indication that it is from a separated syntax list but the constraints
            (node, token, node, token, ...) should still be maintained.
            </summary>
            <remarks>
            In order to avoid creating a separate pool of SeparatedSyntaxListBuilders, we expose
            our underlying SyntaxListBuilder to SyntaxListPool.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList.WithLotsOfChildren.FindSlotIndexContainingOffset(System.Int32)">
            <summary>
            Find the slot that contains the given offset.
            </summary>
            <param name="offset">The target offset. Must be between 0 and <see cref="P:Microsoft.CodeAnalysis.GreenNode.FullWidth"/>.</param>
            <returns>The slot index of the slot containing the given offset.</returns>
            <remarks>
            This implementation uses a binary search to find the first slot that contains
            the given offset.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1.Add(`0)">
            <summary>
            Adds <paramref name="node"/> to the end of this builder.  No change happens if <see langword="null"/> is
            passed in.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Syntax.InternalSyntax.GreenStats">
            <summary>
            Provides caching functionality for green nonterminals with up to 3 children.
            Example:
                When constructing a node with given kind, flags, child1 and child2, we can look up 
                in the cache whether we already have a node that contains same kind, flags, 
                child1 and child2 and use that.
                
                For the purpose of children comparison, reference equality is used as a much cheaper 
                alternative to the structural/recursive equality. This implies that in order to de-duplicate
                a node to a cache node, the children of two nodes must be already de-duplicated.     
                When adding a node to the cache we verify that cache does contain node's children,
                since otherwise there is no reason for the node to be used.
                Tokens/nulls are for this purpose considered deduplicated. Indeed most of the tokens
                are deduplicated via quick-scanner caching, so we just assume they all are.
                
                As a result of above, "fat" nodes with 4 or more children or their recursive parents
                will never be in the cache. This naturally limits the typical single cache item to be 
                a relatively simple expression. We do not want the cache to be completely unbounded 
                on the item size. 
                While it still may be possible to store a gigantic nested binary expression, 
                it should be a rare occurrence.
                
                We only consider "normal" nodes to be cacheable. 
                Nodes with diagnostics/annotations/directives/skipped, etc... have more complicated identity 
                and are not likely to be repetitive.
                
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Syntax.TranslationSyntaxReference">
            <summary>
            This is a SyntaxReference implementation that lazily translates the result (SyntaxNode) of the
            original syntax reference to another one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node identical to this node with the specified annotations attached.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be added to the new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node identical to this node with the specified annotations attached.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be added to the new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node identical to this node with the specified annotations removed.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be removed from the new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node identical to this node with the specified annotations removed.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotations">Annotations to be removed from the new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.String)">
            <summary>
            Creates a new node identical to this node with the annotations of the specified kind removed.
            </summary>
            <param name="node">Original node.</param>
            <param name="annotationKind">The kind of annotation to remove.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.Count">
            <summary>
            Gets the number of children contained in the <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.Item(System.Int32)">
            <summary>Gets the child at the specified index.</summary>
            <param name="index">The zero-based index of the child to get.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="index"/> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:Microsoft.CodeAnalysis.ChildSyntaxList.Count"/>. </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.ItemInternal(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            internal indexer that does not verify index.
            Used when caller has already ensured that index is within bounds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.ChildThatContainsPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Locate the node or token that is a child of the given <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> and contains the given position.
            </summary>
            <param name="node">The <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> to search.</param>
            <param name="targetPosition">The position.</param>
            <returns>The node or token that spans the given position.</returns>
            <remarks>
            Assumes that <paramref name="targetPosition"/> is within the span of <paramref name="node"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.ItemInternalAsNode(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            internal indexer that does not verify index.
            Used when caller has already ensured that index is within bounds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.First">
            <summary>
            Returns the first child in the list.
            </summary>
            <returns>The first child in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>    
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Last">
            <summary>
            Returns the last child in the list.
            </summary>
            <returns>The last child in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>    
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Reverse">
            <summary>
            Returns a list which contains all children of <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList"/> in reversed order.
            </summary>
            <returns><see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed"/> which contains all children of <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList"/> in reversed order</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList"/>.</summary>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator"/> for the <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current instance.</summary>
            <returns>true if the specified object is a <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure and is equal to the current instance; otherwise, false.</returns>
            <param name="obj">The object to be compared with the current instance.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Equals(Microsoft.CodeAnalysis.ChildSyntaxList)">
            <summary>Determines whether the specified <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure is equal to the current instance.</summary>
            <returns>true if the specified <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure is equal to the current instance; otherwise, false.</returns>
            <param name="other">The <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure to be compared with the current instance.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.GetHashCode">
            <summary>Returns the hash code for the current instance.</summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.op_Equality(Microsoft.CodeAnalysis.ChildSyntaxList,Microsoft.CodeAnalysis.ChildSyntaxList)">
            <summary>Indicates whether two <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structures are equal.</summary>
            <returns>true if <paramref name="list1" /> is equal to <paramref name="list2" />; otherwise, false.</returns>
            <param name="list1">The <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure on the left side of the equality operator.</param>
            <param name="list2">The <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure on the right side of the equality operator.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.op_Inequality(Microsoft.CodeAnalysis.ChildSyntaxList,Microsoft.CodeAnalysis.ChildSyntaxList)">
            <summary>Indicates whether two <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structures are unequal.</summary>
            <returns>true if <paramref name="list1" /> is equal to <paramref name="list2" />; otherwise, false.</returns>
            <param name="list1">The <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure on the left side of the inequality operator.</param>
            <param name="list2">The <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> structure on the right side of the inequality operator.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" />.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" />.</summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator.Current">
            <summary>Gets the element at the current position of the enumerator.</summary>
            <returns>The element in the <see cref="T:Microsoft.CodeAnalysis.ChildSyntaxList" /> at the current position of the enumerator.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator.Reset">
            <summary>Sets the enumerator to its initial position, which is before the first element in the collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.EnumeratorImpl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.EnumeratorImpl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GreenNode.EnumerateNodes">
            <summary>
            Enumerates all nodes of the tree rooted by this node (including this node).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GreenNode.FindSlotIndexContainingOffset(System.Int32)">
            <summary>
            Find the slot that contains the given offset.
            </summary>
            <param name="offset">The target offset. Must be between 0 and <see cref="P:Microsoft.CodeAnalysis.GreenNode.FullWidth"/>.</param>
            <returns>The slot index of the slot containing the given offset.</returns>
            <remarks>
            The base implementation is a linear search. This should be overridden
            if a derived class can implement it more efficiently.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GreenNode.AddError(Microsoft.CodeAnalysis.DiagnosticInfo)">
            <summary>
            Add an error to the given node, creating a new node that is the same except it has no parent,
            and has the given error attached to it. The error span is the entire span of this node.
            </summary>
            <param name="err">The error to attach to this node</param>
            <returns>A new node, with no parent, that has this error added to it.</returns>
            <remarks>Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,
            then add an error with this method to create another node.</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ICompilationUnitSyntax">
             <summary>
             Interface implemented by any node that is the root 'CompilationUnit' of a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>.  i.e. 
             any node returned by <see cref="M:Microsoft.CodeAnalysis.SyntaxTree.GetRoot(System.Threading.CancellationToken)"/> where <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot"/>
             is <see langword="true"/> will implement this interface.
            
             This interface provides a common way to both easily find the root of a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>
             given any <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, as well as a common way for handling the special 
             <see cref="P:Microsoft.CodeAnalysis.ICompilationUnitSyntax.EndOfFileToken"/> that is needed to store all final trivia in a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>
             that is not owned by any other <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ICompilationUnitSyntax.EndOfFileToken">
            <summary>
            Represents the end of the source file. This <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/> may have
            <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/> (whitespace, comments, directives) attached to it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ISkippedTokensTriviaSyntax">
            <summary>
            Represents structured trivia that contains skipped tokens. This is implemented by
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax"/> and
            <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SkippedTokensTriviaSyntax"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IStructuredTriviaSyntax">
            <summary>
            Represents the root node of a structured trivia tree (for example, a preprocessor directive
            or a documentation comment). From this root node you can traverse back up to the containing
            trivia in the outer tree that contains it.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.IStructuredTriviaSyntax.ParentTrivia">
            <summary>
            Returns the parent trivia syntax for this structured trivia syntax.
            </summary>
            <returns>The parent trivia syntax for this structured trivia syntax.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LineDirectiveMap`1">
            <summary>
            The LineDirectiveMap is created to enable translating positions, using the #line directives
            in a file. The basic implementation creates an ordered array of line mapping entries, one
            for each #line directive in the file (plus one at the beginning). If the file has no
            directives, then the array has just one element in it. To map line numbers, a binary search
            of the mapping entries is done and nearest line mapping is applied.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LineDirectiveMap`1.GetLineVisibility(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <summary>
            Determines whether the position is considered to be hidden from the debugger or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LineDirectiveMap`1.TranslateSpanAndVisibility(Microsoft.CodeAnalysis.Text.SourceText,System.String,Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean@)">
            <summary>
            Combines TranslateSpan and IsHiddenPosition to not search the entries twice when emitting sequence points
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LineDirectiveMap`1.HasAnyHiddenRegions">
            <summary>
            Are there any hidden regions in the map?
            </summary>
            <returns>True if there's at least one hidden region in the map.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LineDirectiveMap`1.GetLineMappings(Microsoft.CodeAnalysis.Text.TextLineCollection)">
            <summary>
            The caller is expected to not call this if <see cref="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.Entries"/> is empty.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState">
            <summary>
            Enum that describes the state related to the #line or #externalsource directives at a position in source.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.Unknown">
            <summary>
            Used in VB when the position is not hidden, but it's not known yet that there is a (nonempty) <c>#ExternalSource</c>
            following.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.Unmapped">
            <summary>
            Used in C# for spans preceding the first <c>#line</c> directive (if any) and for <c>#line default</c> spans
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.Remapped">
            <summary>
            Used in C# for spans inside of <c>#line linenumber</c> directive
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.RemappedSpan">
            <summary>
            Used in C# for spans inside of <c>#line (startLine, startChar) - (endLine, endChar) charOffset</c> directive
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.RemappedAfterUnknown">
            <summary>
            Used in VB for spans inside of a <c>#ExternalSource</c> directive that followed an unknown span
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.RemappedAfterHidden">
            <summary>
            Used in VB for spans inside of a <c>#ExternalSource</c> directive that followed a hidden span
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineDirectiveMap`1.PositionState.Hidden">
            <summary>
            Used in C# and VB for spans that are inside of <c>#line hidden</c> (C#) or outside of <c>#ExternalSource</c> (VB) 
            directives
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LineMapping">
            <summary>
            Represents a line mapping defined by a single line mapping directive (<c>#line</c> in C# or <c>#ExternalSource</c> in VB).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LineMapping.Span">
            <summary>
            The span in the syntax tree containing the line mapping directive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LineMapping.CharacterOffset">
            <summary>
            The optional offset in the syntax tree for the line immediately following an enhanced <c>#line</c> directive in C#.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LineMapping.MappedSpan">
            <summary>
            If the line mapping directive maps the span into an explicitly specified file the <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.HasMappedPath"/> is true.
            If the path is not mapped <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.Path"/> is empty and <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.HasMappedPath"/> is false.
            If the line mapping directive marks hidden code <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid"/> is false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LineMapping.IsHidden">
            <summary>
            True if the line mapping marks hidden code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LineVisibility">
            <summary>
            The state of the visibility of a line.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineVisibility.BeforeFirstLineDirective">
            <summary>
            The line is located before any #line directive and there is at least one #line directive present in this syntax tree.
            This enum value is used for C# only to enable the consumer to define how to interpret the lines before the first
            line directive. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineVisibility.Hidden">
            <summary>
            The line is following a #line hidden directive.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LineVisibility.Visible">
            <summary>
            The line is following a #line default directive or a #line directive with at least a line number.
            If there is no line directive at all, Visible is returned for all lines.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
            <summary>
            Gets the separator at the given index in this list.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.GetSeparators">
            <summary>
            Returns the sequence of just the separator tokens.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.FullSpan">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.Span">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.ToString">
            <summary>
            Returns the string representation of the nodes in this list including separators but not including 
            the first node's leading trivia and the last node or token's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes in this list including separators but not including 
            the first node's leading trivia and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.ToFullString">
            <summary>
            Returns the full string representation of the nodes in this list including separators, 
            the first node's leading trivia, and the last node or token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes in this list including separators including separators,
            the first node's leading trivia, and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.Add(`0)">
            <summary>
            Creates a new list with the specified node added to the end.
            </summary>
            <param name="node">The node to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes added to the end.
            </summary>
            <param name="nodes">The nodes to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.Insert(System.Int32,`0)">
            <summary>
            Creates a new list with the specified node inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="node">The node to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodes">The nodes to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.RemoveAt(System.Int32)">
            <summary>
            Creates a new list with the element at the specified index removed.
            </summary>
            <param name="index">The index of the element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.Remove(`0)">
            <summary>
            Creates a new list with specified element removed.
            </summary>
            <param name="node">The element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.Replace(`0,`0)">
            <summary>
            Creates a new list with the specified element replaced by the new node.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNode">The new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.ReplaceRange(`0,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified element replaced by the new nodes.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNodes">The new nodes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SeparatedSyntaxList`1.ReplaceSeparator(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new list with the specified separator token replaced with the new separator.
            </summary>
            <param name="separatorToken">The separator token to be replaced.</param>
            <param name="newSeparator">The new separator token.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxAnnotation">
            <summary>
            A SyntaxAnnotation is used to annotate syntax elements with additional information. 
            
            Since syntax elements are immutable, annotating them requires creating new instances of them
            with the annotations attached.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxAnnotation.ElasticAnnotation">
            <summary>
            A predefined syntax annotation that indicates whether the syntax element has elastic trivia.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxList`1">
            <summary>
            A list of <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.#ctor(`0)">
            <summary>
            Creates a singleton list of syntax nodes.
            </summary>
            <param name="node">The single element node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a list of syntax nodes.
            </summary>
            <param name="nodes">A sequence of element nodes.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxList`1.Count">
            <summary>
            The number of nodes in the list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxList`1.Item(System.Int32)">
            <summary>
            Gets the node at the specified index.
            </summary>
            <param name="index">The zero-based index of the node to get or set.</param>
            <returns>The node at the specified index.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxList`1.FullSpan">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxList`1.Span">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.ToString">
            <summary>
            Returns the string representation of the nodes in this list, not including 
            the first node's leading trivia and the last node's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes in this list, not including 
            the first node's leading trivia and the last node's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.ToFullString">
            <summary>
            Returns the full string representation of the nodes in this list including 
            the first node's leading trivia and the last node's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes in this list including 
            the first node's leading trivia and the last node's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Add(`0)">
            <summary>
            Creates a new list with the specified node added at the end.
            </summary>
            <param name="node">The node to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes added at the end.
            </summary>
            <param name="nodes">The nodes to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Insert(System.Int32,`0)">
            <summary>
            Creates a new list with the specified node inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="node">The node to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified nodes inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodes">The nodes to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.RemoveAt(System.Int32)">
            <summary>
            Creates a new list with the element at specified index removed.
            </summary>
            <param name="index">The index of the element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Remove(`0)">
            <summary>
            Creates a new list with the element removed.
            </summary>
            <param name="node">The element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Replace(`0,`0)">
            <summary>
            Creates a new list with the specified element replaced with the new node.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNode">The new node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.ReplaceRange(`0,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the specified element replaced with new nodes.
            </summary>
            <param name="nodeInList">The element to replace.</param>
            <param name="newNodes">The new nodes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.First">
            <summary>
            The first node in the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.FirstOrDefault">
            <summary>
            The first node in the list or default if the list is empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Last">
            <summary>
            The last node in the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.LastOrDefault">
            <summary>
            The last node in the list or default if the list is empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.Any">
            <summary>
            True if the list has at least one node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.GetEnumerator">
            <summary>
            Get's the enumerator for this list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxList`1.IndexOf(`0)">
            <summary>
            The index of the node in this list, or -1 if the node is not in the list.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxNode">
            <summary>
            Represents a non-terminal node in the syntax tree. This is the language agnostic equivalent of <see
            cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> and <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.#ctor(Microsoft.CodeAnalysis.GreenNode,System.Int32,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Used by structured trivia which has "parent == null", and therefore must know its
            SyntaxTree explicitly when created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.RawKind">
            <summary>
            An integer representing the language specific kind of this node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.Language">
            <summary>
            The language name that this node is syntax of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.SyntaxTree">
            <summary>
            Returns SyntaxTree that owns the node or null if node does not belong to a
            SyntaxTree
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan">
            <summary>
            The absolute span of this node in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.Span">
            <summary>
            The absolute span of this node in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.SpanStart">
            <summary>
            Same as accessing <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.Width">
            <summary>
            The width of the node in characters, not including leading and trailing trivia.
            </summary>
            <remarks>
            The Width property returns the same value as Span.Length, but is somewhat more efficient.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.FullWidth">
            <summary>
            The complete width of the node in characters, including leading and trailing trivia.
            </summary>
            <remarks>The FullWidth property returns the same value as FullSpan.Length, but is
            somewhat more efficient.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetRedElement(Microsoft.CodeAnalysis.SyntaxNode@,System.Int32)">
            <summary>
            This works the same as GetRed, but intended to be used in lists
            The only difference is that the public parent of the node is not the list, 
            but the list's parent. (element's grand parent).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetRedElementIfNotToken(Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            special cased helper for 2 and 3 children lists where child #1 may map to a token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ToString">
            <summary>
            Returns the string representation of this node, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ToFullString">
            <summary>
            Returns full string representation of this node including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node to the specified <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetText(System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Gets the full text of this node as a new <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> instance.
            </summary>
            <param name="encoding">
            Encoding of the file that the text was read from or is going to be saved to.
            <c>null</c> if the encoding is unspecified.
            If the encoding is not specified the <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> isn't debuggable.
            If an encoding-less <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> is written to a file a <see cref="P:System.Text.Encoding.UTF8"/> shall be used as a default.
            </param>
            <param name="checksumAlgorithm">
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </param>
            <exception cref="T:System.ArgumentException"><paramref name="checksumAlgorithm"/> is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine whether this node is structurally equivalent to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.IsIncrementallyIdenticalTo(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if these two nodes are considered "incrementally identical".  An incrementally identical node
            occurs when a <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.SyntaxTree"/> is incrementally parsed using <see cref="M:Microsoft.CodeAnalysis.SyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)"/>
            and the incremental parser is able to take the node from the original tree and use it in its entirety in the
            new tree.  In this case, the <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ToFullString"/> of each node will be the same, though 
            they could have different parents, and may occur at different positions in their respective trees.  If two nodes are
            incrementally identical, all children of each node will be incrementally identical as well.
            </summary>
            <remarks>
            Incrementally identical nodes can also appear within the same syntax tree, or syntax trees that did not arise
            from <see cref="M:Microsoft.CodeAnalysis.SyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)"/>.  This can happen as the parser is allowed to construct parse
            trees from shared nodes for efficiency.  In all these cases though, it will still remain true that the incrementally
            identical nodes could have different parents and may occur at different positions in their respective trees.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.IsMissing">
            <summary>
            Determines whether the node represents a language construct that was actually parsed
            from the source code. Missing nodes are generated by the parser in error scenarios to
            represent constructs that should have been present in the source code in order to
            compile successfully but were actually missing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.IsPartOfStructuredTrivia">
            <summary>
            Determines whether this node is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.IsStructuredTrivia">
            <summary>
            Determines whether this node represents a structured trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.HasStructuredTrivia">
            <summary>
            Determines whether a descendant trivia of this node is structured.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsSkippedText">
            <summary>
            Determines whether this node has any descendant skipped text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsDirectives">
            <summary>
            Determines whether this node has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsDiagnostics">
            <summary>
            Determines whether this node or any of its descendant nodes, tokens or trivia have any diagnostics on them. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.Contains(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determines if the specified node is a descendant of this node.
            Returns true for current node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.HasLeadingTrivia">
            <summary>
            Determines whether this node has any leading trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.HasTrailingTrivia">
            <summary>
            Determines whether this node has any trailing trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetCachedSlot(System.Int32)">
            <summary>
            Gets a node at given node index without forcing its creation.
            If node was not created it would return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetChildPosition(System.Int32)">
            <summary>
            This function calculates the offset of a child at given position. It is very common that
            some children to the left of the given index already know their positions so we first
            check if that is the case. In a worst case the cost is O(n), but it is not generally an
            issue because number of children in regular nodes is fixed and small. In a case where
            the number of children could be large (lists) this function is overridden with more
            efficient implementations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has this node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetReference">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.SyntaxReference"/> for this syntax node. CommonSyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.Parent">
            <summary>
            The node that contains this node in its <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes"/> collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodesAndTokens">
            <summary>
            The list of child nodes and tokens of this node, where each element is a SyntaxNodeOrToken instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetNodeSlot(System.Int32)">
            <summary>
            Gets node at given node index. 
            This WILL force node creation if node has not yet been created.
            Can still return null for invalid slot numbers
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes">
            <summary>
            Gets a list of the child nodes in prefix document order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.Ancestors(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes (including this node) 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FirstAncestorOrSelf``1(System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
            Gets the first node of type TNode that matches the predicate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FirstAncestorOrSelf``2(System.Func{``0,``1,System.Boolean},``1,System.Boolean)">
            <summary>
            Gets the first node of type TNode that matches the predicate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes and tokens in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendant nodes and tokens in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendant nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindNode(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.Boolean)">
            <summary>
            Finds the node with the smallest <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan"/> that contains <paramref name="span"/>.
            <paramref name="getInnermostNodeForTie"/> is used to determine the behavior in case of a tie (i.e. a node having the same span as its parent).
            If <paramref name="getInnermostNodeForTie"/> is true, then it returns lowest descending node encompassing the given <paramref name="span"/>.
            Otherwise, it returns the outermost node encompassing the given <paramref name="span"/>.
            </summary>
            <devdoc>
            TODO: This should probably be reimplemented with <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)"/>
            </devdoc>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan"/> doesn't contain the given span.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindToken(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)
            includes the position.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the first token of the tree rooted by this node. Skips zero-width tokens.
            </summary>
            <returns>The first token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the last token of the tree rooted by this node. Skips zero-width tokens.
            </summary>
            <returns>The last token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ChildTokens">
            <summary>
            Gets a list of the direct child tokens of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of all the tokens in the span of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of all the tokens in the full span of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetLeadingTrivia">
            <summary>
            The list of trivia that appears before this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetTrailingTrivia">
            <summary>
            The list of trivia that appears after this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindTrivia(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)
            includes the position.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindTrivia(System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Finds a descendant trivia of this node at the specified position, where the position is
            within the span of the node.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of
            the file.</param>
            <param name="stepInto">Specifies a function that determines per trivia node, whether to
            descend into structured trivia of that node.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Get a list of all the trivia associated with the descendant nodes and tokens.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Get a list of all the trivia associated with the descendant nodes and tokens.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsAnnotations">
            <summary>
            Determines whether this node or any sub node, token or trivia has annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(System.String)">
            <summary>
            Determines whether this node has any annotations with the specific annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether this node has any annotations with any of the specific annotation kinds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Determines whether this node has the specific annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(System.String)">
            <summary>
            Gets all the annotations with the specified annotation kind. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets all the annotations with the specified annotation kinds. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String)">
            <summary>
            Gets all nodes and tokens with an annotation of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String[])">
            <summary>
            Gets all nodes and tokens with an annotation of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all nodes and tokens with the specified annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all nodes with the specified annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(System.String)">
            <summary>
            Gets all nodes with the specified annotation kind.
            </summary>
            <param name="annotationKind"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all tokens with the specified annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(System.String)">
            <summary>
            Gets all tokens with the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String)">
            <summary>
            Gets all trivia with an annotation of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String[])">
            <summary>
            Gets all trivia with an annotation of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Gets all trivia with the specified annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.CopyAnnotationsTo``1(``0)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxNode instance and attaches them to a new instance based on <paramref name="node" />.
            </summary>
            <remarks>
            <para>
            If no annotations are copied, just returns <paramref name="node" />.
            </para>
            <para>
            It can also be used manually to preserve annotations in a more complex tree
            modification, even if the type of a node changes.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Determines if two nodes are the same, disregarding trivia differences.
            </summary>
            <param name="node">The node to compare against.</param>
            <param name="topLevel"> If true then the nodes are equivalent if the contained nodes and
            tokens declaring metadata visible symbolic information are equivalent, ignoring any
            differences of nodes inside method bodies or initializer expressions, otherwise all
            nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.SerializeTo(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Serializes the node to the given <paramref name="stream"/>.
            Leaves the <paramref name="stream"/> open for further writes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.EquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine if this node is structurally equivalent to another.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNode.SyntaxTreeCore">
            <summary>
            Returns SyntaxTree that owns the node. If the node does not belong to a tree then
            one will be generated.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia.
            If false finds the token whose full span (including trivia) includes the position.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="stepInto">
            Applied on every structured trivia. Return false if the tokens included in the trivia should be skipped. 
            Pass null to skip all structured trivia.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.FindTriviaCore(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of the file.</param>
            <param name="findInsideTrivia">Whether to search inside structured trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ReplaceCore``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified nodes, tokens or trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.RemoveNodesCore(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified node removed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Determines if two nodes are the same, disregarding trivia differences.
            </summary>
            <param name="node">The node to compare against.</param>
            <param name="topLevel"> If true then the nodes are equivalent if the contained nodes and
            tokens declaring metadata visible symbolic information are equivalent, ignoring any
            differences of nodes inside method bodies or initializer expressions, otherwise all
            nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.ShouldCreateWeakList">
            <summary>
            Whether or not this parent node wants its child SyntaxList node to be 
            converted to a Weak-SyntaxList when creating the red-node equivalent.
            For example, in C# the statements of a Block-Node that is parented by a 
            MethodDeclaration will be held weakly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNode.CloneNodeAsRoot``1(``0,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Creates a clone of a red node that can be used as a root of given syntaxTree.
            New node has no parents, position == 0, and syntaxTree as specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceSyntax``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified nodes, tokens and trivia replaced.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="nodes">The nodes to be replaced.</param>
            <param name="computeReplacementNode">A function that computes a replacement node for the
            argument nodes. The first argument is the original node. The second argument is the same
            node potentially rewritten with replaced descendants.</param>
            <param name="tokens">The tokens to be replaced.</param>
            <param name="computeReplacementToken">A function that computes a replacement token for
            the argument tokens. The first argument is the original token. The second argument is
            the same token potentially rewritten with replaced trivia.</param>
            <param name="trivia">The trivia to be replaced.</param>
            <param name="computeReplacementTrivia">A function that computes replacement trivia for
            the specified arguments. The first argument is the original trivia. The second argument is
            the same trivia with potentially rewritten sub structure.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNodes``2(``0,System.Collections.Generic.IEnumerable{``1},System.Func{``1,``1,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <typeparam name="TNode">The type of the nodes being replaced.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="nodes">The nodes to be replaced; descendants of the root node.</param>
            <param name="computeReplacementNode">A function that computes a replacement node for the
            argument nodes. The first argument is the original node. The second argument is the same
            node potentially rewritten with replaced descendants.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldNode">The node to be replaced; a descendant of the root node.</param>
            <param name="newNode">The new node to use in the new tree in place of the old node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with specified old node replaced with a new nodes.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="oldNode">The node to be replaced; a descendant of the root node and an element of a list member.</param>
            <param name="newNodes">A sequence of nodes to use in the tree in place of the old node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesBefore``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with new nodes inserted before the specified node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="nodeInList">The node to insert before; a descendant of the root node an element of a list member.</param>
            <param name="newNodes">A sequence of nodes to insert into the tree immediately before the specified node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesAfter``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with new nodes inserted after the specified node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="nodeInList">The node to insert after; a descendant of the root node an element of a list member.</param>
            <param name="newNodes">A sequence of nodes to insert into the tree immediately after the specified node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with the specified old token replaced with new tokens.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="tokenInList">The token to be replaced; a descendant of the root node and an element of a list member.</param>
            <param name="newTokens">A sequence of tokens to use in the tree in place of the specified token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensBefore``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with new tokens inserted before the specified token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="tokenInList">The token to insert before; a descendant of the root node and an element of a list member.</param>
            <param name="newTokens">A sequence of tokens to insert into the tree immediately before the specified token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensAfter``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with new tokens inserted after the specified token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="tokenInList">The token to insert after; a descendant of the root node and an element of a list member.</param>
            <param name="newTokens">A sequence of tokens to insert into the tree immediately after the specified token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified old trivia replaced with new trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="oldTrivia">The trivia to be replaced; a descendant of the root node.</param>
            <param name="newTrivia">A sequence of trivia to use in the tree in place of the specified trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaBefore``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with new trivia inserted before the specified trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="trivia">The trivia to insert before; a descendant of the root node.</param>
            <param name="newTrivia">A sequence of trivia to insert into the tree immediately before the specified trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaAfter``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with new trivia inserted after the specified trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root of the tree of nodes.</param>
            <param name="trivia">The trivia to insert after; a descendant of the root node.</param>
            <param name="newTrivia">A sequence of trivia to insert into the tree immediately after the specified trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTokens``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="tokens">The token to be replaced; descendants of the root node.</param>
            <param name="computeReplacementToken">A function that computes a replacement token for
            the argument tokens. The first argument is the original token. The second argument is
            the same token potentially rewritten with replaced trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new tree of nodes with the specified old token replaced with a new token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldToken">The token to be replaced.</param>
            <param name="newToken">The new token to use in the new tree in place of the old
            token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new tree of nodes with the specified trivia replaced with new trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="trivia">The trivia to be replaced; descendants of the root node.</param>
            <param name="computeReplacementTrivia">A function that computes replacement trivia for
            the specified arguments. The first argument is the original trivia. The second argument is
            the same trivia with potentially rewritten sub structure.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new tree of nodes with the specified trivia replaced with new trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="trivia">The trivia to be replaced.</param>
            <param name="newTrivia">The new trivia to use in the new tree in place of the old trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified node removed.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node from which to remove a descendant node from.</param>
            <param name="node">The node to remove.</param>
            <param name="options">Options that determine how the node's trivia is treated.</param>
            <returns>New root or null if the root node itself is removed.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNodes``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified nodes removed.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node from which to remove a descendant node from.</param>
            <param name="nodes">The nodes to remove.</param>
            <param name="options">Options that determine how the nodes' trivia is treated.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.Boolean)">
            <summary>
            Creates a new syntax node with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <typeparam name="TNode">The type of the node.</typeparam>
            <param name="node">The node to format.</param>
            <param name="indentation">A sequence of whitespace characters that defines a single level of indentation.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.String,System.Boolean)">
            <summary>
            Creates a new syntax node with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <typeparam name="TNode">The type of the node.</typeparam>
            <param name="node">The node to format.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a single level of indentation.</param>
            <param name="eol">An optional sequence of whitespace characters used for end of line.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTriviaFrom``1(``0,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a new node from this node with both the leading and trailing trivia of the specified node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrivia``1(``0)">
            <summary>
            Creates a new node from this node without leading or trailing trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrivia(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new token from this token without leading or trailing trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutLeadingTrivia``1(``0)">
            <summary>
            Creates a new node from this node with the leading trivia removed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrailingTrivia``1(``0)">
            <summary>
            Creates a new node from this node with the trailing trivia removed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.AsRootOfNewTreeWithOptionsFrom(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Attaches the node to a SyntaxTree that the same options as <paramref name="oldTree"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with the specified nodes being tracked.
            
            Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,
            to get the current node corresponding to the original tracked node.
            </summary>
            <param name="root">The root of the subtree containing the nodes to be tracked.</param>
            <param name="nodes">One or more nodes that are descendants of the root node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new tree of nodes with the specified nodes being tracked.
            
            Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,
            to get the current node corresponding to the original tracked node.
            </summary>
            <param name="root">The root of the subtree containing the nodes to be tracked.</param>
            <param name="nodes">One or more nodes that are descendants of the root node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,``0)">
            <summary>
            Gets the nodes within the subtree corresponding to the original tracked node.
            Use TrackNodes to start tracking nodes.
            </summary>
            <param name="root">The root of the subtree containing the current node corresponding to the original tracked node.</param>
            <param name="node">The node instance originally tracked.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNode``1(Microsoft.CodeAnalysis.SyntaxNode,``0)">
            <summary>
            Gets the node within the subtree corresponding to the original tracked node.
            Use TrackNodes to start tracking nodes.
            </summary>
            <param name="root">The root of the subtree containing the current node corresponding to the original tracked node.</param>
            <param name="node">The node instance originally tracked.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets the nodes within the subtree corresponding to the original tracked nodes.
            Use TrackNodes to start tracking nodes.
            </summary>
            <param name="root">The root of the subtree containing the current nodes corresponding to the original tracked nodes.</param>
            <param name="nodes">One or more node instances originally tracked.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken">
            <summary>
            A wrapper for either a syntax node (<see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>) or a syntax token (<see
            cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>).
            </summary>
            <remarks>
            Note that we do not store the token directly, we just store enough information to reconstruct it.
            This allows us to reuse nodeOrToken as a token's parent.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.RawKind">
            <summary>
            An integer representing the language specific kind of the underlying node or token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Language">
            <summary>
            The language name that this node or token is syntax of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsMissing">
            <summary>
            Determines whether the underlying node or token represents a language construct that was actually parsed
            from source code. Missing nodes and tokens are typically generated by the parser in error scenarios to
            represent constructs that should have been present in the source code for the source code to compile
            successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Parent">
            <summary>
            The node that contains the underlying node or token in its Children collection.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsToken">
            <summary>
            Determines whether this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsNode">
            <summary>
            Determines whether this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.AsToken">
            <summary>
            Returns the underlying token if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a
            token.
            </summary>
            <returns>
            The underlying token if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a token.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.AsNode">
            <summary>
            Returns the underlying node if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a
            node.
            </summary>
            <returns>
            The underlying node if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is wrapping a node.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ChildNodesAndTokens">
            <summary>
            The list of child nodes and tokens of the underlying node or token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Span">
            <summary>
            The absolute span of the underlying node or token in characters, not including its leading and trailing
            trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.SpanStart">
            <summary>
            Same as accessing <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.FullSpan">
            <summary>
            The absolute span of the underlying node or token in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ToString">
            <summary>
            Returns the string representation of this node or token, not including its leading and trailing
            trivia.
            </summary>
            <returns>
            The string representation of this node or token, not including its leading and trailing trivia.
            </returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ToFullString">
            <summary>
            Returns the full string representation of this node or token including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node or token including its leading and trailing
            trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node or token to the specified TextWriter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasLeadingTrivia">
            <summary>
            Determines whether the underlying node or token has any leading trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetLeadingTrivia">
            <summary>
            The list of trivia that appear before the underlying node or token in the source code and are attached to a
            token that is a descendant of the underlying node or token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasTrailingTrivia">
            <summary>
            Determines whether the underlying node or token has any trailing trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetTrailingTrivia">
            <summary>
            The list of trivia that appear after the underlying node or token in the source code and are attached to a
            token that is a descendant of the underlying node or token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsDiagnostics">
            <summary>
            Determines whether the underlying node or token or any of its descendant nodes, tokens or trivia have any
            diagnostics on them. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has this node as its root or
            associated with this token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsDirectives">
            <summary>
            Determines whether the underlying node or token has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsAnnotations">
            <summary>
            Determines whether this node or token (or any sub node, token or trivia) as annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasAnnotations(System.String)">
            <summary>
            Determines whether this node or token has annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether this node or token has annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Determines if this node or token has the specific annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetAnnotations(System.String)">
            <summary>
            Gets all annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets all annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithAdditionalAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node or token identical to this one with the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithAdditionalAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node or token identical to this one with the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new node or token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new node or token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(System.String)">
            <summary>
            Creates a new node or token identical to this one without annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Equals(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Equality(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>s are equal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Inequality(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>s are unequal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Determines if the two nodes or tokens are equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsIncrementallyIdenticalTo(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            See <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.IsIncrementallyIdenticalTo(Microsoft.CodeAnalysis.SyntaxNode)"/> and <see cref="M:Microsoft.CodeAnalysis.SyntaxToken.IsIncrementallyIdenticalTo(Microsoft.CodeAnalysis.SyntaxToken)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Implicit(Microsoft.CodeAnalysis.SyntaxToken)~Microsoft.CodeAnalysis.SyntaxNodeOrToken">
            <summary>
            Returns a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied token.
            </summary>
            <param name="token">The input token.</param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied token.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Explicit(Microsoft.CodeAnalysis.SyntaxNodeOrToken)~Microsoft.CodeAnalysis.SyntaxToken">
            <summary>
            Returns the underlying token wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodeOrToken">
            The input <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </param>
            <returns>
            The underlying token wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Implicit(Microsoft.CodeAnalysis.SyntaxNode)~Microsoft.CodeAnalysis.SyntaxNodeOrToken">
            <summary>
            Returns a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied node.
            </summary>
            <param name="node">The input node.</param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> that wraps the supplied node.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Explicit(Microsoft.CodeAnalysis.SyntaxNodeOrToken)~Microsoft.CodeAnalysis.SyntaxNode">
            <summary>
            Returns the underlying node wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodeOrToken">
            The input <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </param>
            <returns>
            The underlying node wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxNodeOrToken.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetLocation">
            <summary>
            Get the location of this node or token.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList">
            <summary>
            A list of <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> structures.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList._node">
            <summary>
            The underlying field
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.index">
            <summary>
            The index from the parent's children list of this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.#ctor(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> structure.
            </summary>
            <param name="node">The underlying syntax node.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.#ctor(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> from a sequence of <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodesAndTokens">The sequence of nodes and tokens</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.#ctor(Microsoft.CodeAnalysis.SyntaxNodeOrToken[])">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> from one or more <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodesAndTokens">The nodes and tokens</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Node">
            <summary>
            Gets the underlying syntax node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Count">
            <summary>
            Gets the count of nodes in this list
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> at the specified index. 
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="index"/> is out of range.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.FullSpan">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Span">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.ToString">
            <summary>
            Returns the string representation of the nodes and tokens in this list, not including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes and tokens in this list, not including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.ToFullString">
            <summary>
            Returns the full string representation of the nodes and tokens in this list including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes and tokens in this list including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.First">
            <summary>
            Gets the first SyntaxNodeOrToken structure from this list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.FirstOrDefault">
            <summary>
            Gets the first SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Last">
            <summary>
            Gets the last SyntaxNodeOrToken structure from this list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.LastOrDefault">
            <summary>
            Gets the last SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.IndexOf(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Returns the index from the list for the given <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodeOrToken">The node or token to search for in the list.</param>
            <returns>The index of the found nodeOrToken, or -1 if it wasn't found</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Any">
            <summary>
            Indicates whether there is any element in the list.
            </summary>
            <returns><c>true</c> if there are any elements in the list, else <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.CopyTo(System.Int32,Microsoft.CodeAnalysis.GreenNode[],System.Int32,System.Int32)">
            <summary>
            Copies a given count of elements into the given array at specified offsets.
            </summary>
            <param name="offset">The offset to start copying from.</param>
            <param name="array">The array to copy the elements into.</param>
            <param name="arrayOffset">The array offset to start writing to.</param>
            <param name="count">The count of elements to copy.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Add(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified node or token added to the end.
            </summary>
            <param name="nodeOrToken">The node or token to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.AddRange(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified nodes or tokens added to the end.
            </summary>
            <param name="nodesOrTokens">The nodes or tokens to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Insert(System.Int32,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified node or token inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodeOrToken">The node or token to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified nodes or tokens inserted at the index.
            </summary>
            <param name="index">The index to insert at.</param>
            <param name="nodesAndTokens">The nodes or tokens to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.RemoveAt(System.Int32)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the element at the specified index removed.
            </summary>
            <param name="index">The index of the element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Remove(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified element removed.
            </summary>
            <param name="nodeOrTokenInList">The element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Replace(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified element replaced with a new node or token.
            </summary>
            <param name="nodeOrTokenInList">The element to replace.</param>
            <param name="newNodeOrToken">The new node or token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.ReplaceRange(Microsoft.CodeAnalysis.SyntaxNodeOrToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> with the specified element replaced with a new nodes and tokens.
            </summary>
            <param name="nodeOrTokenInList">The element to replace.</param>
            <param name="newNodesAndTokens">The new nodes and tokens.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.System#Collections#Generic#IEnumerable{Microsoft#CodeAnalysis#SyntaxNodeOrToken}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.op_Equality(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList,Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left SyntaxNodeOrTokenList</param>
            <param name="right">The right SyntaxNodeOrTokenList</param>
            <returns>
            <c>true</c> if both lists equal, else <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.op_Inequality(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList,Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left SyntaxNodeOrTokenList</param>
            <param name="right">The right SyntaxNodeOrTokenList</param>
            <returns>
            <c>true</c> if both lists not equal, else <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Equals(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="other"/> parameter; otherwise,
            <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator">
            <summary>
            Enumerator for lists of SyntaxNodeOrToken structs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.Current">
            <summary>
            Gets the struct that this enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the struct that this enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxReference">
            <summary>
            A reference to a syntax node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxReference.SyntaxTree">
            <summary>
            The syntax tree that this references a node within.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxReference.Span">
            <summary>
            The span of the node referenced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxReference.GetSyntax(System.Threading.CancellationToken)">
            <summary>
            Retrieves the original referenced syntax node.  
            This action may cause a parse to happen to recover the syntax node.
            </summary>
            <returns>The original referenced syntax node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxReference.GetSyntaxAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves the original referenced syntax node.  
            This action may cause a parse to happen to recover the syntax node.
            </summary>
            <returns>The original referenced syntax node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxReference.GetLocation">
            <summary>
            The location of this syntax reference.
            </summary>
            <returns>The location of this syntax reference.</returns>
            <remarks>
            More performant than GetSyntax().GetLocation().
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepNoTrivia">
            <summary>
            None of the trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepLeadingTrivia">
            <summary>
            The leading trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepTrailingTrivia">
            <summary>
            The trailing trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepExteriorTrivia">
            <summary>
            The leading and trailing trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepUnbalancedDirectives">
            <summary>
            Any directives that would become unbalanced are kept.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepDirectives">
            <summary>
            All directives are kept
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.KeepEndOfLine">
            <summary>
            Ensure that at least one EndOfLine trivia is kept if one was present 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxRemoveOptions.AddElasticMarker">
            <summary>
            Adds elastic marker trivia
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxToken">
            <summary>
            Represents a token in the syntax tree. This is the language agnostic equivalent of <see
            cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxToken"/> and <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxToken"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind">
            <summary>
            An integer representing the language specific kind of this token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.Language">
            <summary>
            The language name that this token is syntax of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.RawContextualKind">
            <summary>
            The kind of token, given its position in the syntax. This differs from <see
            cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind"/> when a contextual keyword is used in a place in the syntax that gives it
            its keyword meaning.
            </summary>
            <remarks>
            The ContextualKind is relevant only on contextual keyword tokens. ContextualKind differs
            from Kind when a token is used in context where the token should be interpreted as a
            keyword.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.Parent">
            <summary>
            The node that contains this token in its Children collection.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.Width">
            <summary>
            The width of the token in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.FullWidth">
            <summary>
            The complete width of the token in characters including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.Span">
            <summary>
            The absolute span of this token in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.SpanStart">
            <summary>
            Same as accessing <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.FullSpan">
            <summary>
            The absolute span of this token in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.IsMissing">
            <summary>
            Determines whether this token represents a language construct that was actually parsed from source code.
            Missing tokens are typically generated by the parser in error scenarios to represent constructs that should
            have been present in the source code for the source code to compile successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.Value">
            <summary>
            Returns the value of the token. For example, if the token represents an integer literal, then this property
            would return the actual integer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.ValueText">
            <summary>
            Returns the text representation of the value of the token. For example, if the token represents an integer
            literal, then this property would return a string representing the integer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.ToString">
            <summary>
            Returns the string representation of this token, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this token, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.ToFullString">
            <summary>
            Returns the full string representation of this token including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this token including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this token to the specified <paramref name="writer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WriteTo(System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Writes the text of this token to the specified TextWriter, optionally including trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.HasLeadingTrivia">
            <summary>
            Determines whether this token has any leading trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.HasTrailingTrivia">
            <summary>
            Determines whether this token has any trailing trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.LeadingWidth">
            <summary>
            Full width of the leading trivia of this token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.TrailingWidth">
            <summary>
            Full width of the trailing trivia of this token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.ContainsDiagnostics">
            <summary>
            Determines whether this token or any of its descendant trivia have any diagnostics on them. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.ContainsDirectives">
            <summary>
            Determines whether this token has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.IsPartOfStructuredTrivia">
            <summary>
            Determines whether this token is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.HasStructuredTrivia">
            <summary>
            Determines whether any of this token's trivia is structured.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.ContainsAnnotations">
            <summary>
            True if this token or its trivia has any annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.HasAnnotations(System.String)">
            <summary>
            True if this token has annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.HasAnnotations(System.String[])">
            <summary>
            True if this token has annotations of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            True if this token has the specified annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetAnnotations(System.String)">
            <summary>
            Gets all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetAnnotations(System.String[])">
            <summary>
            Gets all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetAnnotations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithAdditionalAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithAdditionalAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithoutAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new syntax token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithoutAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new syntax token identical to this one without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithoutAnnotations(System.String)">
            <summary>
            Creates a new syntax token identical to this one without annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.CopyAnnotationsTo(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxToken instance and attaches them to a new instance based on <paramref name="token" />.
            </summary>
            <remarks>
            If no annotations are copied, just returns <paramref name="token" />.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia">
            <summary>
            The list of trivia that appear before this token in the source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia">
            <summary>
            The list of trivia that appear after this token in the source code and are attached to this token or any of
            its descendants.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithTriviaFrom(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new token from this token with the leading and trailing trivia from the specified token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithLeadingTrivia(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a new token from this token with the leading trivia specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithLeadingTrivia(Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a new token from this token with the leading trivia specified..
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithLeadingTrivia(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new token from this token with the leading trivia specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithTrailingTrivia(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a new token from this token with the trailing trivia specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithTrailingTrivia(Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a new token from this token with the trailing trivia specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.WithTrailingTrivia(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new token from this token with the trailing trivia specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetAllTrivia">
            <summary>
            Gets a list of all the trivia (both leading and trailing) for this token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.op_Equality(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>s are equal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.op_Inequality(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>s are unequal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.Equals(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetNextToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the token that follows this token in the syntax tree.
            </summary>
            <returns>The token that follows this token in the syntax tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetNextToken(System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Returns the token after this token in the syntax tree.
            </summary>
            <param name="predicate">Delegate applied to each token.  The token is returned if the predicate returns
            true.</param>
            <param name="stepInto">Delegate applied to trivia.  If this delegate is present then trailing trivia is
            included in the search.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetPreviousToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the token that precedes this token in the syntax tree.
            </summary>
            <returns>The previous token that precedes this token in the syntax tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetPreviousToken(System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Returns the token before this token in the syntax tree.
            </summary>
            <param name="predicate">Delegate applied to each token.  The token is returned if the predicate returns
            true.</param>
            <param name="stepInto">Delegate applied to trivia.  If this delegate is present then trailing trivia is
            included in the search.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxToken.SyntaxTree">
            <summary>
            The SyntaxTree that contains this token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetLocation">
            <summary>
            Gets the location for this token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics associated with this token and any related trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines if this token is equivalent to the specified token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxToken.IsIncrementallyIdenticalTo(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns true if these two tokens are considered "incrementally identical".  An incrementally identical token
            occurs when a <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.SyntaxTree"/> is incrementally parsed using <see cref="M:Microsoft.CodeAnalysis.SyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)"/>
            and the incremental parser is able to take the token from the original tree and use it in its entirety in the
            new tree.  In this case, the <see cref="M:Microsoft.CodeAnalysis.SyntaxToken.ToFullString"/> of each token will be the same, though 
            they could have different parents, and may occur at different positions in the respective trees.  If two tokens are
            incrementally identical, all trivial of each node will be incrementally identical as well.
            </summary>
            <remarks>
            Incrementally identical tokens can also appear within the same syntax tree, or syntax trees that did not arise
            from <see cref="M:Microsoft.CodeAnalysis.SyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)"/>.  This can happen as the parser is allowed to construct parse
            trees using shared tokens for efficiency.  In all these cases though, it will still remain true that the incrementally
            identical tokens could have different parents and may occur at different positions in their respective trees.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTokenList">
            <summary>
            Represents a read-only list of <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>.
            </summary>
            <summary>
             Represents a read-only list of <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.#ctor(Microsoft.CodeAnalysis.SyntaxToken[])">
            <summary>
            Creates a list of tokens.
            </summary>
            <param name="tokens">An array of tokens.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.#ctor(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a list of tokens.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTokenList.Count">
            <summary>
            Returns the number of tokens in the list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTokenList.Item(System.Int32)">
            <summary>
            Gets the token at the specified index.
            </summary>
            <param name="index">The zero-based index of the token to get.</param>
            <returns>The token at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index" /> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:Microsoft.CodeAnalysis.SyntaxTokenList.Count" />. </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTokenList.FullSpan">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTokenList.Span">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.ToString">
            <summary>
            Returns the string representation of the tokens in this list, not including 
            the first token's leading trivia and the last token's trailing trivia.
            </summary>
            <returns>
            The string representation of the tokens in this list, not including 
            the first token's leading trivia and the last token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.ToFullString">
            <summary>
            Returns the full string representation of the tokens in this list including 
            the first token's leading trivia and the last token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the tokens in this list including 
            the first token's leading trivia and the last token's trailing trivia.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.First">
            <summary>
            Returns the first token in the list.
            </summary>
            <returns>The first token in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Last">
            <summary>
            Returns the last token in the list.
            </summary>
            <returns> The last token in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Any">
            <summary>
            Tests whether the list is non-empty.
            </summary>
            <returns>True if the list contains any tokens.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Reverse">
            <summary>
            Returns a list which contains all elements of <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> in reversed order.
            </summary>
            <returns><see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList.Reversed"/> which contains all elements of <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> in reversed order</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.GetGreenNodeAt(System.Int32)">
            <summary>
            get the green node at the given slot
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.GetGreenNodeAt(Microsoft.CodeAnalysis.GreenNode,System.Int32)">
            <summary>
            get the green node at the given slot
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Add(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified token added to the end.
            </summary>
            <param name="token">The token to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.AddRange(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified tokens added to the end.
            </summary>
            <param name="tokens">The tokens to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Insert(System.Int32,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified token insert at the index.
            </summary>
            <param name="index">The index to insert the new token.</param>
            <param name="token">The token to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified tokens insert at the index.
            </summary>
            <param name="index">The index to insert the new tokens.</param>
            <param name="tokens">The tokens to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.RemoveAt(System.Int32)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the token at the specified index removed.
            </summary>
            <param name="index">The index of the token to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Remove(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified token removed.
            </summary>
            <param name="tokenInList">The token to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Replace(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified token replaced with a new token.
            </summary>
            <param name="tokenInList">The token to replace.</param>
            <param name="newToken">The new token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.ReplaceRange(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the specified token replaced with new tokens.
            </summary>
            <param name="tokenInList">The token to replace.</param>
            <param name="newTokens">The new tokens.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.GetEnumerator">
            <summary>
            Returns an enumerator for the tokens in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.op_Equality(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Compares <paramref name="left"/> and <paramref name="right"/> for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if the two <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/>s are equal.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.op_Inequality(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Compares <paramref name="left"/> and <paramref name="right"/> for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if the two <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/>s are not equal.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Equals(System.Object)">
            <summary>
            Compares this <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/> with the <paramref name="obj"/> for equality.
            </summary>
            <returns>True if the two objects are equal.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Create(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Create a new Token List
            </summary>
            <param name="token">Element of the return Token List</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTokenList.Enumerator">
            <summary>
            A structure for enumerating a <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTokenList.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next token in the collection.
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator
            has passed the end of the collection.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTokenList.Enumerator.Current">
            <summary>
            Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTokenList.Reversed">
            <summary>
            Reversed enumerable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTree">
            <summary>
            The parsed representation of a source document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxTree.EmptyDiagnosticOptions">
            <summary>
            Cached value for empty <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.DiagnosticOptions"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath">
            <summary>
            The path of the source document file.
            </summary>
            <remarks>
            If this syntax tree is not associated with a file, this value can be empty.
            The path shall not be null.
            
            The file doesn't need to exist on disk. The path is opaque to the compiler.
            The only requirement on the path format is that the implementations of 
            <see cref="T:Microsoft.CodeAnalysis.SourceReferenceResolver"/>, <see cref="T:Microsoft.CodeAnalysis.XmlReferenceResolver"/> and <see cref="T:Microsoft.CodeAnalysis.MetadataReferenceResolver"/> 
            passed to the compilation that contains the tree understand it.
            
            Clients must also not assume that the values of this property are unique
            within a Compilation.
            
            The path is used as follows:
               - When debug information is emitted, this path is embedded in the debug information.
               - When resolving and normalizing relative paths in #r, #load, #line/#ExternalSource, 
                 #pragma checksum, #ExternalChecksum directives, XML doc comment include elements, etc.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot">
            <summary>
            Returns true if this syntax tree has a root with SyntaxKind "CompilationUnit".
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.Options">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.OptionsCore">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.DiagnosticOptions">
            <summary>
            Option to specify custom behavior for each warning in this tree.
            </summary>
            <returns>
            A map from diagnostic ID to diagnostic reporting level. The diagnostic
            ID string may be case insensitive depending on the language.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.Length">
            <summary>
            The length of the text of the syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.TryGetText(Microsoft.CodeAnalysis.Text.SourceText@)">
            <summary>
            Gets the syntax tree's text if it is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetText(System.Threading.CancellationToken)">
            <summary>
            Gets the text of the source document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTree.Encoding">
            <summary>
            The text encoding of the source document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxTree._sourceGeneratorInfo">
            <summary>
            Useful information about this tree that is stored for source-generator scenarios.  Allows the incremental
            generation framework to compute and cache data once against a tree so it does not have to go back to source
            for untouched trees when other trees in the compilation are modified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetTextAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the text of the source document asynchronously.
            </summary>
            <remarks>
            By default, the work associated with this method will be executed immediately on the current thread.
            Implementations that wish to schedule this work differently should override <see cref="M:Microsoft.CodeAnalysis.SyntaxTree.GetTextAsync(System.Threading.CancellationToken)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRoot(Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Gets the root of the syntax tree if it is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRootCore(Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Gets the root of the syntax tree if it is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetRoot(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree, causing computation if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetRootCore(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree, causing computation if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsyncCore(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Create a new syntax tree based off this tree using a new source text.
            
            If the new source text is a minor change from the current source text an incremental
            parse will occur reusing most of the current syntax tree internal data.  Otherwise, a
            full parse will occur using the new source text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets a list of all the diagnostics in the syntax tree.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets a list of all the diagnostics associated with the token and any related trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Gets a list of all the diagnostics associated with the trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
            associated with the token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Gets the location in terms of path, line and column for a given span.
            </summary>
            <param name="span">Span within the tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>
            A valid <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.
            The values are not affected by line mapping directives (<c>#line</c>).
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Gets the location in terms of path, line and column after applying source line mapping directives 
            (<c>#line</c> in C# or <c>#ExternalSource</c> in VB). 
            </summary>
            <param name="span">Span within the tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>
            A valid <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.
            
            If the location path is mapped the resulting path is the path specified in the corresponding <c>#line</c>,
            otherwise it's <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath"/>.
            
            A location path is considered mapped if it is preceded by a line mapping directive that
            either specifies an explicit file path or is <c>#line default</c>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetLineMappings(System.Threading.CancellationToken)">
            <summary>
            Returns empty sequence if there are no line mapping directives in the tree.
            Otherwise, returns a sequence of pairs of spans: each describing a mapping of a span of the tree between two consecutive #line directives.
            If the first directive is not on the first line the first pair describes mapping of the span preceding the first directive.
            The last pair of the sequence describes mapping of the span following the last #line directive.
            </summary>
            <returns>
            Empty sequence if the tree does not contain a line mapping directive.
            Otherwise a non-empty sequence of <see cref="T:Microsoft.CodeAnalysis.LineMapping"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetLineVisibility(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns the visibility for the line at the given position.
            </summary>
            <param name="position">The position to check.</param>
            <param name="cancellationToken">The cancellation token.</param> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetMappedLineSpanAndVisibility(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean@)">
            <summary>
            Gets a FileLinePositionSpan for a TextSpan and the information whether this span is considered to be hidden or not. 
            FileLinePositionSpans are used primarily for diagnostics and source locations.
            This method combines a call to GetLineSpan and IsHiddenPosition.
            </summary>
            <param name="span"></param>
            <param name="isHiddenPosition">Returns a boolean indicating whether this span is considered hidden or not.</param>
            <remarks>This function is being called only in the context of sequence point creation and therefore interprets the 
            LineVisibility accordingly (BeforeFirstRemappingDirective -> Visible).</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDisplayPath(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SourceReferenceResolver)">
            <summary>
            Returns a path for particular location in source that is presented to the user. 
            </summary>
            <remarks>
            Used for implementation of <see cref="T:System.Runtime.CompilerServices.CallerFilePathAttribute"/> 
            or for embedding source paths in error messages.
            
            Unlike Dev12 we do account for #line and #ExternalSource directives when determining value for 
            <see cref="T:System.Runtime.CompilerServices.CallerFilePathAttribute"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDisplayLineNumber(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns a line number for particular location in source that is presented to the user. 
            </summary>
            <remarks>
            Used for implementation of <see cref="T:System.Runtime.CompilerServices.CallerLineNumberAttribute"/> 
            or for embedding source line numbers in error messages.
            
            Unlike Dev12 we do account for #line and #ExternalSource directives when determining value for 
            <see cref="T:System.Runtime.CompilerServices.CallerLineNumberAttribute"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.HasHiddenRegions">
            <summary>
            Are there any hidden regions in the tree?
            </summary>
            <returns>True if there is at least one hidden region.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns a list of the changed regions between this tree and the specified tree. The list is conservative for
            performance reasons. It may return larger regions than what has actually changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetLocation(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets a location for the specified text span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="tree">The tree to compare against.</param>
            <param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetReference(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets a SyntaxReference for a specified syntax node. SyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetChanges(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets a list of text changes that when applied to the old tree produce this tree.
            </summary>
            <param name="oldTree">The old tree.</param>
            <remarks>The list of changes may be different than the original changes that produced
            this tree.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.GetDebugSourceInfo">
            <summary>
            Gets the checksum + algorithm id to use in the PDB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.WithRootAndOptions(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Returns a new tree whose root and options are as specified and other properties are copied from the current tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.WithFilePath(System.String)">
            <summary>
            Returns a new tree whose <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath"/> is the specified node and other properties are copied from the current tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.WithDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})">
            <summary>
            Returns a new tree whose <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.DiagnosticOptions" /> are the specified value and other properties are copied
            from the current tree.
            </summary>
            <param name="options">
            A mapping from diagnostic id to diagnostic reporting level. The diagnostic ID may be case-sensitive depending
            on the language.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTree.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents the entire source text of this <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.VerifySource(Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Verify nodes match source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.FindFirstDifference(System.String,System.String)">
            <summary>
            Return the index of the first difference between
            the two strings, or -1 if the strings are the same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.IsHiddenPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns <c>true</c> if the provided position is in a hidden region inaccessible to the user.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTrivia">
            <summary>
            Represents a trivia in the syntax tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.RawKind">
            <summary>
            An integer representing the language specific kind of this trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.Language">
            <summary>
            The language name that this trivia is syntax of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.Token">
            <summary>
            The parent token that contains this token in its LeadingTrivia or TrailingTrivia collection.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.Width">
            <summary>
            The width of this trivia in characters. If this trivia is a structured trivia then the returned width will
            not include the widths of any leading or trailing trivia present on the child non-terminal node of this
            trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.FullWidth">
            <summary>
            The width of this trivia in characters. If this trivia is a structured trivia then the returned width will
            include the widths of any leading or trailing trivia present on the child non-terminal node of this trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.Span">
            <summary>
            The absolute span of this trivia in characters. If this trivia is a structured trivia then the returned span
            will not include spans of any leading or trailing trivia present on the child non-terminal node of this
            trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.SpanStart">
            <summary>
            Same as accessing <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start"/> on <see cref="P:Microsoft.CodeAnalysis.SyntaxTrivia.Span"/>.
            </summary>
            <remarks>
            Slight performance improvement.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.FullSpan">
            <summary>
            The absolute span of this trivia in characters. If this trivia is a structured trivia then the returned span
            will include spans of any leading or trailing trivia present on the child non-terminal node of this trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.ContainsDiagnostics">
            <summary>
            Determines whether this trivia has any diagnostics on it. If this trivia is a structured trivia then the
            returned value will indicate whether this trivia or any of its descendant nodes, tokens or trivia have any
            diagnostics on them.
            </summary>>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.HasStructure">
            <summary>
            Determines whether this trivia is a structured trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.IsPartOfStructuredTrivia">
            <summary>
            Determines whether this trivia is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.ContainsAnnotations">
            <summary>
            Determines whether this trivia or any of its structure has annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.HasAnnotations(System.String)">
            <summary>
            Determines where this trivia has annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.HasAnnotations(System.String[])">
            <summary>
            Determines where this trivia has any annotations of the specified annotation kinds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            Determines whether this trivia has the specific annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetAnnotations(System.String)">
            <summary>
            Get all the annotations of the specified annotation kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetAnnotations(System.String[])">
            <summary>
            Get all the annotations of the specified annotation kinds.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.IsDirective">
            <summary>
            Determines whether this trivia represents a preprocessor directive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetStructure">
            <summary>
            Returns the child non-terminal node representing the syntax tree structure under this structured trivia.
            </summary>
            <returns>The child non-terminal node representing the syntax tree structure under this structured
            trivia.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.ToString">
            <summary> 
            Returns the string representation of this trivia. If this trivia is structured trivia then the returned string
            will not include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
            </summary>
            <returns>The string representation of this trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.ToFullString">
            <summary> 
            Returns the full string representation of this trivia. If this trivia is structured trivia then the returned string will
            include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
            </summary>
            <returns>The full string representation of this trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this trivia to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.op_Equality(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>s are equal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.op_Inequality(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>s are unequal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.Equals(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WithAdditionalAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new SyntaxTrivia with the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WithAdditionalAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new SyntaxTrivia with the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WithoutAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])">
            <summary>
            Creates a new SyntaxTrivia without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WithoutAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            Creates a new SyntaxTrivia without the specified annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.WithoutAnnotations(System.String)">
            <summary>
            Creates a new SyntaxTrivia without annotations of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.CopyAnnotationsTo(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxTrivia instance and attaches them to a new instance based on <paramref name="trivia" />.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTrivia.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxTrivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetLocation">
            <summary>
            Get the location of this trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics associated with this trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTrivia.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Determines if this trivia is equivalent to the specified trivia.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTriviaList">
            <summary>
            Represents a read-only list of <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.#ctor(Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a list of trivia.
            </summary>
            <param name="trivias">An array of trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.#ctor(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a list of trivia.
            </summary>
            <param name="trivias">A sequence of trivia.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTriviaList.Item(System.Int32)">
            <summary>
            Gets the trivia at the specified index.
            </summary>
            <param name="index">The zero-based index of the trivia to get.</param>
            <returns>The token at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index" /> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:Microsoft.CodeAnalysis.SyntaxTriviaList.Count" />. </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTriviaList.FullSpan">
            <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxTriviaList.Span">
            <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.First">
            <summary>
            Returns the first trivia in the list.
            </summary>
            <returns>The first trivia in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Last">
            <summary>
            Returns the last trivia in the list.
            </summary>
            <returns>The last trivia in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The list is empty.</exception>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Any">
            <summary>
            Does this list have any items.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Reverse">
            <summary>
            Returns a list which contains all elements of <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> in reversed order.
            </summary>
            <returns><see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed"/> which contains all elements of <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> in reversed order</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Add(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia added to the end.
            </summary>
            <param name="trivia">The trivia to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.AddRange(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia added to the end.
            </summary>
            <param name="trivia">The trivia to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Insert(System.Int32,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia inserted at the index.
            </summary>
            <param name="index">The index in the list to insert the trivia at.</param>
            <param name="trivia">The trivia to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified trivia inserted at the index.
            </summary>
            <param name="index">The index in the list to insert the trivia at.</param>
            <param name="trivia">The trivia to insert.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.RemoveAt(System.Int32)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the element at the specified index removed.
            </summary>
            <param name="index">The index identifying the element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Remove(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified element removed.
            </summary>
            <param name="triviaInList">The trivia element to remove.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.Replace(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified element replaced with new trivia.
            </summary>
            <param name="triviaInList">The trivia element to replace.</param>
            <param name="newTrivia">The trivia to replace the element with.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.ReplaceRange(Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/> with the specified element replaced with new trivia.
            </summary>
            <param name="triviaInList">The trivia element to replace.</param>
            <param name="newTrivia">The trivia to replace the element with.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.GetGreenNodeAt(System.Int32)">
            <summary>
            get the green node at the specific slot
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTriviaList.CopyTo(System.Int32,Microsoft.CodeAnalysis.SyntaxTrivia[],System.Int32,System.Int32)">
            <summary>
            Copy <paramref name="count"/> number of items starting at <paramref name="offset"/> from this list into <paramref name="array"/> starting at <paramref name="arrayOffset"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed">
            <summary>
            Reversed enumerable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxWalker">
            <summary>
            Walks the syntax tree, allowing subclasses to operate on all nodes, token and trivia.  The
            walker will perform a depth first walk of the tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SyntaxWalker.Depth">
            <summary>
            Syntax the <see cref="T:Microsoft.CodeAnalysis.SyntaxWalker"/> should descend into.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxWalker.#ctor(Microsoft.CodeAnalysis.SyntaxWalkerDepth)">
            <summary>
            Creates a new walker instance.
            </summary>
            <param name="depth">Syntax the <see cref="T:Microsoft.CodeAnalysis.SyntaxWalker"/> should descend into.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxWalker.Visit(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Called when the walker visits a node.  This method may be overridden if subclasses want
            to handle the node.  Overrides should call back into this base method if they want the
            children of this node to be visited.
            </summary>
            <param name="node">The current node that the walker is visiting.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxWalker.VisitToken(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Called when the walker visits a token.  This method may be overridden if subclasses want
            to handle the token.  Overrides should call back into this base method if they want the 
            trivia of this token to be visited.
            </summary>
            <param name="token">The current token that the walker is visiting.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxWalker.VisitTrivia(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Called when the walker visits a trivia syntax.  This method may be overridden if
            subclasses want to handle the token.  Overrides should call back into this base method if
            they want the children of this trivia syntax to be visited.
            </summary>
            <param name="trivia">The current trivia syntax that the walker is visiting.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxWalkerDepth">
            <summary>
            Syntax the <see cref="T:Microsoft.CodeAnalysis.SyntaxWalker"/> should descend into.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxWalkerDepth.Node">
            <summary>
            descend into only nodes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxWalkerDepth.Token">
            <summary>
            descend into nodes and tokens
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxWalkerDepth.Trivia">
            <summary>
            descend into nodes, tokens and trivia
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SyntaxWalkerDepth.StructuredTrivia">
            <summary>
            descend into everything
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SynthesizedLocalKind">
            <summary>
            Kind of a synthesized local variable.
            </summary>
            <remarks>
            Synthesized local variables are either 
            1) Short-lived (temporary)
               The lifespan of a temporary variable shall not cross a statement boundary (a PDB sequence point).
               These variables are not tracked by EnC and don't have names. Only values less than 0 are considered
               short-lived: new short-lived kinds should have a negative value.
             
            2) Long-lived
               All variables whose lifespan might cross a statement boundary (include a PDB sequence point)
               must be named in a build configuration that supports EnC. Some of them might need to be named in release, to support EE.
               The kind of such local must be encoded in the name, so that we can retrieve it from debug metadata during EnC.
            
               The integer value of the kind must match corresponding Dev11/12 TEMP_KIND enum values for
               compatibility with assemblies generated by the native compiler.
            
               Long-lived local variables must be assigned slots in source order.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.FrameCache">
            <summary>
            Temp created for caching "this".
            Technically it is long-lived, but will happen only in optimized code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.OptimizerTemp">
            <summary>
            Temp variable created by the optimizer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.LoweringTemp">
            <summary>
            Temp variable created during lowering.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.EmitterTemp">
            <summary>
            Temp variable created by the emitter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.UserDefined">
            <summary>
            The variable is not synthesized (C#, VB). Note that SynthesizedLocalKind values
            greater than or equal to this are considered long-lived;
            see <see cref="M:Microsoft.CodeAnalysis.SynthesizedLocalKindExtensions.IsLongLived(Microsoft.CodeAnalysis.SynthesizedLocalKind)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.ConditionalBranchDiscriminator">
            <summary>
            Local variable that stores value of an expression consumed by a subsequent conditional branch instruction that might jump across PDB sequence points.
            The value needs to be preserved when remapping the IL offset from old method body to new method body during EnC.
            A hidden sequence point also needs to be inserted at the offset where this variable is loaded to be consumed by the branch instruction.
            (VB, C#).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.LockTaken">
            <summary>
            Boolean passed to Monitor.Enter (C#, VB).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.Lock">
            <summary>
            Variable holding on the object being locked while the execution is within the block of the lock statement (C#) or SyncLock statement (VB).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.Using">
            <summary>
            Local variable that stores the resources to be disposed at the end of using statement (C#, VB).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.ForEachEnumerator">
            <summary>
            Local variable that stores the enumerator instance (C#, VB).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.ForEachArray">
            <summary>
            Local variable that stores the array instance (C#, VB?).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.ForEachArrayLimit">
            <summary>
            Local variables that store upper bound of multi-dimensional array, for each dimension (C#, VB?).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.ForEachArrayIndex">
            <summary>
            Local variables that store the current index, for each dimension (C#, VB?).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.FixedReference">
            <summary>
            Local variable that holds a pinned handle of a managed reference passed to a fixed statement (C#).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.With">
            <summary>
            Local variable that holds the object passed to With statement (VB). 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.SelectCaseValue">
            <summary>
            Local variable used to store the value of Select Case during the execution of Case statements.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.AsyncMethodReturnValue">
            <summary>
            Local variable that stores the return value of an async method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.FunctionReturnValue">
            <summary>
            VB: Stores the return value of a function that is not accessible from user code (e.g. operator, lambda, async, iterator).
            C#: Stores the return value of a method/lambda with a block body, so that we can put a sequence point on the closing brace of the body.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.ExceptionFilterAwaitHoistedExceptionLocal">
            <summary>
            Very special corner case involving filters, await and lambdas.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.StateMachineCachedState">
            <summary>
            Local variable that stores the current state of the state machine while MoveNext method is executing.
            Used to avoid race conditions due to multiple reads from the lifted state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.Spill">
            <summary>
            Local that stores an expression value which needs to be spilled.
            Such a local arises from the translation of an await or switch expression,
            and might be hoisted to an async state machine if it remains alive
            after an await expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.LambdaDisplayClass">
            <summary>
            Local variable that holds on the display class instance.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.CachedAnonymousMethodDelegate">
            <summary>
            Local variable used to cache a delegate that is used in inner block (possibly a loop), 
            and can be reused for all iterations of the loop.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.Awaiter">
            <summary>
            Local variable that stores the result of an await expression (the awaiter object).
            The variable is assigned the result of a call to await-expression.GetAwaiter() and subsequently used 
            to check whether the task completed. Eventually the value is stored in an awaiter field.
            
            The value assigned to the variable needs to be preserved when remapping the IL offset from old method body 
            to new method body during EnC. If the awaiter expression is contained in an active statement and the 
            containing MoveNext method changes the debugger finds the next sequence point that follows the await expression 
            and transfers the execution to the new method version. This sequence point is placed by the compiler at 
            the immediately after the stloc instruction that stores the awaiter object to this variable.
            The subsequent ldloc then restores it in the new method version.
            
            (VB, C#).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.InstrumentationPayload">
            <summary>
            Stores a dynamic analysis instrumentation payload array. The value is initialized in
            synthesized method prologue code and referred to throughout the method body.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.SwitchCasePatternMatching">
            <summary>
            Temp created for pattern matching by type. This holds the value of an input value provisionally
            converted to the type against which it is being matched.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.MaxValidValueForLocalVariableSerializedToDebugInformation">
            <summary>
            All values have to be less than or equal to <see cref="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.MaxValidValueForLocalVariableSerializedToDebugInformation"/> 
            (<see cref="T:Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation"/>)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.AwaiterField">
            <summary>
            An awaiter in async method. 
            Never actually created as a local variable, immediately lifted to a state machine field.
            Not serialized to <see cref="T:Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.DelegateRelaxationReceiver">
            <summary>
            The receiver of a delegate relaxation stub.
            Created as a local variable but always lifted to a relaxation display class field. 
            We never emit debug info for hoisted relaxation variable. 
            TODO: Avoid using lambdas and display classes for implementation of relaxation stubs and remove this kind.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TreeDumper">
            <summary>
            This is ONLY used id BoundNode.cs Debug method - Dump()
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TreeDumperNode">
            <summary>
            This is ONLY used for debugging purpose
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionHelper.TryParse(System.String,System.Version@)">
            <summary>
            Parses a version string of the form "major [ '.' minor [ '.' build [ '.' revision ] ] ]".
            </summary>
            <param name="s">The version string to parse.</param>
            <param name="version">If parsing succeeds, the parsed version. Otherwise a version that represents as much of the input as could be parsed successfully.</param>
            <returns>True when parsing succeeds completely (i.e. every character in the string was consumed), false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionHelper.TryParseAssemblyVersion(System.String,System.Boolean,System.Version@)">
            <summary>
            Parses a version string of the form "major [ '.' minor [ '.' ( '*' | ( build [ '.' ( '*' | revision ) ] ) ) ] ]"
            as accepted by System.Reflection.AssemblyVersionAttribute.
            </summary>
            <param name="s">The version string to parse.</param>
            <param name="allowWildcard">Indicates whether or not a wildcard is accepted as the terminal component.</param>
            <param name="version">
            If parsing succeeded, the parsed version. Otherwise a version instance with all parts set to zero.
            If <paramref name="s"/> contains * the version build and/or revision numbers are set to <see cref="F:System.UInt16.MaxValue"/>.
            </param>
            <returns>True when parsing succeeds completely (i.e. every character in the string was consumed), false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionHelper.TryParse(System.String,System.Boolean,System.UInt16,System.Boolean,System.Version@)">
            <summary>
            Parses a version string of the form "major [ '.' minor [ '.' ( '*' | ( build [ '.' ( '*' | revision ) ] ) ) ] ]"
            as accepted by System.Reflection.AssemblyVersionAttribute.
            </summary>
            <param name="s">The version string to parse.</param>
            <param name="allowWildcard">Indicates whether or not we're parsing an assembly version string. If so, wildcards are accepted and each component must be less than 65535.</param>
            <param name="maxValue">The maximum value that a version component may have.</param>
            <param name="allowPartialParse">Allow the parsing of version elements where invalid characters exist. e.g. 1.2.2a.1</param>
            <param name="version">
            If parsing succeeded, the parsed version. When <paramref name="allowPartialParse"/> is true a version with values up to the first invalid character set. Otherwise a version with all parts set to zero.
            If <paramref name="s"/> contains * and wildcard is allowed the version build and/or revision numbers are set to <see cref="F:System.UInt16.MaxValue"/>.
            </param>
            <returns>True when parsing succeeds completely (i.e. every character in the string was consumed), false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionHelper.GenerateVersionFromPatternAndCurrentTime(System.DateTime,System.Version)">
            <summary>
            If build and/or revision numbers are 65535 they are replaced with time-based values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.WellKnownMembers.IsSynthesizedAttributeOptional(Microsoft.CodeAnalysis.WellKnownMember)">
            <summary>
            This function defines whether an attribute is optional or not.
            </summary>
            <param name="attributeMember">The attribute member.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WellKnownType">
            <summary>
            Ids of well known runtime types.
            Values should not intersect with SpecialType enum!
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownTypes.Count">
            <summary>
            Number of well known types in WellKnownType enum
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WellKnownTypes.s_metadataNames">
            <summary>
            Array of names for types.
            The names should correspond to ids from WellKnownType enum so
            that we could use ids to index into the array
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlFileResolver">
            <summary>
            Resolves references to XML files specified in the source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlFileResolver.ResolveReference(System.String,System.String)">
            <summary>
            Resolves XML document file path.
            </summary>
            <param name="path">
            Value of the "file" attribute of an &lt;include&gt; documentation comment element.
            </param>
            <param name="baseFilePath">
            Path of the source file (<see cref="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath"/>) or XML document that contains the <paramref name="path"/>.
            If not null used as a base path of <paramref name="path"/>, if <paramref name="path"/> is relative.
            If <paramref name="baseFilePath"/> is relative <see cref="P:Microsoft.CodeAnalysis.XmlFileResolver.BaseDirectory"/> is used as the base path of <paramref name="baseFilePath"/>.
            </param>
            <returns>Normalized XML document file path or null if not found.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlCharType">
            
            The XmlCharType class is used for quick character type recognition
            which is optimized for the first 127 ascii characters.
            
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlCharType.InRange(System.Char,System.Char,System.Char)">
            <summary>
            start &gt;= value &lt;= end
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DeclarationInfo">
            <summary>
            Struct containing information about a source declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredNode">
            <summary>
            Topmost syntax node for this declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DeclarationInfo.ExecutableCodeBlocks">
            <summary>
            Syntax nodes for executable code blocks (method body, initializers, etc.) associated with this declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredSymbol">
            <summary>
            Symbol declared by this declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutable">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableAndClear">
            <summary>
            Realizes the array and clears the collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.SetItem(System.Int32,`0)">
            <summary>
            Write <paramref name="value"/> to slot <paramref name="index"/>. 
            Fills in unallocated slots preceding the <paramref name="index"/>, if any.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToDowncastedImmutable``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.Enumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates">
            <summary>
            Provides pooled delegate instances to help avoid closure allocations for delegates that require a state argument
            with APIs that do not provide appropriate overloads with state arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``1(System.Action{``0},``0,System.Action@)">
             <summary>
             Gets an <see cref="T:System.Action"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback(() => this.DoSomething(x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction(arg => arg.self.DoSomething(arg.x), (self: this, x), out Action action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``2(System.Action{``0,``1},``1,System.Action{``0}@)">
             <summary>
             Gets an <see cref="T:System.Action`1"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback(a => this.DoSomething(a, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, arg) => arg.self.DoSomething(a, arg.x), (self: this, x), out Action&lt;int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``3(System.Action{``0,``1,``2},``2,System.Action{``0,``1}@)">
             <summary>
             Gets an <see cref="T:System.Action`2"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback((a, b) => this.DoSomething(a, b, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, b, arg) => arg.self.DoSomething(a, b, arg.x), (self: this, x), out Action&lt;int, int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``4(System.Action{``0,``1,``2,``3},``3,System.Action{``0,``1,``2}@)">
             <summary>
             Gets an <see cref="T:System.Action`3"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback((a, b, c) => this.DoSomething(a, b, c, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, b, c, arg) => arg.self.DoSomething(a, b, c, arg.x), (self: this, x), out Action&lt;int, int, int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound action.</typeparam>
             <typeparam name="T3">The type of the third parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``2(System.Func{``0,``1},``0,System.Func{``1}@)">
             <summary>
             Gets a <see cref="T:System.Func`1"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate(() => this.IsSomething(x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction(arg => arg.self.IsSomething(arg.x), (self: this, x), out Func&lt;bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``3(System.Func{``0,``1,``2},``1,System.Func{``0,``2}@)">
             <summary>
             Gets a <see cref="T:System.Func`2"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate(a => this.IsSomething(a, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, arg) => arg.self.IsSomething(a, arg.x), (self: this, x), out Func&lt;int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``4(System.Func{``0,``1,``2,``3},``2,System.Func{``0,``1,``3}@)">
             <summary>
             Gets a <see cref="T:System.Func`3"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate((a, b) => this.IsSomething(a, b, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, b, arg) => arg.self.IsSomething(a, b, arg.x), (self: this, x), out Func&lt;int, int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``5(System.Func{``0,``1,``2,``3,``4},``3,System.Func{``0,``1,``2,``4}@)">
             <summary>
             Gets a <see cref="T:System.Func`4"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate((a, b, c) => this.IsSomething(a, b, c, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, b, c, arg) => arg.self.IsSomething(a, b, c, arg.x), (self: this, x), out Func&lt;int, int, int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound function.</typeparam>
             <typeparam name="T3">The type of the third parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser">
             <summary>
             A releaser for a pooled delegate.
             </summary>
             <remarks>
             <para>This type is intended for use as the resource of a <c>using</c> statement. When used in this manner,
             <see cref="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> should not be called explicitly.</para>
            
             <para>If used without a <c>using</c> statement, calling <see cref="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> is optional. If the call is
             omitted, the object will not be returned to the pool. The behavior of this type if <see cref="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> is
             called multiple times is undefined.</para>
             </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder">
            <summary>
            The usage is:
                   var inst = PooledStringBuilder.GetInstance();
                   var sb = inst.builder;
                   ... Do Stuff...
                   ... sb.ToString() ...
                   inst.Free();
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.CreatePool(System.Int32)">
            <summary>
            If someone need to create a private pool
            </summary>
            <param name="size">The size of the pool.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.OutputKindNotSupported">
            <summary>Output kind not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PathReturnedByResolveMetadataFileMustBeAbsolute">
            <summary>Path returned by {0}.ResolveMetadataFile must be absolute: '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AssemblyMustHaveAtLeastOneModule">
            <summary>Assembly must have at least one module.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ModuleCopyCannotBeUsedToCreateAssemblyMetadata">
            <summary>Module copy can't be used to create an assembly metadata.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Unresolved">
            <summary>Unresolved:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Assembly">
            <summary>assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Class1">
            <summary>class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Constructor">
            <summary>constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Delegate1">
            <summary>delegate</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Enum1">
            <summary>enum</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Event1">
            <summary>event</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Field">
            <summary>field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TypeParameter">
            <summary>type parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Interface1">
            <summary>interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Method">
            <summary>method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Module">
            <summary>module</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Parameter">
            <summary>parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Property">
            <summary>property, indexer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Return1">
            <summary>return</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Struct1">
            <summary>struct</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CannotCreateReferenceToSubmission">
            <summary>Can't create a reference to a submission.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CannotCreateReferenceToModule">
            <summary>Can't create a reference to a module.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InMemoryAssembly">
            <summary>&lt;in-memory assembly&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InMemoryModule">
            <summary>&lt;in-memory module&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SizeHasToBePositive">
            <summary>Size has to be positive.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AssemblyFileNotFound">
            <summary>Assembly file not found</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CannotEmbedInteropTypesFromModule">
            <summary>Can't embed interop types from module.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CannotAliasModule">
            <summary>Can't alias a module.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidAlias">
            <summary>Invalid alias.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.GetMetadataMustReturnInstance">
            <summary>{0}.GetMetadata() must return an instance of {1}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer">
            <summary>Value too large to be represented as a 30 bit unsigned integer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Arrays_with_more_than_one_dimension_cannot_be_serialized">
            <summary>Arrays with more than one dimension cannot be serialized.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidAssemblyName">
            <summary>Invalid assembly name: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AbsolutePathExpected">
            <summary>Absolute path expected.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.EmptyKeyInPathMap">
            <summary>A key in the pathMap is empty.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NullValueInPathMap">
            <summary>A value in the pathMap is null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CompilationOptionsMustNotHaveErrors">
            <summary>Compilation options must not have errors.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ReturnTypeCannotBeValuePointerbyRefOrOpen">
            <summary>Return type can't be a value type, pointer, by-ref or open generic type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ReturnTypeCannotBeVoidByRefOrOpen">
            <summary>Return type can't be void, by-ref or open generic type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TypeMustBeSameAsHostObjectTypeOfPreviousSubmission">
            <summary>Type must be same as host object type of previous submission.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PreviousSubmissionHasErrors">
            <summary>Previous submission has errors.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidOutputKindForSubmission">
            <summary>Invalid output kind for submission. DynamicallyLinkedLibrary expected.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidCompilationOptions">
            <summary>Invalid compilation options -- submission can't be signed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ResourceStreamProviderShouldReturnNonNullStream">
            <summary>Resource stream provider should return non-null stream.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ReferenceResolverShouldReturnReadableNonNullStream">
            <summary>Reference resolver should return readable non-null stream.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.EmptyOrInvalidResourceName">
            <summary>Empty or invalid resource name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.EmptyOrInvalidFileName">
            <summary>Empty or invalid file name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ResourceDataProviderShouldReturnNonNullStream">
            <summary>Resource data provider should return non-null stream</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.FileNotFound">
            <summary>File not found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PathReturnedByResolveStrongNameKeyFileMustBeAbsolute">
            <summary>Path returned by {0}.ResolveStrongNameKeyFile must be absolute: '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TypeMustBeASubclassOfSyntaxAnnotation">
            <summary>type must be a subclass of SyntaxAnnotation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidModuleName">
            <summary>Invalid module name specified in metadata module '{0}': '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.FileSizeExceedsMaximumAllowed">
            <summary>File size exceeds maximum allowed size of a valid metadata file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NameCannotBeNull">
            <summary>Name cannot be null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NameCannotBeEmpty">
            <summary>Name cannot be empty.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NameCannotStartWithWhitespace">
            <summary>Name cannot start with whitespace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NameContainsInvalidCharacter">
            <summary>Name contains invalid characters.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SpanDoesNotIncludeStartOfLine">
            <summary>The span does not include the start of a line.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SpanDoesNotIncludeEndOfLine">
            <summary>The span does not include the end of a line.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.StartMustNotBeNegative">
            <summary>'start' must not be negative</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.EndMustNotBeLessThanStart">
            <summary>'end' must not be less than 'start'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidContentType">
            <summary>Invalid content type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ExpectedNonEmptyPublicKey">
            <summary>Expected non-empty public key</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidSizeOfPublicKeyToken">
            <summary>Invalid size of public key token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidCharactersInAssemblyName">
            <summary>Invalid characters in assembly name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidCharactersInAssemblyCultureName">
            <summary>Invalid characters in assembly culture name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.StreamMustSupportReadAndSeek">
            <summary>Stream must support read and seek operations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.StreamMustSupportRead">
            <summary>Stream must be readable.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.StreamMustSupportWrite">
            <summary>Stream must be writable.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PdbStreamUnexpectedWhenEmbedding">
            <summary>PDB stream should not be given when embedding PDB into the PE stream.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PdbStreamUnexpectedWhenEmittingMetadataOnly">
            <summary>PDB stream should not be given when emitting metadata only.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.MetadataPeStreamUnexpectedWhenEmittingMetadataOnly">
            <summary>Metadata PE stream should not be given when emitting metadata only.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.IncludingPrivateMembersUnexpectedWhenEmittingToMetadataPeStream">
            <summary>Including private members should not be used when emitting to the secondary assembly output.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.MustIncludePrivateMembersUnlessRefAssembly">
            <summary>Must include private members unless emitting a ref assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.EmbeddingPdbUnexpectedWhenEmittingMetadata">
            <summary>Embedding PDB is not allowed when emitting metadata.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CannotTargetNetModuleWhenEmittingRefAssembly">
            <summary>Cannot target net module when emitting ref assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidHash">
            <summary>Invalid hash.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.UnsupportedHashAlgorithm">
            <summary>Unsupported hash algorithm.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InconsistentLanguageVersions">
            <summary>Inconsistent language versions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CoffResourceInvalidRelocation">
            <summary>Win32 resources, assumed to be in COFF object format, have one or more invalid relocation header values.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CoffResourceInvalidSectionSize">
            <summary>Win32 resources, assumed to be in COFF object format, have an invalid section size.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CoffResourceInvalidSymbol">
            <summary>Win32 resources, assumed to be in COFF object format, have one or more invalid symbol values.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CoffResourceMissingSection">
            <summary>Win32 resources, assumed to be in COFF object format, are missing one or both of sections '.rsrc$01' and '.rsrc$02'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.IconStreamUnexpectedFormat">
            <summary>Icon stream is not in the expected format.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidCultureName">
            <summary>Invalid culture name: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.WinRTIdentityCantBeRetargetable">
            <summary>WindowsRuntime identity can't be retargetable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PEImageNotAvailable">
            <summary>PE image not available.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AssemblySigningNotSupported">
            <summary>Assembly signing not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.XmlReferencesNotSupported">
            <summary>References to XML documents are not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.FailedToResolveRuleSetName">
            <summary>Could not locate the rule set file '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidRuleSetInclude">
            <summary>An error occurred while loading the included rule set file {0} - {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CompilerAnalyzerFailure">
            <summary>Analyzer Failure</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CompilerAnalyzerThrows">
            <summary>Analyzer '{0}' threw an exception of type '{1}' with message '{2}'.
            {3}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CompilerAnalyzerThrowsDescription">
            <summary>Analyzer '{0}' threw the following exception:
            '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AnalyzerDriverFailure">
            <summary>Analyzer Driver Failure</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AnalyzerDriverThrows">
            <summary>Analyzer driver threw an exception of type '{0}' with message '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AnalyzerDriverThrowsDescription">
            <summary>Analyzer driver threw the following exception:
            '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.PEImageDoesntContainManagedMetadata">
            <summary>PE image doesn't contain managed metadata.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ChangesMustNotOverlap">
            <summary>The changes must not overlap.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.DiagnosticIdCantBeNullOrWhitespace">
            <summary>A DiagnosticDescriptor must have an Id that is neither null nor an empty string nor a string that only contains white space.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SuppressionIdCantBeNullOrWhitespace">
            <summary>A SuppressionDescriptor must have an Id that is neither null nor an empty string nor a string that only contains white space.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.RuleSetHasDuplicateRules">
            <summary>The rule set file has duplicate rules for '{0}' with differing actions '{1}' and '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CantCreateModuleReferenceToAssembly">
            <summary>Can't create a module reference to an assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CantCreateReferenceToDynamicAssembly">
            <summary>Can't create a metadata reference to a dynamic assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CantCreateReferenceToAssemblyWithoutLocation">
            <summary>Can't create a metadata reference to an assembly without location.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ArgumentCannotBeEmpty">
            <summary>Argument cannot be empty.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ArgumentElementCannotBeNull">
            <summary>Argument cannot have a null element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.UnsupportedDiagnosticReported">
            <summary>Reported diagnostic with ID '{0}' is not supported by the analyzer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.UnsupportedSuppressionReported">
            <summary>Reported suppression with ID '{0}' is not supported by the suppressor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidDiagnosticSuppressionReported">
            <summary>Suppressed diagnostic ID '{0}' does not match suppressable ID '{1}' for the given suppression descriptor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NonReportedDiagnosticCannotBeSuppressed">
            <summary>Non-reported diagnostic with ID '{0}' cannot be suppressed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidDiagnosticIdReported">
            <summary>Reported diagnostic has an ID '{0}', which is not a valid identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidDiagnosticLocationReported">
            <summary>Reported diagnostic '{0}' has a source location in file '{1}', which is not part of the compilation being analyzed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SupportedDiagnosticsHasNullDescriptor">
            <summary>Analyzer '{0}' contains a null descriptor in its 'SupportedDiagnostics'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SupportedSuppressionsHasNullDescriptor">
            <summary>Analyzer '{0}' contains a null descriptor in its 'SupportedSuppressions'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.The_type_0_is_not_understood_by_the_serialization_binder">
            <summary>The type '{0}' is not understood by the serialization binder.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Cannot_deserialize_type_0">
            <summary>Cannot deserialize type '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Cannot_serialize_type_0">
            <summary>Cannot serialize type '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidNodeToTrack">
            <summary>Node to track is not a descendant of the root.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NodeOrTokenOutOfSequence">
            <summary>A node or token is out of sequence.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.UnexpectedTypeOfNodeInList">
            <summary>A node in the list is not of the expected type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.MissingListItem">
            <summary>The item specified is not the element of a list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidPublicKey">
            <summary>Invalid public key.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidPublicKeyToken">
            <summary>Invalid public key token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidDataAtOffset">
            <summary>Invalid data at offset {0}: {1}{2}*{3}{4}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SymWriterNotDeterministic">
            <summary>Windows PDB writer doesn't support deterministic compilation: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SymWriterOlderVersionThanRequired">
            <summary>The version of Windows PDB writer is older than required: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SymWriterDoesNotSupportSourceLink">
            <summary>Windows PDB writer doesn't support SourceLink feature: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.RuleSetBadAttributeValue">
            <summary>The attribute {0} has an invalid value of {1}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.RuleSetMissingAttribute">
            <summary>The element {0} is missing an attribute named {1}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.KeepAliveIsNotAnInteger">
            <summary>Argument to '/keepalive' option is not a 32-bit integer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.KeepAliveIsTooSmall">
            <summary>Arguments to '/keepalive' option below -1 are invalid.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.KeepAliveWithoutShared">
            <summary>'/keepalive' option is only valid with '/shared' option.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.MismatchedVersion">
            <summary>Roslyn compiler server reports different protocol version than build task.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.MissingKeepAlive">
            <summary>Missing argument for '/keepalive' option.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AnalyzerTotalExecutionTime">
            <summary>Total analyzer execution time: {0} seconds.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.MultithreadedAnalyzerExecutionNote">
            <summary>NOTE: Elapsed time may be less than analyzer execution time because analyzers can run concurrently.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AnalyzerExecutionTimeColumnHeader">
            <summary>Time (s)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AnalyzerNameColumnHeader">
            <summary>Analyzer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NoAnalyzersFound">
            <summary>No analyzers found</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.DuplicateAnalyzerInstances">
            <summary>Argument contains duplicate analyzer instances.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.UnsupportedAnalyzerInstance">
            <summary>Argument contains an analyzer instance that does not belong to the 'Analyzers' for this CompilationWithAnalyzers instance.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidTree">
            <summary>Syntax tree doesn't belong to the underlying 'Compilation'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidAdditionalFile">
            <summary>Additional file doesn't belong to the underlying 'CompilationWithAnalyzers'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ResourceStreamEndedUnexpectedly">
            <summary>Resource stream ended at {0} bytes, expected {1} bytes.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SharedArgumentMissing">
            <summary>Value for argument '/shared:' must not be empty</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ExceptionContext">
            <summary>Exception occurred with following context:
            {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AnonymousTypeMemberAndNamesCountMismatch2">
            <summary>{0} and {1} must have the same length.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AnonymousTypeArgumentCountMismatch2">
            <summary>{0} must either be 'default' or have the same length as {1}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InconsistentSyntaxTreeFeature">
            <summary>Inconsistent syntax tree features</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ReferenceOfTypeIsInvalid1">
            <summary>Reference of type '{0}' is not valid for this compilation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.MetadataRefNotFoundToRemove1">
            <summary>MetadataReference '{0}' not found to remove.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TupleElementNameCountMismatch">
            <summary>If tuple element names are specified, the number of element names must match the cardinality of the tuple.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TupleElementNameEmpty">
            <summary>Tuple element name cannot be an empty string.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TupleElementLocationCountMismatch">
            <summary>If tuple element locations are specified, the number of locations must match the cardinality of the tuple.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TupleElementNullableAnnotationCountMismatch">
            <summary>If tuple element nullable annotations are specified, the number of annotations must match the cardinality of the tuple.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TuplesNeedAtLeastTwoElements">
            <summary>Tuples must have at least two elements.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.CompilationReferencesAssembliesWithDifferentAutoGeneratedVersion">
            <summary>The compilation references multiple assemblies whose versions only differ in auto-generated build and/or revision numbers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TupleUnderlyingTypeMustBeTupleCompatible">
            <summary>The underlying type for a tuple must be tuple-compatible.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.UnrecognizedResourceFileFormat">
            <summary>Unrecognized resource file format.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SourceTextCannotBeEmbedded">
            <summary>SourceText cannot be embedded. Provide encoding or canBeEmbedded=true at construction.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.StreamIsTooLong">
            <summary>Stream is too long.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.EmbeddedTextsRequirePdb">
            <summary>Embedded texts are only supported when emitting a PDB.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TheStreamCannotBeWrittenTo">
            <summary>The stream cannot be written to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ElementIsExpected">
            <summary>element is expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SeparatorIsExpected">
            <summary>separator is expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.TheStreamCannotBeReadFrom">
            <summary>The stream cannot be read from.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Deserialization_reader_for_0_read_incorrect_number_of_values">
            <summary>Deserialization reader for '{0}' read incorrect number of values.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Stream_contains_invalid_data">
            <summary>Stream contains invalid data</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidDiagnosticSpanReported">
            <summary>Reported diagnostic '{0}' has a source location '{1}' in file '{2}', which is outside of the given file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ExceptionEnablingMulticoreJit">
            <summary>Warning: Could not enable multicore JIT due to exception: {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.NotARootOperation">
            <summary>Given operation has a non-null parent.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.OperationHasNullSemanticModel">
            <summary>Given operation has a null semantic model.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.InvalidOperationBlockForAnalysisContext">
            <summary>Given operation block does not belong to the current analysis context.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.IsSymbolAccessibleBadWithin">
            <summary>Parameter '{0}' must be an 'INamedTypeSymbol' or an 'IAssemblySymbol'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.IsSymbolAccessibleWrongAssembly">
            <summary>Parameter '{0}' must be a symbol from this compilation or some referenced assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.OperationMustNotBeControlFlowGraphPart">
            <summary>The provided operation must not be part of a Control Flow Graph.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.A_language_name_cannot_be_specified_for_this_option">
            <summary>A language name cannot be specified for this option.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.A_language_name_must_be_specified_for_this_option">
            <summary>A language name must be specified for this option.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.WRN_InvalidSeverityInAnalyzerConfig">
            <summary>The diagnostic '{0}' was given an invalid severity '{1}' in the analyzer config file at '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.WRN_InvalidSeverityInAnalyzerConfig_Title">
            <summary>Invalid severity in analyzer config file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SuppressionDiagnosticDescriptorTitle">
            <summary>Programmatic suppression of an analyzer diagnostic</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SuppressionDiagnosticDescriptorMessage">
            <summary>Diagnostic '{0}: {1}' was programmatically suppressed by a DiagnosticSuppressor with suppression ID '{2}' and justification '{3}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ModuleHasInvalidAttributes">
            <summary>Module has invalid attributes.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure">
            <summary>Unable to determine specific cause of the failure.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ChangingVersionOfAssemblyReferenceIsNotAllowedDuringDebugging">
            <summary>Changing the version of an assembly reference is not allowed during debugging: '{0}' changed version to '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.DisableAnalyzerDiagnosticsMessage">
            <summary>Suppress the following diagnostics to disable this analyzer: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.Single_type_per_generator_0">
            <summary>Only a single {0} can be registered per generator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.WRN_MultipleGlobalAnalyzerKeys">
            <summary>Multiple global analyzer config files set the same key '{0}' in section '{1}'. It has been unset. Key was set by the following files: '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.WRN_MultipleGlobalAnalyzerKeys_Title">
            <summary>Multiple global analyzer config files set the same key. It has been unset.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.HintNameUniquePerGenerator">
            <summary>The hintName '{0}' of the added source file must be unique within a generator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.HintNameInvalidChar">
            <summary>The hintName '{0}' contains an invalid character '{1}' at position {2}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.SourceTextRequiresEncoding">
            <summary>The SourceText with hintName '{0}' must have an explicit encoding set.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.AssemblyReferencesNetFramework">
            <summary>The assembly containing type '{0}' references .NET Framework, which is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.WRN_InvalidGlobalSectionName">
            <summary>Global analyzer config section name '{0}' is invalid as it is not an absolute path. Section will be ignored. Section was declared in file: '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.WRN_InvalidGlobalSectionName_Title">
            <summary>Global analyzer config section name is invalid as it is not an absolute path. Section will be ignored.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.ChangesMustBeWithinBoundsOfSourceText">
            <summary>Changes must be within bounds of SourceText</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.EncCannotResumeSuspendedAsyncMethod">
            <summary>Edit and Continue can't resume suspended asynchronous method since the corresponding await expression has been deleted</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.EncCannotResumeSuspendedIteratorMethod">
            <summary>Edit and Continue can't resume suspended iterator since the corresponding yield return statement has been deleted</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.GeneratorNameColumnHeader">
            <summary>Generator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.GeneratorTotalExecutionTime">
            <summary>Total generator execution time: {0} seconds.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.BadBuiltInOps1">
            <summary>Illegal built-in operator name '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.BadBuiltInOps2">
            <summary>Unsupported built-in operator: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeAnalysisResources.BadBuiltInOps3">
            <summary>'{0}' was not a valid built-in operator name</summary>
        </member>
        <member name="M:Microsoft.DiaSymReader.IMetadataImport.ResolveTypeRef(System.Int32,System.Guid@,System.Object@,System.Int32@)">
            <summary>
            Resolves type reference.
            </summary>
            <param name="typeRef">The TypeRef metadata token to return the referenced type information for.</param>
            <param name="scopeInterfaceId">The IID of the interface to return in scope. Typically, this would be IID_IMetaDataImport.</param>
            <param name="scope">An interface to the module scope in which the referenced type is defined.</param>
            <param name="typeDef">A pointer to a TypeDef token that represents the referenced type.</param>
            <remarks>
            TypeDefs define a type within a scope. TypeRefs refer to type-defs in other scopes
            and allow you to import a type from another scope. This function attempts to determine
            which type-def a type-ref points to.
            
            This resolve (type-ref, this cope) --> (type-def=*ptd, other scope=*ppIScope)
            
            However, this resolution requires knowing what modules have been loaded, which is not decided
            until runtime via loader / fusion policy. Thus this interface can't possibly be correct since
            it doesn't have that knowledge. Furthermore, when inspecting metadata from another process
            (such as a debugger inspecting the debuggee's metadata), this API can be truly misleading.
            
            This API usage should be avoided.
            </remarks>
        </member>
        <member name="T:Microsoft.DiaSymReader.SymWriterMetadataAdapter">
            <summary>
            Minimal implementation of IMetadataImport that implements APIs used by SymReader and SymWriter.
            </summary>
        </member>
        <member name="T:Microsoft.DiaSymReader.ComMemoryStream">
            <summary>
            A COM IStream implementation over memory. Supports just enough for DiaSymReader's PDB writing.
            Also tuned for performance:
            1. SetSize (and Seek beyond the length) is very fast and doesn't re-allocate the underlying memory.
            2. Read and Write are optimized to avoid copying (see <see cref="T:Microsoft.DiaSymReader.IUnsafeComStream"/>)
            3. Allocates in chunks instead of a contiguous buffer to avoid re-alloc and copy costs when growing.
            </summary>
        </member>
        <member name="T:Microsoft.DiaSymReader.IUnsafeComStream">
            <summary>
            This is a re-definition of COM's IStream interface. The important change is that
            the Read and Write methods take an <see cref="T:System.IntPtr"/> instead of a byte[] to avoid the
            allocation cost when called from native code.
            </summary>
        </member>
        <member name="M:Microsoft.DiaSymReader.ISymUnmanagedCompilerInfoWriter.AddCompilerInfo(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.String)">
            <summary>
            Adds compiler version number and name.
            </summary>
        </member>
        <member name="T:Microsoft.DiaSymReader.ISymUnmanagedWriter5">
            <summary>
            The highest version of the interface available on Desktop FX 4.0+.
            </summary>
        </member>
        <member name="M:Microsoft.DiaSymReader.ISymUnmanagedWriter5.DefineConstant2(System.String,Microsoft.DiaSymReader.VariantStructure,System.Int32)">
            <remarks>
            <paramref name="value"/> has type <see cref="T:Microsoft.DiaSymReader.VariantStructure"/>, rather than <see cref="T:System.Object"/>,
            so that we can do custom marshalling of <see cref="T:System.DateTime"/>.  Unfortunately, .NET marshals
            <see cref="T:System.DateTime"/>s as the number of days since 1899/12/30, whereas the native VB compiler
             marshalled them as the number of ticks since the Unix epoch (i.e. a much, much larger number).
            </remarks>
        </member>
        <member name="M:Microsoft.DiaSymReader.ISymUnmanagedWriter5.OpenMapTokensToSourceSpans">
            <summary>
            Open a special custom data section to emit token to source span mapping information into. 
            Opening this section while a method is already open or vice versa is an error.
            </summary>
        </member>
        <member name="M:Microsoft.DiaSymReader.ISymUnmanagedWriter5.CloseMapTokensToSourceSpans">
            <summary>
            Close the special custom data section for token to source span mapping
            information. Once it is closed no more mapping information can be added.
            </summary>
        </member>
        <member name="M:Microsoft.DiaSymReader.ISymUnmanagedWriter5.MapTokenToSourceSpan(System.Int32,Microsoft.DiaSymReader.ISymUnmanagedDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Maps the given metadata token to the given source line span in the specified source file. 
            Must be called between calls to <see cref="M:Microsoft.DiaSymReader.ISymUnmanagedWriter5.OpenMapTokensToSourceSpans"/> and <see cref="M:Microsoft.DiaSymReader.ISymUnmanagedWriter5.CloseMapTokensToSourceSpans"/>.
            </summary>
        </member>
        <member name="T:Microsoft.DiaSymReader.ISymUnmanagedWriter8">
            <summary>
            The highest version of the interface available in Microsoft.DiaSymReader.Native.
            </summary>
        </member>
        <member name="T:Microsoft.DiaSymReader.VariantStructure">
            <summary>
            A struct with the same size and layout as the native VARIANT type:
              2 bytes for a discriminator (i.e. which type of variant it is).
              6 bytes of padding
              8 or 16 bytes of data
            </summary>
        </member>
        <member name="F:Microsoft.DiaSymReader.VariantStructure._padding">
            <summary>
            This field determines the size of the struct 
            (16 bytes on 32-bit platforms, 24 bytes on 64-bit platforms).
            </summary>
        </member>
        <member name="T:Microsoft.DiaSymReader.VariantPadding">
            <summary>
            This type is 8 bytes on a 32-bit platforms and 16 bytes on 64-bit platforms.
            </summary>
        </member>
        <member name="T:Microsoft.DiaSymReader.SymUnmanagedWriter">
            <summary>
            Windows PDB writer.
            </summary>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.Dispose">
            <summary>
            Disposes the writer.
            </summary>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.GetUnderlyingData">
            <summary>
            Gets the raw data blobs that comprise the written PDB content so far.
            </summary>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.WriteTo(System.IO.Stream)">
            <summary>
            Writes the PDB data to specified stream. Once called no more changes to the data can be made using this writer.
            May be called multiple times. Always writes the same data. 
            </summary>
            <param name="stream">Stream to write PDB data to.</param>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing data to the stream.</exception>
        </member>
        <member name="P:Microsoft.DiaSymReader.SymUnmanagedWriter.DocumentTableCapacity">
            <summary>
            The capacity of document table. 
            </summary>
            <remarks>
            Whenever a document is defined an entry is added to this table. 
            If the number of documents is known upfront setting this value may reduce memory consumption.
            </remarks>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.DefineDocument(System.String,System.Guid,System.Guid,System.Guid,System.Guid,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Defines a source document.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.DefineSequencePoints(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Defines sequence points.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.OpenMethod(System.Int32)">
            <summary>
            Opens a method.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.CloseMethod">
            <summary>
            Closes a method previously open using <see cref="M:Microsoft.DiaSymReader.SymUnmanagedWriter.OpenMethod(System.Int32)"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.OpenScope(System.Int32)">
            <summary>
            Opens a local scope.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.CloseScope(System.Int32)">
            <summary>
            Closes a local scope previously open using <see cref="M:Microsoft.DiaSymReader.SymUnmanagedWriter.OpenScope(System.Int32)"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.DefineLocalVariable(System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Defines a local variable.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.DefineLocalConstant(System.String,System.Object,System.Int32)">
            <summary>
            Defines a local constant.
            </summary>
            <param name="name">Name of the constant.</param>
            <param name="value">Value.</param>
            <param name="constantSignatureToken">Standalone signature token encoding the static type of the constant.</param>
            <returns>False if the constant representation is too long (e.g. long string).</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is null</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.UsingNamespace(System.String)">
            <summary>
            Adds namespace import.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="importString"/> is null</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.SetAsyncInfo(System.Int32,System.Int32,System.Int32,System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32})">
            <summary>
            Sets method async information.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="yieldOffsets"/> or <paramref name="resumeOffsets"/> is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="yieldOffsets"/> or <paramref name="resumeOffsets"/> differ in length.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.DefineCustomMetadata(System.Byte[])">
            <summary>
            Associates custom debug information blob with the current method.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadata"/> is null</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.SetEntryPoint(System.Int32)">
            <summary>
            Designates specified method as an entry point.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.UpdateSignature(System.Guid,System.UInt32,System.Int32)">
            <summary>
            Updates the current PDB signature.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.GetSignature(System.Guid@,System.UInt32@,System.Int32@)">
            <summary>
            Gets the current PDB signature.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.SetSourceServerData(System.Byte[])">
            <summary>
            Sets source server data blob (srcsvr stream).
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="data"/> is null</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.SetSourceLinkData(System.Byte[])">
            <summary>
            Sets source link data blob (sourcelink stream).
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="data"/> is null</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.OpenTokensToSourceSpansMap">
            <summary>
            Opens a map of tokens to source spans.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.MapTokenToSourceSpan(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Maps specified token to a source span.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="documentIndex"/> doesn't correspond to any defined document.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.CloseTokensToSourceSpansMap">
            <summary>
            Closes map of tokens to source spans previously opened using <see cref="M:Microsoft.DiaSymReader.SymUnmanagedWriter.OpenTokensToSourceSpansMap"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Writes are not allowed to the underlying stream.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriter.AddCompilerInfo(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.String)">
            <summary>
            Writes compiler version and name to the PDB.
            </summary>
            <param name="major">Major version</param>
            <param name="minor">Minor version</param>
            <param name="build">Build</param>
            <param name="revision">Revision</param>
            <param name="name">Compiler name</param>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error occurred while writing PDB data.</exception>
            <exception cref="T:System.NotSupportedException">The PDB writer does not support adding compiler info.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is null.</exception>
        </member>
        <member name="T:Microsoft.DiaSymReader.SymUnmanagedWriterCreationOptions">
            <summary>
            <see cref="T:Microsoft.DiaSymReader.SymUnmanagedWriter"/> creation options.
            </summary>
        </member>
        <member name="F:Microsoft.DiaSymReader.SymUnmanagedWriterCreationOptions.Default">
            <summary>
            Default options.
            </summary>
        </member>
        <member name="F:Microsoft.DiaSymReader.SymUnmanagedWriterCreationOptions.UseAlternativeLoadPath">
            <summary>
            Use environment variable MICROSOFT_DIASYMREADER_NATIVE_ALT_LOAD_PATH to locate Microsoft.DiaSymReader.Native.{platform}.dll.
            </summary>
        </member>
        <member name="F:Microsoft.DiaSymReader.SymUnmanagedWriterCreationOptions.UseComRegistry">
            <summary>
            Use COM registry to locate an implementation of the writer.
            </summary>
        </member>
        <member name="F:Microsoft.DiaSymReader.SymUnmanagedWriterCreationOptions.Deterministic">
            <summary>
            Create a deterministic PDB writer.
            </summary>
        </member>
        <member name="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">
            <summary>
            Exception reported when PDB write operation fails.
            </summary>
        </member>
        <member name="P:Microsoft.DiaSymReader.SymUnmanagedWriterException.ImplementationModuleName">
            <summary>
            The name of the module that implements the underlying PDB writer (e.g. diasymreader.dll), or null if not available.
            </summary>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriterFactory.CreateWriter(Microsoft.DiaSymReader.ISymWriterMetadataProvider,Microsoft.DiaSymReader.SymUnmanagedWriterCreationOptions)">
            <summary>
            Creates a Windows PDB writer.
            </summary>
            <param name="metadataProvider"><see cref="T:Microsoft.DiaSymReader.ISymWriterMetadataProvider"/> implementation.</param>
            <param name="options">Options.</param>
            <remarks>
            Tries to load the implementation of the PDB writer from Microsoft.DiaSymReader.Native.{platform}.dll library first.
            It searches for this library in the directory Microsoft.DiaSymReader.dll is loaded from, 
            the application directory, the %WinDir%\System32 directory, and user directories in the DLL search path, in this order.
            If not found in the above locations and <see cref="F:Microsoft.DiaSymReader.SymUnmanagedWriterCreationOptions.UseAlternativeLoadPath"/> option is specified
            the directory specified by MICROSOFT_DIASYMREADER_NATIVE_ALT_LOAD_PATH environment variable is also searched.
            If the Microsoft.DiaSymReader.Native.{platform}.dll library can't be found and <see cref="F:Microsoft.DiaSymReader.SymUnmanagedWriterCreationOptions.UseComRegistry"/> 
            option is specified checks if the PDB reader is available from a globally registered COM object. This COM object is provided 
            by .NET Framework and has limited functionality (features like determinism and source link are not supported).
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadataProvider"/>is null.</exception>
            <exception cref="T:System.DllNotFoundException">The SymWriter implementation is not available or failed to load.</exception>
            <exception cref="T:Microsoft.DiaSymReader.SymUnmanagedWriterException">Error creating the PDB writer. See inner exception for root cause.</exception>
        </member>
        <member name="M:Microsoft.DiaSymReader.SymUnmanagedWriterImpl.WriteTo(System.IO.Stream)">
            <summary>
            Writes the content to the given stream. The writer is disposed and can't be used for further writing.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ModulePropertiesForSerialization">
            <summary>
            This class is used to store the module serialization properties for a compilation.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModulePropertiesForSerialization.FileAlignment">
            <summary>
            The alignment factor (in bytes) that is used to align the raw data of sections in the image file.
             The value should be a power of 2 between 512 and 64K, inclusive. The default is 512.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModulePropertiesForSerialization.SectionAlignment">
            <summary>
            The alignment (in bytes) of sections when they are loaded into memory. 
            It must be greater than or equal to <see cref="F:Microsoft.Cci.ModulePropertiesForSerialization.FileAlignment"/>. 
            The default is the page size for the architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModulePropertiesForSerialization.TargetRuntimeVersion">
            <summary>
            Identifies the version of the CLR that is required to load this module or assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModulePropertiesForSerialization.Machine">
            <summary>
            Specifies the target CPU. <see cref="F:System.Reflection.PortableExecutable.Machine.Unknown"/> means AnyCPU.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModulePropertiesForSerialization.PersistentIdentifier">
            <summary>
            A globally unique persistent identifier for this module.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModulePropertiesForSerialization.BaseAddress">
            <summary>
            The preferred memory address at which the module is to be loaded at runtime.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModulePropertiesForSerialization.SizeOfHeapReserve">
            <summary>
            The size of the virtual memory to reserve for the initial process heap.
            Must fit into 32 bits if the target platform is 32 bit.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModulePropertiesForSerialization.SizeOfHeapCommit">
            <summary>
            The size of the virtual memory initially committed for the initial process heap.
            Must fit into 32 bits if the target platform is 32 bit.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModulePropertiesForSerialization.SizeOfStackReserve">
            <summary>
            The size of the virtual memory to reserve for the initial thread's stack.
            Must fit into 32 bits if the target platform is 32 bit.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModulePropertiesForSerialization.LinkerMajorVersion">
            <summary>
            The first part of a two part version number indicating the version of the linker that produced this module. For example, the 8 in 8.0.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModulePropertiesForSerialization.LinkerMinorVersion">
            <summary>
            The first part of a two part version number indicating the version of the linker that produced this module. For example, the 0 in 8.0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ModulePropertiesForSerialization.DllCharacteristics">
            <summary>
            Flags that control the behavior of the target operating system. CLI implementations are supposed to ignore this, but some operating system pay attention.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PdbWriter.WriteRemainingDebugDocuments(System.Collections.Generic.IReadOnlyDictionary{System.String,Microsoft.Cci.DebugSourceDocument})">
            <summary>
            Write document entries for all debug documents that do not yet have an entry.
            </summary>
            <remarks>
            This is done after serializing method debug info to ensure that we embed all requested
            text even if there are no corresponding sequence points.
            </remarks>
        </member>
        <member name="T:Microsoft.Cci.AssemblyReferenceAlias">
            <summary>
            Represents an assembly reference with an alias (C# only, /r:Name=Reference on command line).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.AssemblyReferenceAlias.Name">
            <summary>
            An alias for the global namespace of the assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.AssemblyReferenceAlias.Assembly">
            <summary>
            The assembly reference.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.CompilationOptionNames">
            <summary>
            Names for compilation options that get embedded as debug information
            in the PDB as key-value pairs.
            </summary>
            <remarks>
            REMOVAL OR CHANGES TO EXISTING VALUES IS CONSIDERED A BREAKING CHANGE FOR PDB FORMAT
            </remarks>
        </member>
        <member name="T:Microsoft.Cci.VarEnum">
            <summary>
            System.Runtime.InteropServices.VarEnum is obsolete.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IDefinition">
            <summary>
            An object corresponding to a metadata entity such as a type or a field.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IReference">
            <summary>
            An object corresponding to reference to a metadata entity such as a type or a field.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IReference.GetAttributes(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IReference.Dispatch(Microsoft.Cci.MetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IDefinition. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IReference.AsDefinition(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Gets the definition object corresponding to this reference within the given context, 
            or null if the referenced entity isn't defined in the context.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IReference.GetInternalSymbol">
            <summary>
            Returns underlying internal symbol object, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.CustomDebugInfoWriter.ShouldForwardNamespaceScopes(Microsoft.CodeAnalysis.Emit.EmitContext,Microsoft.Cci.IMethodBody,System.Reflection.Metadata.MethodDefinitionHandle,Microsoft.Cci.IMethodDefinition@)">
            <summary>
            Returns true if the namespace scope for this method should be forwarded to another method.
            Returns non-null <paramref name="forwardToMethod"/> if the forwarding should be done directly via UsingNamespace,
            null if the forwarding is done via custom debug info.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.DebugSourceDocument.#ctor(System.String,System.Guid,System.Func{Microsoft.Cci.DebugSourceInfo})">
            <summary>
            Use to create a document when checksum is computed based on actual source stream.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.DebugSourceDocument.#ctor(System.String,System.Guid,System.Collections.Immutable.ImmutableArray{System.Byte},System.Guid)">
            <summary>
            Use to create a document when checksum is suggested via external checksum pragma/directive
            </summary>
        </member>
        <member name="P:Microsoft.Cci.DebugSourceDocument.IsComputedChecksum">
            <summary>
            returns true when checksum was computed base on an actual source stream
            as opposed to be suggested via a checksum directive/pragma
            </summary>
        </member>
        <member name="T:Microsoft.Cci.DebugSourceInfo">
            <summary>
            Represents the portion of a <see cref="T:Microsoft.Cci.DebugSourceDocument"/> that are derived
            from the source document content, and which can be computed asynchronously.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.DebugSourceInfo.ChecksumAlgorithmId">
            <summary>
            The ID of the hash algorithm used.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.DebugSourceInfo.Checksum">
            <summary>
            The hash of the document content.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.DebugSourceInfo.EmbeddedTextBlob">
            <summary>
            The source text to embed in the PDB. (If any, otherwise default.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ExceptionHandlerRegion">
            <summary>
            A region representing an exception handler clause. The region exposes the type (catch or
            finally) and the bounds of the try block and catch or finally block as needed by 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.TryStartOffset">
            <summary>
            Label instruction corresponding to the start of try block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.TryEndOffset">
            <summary>
            Label instruction corresponding to the end of try block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.HandlerStartOffset">
            <summary>
            Label instruction corresponding to the start of handler block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.HandlerEndOffset">
            <summary>
            Label instruction corresponding to the end of handler block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.HandlerKind">
            <summary>
            Handler kind for this SEH info
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.ExceptionType">
            <summary>
            If HandlerKind == HandlerKind.Catch, this is the type of exception to catch. If HandlerKind == HandlerKind.Filter, this is System.Object.
            Otherwise this is a Dummy.TypeReference.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ExceptionHandlerRegion.FilterDecisionStartOffset">
            <summary>
            Label instruction corresponding to the start of filter decision block
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ExportedType">
            <summary>
            Info needed when emitting ExportedType table entry.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ExportedType.Type">
            <summary>
            The target type reference. 
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ExportedType.IsForwarder">
            <summary>
            True if this <see cref="T:Microsoft.Cci.ExportedType"/> represents a type forwarder definition,
            false if it represents a type from a linked netmodule.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ExportedType.ParentIndex">
            <summary>
            If <see cref="F:Microsoft.Cci.ExportedType.Type"/> is a nested type defined in a linked netmodule, 
            the index of the <see cref="T:Microsoft.Cci.ExportedType"/> entry that represents the enclosing type.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataExpression">
            <summary>
            An expression that can be represented directly in metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataExpression.Dispatch(Microsoft.Cci.MetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IStatement. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataExpression.Type">
            <summary>
            The type of value the expression represents.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataNamedArgument">
            <summary>
            An expression that represents a (name, value) pair and that is typically used in method calls, custom attributes and object initializers.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataNamedArgument.ArgumentName">
            <summary>
            The name of the parameter or property or field that corresponds to the argument.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataNamedArgument.ArgumentValue">
            <summary>
            The value of the argument.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataNamedArgument.IsField">
            <summary>
            True if the named argument provides the value of a field.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ExtendedPEBuilder">
            <summary>
            This PEBuilder adds an .mvid section.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ICustomAttribute">
            <summary>
            A metadata custom attribute.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.GetArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more positional arguments for the attribute constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.Constructor(Microsoft.CodeAnalysis.Emit.EmitContext,System.Boolean)">
            <summary>
            A reference to the constructor that will be used to instantiate this custom attribute during execution (if the attribute is inspected via Reflection).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.GetNamedArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more named arguments that specify values for fields and properties of the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomAttribute.ArgumentCount">
            <summary>
            The number of positional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomAttribute.NamedArgumentCount">
            <summary>
            The number of named arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of the attribute. For example System.AttributeUsageAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomAttribute.AllowMultiple">
            <summary>
            Whether attribute allows multiple.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IFileReference">
            <summary>
            Represents a file referenced by an assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFileReference.HasMetadata">
            <summary>
            True if the file has metadata.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFileReference.FileName">
            <summary>
            File name with extension.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IFileReference.GetHashValue(System.Reflection.AssemblyHashAlgorithm)">
            <summary>
            A hash of the file contents.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IImportScope">
            <summary>
            Represents a lexical scope that declares imports.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IImportScope.GetUsedNamespaces">
            <summary>
            Zero or more used namespaces. These correspond to using directives in C# or Imports syntax in VB.
            Multiple invocations return the same array instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IImportScope.Parent">
            <summary>
            Parent import scope, or null.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.LocalScope">
            <summary>
            A range of CLR IL operations that comprise a lexical scope.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.LocalScope.StartOffset">
            <summary>
            The offset of the first operation in the scope.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.LocalScope.EndOffset">
            <summary>
            The offset of the first operation outside of the scope, or the method body length.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.LocalScope.Constants">
            <summary>
            Returns zero or more local constant definitions that are local to the given scope.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.LocalScope.Variables">
            <summary>
            Returns zero or more local variable definitions that are local to the given scope.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ManagedResource.#ctor(System.String,System.Boolean,System.Func{System.IO.Stream},Microsoft.Cci.IFileReference,System.UInt32)">
            <summary>
            <paramref name="streamProvider"/> streamProvider callers will dispose result after use.
            <paramref name="streamProvider"/> and <paramref name="fileReference"/> are mutually exclusive.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.CallingConvention">
            <summary>
            Specifies how the caller passes parameters to the callee and who cleans up the stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.CDecl">
            <summary>
            C/C++ style calling convention for unmanaged methods. The call stack is cleaned up by the caller, 
            which makes this convention suitable for calling methods that accept extra arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.Default">
            <summary>
            The convention for calling managed methods with a fixed number of arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.ExtraArguments">
            <summary>
            The convention for calling managed methods that accept extra arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.FastCall">
            <summary>
            Arguments are passed in registers when possible. This calling convention is not yet supported.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.Standard">
            <summary>
            Win32 API calling convention for calling unmanaged methods via PlatformInvoke. The call stack is cleaned up by the callee.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.ThisCall">
            <summary>
            C++ member unmanaged method (non-vararg) calling convention. The callee cleans the stack and the this pointer is pushed on the stack last.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.Unmanaged">
            <summary>
            Extensible calling convention protocol. This represents either the union of calling convention modopts after the paramcount specifier
            in IL, or platform default if none are present
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.Generic">
            <summary>
            The convention for calling a generic method.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.HasThis">
            <summary>
            The convention for calling an instance method with an implicit this parameter (the method does not have an explicit parameter definition for this).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.ExplicitThis">
            <summary>
            The convention for calling an instance method that explicitly declares its first parameter to correspond to the this instance.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.CallingConventionUtils.IsCallingConvention(Microsoft.Cci.CallingConvention,Microsoft.Cci.CallingConvention)">
            <summary>
            Compares calling conventions, ignoring calling convention attributes.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IEventDefinition">
            <summary>
            An event is a member that enables an object or class to provide notifications. Clients can attach executable code for events by supplying event handlers.
            This interface models the metadata representation of an event.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IEventDefinition.GetAccessors(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A list of methods that are associated with the event.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.Adder">
            <summary>
            The method used to add a handler to the event.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.Caller">
            <summary>
            The method used to call the event handlers when the event occurs. May be null.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.IsRuntimeSpecial">
            <summary>
            True if the event gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.IsSpecialName">
            <summary>
            This event is special in some way, as specified by the name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.Remover">
            <summary>
            The method used to add a handler to the event.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IEventDefinition.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The (delegate) type of the handlers that will handle the event.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IFieldDefinition">
            <summary>
            A field is a member that represents a variable associated with an object or class.
            This interface models the metadata representation of a field.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IFieldDefinition.GetCompileTimeValue(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The compile time value of the field. This value should be used directly in IL, rather than a reference to the field.
            If the field does not have a valid compile time value, Dummy.Constant is returned.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.MappedData">
            <summary>
            Mapped field data, or null if the field is not mapped.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsCompileTimeConstant">
            <summary>
            This field is a compile-time constant. The field has no runtime location and cannot be directly addressed from IL.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsMarshalledExplicitly">
            <summary>
            This field has associated field marshalling information.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsNotSerialized">
            <summary>
            The field does not have to be serialized when its containing instance is serialized.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsReadOnly">
            <summary>
            This field can only be read. Initialization takes place in a constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsRuntimeSpecial">
            <summary>
            True if the field gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsSpecialName">
            <summary>
            This field is special in some way, as specified by the name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsStatic">
            <summary>
            This field is static (shared by all instances of its declaring type).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.MarshallingInformation">
            <summary>
            Specifies how this field is marshalled when it is accessed from unmanaged code.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.MarshallingDescriptor">
            <summary>
            Checked if IsMarshalledExplicitly == true and MarshallingInformation is null
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.Offset">
            <summary>
            Offset of the field.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IFieldReference">
            <summary>
            A reference to a field.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IFieldReference.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of value that is stored in this field.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldReference.RefCustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the ref modifier. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldReference.IsByReference">
            <summary>
            True if the field contains a managed pointer.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IFieldReference.GetResolvedField(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The Field being referred to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldReference.IsContextualNamedEntity">
            <summary>
            True, if field is an IContextualNamedEntity, even if field reference implements the interface,
            doesn't mean it is contextual.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ILocalDefinition">
            <summary>
            An object that represents a local variable or constant.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.CompileTimeValue">
            <summary>
            The compile time value of the definition, if it is a local constant.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.CustomModifiers">
            <summary>
            Custom modifiers associated with local variable definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.IsPinned">
            <summary>
            TODO: use <see cref="P:Microsoft.Cci.ILocalDefinition.Constraints"/> instead.
            True if the value referenced by the local must not be moved by the actions of the garbage collector.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.IsReference">
            <summary>
            TODO: use <see cref="P:Microsoft.Cci.ILocalDefinition.Constraints"/> instead.
            True if the local contains a managed pointer (for example a reference to a local variable or a reference to a field of an object).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.PdbAttributes">
            <summary>
            Each local has an attributes field in the PDB.  To match the native compiler,
            we emit <see cref="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden"/> for locals that should 
            definitely not bind in the debugger and <see cref="F:System.Reflection.Metadata.LocalVariableAttributes.None"/>
            for all other locals.
            </summary>
            <remarks>
            A value of <see cref="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden"/> is a sufficient, but not a necessary, condition for hiding the
            local in the debugger.  Locals with value <see cref="F:System.Reflection.Metadata.LocalVariableAttributes.None"/> may also be hidden.
            
            Hidden locals must still be emitted because they participate in evaluation.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.DynamicTransformFlags">
            <summary>
            The synthesized dynamic attributes of the local definition if any, or empty.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.TupleElementNames">
            <summary>
            The tuple element names of the local definition if any, or empty.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.Type">
            <summary>
            The type of the local.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.Location">
            <summary>
            Location for reporting diagnostics about the local.
            </summary>
            <remark>
            Use <see cref="P:Microsoft.CodeAnalysis.Location.None"/> rather than null.
            </remark>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.SlotIndex">
            <summary>
            Slot index or -1 if not applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.Signature">
            <summary>
            Optional serialized local signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.SlotInfo">
            <summary>
            Local id, or <see cref="F:Microsoft.CodeAnalysis.CodeGen.LocalDebugId.None"/> if this is a local constant, short-lived temp variable, 
            or we are not emitting local variable ids (release builds).
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMethodBody">
            <summary>
            A metadata (IL) level representation of the body of a method or of a property/event accessor.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.ExceptionRegions">
            <summary>
            A list exception data within the method body IL.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.AreLocalsZeroed">
            <summary>
            True if the locals are initialized by zeroing the stack upon method entry.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.HasStackalloc">
            <summary>
            True if there's a stackalloc somewhere in the method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.LocalVariables">
            <summary>
            The local variables of the method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.MethodDefinition">
            <summary>
            The definition of the method whose body this is.
            If this is the body of an event or property accessor, this will hold the corresponding adder/remover/setter or getter method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.MoveNextBodyInfo">
            <summary>
            Debugging information associated with a MoveNext method of a state machine.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.MaxStack">
            <summary>
            The maximum number of elements on the evaluation stack during the execution of the method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.HasDynamicLocalVariables">
            <summary>
            Returns true if there is at least one dynamic local within the MethodBody
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.LocalScopes">
            <summary>
            Returns zero or more local (block) scopes into which the CLR IL operations in the given method body is organized.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.ImportScope">
            <summary>
            Returns an import scope the method is declared within, or null if there is none 
            (e.g. the method doesn't contain user code).
            </summary>
            <remarks>
            The chain is a spine of a tree in a forest of import scopes. A tree of import scopes is created by the language for each source file
            based on namespace declarations. In VB each tree is trivial single-node tree that declares the imports of a file.
            In C# the tree copies the nesting of namespace declarations in the file. There is a separate scope for each dotted component in 
            the namespace type name. For instance namespace type x.y.z will have two namespace scopes, the first is for the x and the second
            is for the y.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.StateMachineHoistedLocalScopes">
            <summary>
            Returns debug information for local variables hoisted to state machine fields, 
            or null if this method isn't MoveNext method of a state machine.
            </summary>
            <remarks>
            Returns zero or more local (block) scopes, each defining an IL range in which an iterator local is defined.
            The scopes are returned for the MoveNext method of the object returned by the iterator method.
            The index of the scope corresponds to the index of the local.  Specifically local scope i corresponds
            to the local stored in a field named &lt;localName&gt;5__i of the class used to store the local values in
            between calls to MoveNext, where localName is the original name of the local variable.  For example, if
            the first local to be moved into the class is named "xyzzy", it will be stored in a field named
            "&lt;xyzzy&gt;5__1", and the ILocalScope returned from this method at index 1 (i.e. the second one) will
            have the scope information for where that variable is in scope.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.StateMachineTypeName">
            <summary>
            The name of the state machine generated for the method, 
            or null if the method isn't the kickoff method of a state machine.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.StateMachineHoistedLocalSlots">
            <summary>
            Returns information relevant to EnC on slots of local variables hoisted to state machine fields, 
            or null if the method isn't the kickoff method of a state machine.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.StateMachineAwaiterSlots">
            <summary>
            Returns types of awaiter slots allocated on the state machine,
            or null if the method isn't the kickoff method of a state machine.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMethodDefinition">
            <summary>
            This interface models the metadata representation of a method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodDefinition.GetBody(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A container for a list of IL instructions providing the implementation (if any) of this method.
            </summary>
            <remarks>
            When emitting metadata-only assemblies this returns null even if <see cref="M:Microsoft.Cci.Extensions.HasBody(Microsoft.Cci.IMethodDefinition)"/> returns true.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.GenericParameters">
            <summary>
            If the method is generic then this list contains the type parameters.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.HasDeclarativeSecurity">
            <summary>
            True if this method has a non empty collection of SecurityAttributes or the System.Security.SuppressUnmanagedCodeSecurityAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsAbstract">
            <summary>
            True if the method does not provide an implementation.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsAccessCheckedOnOverride">
            <summary>
            True if the method can only be overridden when it is also accessible. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsConstructor">
            <summary>
            True if the method is a constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsExternal">
            <summary>
            True if the method has an external implementation (i.e. not supplied by this definition).
            </summary>
            <remarks>
            If the method is not external and not abstract it has to provide an IL body.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsHiddenBySignature">
            <summary>
            True if this method is hidden if a derived type declares a method with the same name and signature. 
            If false, any method with the same name hides this method. This flag is ignored by the runtime and is only used by compilers.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsNewSlot">
            <summary>
            The method always gets a new slot in the virtual method table. 
            This means the method will hide (not override) a base type method with the same name and signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsPlatformInvoke">
            <summary>
            True if the method is implemented via the invocation of an underlying platform method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsRuntimeSpecial">
            <summary>
            True if the method gets special treatment from the runtime. For example, it might be a constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsSealed">
            <summary>
            True if the method may not be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsSpecialName">
            <summary>
            True if the method is special in some way for tools. For example, it might be a property getter or setter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsStatic">
            <summary>
            True if the method does not require an instance of its declaring type as its first argument.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsVirtual">
            <summary>
            True if the method may be overridden (or if it is an override).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodDefinition.GetImplementationAttributes(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Implementation flags.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.Parameters">
            <summary>
            The parameters forming part of this signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.PlatformInvokeData">
            <summary>
            Detailed information about the PInvoke stub. Identifies which method to call, which module has the method and the calling convention among other things.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.RequiresSecurityObject">
            <summary>
            True if the method calls another method containing security code. If this flag is set, the method
            should have System.Security.DynamicSecurityMethodAttribute present in its list of custom attributes.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodDefinition.GetReturnValueAttributes(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Custom attributes associated with the method's return value.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ReturnValueIsMarshalledExplicitly">
            <summary>
            The return value has associated marshalling information.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ReturnValueMarshallingInformation">
            <summary>
            Specifies how the return value is marshalled when the method is called from unmanaged code.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ReturnValueMarshallingDescriptor">
            <summary>
            Checked if ReturnValueIsMarshalledExplicitly == true and ReturnValueMarshallingInformation is null
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.SecurityAttributes">
            <summary>
            Declarative security actions for this method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ContainingNamespace">
            <summary>
            Namespace containing this method.
            TODO: Ideally we would expose INamespace on INamespaceTypeDefinition. Right now we can only get the qualified namespace name.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IParameterDefinition">
            <summary>
            This interface models the metadata representation of a method or property parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IParameterDefinition.GetDefaultValue(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A compile time constant value that should be supplied as the corresponding argument value by callers that do not explicitly specify an argument value for this parameter.
            Null if the parameter doesn't have default value.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.HasDefaultValue">
            <summary>
            True if the parameter has a default value that should be supplied as the argument value by a caller for which the argument value has not been explicitly specified.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsIn">
            <summary>
            True if the argument value must be included in the marshalled arguments passed to a remote callee.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsMarshalledExplicitly">
            <summary>
            This parameter has associated marshalling information.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsOptional">
            <summary>
            True if the argument value must be included in the marshalled arguments passed to a remote callee only if it is different from the default value (if there is one).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsOut">
            <summary>
            True if the final value assigned to the parameter will be marshalled with the return values passed back from a remote callee.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.MarshallingInformation">
            <summary>
            Specifies how this parameter is marshalled when it is accessed from unmanaged code.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.MarshallingDescriptor">
            <summary>
            Checked if IsMarshalledExplicitly == true and MarshallingInformation is null
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IPropertyDefinition">
            <summary>
            A property is a member that provides access to an attribute of an object or a class.
            This interface models the metadata representation of a property.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IPropertyDefinition.GetAccessors(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A list of methods that are associated with the property.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.DefaultValue">
            <summary>
            A compile time constant value that provides the default value for the property. (Who uses this and why?)
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.Getter">
            <summary>
            The method used to get the value of this property. May be absent (null).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.HasDefaultValue">
            <summary>
            True if this property has a compile time constant associated with that serves as a default value for the property. (Who uses this and why?)
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.IsRuntimeSpecial">
            <summary>
            True if this property gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.IsSpecialName">
            <summary>
            True if this property is special in some way, as specified by the name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.Parameters">
            <summary>
            The parameters forming part of this signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.Setter">
            <summary>
            The method used to set the value of this property. May be absent (null).
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISignature">
            <summary>
            The parameters and return type that makes up a method or property signature.
            This interface models the metadata representation of a signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.CallingConvention">
            <summary>
            Calling convention of the signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.ParameterCount">
            <summary>
            The number of required parameters of the signature.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISignature.GetParameters(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The parameters forming part of this signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.ReturnValueCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the return type. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.RefCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the ref modifier. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.ReturnValueIsByRef">
            <summary>
            True if the return value is passed by reference (using a managed pointer).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISignature.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The return type of the method or type of the property.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeDefinitionMember">
            <summary>
            A member of a type definition, such as a field or a method.
            This interface models the metadata representation of a type member.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinitionMember.ContainingTypeDefinition">
            <summary>
            The type definition that contains this member.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinitionMember.Visibility">
            <summary>
            Indicates if the member is public or confined to its containing type, derived types and/or declaring assembly.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeMemberReference">
            <summary>
            A reference to a member of a type, such as a field or a method.
            This interface models the metadata representation of a type member reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeMemberReference.GetContainingType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A reference to the containing type of the referenced type member.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedEventDefinition">
            <summary>
            Represents the specialized event definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedEventDefinition.UnspecializedVersion">
            <summary>
            The event that has been specialized to obtain this event. When the containing type is an instance of type which is itself a specialized member (i.e. it is a nested
            type of a generic type instance), then the unspecialized member refers to a member from the unspecialized containing type. (I.e. the unspecialized member always
            corresponds to a definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedFieldReference">
            <summary>
            Represents reference specialized field.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedFieldReference.UnspecializedVersion">
            <summary>
            A reference to the field definition that has been specialized to obtain the field definition referred to by this field reference. 
            When the containing type of the referenced specialized field definition is itself a specialized nested type of a generic type instance, 
            then the unspecialized field reference refers to the corresponding field definition from the unspecialized containing type definition.
            (I.e. the unspecialized field reference always refers to a field definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedMethodReference">
            <summary>
            Represents reference specialized method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedMethodReference.UnspecializedVersion">
            <summary>
            A reference to the method definition that has been specialized to obtain the method definition referred to by this method reference. 
            When the containing type of the referenced specialized method definition is itself a specialized nested type of a generic type instance, 
            then the unspecialized method reference refers to the corresponding method definition from the unspecialized containing type definition.
            (I.e. the unspecialized method reference always refers to a method definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedPropertyDefinition">
            <summary>
            Represents the specialized property definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedPropertyDefinition.UnspecializedVersion">
            <summary>
            The property that has been specialized to obtain this property. When the containing type is an instance of type which is itself a specialized member (i.e. it is a nested
            type of a generic type instance), then the unspecialized member refers to a member from the unspecialized containing type. (I.e. the unspecialized member always
            corresponds to a definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMethodReference">
            <summary>
            A reference to a method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.AcceptsExtraArguments">
            <summary>
            True if the call sites that references the method with this object supply extra arguments.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.GenericParameterCount">
            <summary>
            The number of generic parameters of the method. Zero if the referenced method is not generic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.IsGeneric">
            <summary>
            True if the method has generic parameters;
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodReference.GetResolvedMethod(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The method being referred to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.ExtraParameters">
            <summary>
            Information about this types of the extra arguments supplied at the call sites that references the method with this object.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericMethodInstanceReference">
            <summary>
            A reference to generic method instantiated with a list of type arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericMethodInstanceReference.GetGenericArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type arguments that were used to instantiate this.GenericMethod in order to create this method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericMethodInstanceReference.GetGenericMethod(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Returns the generic method of which this method is an instance.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGlobalFieldDefinition">
            <summary>
            Represents a global field in symbol table.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGlobalMethodDefinition">
            <summary>
            Represents a global method in symbol table.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGlobalMethodDefinition.Name">
            <summary>
            The name of the method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Extensions.ShouldInclude(Microsoft.Cci.ITypeDefinitionMember,Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            When emitting ref assemblies, some members will not be included.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.MetadataVisitor">
            <summary>
            A visitor base class that traverses the object model in depth first, left to right order.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataVisitor.DispatchAsReference(Microsoft.Cci.ITypeReference)">
            <summary>
            Use this routine, rather than ITypeReference.Dispatch, to call the appropriate derived overload of an ITypeReference.
            The former routine will call Visit(INamespaceTypeDefinition) rather than Visit(INamespaceTypeReference), etc., 
            in the case where a definition is used as a reference to itself.
            </summary>
            <param name="typeReference">A reference to a type definition. Note that a type definition can serve as a reference to itself.</param>
        </member>
        <member name="M:Microsoft.Cci.MetadataVisitor.DispatchAsReference(Microsoft.Cci.IUnitReference)">
            <summary>
            Use this routine, rather than IUnitReference.Dispatch, to call the appropriate derived overload of an IUnitReference.
            The former routine will call Visit(IAssembly) rather than Visit(IAssemblyReference), etc.
            in the case where a definition is used as the reference to itself.
            </summary>
            <param name="unitReference">A reference to a unit. Note that a unit can serve as a reference to itself.</param>
        </member>
        <member name="F:Microsoft.Cci.MetadataWriter.NameLengthLimit">
            <summary>
            This is the maximum length of a type or member name in metadata, assuming
            the name is in UTF-8 format and not (yet) null-terminated.
            </summary>
            <remarks>
            Source names may have to be shorter still to accommodate mangling.
            Used for event names, field names, property names, field names, method def names,
            member ref names, type def (full) names, type ref (full) names, exported type
            (full) names, parameter names, manifest resource names, and unmanaged method names
            (ImplMap table).
            
            See CLI Part II, section 22.
            </remarks>
        </member>
        <member name="F:Microsoft.Cci.MetadataWriter.PathLengthLimit">
            <summary>
            This is the maximum length of a path in metadata, assuming the path is in UTF-8
            format and not (yet) null-terminated.
            </summary>
            <remarks>
            Used for file names, module names, and module ref names.
            
            See CLI Part II, section 22.
            </remarks>
        </member>
        <member name="F:Microsoft.Cci.MetadataWriter.PdbLengthLimit">
            <summary>
            This is the maximum length of a string in the PDB, assuming it is in UTF-8 format 
            and not (yet) null-terminated.
            </summary>
            <remarks>
            Used for import strings, locals, and local constants.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.MetadataWriter.IsFullMetadata">
            <summary>
            Returns true if writing full metadata, false if writing delta.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataWriter.IsMinimalDelta">
            <summary>
            True if writing delta metadata in a minimal format.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataWriter.EmitAssemblyDefinition">
            <summary>
            NetModules and EnC deltas don't have AssemblyDef record.
            We don't emit it for EnC deltas since assembly identity has to be preserved across generations (CLR/debugger get confused otherwise).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataWriter.Generation">
            <summary>
            Returns metadata generation ordinal. Zero for
            full metadata and non-zero for delta.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataWriter.EncId">
            <summary>
            Returns unique Guid for this delta, or default(Guid)
            if full metadata.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataWriter.EncBaseId">
            <summary>
            Returns Guid of previous delta, or default(Guid)
            if full metadata or generation 1 delta.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.TryGetTypeDefinitionHandle(Microsoft.Cci.ITypeDefinition,System.Reflection.Metadata.TypeDefinitionHandle@)">
            <summary>
            Returns true and full metadata handle of the type definition
            if the type definition is recognized. Otherwise returns false.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetTypeDefinitionHandle(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Get full metadata handle of the type definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetTypeDef(System.Reflection.Metadata.TypeDefinitionHandle)">
            <summary>
            The type definition corresponding to full metadata type handle.
            Deltas are only required to support indexing into current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetTypeDefs">
            <summary>
            The type definitions to be emitted, in row order. These
            are just the type definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetEventDefinitionHandle(Microsoft.Cci.IEventDefinition)">
            <summary>
            Get full metadata handle of the event definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetEventDefs">
            <summary>
            The event definitions to be emitted, in row order. These
            are just the event definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetFieldDefinitionHandle(Microsoft.Cci.IFieldDefinition)">
            <summary>
            Get full metadata handle of the field definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetFieldDefs">
            <summary>
            The field definitions to be emitted, in row order. These
            are just the field definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.TryGetMethodDefinitionHandle(Microsoft.Cci.IMethodDefinition,System.Reflection.Metadata.MethodDefinitionHandle@)">
            <summary>
            Returns true and handle of the method definition
            if the method definition is recognized. Otherwise returns false.
            The index is into the full metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetMethodDefinitionHandle(Microsoft.Cci.IMethodDefinition)">
            <summary>
            Get full metadata handle of the method definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetMethodDef(System.Reflection.Metadata.MethodDefinitionHandle)">
            <summary>
            The method definition corresponding to full metadata method handle. 
            Deltas are only required to support indexing into current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetMethodDefs">
            <summary>
            The method definitions to be emitted, in row order. These
            are just the method definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetPropertyDefIndex(Microsoft.Cci.IPropertyDefinition)">
            <summary>
            Get full metadata handle of the property definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetPropertyDefs">
            <summary>
            The property definitions to be emitted, in row order. These
            are just the property definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetParameterHandle(Microsoft.Cci.IParameterDefinition)">
            <summary>
            The full metadata handle of the parameter definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetParameterDefs">
            <summary>
            The parameter definitions to be emitted, in row order. These
            are just the parameter definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetGenericParameters">
            <summary>
            The generic parameter definitions to be emitted, in row order. These
            are just the generic parameter definitions from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetFirstFieldDefinitionHandle(Microsoft.Cci.INamedTypeDefinition)">
            <summary>
            The handle of the first field of the type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetFirstMethodDefinitionHandle(Microsoft.Cci.INamedTypeDefinition)">
            <summary>
            The handle of the first method of the type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetFirstParameterHandle(Microsoft.Cci.IMethodDefinition)">
            <summary>
            The handle of the first parameter of the method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetOrAddAssemblyReferenceHandle(Microsoft.Cci.IAssemblyReference)">
            <summary>
            Return full metadata handle of the assembly reference, adding
            the reference to the index for this generation if missing.
            Deltas are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetAssemblyRefs">
            <summary>
            The assembly references to be emitted, in row order. These
            are just the assembly references from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetOrAddModuleReferenceHandle(System.String)">
            <summary>
            Return full metadata handle of the module reference, adding
            the reference to the index for this generation if missing.
            Deltas are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetModuleRefs">
            <summary>
            The module references to be emitted, in row order. These
            are just the module references from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetOrAddMemberReferenceHandle(Microsoft.Cci.ITypeMemberReference)">
            <summary>
            Return full metadata handle of the member reference, adding
            the reference to the index for this generation if missing.
            Deltas are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetMemberRefs">
            <summary>
            The member references to be emitted, in row order. These
            are just the member references from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetOrAddMethodSpecificationHandle(Microsoft.Cci.IGenericMethodInstanceReference)">
            <summary>
            Return full metadata handle of the method spec, adding
            the spec to the index for this generation if missing.
            Deltas are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetMethodSpecs">
            <summary>
            The method specs to be emitted, in row order. These
            are just the method specs from the current generation.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MetadataWriter.GreatestMethodDefIndex">
            <summary>
            The greatest index given to any method definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.TryGetTypeReferenceHandle(Microsoft.Cci.ITypeReference,System.Reflection.Metadata.TypeReferenceHandle@)">
            <summary>
            Return true and full metadata handle of the type reference
            if the reference is available in the current generation.
            Deltas are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetOrAddTypeReferenceHandle(Microsoft.Cci.ITypeReference)">
            <summary>
            Return full metadata handle of the type reference, adding
            the reference to the index for this generation if missing.
            Deltas are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetTypeRefs">
            <summary>
            The type references to be emitted, in row order. These
            are just the type references from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetOrAddTypeSpecificationHandle(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns full metadata handle of the type spec, adding
            the spec to the index for this generation if missing.
            Deltas are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetTypeSpecs">
            <summary>
            The type specs to be emitted, in row order. These
            are just the type specs from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetOrAddStandaloneSignatureHandle(System.Reflection.Metadata.BlobHandle)">
            <summary>
            Returns full metadata handle the standalone signature, adding
            the signature to the index for this generation if missing.
            Deltas are not required to return rows from previous generations.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetStandaloneSignatureBlobHandles">
            <summary>
            The signature blob handles to be emitted, in row order. These
            are just the signature indices from the current generation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.CreateReferenceVisitor">
            <summary>
            Return a visitor for traversing all references to be emitted.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.PopulateEventMapTableRows">
            <summary>
            Populate EventMap table.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.PopulatePropertyMapTableRows">
            <summary>
            Populate PropertyMap table.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetDefiningUnitReference(Microsoft.Cci.ITypeReference,Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Returns a reference to the unit that defines the given referenced type. If the referenced type is a structural type, such as a pointer or a generic type instance,
            then the result is null.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.GetStringHandleForNamespaceAndCheckLength(Microsoft.Cci.INamespaceTypeReference,System.String)">
            <summary>
            The Microsoft CLR requires that {namespace} + "." + {name} fit in MAX_CLASS_NAME 
            (even though the name and namespace are stored separately in the Microsoft
            implementation).  Note that the namespace name of a nested type is always blank
            (since comes from the container).
            </summary>
            <param name="namespaceType">We're trying to add the containing namespace of this type to the string heap.</param>
            <param name="mangledTypeName">Namespace names are never used on their own - this is the type that is adding the namespace name.
            Used only for length checking.</param>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.IsTooLongInternal(System.String,System.Int32)">
            <summary>
            Test the given name to see if it fits in metadata.
            </summary>
            <param name="str">String to test (non-null).</param>
            <param name="maxLength">Max length for name.  (Expected to be at least 5.)</param>
            <returns>True if the name is too long.</returns>
            <remarks>Internal for test purposes.</remarks>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.SerializeLocalVariablesSignature(Microsoft.Cci.IMethodBody)">
            <summary>
            Serialize the method local signature to the blob.
            </summary>
            <returns>Standalone signature token</returns>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.StrongName(Microsoft.Cci.IAssemblyReference)">
            <summary>
            Computes the string representing the strong name of the given assembly reference.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.MetadataWriter.ImportScopeEqualityComparer">
            <summary>
            Import scopes are associated with binders (in C#) and thus multiple instances might be created for a single set of imports.
            We consider scopes with the same parent and the same imports the same.
            Internal for testing.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.WriteUtf8String(System.Reflection.Metadata.BlobBuilder,System.String)">
            <summary>
            Write string as UTF-8 with null terminator.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.AddRemainingDebugDocuments(System.Collections.Generic.IReadOnlyDictionary{System.String,Microsoft.Cci.DebugSourceDocument})">
            <summary>
            Add document entries for all debug documents that do not yet have an entry.
            </summary>
            <remarks>
            This is done after serializing method debug info to ensure that we embed all requested
            text even if there are no corresponding sequence points.
            </remarks>
        </member>
        <member name="F:Microsoft.Cci.MetadataWriter.CompilationOptionsSchemaVersion">
            <summary>The version of the compilation options schema to be written to the PDB.</summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.EmbedCompilationOptions(Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder)">
            <summary>
            Capture the set of compilation options to allow a compilation 
            to be reconstructed from the pdb
            </summary>
        </member>
        <member name="M:Microsoft.Cci.MetadataWriter.EmbedMetadataReferenceInformation(Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder)">
            <summary>
            Writes information about metadata references to the pdb so the same
            reference can be found on sourcelink to create the compilation again
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IteratorHelper">
            <summary>
            A container for static helper methods that are used for manipulating and computing iterators.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IteratorHelper.EnumerableIsNotEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            True if the given enumerable is not null and contains at least one element.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IteratorHelper.EnumerableIsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            True if the given enumerable is null or contains no elements
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IteratorHelper.EnumerableCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the number of elements in the given enumerable. A null enumerable is allowed and results in 0.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.SecurityAttribute">
            <summary>
            A declarative specification of a security action applied to a set of permissions. Used by the CLR loader to enforce security restrictions.
            Each security attribute represents a serialized permission or permission set for a specified security action.
            The union of the security attributes with identical security action, define the permission set to which the security action applies.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMarshallingInformation">
            <summary>
            Information about how values of managed types should be marshalled to and from unmanaged types.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMarshallingInformation.GetCustomMarshaller(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            <see cref="T:Microsoft.Cci.ITypeReference"/> or a string (usually a fully-qualified type name of a type implementing the custom marshaller, but Dev11 allows any string).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.CustomMarshallerRuntimeArgument">
            <summary>
            An argument string (cookie) passed to the custom marshaller at run time.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.ElementType">
            <summary>
            The unmanaged element type of the unmanaged array.
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.IidParameterIndex">
            <summary>
            Specifies the index of the parameter that contains the value of the Interface Identifier (IID) of the marshalled object.
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.UnmanagedType">
            <summary>
            The unmanaged type to which the managed type will be marshalled. This can be UnmanagedType.CustomMarshaler, in which case the unmanaged type
            is decided at runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.NumberOfElements">
            <summary>
            The number of elements in the fixed size portion of the unmanaged array.
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.ParamIndex">
            <summary>
            The zero based index of the parameter in the unmanaged method that contains the number of elements in the variable portion of unmanaged array.
            If -1, the variable portion is of size zero, or the caller conveys the size of the variable portion of the array to the unmanaged method in some other way.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.SafeArrayElementSubtype">
            <summary>
            The type to which the variant values of all elements of the safe array must belong. See also SafeArrayElementUserDefinedSubtype.
            (The element type of a safe array is VARIANT. The "sub type" specifies the value of all of the tag fields (vt) of the element values. )
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMarshallingInformation.GetSafeArrayElementUserDefinedSubtype(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A reference to the user defined type to which the variant values of all elements of the safe array must belong.
            (The element type of a safe array is VARIANT. The tag fields will all be either VT_DISPATCH or VT_UNKNOWN or VT_RECORD.
            The "user defined sub type" specifies the type of value the ppdispVal/ppunkVal/pvRecord fields of the element values may point to.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamedEntity">
            <summary>
            Implemented by any entity that has a name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamedEntity.Name">
            <summary>
            The name of the entity.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IContextualNamedEntity">
            <summary>
            The name of the entity depends on other metadata (tokens, signatures) originated from
            PeWriter.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IContextualNamedEntity.AssociateWithMetadataWriter(Microsoft.Cci.MetadataWriter)">
            <summary>
            Method must be called before calling INamedEntity.Name.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IParameterListEntry">
            <summary>
            Implemented by an entity that is always a member of a particular parameter list, such as an IParameterDefinition.
            Provides a way to determine the position where the entity appears in the parameter list.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterListEntry.Index">
            <summary>
            The position in the parameter list where this instance can be found.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IPlatformInvokeInformation">
            <summary>
            Information that describes how a method from the underlying Platform is to be invoked.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPlatformInvokeInformation.ModuleName">
            <summary>
            Module providing the method/field.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPlatformInvokeInformation.EntryPointName">
            <summary>
            Name of the method providing the implementation.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPlatformInvokeInformation.Flags">
            <summary>
            Flags that determine marshalling behavior.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IWin32Resource">
            <summary>
            A resource file formatted according to Win32 API conventions and typically obtained from a Portable Executable (PE) file.
            See the Win32 UpdateResource method for more details.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.TypeName">
            <summary>
            A string that identifies what type of resource this is. Only valid if this.TypeId &lt; 0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.TypeId">
            <summary>
            An integer tag that identifies what type of resource this is. If the value is less than 0, this.TypeName should be used instead.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.Name">
            <summary>
            The name of the resource. Only valid if this.Id &lt; 0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.Id">
            <summary>
            An integer tag that identifies this resource. If the value is less than 0, this.Name should be used instead.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.LanguageId">
            <summary>
            The language for which this resource is appropriate.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.CodePage">
            <summary>
            The code page for which this resource is appropriate.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.Data">
            <summary>
            The data of the resource.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.RootModuleType">
            <summary>
            Special type &lt;Module&gt;
            </summary>
        </member>
        <member name="T:Microsoft.Cci.SymbolEquivalentEqualityComparer">
            <summary>
            Allows for the comparison of two <see cref="T:Microsoft.Cci.IReference"/> instances or two <see cref="T:Microsoft.Cci.INamespace"/>
            instances based on underlying symbols, if any.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameSerializer.UnwrapTypeReference(Microsoft.Cci.ITypeReference,Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Strip off *, &amp;, and [].
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeNameSerializer.BuildQualifiedNamespaceName(Microsoft.Cci.INamespace)">
            <summary>
            Qualified name of namespace.
            e.g. "A.B.C"
            </summary>
        </member>
        <member name="T:Microsoft.Cci.TypeReferenceIndexer">
            <summary>
            Visitor to force translation of all symbols that will be referred to
            in metadata. Allows us to build the set of types that must be embedded
            as local types (for NoPia).
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IArrayTypeReference">
            <summary>
            This interface models the metadata representation of an array type reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IArrayTypeReference.GetElementType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of the elements of this array.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.IsSZArray">
            <summary>
            This type of array is a single dimensional array with zero lower bound for index values.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.LowerBounds">
            <summary>
            A possibly empty list of lower bounds for dimension indices. When not explicitly specified, a lower bound defaults to zero.
            The first lower bound in the list corresponds to the first dimension. Dimensions cannot be skipped.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.Rank">
            <summary>
            The number of array dimensions.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.Sizes">
            <summary>
            A possible empty list of upper bounds for dimension indices.
            The first upper bound in the list corresponds to the first dimension. Dimensions cannot be skipped.
            An unspecified upper bound means that instances of this type can have an arbitrary upper bound for that dimension.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ICustomModifier">
            <summary>
            Modifies the set of allowed values for a type, or the semantics of operations allowed on those values. 
            Custom modifiers are not associated directly with types, but rather with typed storage locations for values.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomModifier.IsOptional">
            <summary>
            If true, a language may use the modified storage location without being aware of the meaning of the modification.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomModifier.GetModifier(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A type used as a tag that indicates which type of modification applies to the storage location.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IParameterTypeInformation">
            <summary>
            Information that describes a method or property parameter, but does not include all the information in a IParameterDefinition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterTypeInformation.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the parameter type. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterTypeInformation.RefCustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the ref modifier. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterTypeInformation.IsByReference">
            <summary>
            True if the parameter is passed by reference (using a managed pointer).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IParameterTypeInformation.GetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of argument value that corresponds to this parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericParameter">
            <summary>
            The definition of a type parameter of a generic type or method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericParameter.GetConstraints(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A list of classes or interfaces. All type arguments matching this parameter must be derived from all of the classes and implement all of the interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.MustBeReferenceType">
            <summary>
            True if all type arguments matching this parameter are constrained to be reference types.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.MustBeValueType">
            <summary>
            True if all type arguments matching this parameter are constrained to be value types.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.MustHaveDefaultConstructor">
            <summary>
            True if all type arguments matching this parameter are constrained to be value types or concrete classes with visible default constructors.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.Variance">
            <summary>
            Indicates if the generic type or method with this type parameter is co-, contra-, or non variant with respect to this type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericParameterReference">
            <summary>
            A reference to the definition of a type parameter of a generic type or method.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericMethodParameter">
            <summary>
            The definition of a type parameter of a generic method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericMethodParameter.DefiningMethod">
            <summary>
            The generic method that defines this type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericMethodParameterReference">
            <summary>
            A reference to a type parameter of a generic method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericMethodParameterReference.DefiningMethod">
            <summary>
            A reference to the generic method that defines the referenced type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericTypeInstanceReference">
            <summary>
            A generic type instantiated with a list of type arguments
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericTypeInstanceReference.GetGenericArguments(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type arguments that were used to instantiate this.GenericType in order to create this type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericTypeInstanceReference.GetGenericType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Returns the generic type of which this type is an instance.
            Equivalent to Symbol.OriginalDefinition
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericTypeParameter">
            <summary>
            The definition of a type parameter of a generic type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericTypeParameter.DefiningType">
            <summary>
            The generic type that defines this type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericTypeParameterReference">
            <summary>
            A reference to a type parameter of a generic type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericTypeParameterReference.DefiningType">
            <summary>
            A reference to the generic type that defines the referenced type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamedTypeReference">
            <summary>
            A reference to a named type, such as an INamespaceTypeReference or an INestedTypeReference.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamedTypeReference.GenericParameterCount">
            <summary>
            The number of generic parameters. Zero if the type is not generic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamedTypeReference.MangleName">
            <summary>
            If true, the persisted type name is mangled by appending "`n" where n is the number of type parameters, if the number of type parameters is greater than 0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamedTypeReference.AssociatedFileIdentifier">
            <summary>Indicates that the type is scoped to the file it is declared in. Used as a prefix for the metadata name.</summary>
        </member>
        <member name="T:Microsoft.Cci.INamedTypeDefinition">
            <summary>
            A named type definition, such as an INamespaceTypeDefinition or an INestedTypeDefinition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamespaceTypeDefinition">
            <summary>
            A type definition that is a member of a namespace definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamespaceTypeDefinition.IsPublic">
            <summary>
            True if the type can be accessed from other assemblies.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamespace">
            <summary>
            Represents a namespace.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamespace.ContainingNamespace">
            <summary>
            Containing namespace or null if this namespace is global.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.INamespace.GetInternalSymbol">
            <summary>
            Returns underlying internal symbol object, if any.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamespaceTypeReference">
            <summary>
            A reference to a type definition that is a member of a namespace definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.INamespaceTypeReference.GetUnit(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A reference to the unit that defines the referenced type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamespaceTypeReference.NamespaceName">
            <summary>
            Fully qualified name of the containing namespace.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INestedTypeDefinition">
            <summary>
            A type definition that is a member of another type definition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INestedTypeReference">
            <summary>
            A type definition that is a member of another type definition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedNestedTypeReference">
            <summary>
            A reference to a type definition that is a specialized nested type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISpecializedNestedTypeReference.GetUnspecializedVersion(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            A reference to the nested type that has been specialized to obtain this nested type reference. When the containing type is an instance of type which is itself a specialized member (i.e. it is a nested
            type of a generic type instance), then the unspecialized member refers to a member from the unspecialized containing type. (I.e. the unspecialized member always
            corresponds to a definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.MethodImplementation">
            <summary>
            Models an explicit implementation or override of a base class virtual method or an explicit implementation of an interface method.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.MethodImplementation.ImplementingMethod">
            <summary>
            The type that is explicitly implementing or overriding the base class virtual method or explicitly implementing an interface method.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.MethodImplementation.ImplementedMethod">
            <summary>
            A reference to the method that provides the implementation.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.MethodImplementation.ContainingType">
            <summary>
            The type that is explicitly implementing or overriding the base class virtual method or explicitly implementing an interface method.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IModifiedTypeReference">
            <summary>
            A type reference that has custom modifiers associated with it. For example a reference to the target type of a managed pointer to a constant.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModifiedTypeReference.CustomModifiers">
            <summary>
            Returns the list of custom modifiers associated with the type reference.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModifiedTypeReference.UnmodifiedType">
            <summary>
            An unmodified type reference.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IPointerTypeReference">
            <summary>
            This interface models the metadata representation of a pointer to a location in unmanaged memory.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IPointerTypeReference.GetTargetType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type of value stored at the target memory location.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IFunctionPointerTypeReference">
            <summary>
            This interface models the metadata representation of a pointer to a function in unmanaged memory.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFunctionPointerTypeReference.Signature">
            <summary>
            The signature of the function located at the target memory address.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.TypeReferenceWithAttributes">
            <summary>
            A type ref with attributes attached directly to the type reference
            itself. Unlike <see cref="M:Microsoft.Cci.IReference.GetAttributes(Microsoft.CodeAnalysis.Emit.EmitContext)"/> a
            <see cref="T:Microsoft.Cci.TypeReferenceWithAttributes"/> will never provide attributes
            for the "pointed at" declaration, and all attributes will be emitted
            directly on the type ref, rather than the declaration.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.TypeReferenceWithAttributes.TypeRef">
            <summary>
            The type reference.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.TypeReferenceWithAttributes.Attributes">
            <summary>
            The attributes on the type reference itself.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeDefinition">
            <summary>
            This interface models the metadata representation of a type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.Alignment">
            <summary>
            The byte alignment that values of the given type ought to have. Must be a power of 2. If zero, the alignment is decided at runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetBaseClass(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Returns null for interfaces and System.Object.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetEvents(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more events defined by this type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetExplicitImplementationOverrides(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more implementation overrides provided by the class.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetFields(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more fields defined by this type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.GenericParameters">
            <summary>
            Zero or more parameters that can be used as type annotations.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.GenericParameterCount">
            <summary>
            The number of generic parameters. Zero if the type is not generic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.HasDeclarativeSecurity">
            <summary>
            True if this type has a non empty collection of SecurityAttributes or the System.Security.SuppressUnmanagedCodeSecurityAttribute.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.Interfaces(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more interfaces implemented by this type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsAbstract">
            <summary>
            True if the type may not be instantiated.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsBeforeFieldInit">
            <summary>
            Is type initialized anytime before first access to static field
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsComObject">
            <summary>
            Is this imported from COM type library
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsGeneric">
            <summary>
            True if this type is parameterized (this.GenericParameters is a non empty collection).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsInterface">
            <summary>
            True if the type is an interface.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsDelegate">
            <summary>
            True if the type is a delegate.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsRuntimeSpecial">
            <summary>
            True if this type gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsSerializable">
            <summary>
            True if this type is serializable.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsSpecialName">
            <summary>
            True if the type has special name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsWindowsRuntimeImport">
            <summary>
            True if the type is a Windows runtime type.
            </summary>
            <remarks>
            A type can me marked as a Windows runtime type in source by applying the WindowsRuntimeImportAttribute.
            WindowsRuntimeImportAttribute is a pseudo custom attribute defined as an internal class in System.Runtime.InteropServices.WindowsRuntime namespace.
            This is needed to mark Windows runtime types which are redefined in mscorlib.dll and System.Runtime.WindowsRuntime.dll.
            These two assemblies are special as they implement the CLR's support for WinRT.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsSealed">
            <summary>
            True if the type may not be subtyped.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.Layout">
            <summary>
            Layout of the type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetMethods(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more methods defined by this type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetNestedTypes(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more nested types defined by this type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetProperties(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Zero or more properties defined by this type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.SecurityAttributes">
            <summary>
            Declarative security actions for this type. Will be empty if this.HasSecurity is false.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.SizeOf">
            <summary>
            Size of an object of this type. In bytes. If zero, the size is unspecified and will be determined at runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.StringFormat">
            <summary>
            Default marshalling of the Strings in this class.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeReference">
            <summary>
            A reference to a type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeReference.IsEnum">
            <summary>
            True if the type is an enumeration (it extends System.Enum and is sealed). Corresponds to C# enum.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeReference.IsValueType">
            <summary>
            True if the type is a value type. 
            Value types are sealed and extend System.ValueType or System.Enum.
            A type parameter for which MustBeValueType (the struct constraint in C#) is true also returns true for this property.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeReference.GetResolvedType(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The type definition being referred to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeReference.TypeCode">
            <summary>
            Unless the value of TypeCode is PrimitiveTypeCode.NotPrimitive, the type corresponds to a "primitive" CLR type (such as System.Int32) and
            the type code identifies which of the primitive types it corresponds to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeReference.TypeDef">
            <summary>
            TypeDefs defined in modules linked to the assembly being emitted are listed in the ExportedTypes table.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PrimitiveTypeCode">
            <summary>
            A enumeration of all of the value types that are built into the Runtime (and thus have specialized IL instructions that manipulate them).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Boolean">
            <summary>
            A single bit.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Char">
            <summary>
            An unsigned 16 bit integer representing a Unicode UTF16 code point.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int8">
            <summary>
            A signed 8 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Float32">
            <summary>
            A 32 bit IEEE floating point number.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Float64">
            <summary>
            A 64 bit IEEE floating point number.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int16">
            <summary>
            A signed 16 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int32">
            <summary>
            A signed 32 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int64">
            <summary>
            A signed 64 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.IntPtr">
            <summary>
            A signed 32 bit integer or 64 bit integer, depending on the native word size of the underlying processor.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Pointer">
            <summary>
            A pointer to fixed or unmanaged memory.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Reference">
            <summary>
            A reference to managed memory.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.String">
            <summary>
            A string.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt8">
            <summary>
            An unsigned 8 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt16">
            <summary>
            An unsigned 16 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt32">
            <summary>
            An unsigned 32 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt64">
            <summary>
            An unsigned 64 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UIntPtr">
            <summary>
            An unsigned 32 bit integer or 64 bit integer, depending on the native word size of the underlying processor.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Void">
            <summary>
            A type that denotes the absence of a value.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.NotPrimitive">
            <summary>
            Not a primitive type.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.FunctionPointer">
            <summary>
            A pointer to a function in fixed or managed memory.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Invalid">
            <summary>
            Type is a dummy type.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.TypeMemberVisibility">
            <summary>
            Enumerates the different kinds of levels of visibility a type member can have.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Private">
            <summary>
            The member is visible only within its own type.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.FamilyAndAssembly">
            <summary>
            The member is visible only within the intersection of its family (its own type and any subtypes) and assembly. 
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Assembly">
            <summary>
            The member is visible only within its own assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Family">
            <summary>
            The member is visible only within its own type and any subtypes.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.FamilyOrAssembly">
            <summary>
            The member is visible only within the union of its family and assembly. 
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Public">
            <summary>
            The member is visible everywhere its declaring type is visible.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.TypeParameterVariance">
            <summary>
            Enumerates the different kinds of variance a generic method or generic type parameter may have.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeParameterVariance.NonVariant">
            <summary>
            Two type or method instances are compatible only if they have exactly the same type argument for this parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeParameterVariance.Covariant">
            <summary>
            A type or method instance will match another instance if it has a type for this parameter that is the same or a subtype of the type the
            other instance has for this parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeParameterVariance.Contravariant">
            <summary>
            A type or method instance will match another instance if it has a type for this parameter that is the same or a supertype of the type the
            other instance has for this parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IAssemblyReference">
            <summary>
            A reference to a .NET assembly.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IModuleReference">
            <summary>
            A reference to a .NET module.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModuleReference.GetContainingAssembly(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            The Assembly that contains this module. May be null if the module is not part of an assembly.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IUnit">
            <summary>
            A unit of metadata stored as a single artifact and potentially produced and revised independently from other units.
            Examples of units include .NET assemblies and modules, as well C++ object files and compiled headers.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IUnitReference">
            <summary>
            A reference to a instance of <see cref="T:Microsoft.Cci.IUnit"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UsedNamespaceOrType">
            <summary>
            Represents a single using directive (Imports clause).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AssemblyUtilities.FindAssemblySet(System.String)">
            <summary>
            Given a path to an assembly, identifies files in the same directory
            that could satisfy the assembly's dependencies. May throw.
            </summary>
            <remarks>
            Dependencies are identified by simply checking the name of an assembly
            reference against a file name; if they match the file is considered a
            dependency. Other factors, such as version, culture, public key, etc., 
            are not considered, and so the returned collection may include items that
            cannot in fact satisfy the original assembly's dependencies.
            </remarks>
            <exception cref="T:System.IO.IOException">If the file at <paramref name="filePath"/> does not exist or cannot be accessed.</exception>
            <exception cref="T:System.BadImageFormatException">If the file is not an assembly or is somehow corrupted.</exception>
        </member>
        <member name="M:Roslyn.Utilities.AssemblyUtilities.ReadMvid(System.String)">
            <summary>
            Given a path to an assembly, returns its MVID (Module Version ID).
            May throw.
            </summary>
            <exception cref="T:System.IO.IOException">If the file at <paramref name="filePath"/> does not exist or cannot be accessed.</exception>
            <exception cref="T:System.BadImageFormatException">If the file is not an assembly or is somehow corrupted.</exception>
        </member>
        <member name="M:Roslyn.Utilities.AssemblyUtilities.FindSatelliteAssemblies(System.String)">
            <summary>
            Given a path to an assembly, finds the paths to all of its satellite
            assemblies.
            </summary>
            <exception cref="T:System.IO.IOException">If the file at <paramref name="filePath"/> does not exist or cannot be accessed.</exception>
            <exception cref="T:System.BadImageFormatException">If the file is not an assembly or is somehow corrupted.</exception>
        </member>
        <member name="M:Roslyn.Utilities.AssemblyUtilities.IdentifyMissingDependencies(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Given a path to an assembly and a set of paths to possible dependencies,
            identifies which of the assembly's references are missing. May throw.
            </summary>
            <exception cref="T:System.IO.IOException">If the files does not exist or cannot be accessed.</exception>
            <exception cref="T:System.BadImageFormatException">If one of the files is not an assembly or is somehow corrupted.</exception>
        </member>
        <member name="M:Roslyn.Utilities.AssemblyUtilities.GetAssemblyIdentity(System.String)">
            <summary>
            Given a path to an assembly, returns the <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/> for the assembly.
             May throw.
            </summary>
            <exception cref="T:System.IO.IOException">If the file at <paramref name="assemblyPath"/> does not exist or cannot be accessed.</exception>
            <exception cref="T:System.BadImageFormatException">If the file is not an assembly or is somehow corrupted.</exception>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.FullPath">
            <summary>
            Full case-insensitive path.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.Timestamp">
            <summary>
            Last write time (UTC).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.#ctor(System.String,System.DateTime)">
            <summary>
            Constructor.
            </summary>
            <param name="fullPath">Full path.</param>
            <param name="timestamp">Last write time (UTC).</param>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.Create(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.ResolveRelativePath(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
            <summary>
            Resolves relative path and returns absolute path.
            The method depends only on values of its parameters and their implementation (for fileExists).
            It doesn't itself depend on the state of the current process (namely on the current drive directories) or 
            the state of file system.
            </summary>
            <param name="path">
            Path to resolve.
            </param>
            <param name="basePath">
            Base file path to resolve CWD-relative paths against. Null if not available.
            </param>
            <param name="baseDirectory">
            Base directory to resolve CWD-relative paths against if <paramref name="basePath"/> isn't specified. 
            Must be absolute path.
            Null if not available.
            </param>
            <param name="searchPaths">
            Sequence of paths used to search for unqualified relative paths.
            </param>
            <param name="fileExists">
            Method that tests existence of a file.
            </param>
            <returns>
            The resolved path or null if the path can't be resolved or does not exist.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.NormalizeAbsolutePath(System.String)">
            <summary>
            Normalizes an absolute path.
            </summary>
            <param name="path">Path to normalize.</param>
            <exception cref="T:System.IO.IOException"/>
            <returns>Normalized path.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.CreateFileStreamChecked(System.Func{System.String,System.IO.Stream},System.String,System.String)">
            <summary>
            Used to create a file given a path specified by the user.
            paramName - Provided by the Public surface APIs to have a clearer message. Internal API just rethrow the exception
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileTimeStamp(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileLength(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Roslyn.Utilities.ICommonCompilerFileSystem">
            <summary>
            Abstraction over the file system that is useful for test hooks
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.CommonCompilerFileSystemExtensions.OpenFileWithNormalizedException(Roslyn.Utilities.ICommonCompilerFileSystem,System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Open a file and ensure common exception types are wrapped to <see cref="T:System.IO.IOException"/>.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Empty">
            <summary>
            Null or empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Relative">
            <summary>
            "file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentDirectory">
            <summary>
            ".\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentParent">
            <summary>
            "..\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentRoot">
            <summary>
            "\dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToDriveDirectory">
            <summary>
            "C:dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Absolute">
            <summary>
            "C:\file" or "\\machine" (UNC).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDirectorySeparator(System.Char)">
            <summary>
            True if the character is the platform directory separator character or the alternate directory separator.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(System.Char)">
            <summary>
            True if the character is any recognized directory separator character.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.TrimTrailingSeparators(System.String)">
            <summary>
            Removes trailing directory separator characters
            </summary>
            <remarks>
            This will trim the root directory separator:
            "C:\" maps to "C:", and "/" maps to ""
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.EnsureTrailingSeparator(System.String)">
            <summary>
            Ensures a trailing directory separator character
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetDirectoryName(System.String)">
            <summary>
            Get directory name from path.
            </summary>
            <remarks>
            Unlike <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/> it doesn't check for invalid path characters
            </remarks>
            <returns>Prefix of path that represents a directory</returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathRoot(System.String)">
            <summary>
            Gets the root part of the path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathKind(System.String)">
            <summary>
            Gets the specific kind of relative or absolute path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsAbsolute(System.String)">
            <summary>
            True if the path is an absolute path (rooted to drive or network share)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDriveRootedAbsolutePath(System.String)">
            <summary>
            Returns true if given path is absolute and starts with a drive specification ("C:\").
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)">
            <summary>
            Combines an absolute path with a relative.
            </summary>
            <param name="root">Absolute root path.</param>
            <param name="relativePath">Relative path.</param>
            <returns>
            An absolute combined path, or null if <paramref name="relativePath"/> is 
            absolute (e.g. "C:\abc", "\\machine\share\abc"), 
            relative to the current root (e.g. "\abc"), 
            or relative to a drive directory (e.g. "C:abc\def").
            </returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)">
            <summary>
            Combine two paths, the first of which may be absolute.
            </summary>
            <param name="root">First path: absolute, relative, or null.</param>
            <param name="relativePath">Second path: relative and non-null.</param>
            <returns>null, if <paramref name="root"/> is null; a combined path, otherwise.</returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePaths(System.String,System.String)">
            <summary>
            Combines paths with the same semantics as <see cref="M:System.IO.Path.Combine(System.String,System.String)"/>
            but does not throw on null paths or paths with invalid characters.
            </summary>
            <param name="root">First path: absolute, relative, or null.</param>
            <param name="path">Second path: absolute, relative, or null.</param>
            <returns>
            The combined paths. If <paramref name="path"/> contains an absolute path, returns <paramref name="path"/>.
            </returns>
            <remarks>
            Relative and absolute paths treated the same as <see cref="M:System.IO.Path.Combine(System.String,System.String)"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsFilePath(System.String)">
            <summary>
            Determines whether an assembly reference is considered an assembly file path or an assembly name.
            used, for example, on values of /r and #r.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.ContainsPathComponent(System.String,System.String,System.Boolean)">
            <summary>
            Determines if "path" contains 'component' within itself.
            i.e. asking if the path "c:\goo\bar\baz" has component "bar" would return 'true'.
            On the other hand, if you had "c:\goo\bar1\baz" then it would not have "bar" as a
            component.
            
            A path contains a component if any file name or directory name in the path
            matches 'component'.  As such, if you had something like "\\goo" then that would
            not have "goo" as a component. That's because here "goo" is the server name portion
            of the UNC path, and not an actual directory or file name.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetRelativePath(System.String,System.String)">
            <summary>
            Gets a path relative to a directory.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsChildPath(System.String,System.String)">
            <summary>
            True if the child path is a child of the parent path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.PathsEqual(System.String,System.String)">
            <summary>
            True if the two paths are the same.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.PathsEqual(System.String,System.String,System.Int32)">
            <summary>
            True if the two paths are the same.  (but only up to the specified length)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsValidFilePath(System.String)">
            <summary>
            Unfortunately, we cannot depend on Path.GetInvalidPathChars() or Path.GetInvalidFileNameChars()
            From MSDN: The array returned from this method is not guaranteed to contain the complete set of characters
            that are invalid in file and directory names. The full set of invalid characters can vary by file system.
            https://msdn.microsoft.com/en-us/library/system.io.path.getinvalidfilenamechars.aspx
            
            Additionally, Path.GetInvalidPathChars() doesn't include "?" or "*" which are invalid characters,
            and Path.GetInvalidFileNameChars() includes ":" and "\" which are valid characters.
            
            The more accurate way is to let the framework parse the path and throw on any errors.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.NormalizeWithForwardSlash(System.String)">
            <summary>
            If the current environment uses the '\' directory separator, replaces all uses of '\'
            in the given string with '/'. Otherwise, returns the string.
            </summary>
            <remarks>
            This method is equivalent to Microsoft.CodeAnalysis.BuildTasks.GenerateMSBuildEditorConfig.NormalizeWithForwardSlash
            Both methods should be kept in sync.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.ExpandAbsolutePathWithRelativeParts(System.String)">
            <summary>
            Takes an absolute path and attempts to expand any '..' or '.' into their equivalent representation.
            </summary>
            <returns>An equivalent path that does not contain any '..' or '.' path parts, or the original path.</returns>
            <remarks>
            This method handles unix and windows drive rooted absolute paths only (i.e /a/b or x:\a\b). Passing any other kind of path
            including relative, drive relative, unc, or windows device paths will simply return the original input. 
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ArrayExtensions.BinarySearchUpperBound(System.Int32[],System.Int32)">
            <summary>
            Search a sorted integer array for the target value in O(log N) time.
            </summary>
            <param name="array">The array of integers which must be sorted in ascending order.</param>
            <param name="value">The target value.</param>
            <returns>An index in the array pointing to the position where <paramref name="value"/> should be
            inserted in order to maintain the sorted order. All values to the right of this position will be
            strictly greater than <paramref name="value"/>. Note that this may return a position off the end
            of the array if all elements are less than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="T:Roslyn.Utilities.BlobBuildingStream">
            <summary>
            A write-only memory stream backed by a <see cref="T:System.Reflection.Metadata.BlobBuilder"/>.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.BlobBuildingStream.ChunkSize">
             <summary>
             The chunk size to be used by the underlying BlobBuilder.
             </summary>
             <remarks>
             The current single use case for this type is embedded sources in PDBs.
            
             32 KB is:
            
             * Large enough to handle 99.6% all VB and C# files in Roslyn and CoreFX 
               without allocating additional chunks.
            
             * Small enough to avoid the large object heap.
            
             * Large enough to handle the files in the 0.4% case without allocating tons
               of small chunks. Very large source files are often generated in build
               (e.g. Syntax.xml.Generated.vb is 390KB compressed!) and those are actually
               attractive candidates for embedding, so we don't want to discount the large
               case too heavily.)
            
             * We pool the outer BlobBuildingStream but only retain the first allocated chunk.
             </remarks>
        </member>
        <member name="T:Roslyn.Utilities.CharMemoryEqualityComparer">
            <summary>
            Provide structural equality for ReadOnlyMemory{char} instances.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.CommandLineUtilities.SplitCommandLineIntoArguments(System.String,System.Boolean)">
            <summary>
            Split a command line by the same rules as Main would get the commands except the original
            state of backslashes and quotes are preserved.  For example in normal Windows command line 
            parsing the following command lines would produce equivalent Main arguments:
            
                - /r:a,b
                - /r:"a,b"
            
            This method will differ as the latter will have the quotes preserved.  The only case where 
            quotes are removed is when the entire argument is surrounded by quotes without any inner
            quotes. 
            </summary>
            <remarks>
            Rules for command line parsing, according to MSDN:
            
            Arguments are delimited by white space, which is either a space or a tab.
             
            A string surrounded by double quotation marks ("string") is interpreted 
            as a single argument, regardless of white space contained within. 
            A quoted string can be embedded in an argument.
             
            A double quotation mark preceded by a backslash (\") is interpreted as a 
            literal double quotation mark character (").
             
            Backslashes are interpreted literally, unless they immediately precede a 
            double quotation mark.
             
            If an even number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is interpreted as a string delimiter.
             
            If an odd number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is "escaped" by the remaining backslash, 
            causing a literal double quotation mark (") to be placed in argv.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.CompilerOptionParseUtilities.ParseFeatureFromMSBuild(System.String)">
            <summary>
            Parse the value provided to an MSBuild Feature option into a list of entries.  This will 
            leave name=value in their raw form.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentDictionaryExtensions.Add``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,``1)">
            <summary>
            NOTE!!! adding duplicates will result in exceptions. 
            Being concurrent only allows accessing the dictionary without taking locks.
            Duplicate keys are still not allowed in the hashtable.
            If unsure about adding unique items use APIs such as TryAdd, GetOrAdd, etc...
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConcurrentSet`1">
            <summary>
            A concurrent, simplified HashSet.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultConcurrencyLevel">
            <summary>
            The default concurrency level is 2. That means the collection can cope with up to two
            threads making simultaneous modifications without blocking.
            Note ConcurrentDictionary's default concurrency level is dynamic, scaling according to
            the number of processors.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultCapacity">
            <summary>
            Taken from ConcurrentDictionary.DEFAULT_CAPACITY
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1._dictionary">
            <summary>
            The backing dictionary. The values are never used; just the keys.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor">
            <summary>
            Construct a concurrent set with the default concurrency level.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct a concurrent set using the specified equality comparer.
            </summary>
            <param name="equalityComparer">The equality comparer for values in the set.</param>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.Count">
            <summary>
            Obtain the number of elements in the set.
            </summary>
            <returns>The number of elements in the set.</returns>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.IsEmpty">
            <summary>
            Determine whether the set is empty.</summary>
            <returns>true if the set is empty; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Contains(`0)">
            <summary>
            Determine whether the given value is in the set.
            </summary>
            <param name="value">The value to test.</param>
            <returns>true if the set contains the specified value; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Add(`0)">
            <summary>
            Attempts to add a value to the set.
            </summary>
            <param name="value">The value to add.</param>
            <returns>true if the value was added to the set. If the value already exists, this method returns false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Remove(`0)">
            <summary>
            Attempts to remove a value from the set.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>true if the value was removed successfully; otherwise false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Clear">
            <summary>
            Clear the set
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.GetEnumerator">
            <summary>
            Obtain an enumerator that iterates through the elements in the set.
            </summary>
            <returns>An enumerator for the set.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ConfiguredYieldAwaitable">
            <summary>
            A custom awaiter that supports <see cref="M:Roslyn.Utilities.YieldAwaitableExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Boolean)"/> for
            <see cref="M:System.Threading.Tasks.Task.Yield"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConsList`1">
            <summary>
            a simple Lisp-like immutable list.  Good to use when lists are always accessed from the head.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean,System.String)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.AssertOrFailFast(System.Boolean,System.String)">
            <summary>
            Generally <see cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/> is a sufficient method for enforcing DEBUG 
            only invariants in our code. When it triggers that provides a nice stack trace for 
            investigation. Generally that is enough.
            
            <para>There are cases for which a stack is not enough and we need a full heap dump to 
            investigate the failure. This method takes care of that. The behavior is that when running
            in our CI environment if the assert triggers we will rudely crash the process and 
            produce a heap dump for investigation.</para>
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.DocumentationCommentXmlNames">
            <summary>
            Names of well-known XML attributes and elements.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.EmptyComparer">
            <summary>
            Very cheap trivial comparer that never matches the keys,
            should only be used in empty dictionaries.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EncodingExtensions.GetMaxCharCountOrThrowIfHuge(System.Text.Encoding,System.IO.Stream)">
            <summary>
            Get maximum char count needed to decode the entire stream.
            </summary>
            <exception cref="T:System.IO.IOException">Stream is so big that max char count can't fit in <see cref="T:System.Int32"/>.</exception> 
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(``0[])">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.List{``0})">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.SelectAsArrayAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.ValueTask{``1}})">
            <summary>
            Maps an immutable array through a function that returns ValueTask, returning the new ImmutableArray.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.SelectAsArrayAsync``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{``2}},``1,System.Threading.CancellationToken)">
            <summary>
            Maps an immutable array through a function that returns ValueTask, returning the new ImmutableArray.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.AsSingleton``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the only element of specified sequence if it has exactly one, and default(TSource) otherwise.
            Unlike <see cref="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/> doesn't throw if there is more than one element in the sequence.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.Functions`1">
            <summary>
            Cached versions of commonly used delegates.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Roslyn.Utilities.Predicates`1">
            <summary>
            Cached versions of commonly used delegates.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Roslyn.Utilities.EnumUtilities.ConvertEnumUnderlyingTypeToUInt64(System.Object,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Convert a boxed primitive (generally of the backing type of an enum) into a ulong.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ExceptionUtilities.UnexpectedValue(System.Object)">
            <summary>
            Creates an <see cref="T:System.InvalidOperationException"/> with information about an unexpected value.
            </summary>
            <param name="o">The unexpected value.</param>
            <returns>The <see cref="T:System.InvalidOperationException"/>, which should be thrown by the caller.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ExceptionUtilities.IsCurrentOperationBeingCancelled(System.Exception,System.Threading.CancellationToken)">
            <summary>
            Determine if an exception was an <see cref="T:System.OperationCanceledException"/>, and that the provided token caused the cancellation.
            </summary>
            <param name="exception">The exception to test.</param>
            <param name="cancellationToken">Checked to see if the provided token was cancelled.</param>
            <returns><see langword="true"/> if the exception was an <see cref="T:System.OperationCanceledException" /> and the token was canceled.</returns>
        </member>
        <member name="T:Roslyn.Utilities.FileNameUtilities">
            <summary>
            Implements a few file name utilities that are needed by the compiler.
            In general the compiler is not supposed to understand the format of the paths.
            In rare cases it needs to check if a string is a valid file name or change the extension 
            (embedded resources, netmodules, output name).
            The APIs are intentionally limited to cover just these rare cases. Do not add more APIs.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IsFileName(System.String)">
            <summary>
            Returns true if the string represents an unqualified file name. 
            The name may contain any characters but directory and volume separators.
            </summary>
            <param name="path">Path.</param>
            <returns>
            True if <paramref name="path"/> is a simple file name, false if it is null or includes a directory specification.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IndexOfExtension(System.String)">
            <summary>
            Returns the offset in <paramref name="path"/> where the dot that starts an extension is, or -1 if the path doesn't have an extension.
            </summary>
            <remarks>
            Returns 0 for path ".goo".
            Returns -1 for path "goo.".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.GetExtension(System.String)">
            <summary>
            Returns an extension of the specified path string.
            </summary>
            <remarks>
            The same functionality as <see cref="M:System.IO.Path.GetExtension(System.String)"/> but doesn't throw an exception
            if there are invalid characters in the path.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.RemoveExtension(System.String)">
            <summary>
            Removes extension from path.
            </summary>
            <remarks>
            Returns "goo" for path "goo.".
            Returns "goo.." for path "goo...".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.ChangeExtension(System.String,System.String)">
            <summary>
            Returns path with the extension changed to <paramref name="extension"/>.
            </summary>
            <returns>
            Equivalent of <see cref="M:System.IO.Path.ChangeExtension(System.String,System.String)"/>
            
            If <paramref name="path"/> is null, returns null. 
            If path does not end with an extension, the new extension is appended to the path.
            If extension is null, equivalent to <see cref="M:Roslyn.Utilities.FileNameUtilities.RemoveExtension(System.String)"/>.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IndexOfFileName(System.String)">
            <summary>
            Returns the position in given path where the file name starts.
            </summary>
            <returns>-1 if path is null.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.GetFileName(System.String,System.Boolean)">
            <summary>
            Get file name from path.
            </summary>
            <remarks>Unlike <see cref="M:System.IO.Path.GetFileName(System.String)"/> doesn't check for invalid path characters.</remarks>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            PERF: Do not use with enum types because that involves multiple
            unnecessary boxing operations.  Unfortunately, we can't constrain
            T to "non-enum", so we'll use a more restrictive constraint.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Byte},System.Boolean@)">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes and determines if the byte
            sequence is valid ASCII and hence the hash code matches a char sequence
            encoding the same text.
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes that are likely to be ASCII text.</param>
            <param name="isAscii">True if the sequence contains only characters in the ASCII range.</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Char})">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending at the end of the string.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Text.StringBuilder)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string as a char array</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char)">
            <summary>
            Compute the hashcode of a single character using the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: In general, this isn't any more useful than "char.GetHashCode". However,
            it may be needed if you need to generate the same hash code as a string or
            substring with just a single character.
            </summary>
            <param name="ch">The character to hash</param>
            <returns>The FNV-1a hash code of the character.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.String)">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="text">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="text"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.Char)">
            <summary>
            Combine a char with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="ch">The new character to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="ch"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``1(``0@,``0)">
            <summary>
            Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
            The value is changed to <paramref name="value"/> only if the current value is null.
            </summary>
            <typeparam name="T">Type of value.</typeparam>
            <param name="target">Reference to the target location.</param>
            <param name="value">The value to use if the target is currently null.</param>
            <returns>The new value referenced by <paramref name="target"/>. Note that this is
            nearly always more useful than the usual return from <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/>
            because it saves another read to <paramref name="target"/>.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``1(``0@,``0,``0)">
            <summary>
            Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
            The value is changed to <paramref name="initializedValue"/> only if the current value
            is <paramref name="uninitializedValue"/>.
            </summary>
            <typeparam name="T">Type of value.</typeparam>
            <param name="target">Reference to the target location.</param>
            <param name="initializedValue">The value to use if the target is currently uninitialized.</param>
            <param name="uninitializedValue">The uninitialized value.</param>
            <returns>The new value referenced by <paramref name="target"/>. Note that this is
            nearly always more useful than the usual return from <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/>
            because it saves another read to <paramref name="target"/>.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``1(System.Collections.Immutable.ImmutableArray{``0}@,System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Initialize the immutable array referenced by <paramref name="target"/> in a thread-safe manner.
            </summary>
            <typeparam name="T">Elemental type of the array.</typeparam>
            <param name="target">Reference to the target location.</param>
            <param name="initializedValue">The value to use if the target is currently uninitialized (default).</param>
            <returns>The new value referenced by <paramref name="target"/>. Note that this is
            nearly always more useful than the usual return from <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/>
            because it saves another read to <paramref name="target"/>.</returns>
        </member>
        <member name="T:Roslyn.Utilities.JsonWriter">
            <summary>
            A simple, forward-only JSON writer to avoid adding dependencies to the compiler.
            Used to generate /errorlogger output.
            
            Does not guarantee well-formed JSON if misused. It is the caller's responsibility 
            to balance array/object start/end, to only write key-value pairs to objects and
            elements to arrays, etc.
            
            Takes ownership of the given <see cref="T:System.IO.TextWriter" /> at construction and handles its disposal.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.NoThrowStreamDisposer">
            <summary>
            Catches exceptions thrown during disposal of the underlying stream and
            writes them to the given <see cref="T:System.IO.TextWriter"/>. Check
            <see cref="P:Roslyn.Utilities.NoThrowStreamDisposer.HasFailedToDispose" /> after disposal to see if any
            exceptions were thrown during disposal.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.NoThrowStreamDisposer.Stream">
            <summary>
            Underlying stream
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.NoThrowStreamDisposer.HasFailedToDispose">
            <summary>
            True if and only if an exception was thrown during a call to <see cref="M:Roslyn.Utilities.NoThrowStreamDisposer.Dispose"/>
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.OneOrMany`1">
            <summary>
            Represents a single item or many items (including none).
            </summary>
            <remarks>
            Used when a collection usually contains a single item but sometimes might contain multiple.
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.PlatformInformation">
            <summary>
            This class provides simple properties for determining whether the current platform is Windows or Unix-based.
            We intentionally do not use System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(...) because
            it incorrectly reports 'true' for 'Windows' in desktop builds running on Unix-based platforms via Mono.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PlatformInformation.IsUsingMonoRuntime">
            <summary>
            Are we running on .NET 5 or later using the Mono runtime?
            Will also return true when running on Mono itself; if necessary
            we can use IsRunningOnMono to distinguish.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceEqualityComparer">
            <summary>
            Compares objects based upon their reference identity.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ReflectionUtilities.GetTypeFromEither(System.String,System.String)">
            <summary>
            Find a <see cref="T:System.Type"/> instance by first probing the contract name and then the name as it
            would exist in mscorlib.  This helps satisfy both the CoreCLR and Desktop scenarios. 
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.RoslynLazyInitializer.EnsureInitialized``1(``0@)">
            <inheritdoc cref="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynLazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
            <inheritdoc cref="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynLazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
            <inheritdoc cref="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynLazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
            <inheritdoc cref="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynParallel.For(System.Int32,System.Int32,System.Action{System.Int32},System.Threading.CancellationToken)">
            <inheritdoc cref="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynString.IsNullOrEmpty(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynString.IsNullOrWhiteSpace(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
        </member>
        <member name="T:Roslyn.Utilities.SetWithInsertionOrder`1">
            <summary>
            A set that returns the inserted values in insertion order.
            The mutation operations are not thread-safe.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StreamExtensions.TryReadAll(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Attempts to read all of the requested bytes from the stream into the buffer
            </summary>
            <returns>
            The number of bytes read. Less than <paramref name="count" /> will
            only be returned if the end of stream is reached before all bytes can be read.
            </returns>
            <remarks>
            Unlike <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> it is not guaranteed that
            the stream position or the output buffer will be unchanged if an exception is
            returned.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.StreamExtensions.ReadAllBytes(System.IO.Stream)">
            <summary>
            Reads all bytes from the current position of the given stream to its end.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.IsValidClrNamespaceName(System.String)">
            <summary>
            Checks if the given name is a sequence of valid CLR names separated by a dot.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.Unquote(System.String)">
            <summary>
            Remove one set of leading and trailing double quote characters, if both are present.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.StringOrdinalComparer">
            <summary>
            Compares string based upon their ordinal equality.
            We use this comparer for string identifiers because it does exactly what we need and nothing more
            The StringComparer.Ordinal as implemented by StringComparer is more complex to support 
            case sensitive and insensitive compares depending on flags.
            It also defers to the default string hash function that might not be the best for our scenarios.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.StringTable">
            <summary>
            This is basically a lossy cache of strings that is searchable by
            strings, string sub ranges, character array ranges or string-builder.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.TextChangeRangeExtensions.Merge(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange})">
             <summary>
             Merges the new change ranges into the old change ranges, adjusting the new ranges to be with respect to the original text
             (with neither old or new changes applied) instead of with respect to the original text after "old changes" are applied.
            
             This may require splitting, concatenation, etc. of individual change ranges.
             </summary>
             <remarks>
             Both `oldChanges` and `newChanges` must contain non-overlapping spans in ascending order.
             </remarks>
        </member>
        <member name="T:Roslyn.Utilities.TextChangeRangeExtensions.UnadjustedNewChange">
            <summary>
            Represents a new change being processed by <see cref="M:Roslyn.Utilities.TextChangeRangeExtensions.Merge(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange})"/>.
            Such a new change must be adjusted before being added to the result list.
            </summary>
            <remarks>
            A value of this type may represent the intermediate state of merging of an old change into an unadjusted new change,
            resulting in a temporary unadjusted new change whose <see cref="P:Roslyn.Utilities.TextChangeRangeExtensions.UnadjustedNewChange.SpanStart"/> is negative (not valid) until it is adjusted.
            This tends to happen when we need to merge an old change deletion into a new change near the beginning of the text. (see TextChangeTests.Fuzz_4)
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.UnicodeCharacterUtilities">
            <summary>
            Defines a set of helper methods to classify Unicode characters.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsIdentifierPartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be a part of an identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsValidIdentifier(System.String)">
            <summary>
            Check that the name is a valid Unicode identifier.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsFormattingChar(System.Char)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsFormattingChar(System.Globalization.UnicodeCategory)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="cat">The Unicode character.</param>
        </member>
        <member name="T:Roslyn.Utilities.ValueTaskFactory">
            <summary>
            Implements <see cref="T:System.Threading.Tasks.ValueTask"/> and <see cref="T:System.Threading.Tasks.ValueTask`1"/> static members that are only available in .NET 5.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.VoidResult">
            <summary>
            Explicitly indicates result is void
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.WeakList`1">
            <summary>
            Represents an ordered sequence of weak references.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.WeakList`1.Compact(System.Int32,System.WeakReference{`0}[])">
            <summary>
            Copies all live references from <see cref="F:Roslyn.Utilities.WeakList`1._items"/> to <paramref name="result"/>.
            Assumes that all references prior <paramref name="firstDead"/> are alive.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.WeakList`1.WeakCount">
            <summary>
            Returns the number of weak references in this list. 
            Note that some of them might not point to live objects anymore.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.YieldAwaitableExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Boolean)">
            <summary>
            Implements <c>ConfigureAwait(bool)</c> for <see cref="M:System.Threading.Tasks.Task.Yield"/>. The resulting behavior in asynchronous code
            is the same as one would expect for <see cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/>.
            </summary>
            <param name="awaitable">The awaitable provided by <see cref="M:System.Threading.Tasks.Task.Yield"/>.</param>
            <param name="continueOnCapturedContext"><inheritdoc cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/></param>
            <returns>An object used to await this yield.</returns>
        </member>
        <member name="T:Roslyn.Utilities.IObjectWritable">
            <summary>
            Objects that implement this interface know how to write their contents to an <see cref="T:Roslyn.Utilities.ObjectWriter"/>,
            so they can be reconstructed later by an <see cref="T:Roslyn.Utilities.ObjectReader"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization">
            <summary>
            Returns 'true' when the same instance could be used more than once.
            Instances that return 'false' should not be tracked for the purpose 
            of de-duplication while serializing/deserializing.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectBinder">
            <summary>
            <see cref="T:Roslyn.Utilities.ObjectBinder"/> is a registry that maps between arbitrary <see cref="T:System.Type"/>s and 
            the 'reader' function used to deserialize serialized instances of those types.  Registration
            must happen ahead of time using the <see cref="M:Roslyn.Utilities.ObjectBinder.RegisterTypeReader(System.Type,System.Func{Roslyn.Utilities.ObjectReader,Roslyn.Utilities.IObjectWritable})"/> method.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectBinder.s_gate">
            <summary>
            Lock for all data in this type.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectBinder.s_lastSnapshot">
            <summary>
            Last created snapshot of our data.  We hand this out instead of exposing our raw
            data so that <see cref="T:Roslyn.Utilities.ObjectReader"/> and <see cref="T:Roslyn.Utilities.ObjectWriter"/> do not need to
            take any locks while processing.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectBinder.s_typeToIndex">
            <summary>
            Map from a <see cref="T:System.Type"/> to the corresponding index in <see cref="F:Roslyn.Utilities.ObjectBinder.s_types"/> and
            <see cref="F:Roslyn.Utilities.ObjectBinder.s_typeReaders"/>.  <see cref="T:Roslyn.Utilities.ObjectWriter"/> will write out the index into
            the stream, and <see cref="T:Roslyn.Utilities.ObjectReader"/> will use that index to get the reader used
            for deserialization.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectBinder.GetSnapshot">
            <summary>
            Gets an immutable copy of the state of this binder.  This copy does not need to be
            locked while it is used.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectReader">
            <summary>
            An <see cref="T:Roslyn.Utilities.ObjectReader"/> that deserializes objects from a byte stream.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectReader.VersionByte1">
            <summary>
            We start the version at something reasonably random.  That way an older file, with 
            some random start-bytes, has little chance of matching our version.  When incrementing
            this version, just change VersionByte2.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectReader._objectReferenceMap">
            <summary>
            Map of reference id's to deserialized objects.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectReader._binderSnapshot">
            <summary>
            Copy of the global binder data that maps from Types to the appropriate reading-function
            for that type.  Types register functions directly with <see cref="T:Roslyn.Utilities.ObjectBinder"/>, but 
            that means that <see cref="T:Roslyn.Utilities.ObjectBinder"/> is both static and locked.  This gives us 
            local copy we can work with without needing to worry about anyone else mutating.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.#ctor(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a new instance of a <see cref="T:Roslyn.Utilities.ObjectReader"/>.
            </summary>
            <param name="stream">The stream to read objects from.</param>
            <param name="leaveOpen">True to leave the <paramref name="stream"/> open after the <see cref="T:Roslyn.Utilities.ObjectWriter"/> is disposed.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.TryGetReader(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Attempts to create a <see cref="T:Roslyn.Utilities.ObjectReader"/> from the provided <paramref name="stream"/>.
            If the <paramref name="stream"/> does not start with a valid header, then <see langword="null"/> will
            be returned.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.GetReader(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates an <see cref="T:Roslyn.Utilities.ObjectReader"/> from the provided <paramref name="stream"/>.
            Unlike <see cref="M:Roslyn.Utilities.ObjectReader.TryGetReader(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)"/>, it requires the version
            of the data in the stream to exactly match the current format version.
            Should only be used to read data written by the same version of Roslyn.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectReader.ReaderReferenceMap`1">
            <summary>
            A reference-id to object map, that can share base data efficiently.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter">
            <summary>
            An <see cref="T:Roslyn.Utilities.ObjectWriter"/> that serializes objects to a byte stream.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter._objectReferenceMap">
            <summary>
            Map of serialized object's reference ids.  The object-reference-map uses reference equality
            for performance.  While the string-reference-map uses value-equality for greater cache hits 
            and reuse.
            
            These are not readonly because they're structs and we mutate them.
            
            When we write out objects/strings we give each successive, unique, item a monotonically 
            increasing integral ID starting at 0.  I.e. the first object gets ID-0, the next gets 
            ID-1 and so on and so forth.  We do *not* include these IDs with the object when it is
            written out.  We only include the ID if we hit the object *again* while writing.
            
            During reading, the reader knows to give each object it reads the same monotonically 
            increasing integral value.  i.e. the first object it reads is put into an array at position
            0, the next at position 1, and so on.  Then, when the reader reads in an object-reference
            it can just retrieved it directly from that array.
            
            In other words, writing and reading take advantage of the fact that they know they will
            write and read objects in the exact same order.  So they only need the IDs for references
            and not the objects themselves because the ID is inferred from the order the object is
            written or read in.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter._binderSnapshot">
            <summary>
            Copy of the global binder data that maps from Types to the appropriate reading-function
            for that type.  Types register functions directly with <see cref="T:Roslyn.Utilities.ObjectBinder"/>, but 
            that means that <see cref="T:Roslyn.Utilities.ObjectBinder"/> is both static and locked.  This gives us 
            local copy we can work with without needing to worry about anyone else mutating.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.#ctor(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a new instance of a <see cref="T:Roslyn.Utilities.ObjectWriter"/>.
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="leaveOpen">True to leave the <paramref name="stream"/> open after the <see cref="T:Roslyn.Utilities.ObjectWriter"/> is disposed.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter.GuidAccessor">
            <summary>
            Used so we can easily grab the low/high 64bits of a guid for serialization.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteValue(System.ReadOnlySpan{System.Byte})">
            <summary>
            Write an array of bytes. The array data is provided as a
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan</see>&lt;<see cref="T:System.Byte"/>&gt;, and deserialized to a byte array.
            </summary>
            <param name="span">The array data.</param>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter.WriterReferenceMap">
            <summary>
            An object reference to reference-id map, that can share base data efficiently.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.s_reverseTypeMap">
            <summary>
            Indexed by EncodingKind.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.ByteMarkerMask">
            <summary>
            byte marker mask for encoding compressed uint 
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte1Marker">
            <summary>
            byte marker bits for uint encoded in 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte2Marker">
            <summary>
            byte marker bits for uint encoded in 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte4Marker">
            <summary>
            byte marker bits for uint encoded in 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Null">
            <summary>
            The null value
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Type">
            <summary>
            A type
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Object">
            <summary>
            An object with member values encoded as variants
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.ObjectRef_1Byte">
            <summary>
            An object reference with the id encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.ObjectRef_2Bytes">
            <summary>
            An object reference with the id encode as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.ObjectRef_4Bytes">
            <summary>
            An object reference with the id encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringUtf8">
            <summary>
            A string encoded as UTF-8 (using BinaryWriter.Write(string))
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringUtf16">
            <summary>
            A string encoded as UTF16 (as array of UInt16 values)
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringRef_1Byte">
            <summary>
            A reference to a string with the id encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringRef_2Bytes">
            <summary>
            A reference to a string with the id encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringRef_4Bytes">
            <summary>
            A reference to a string with the id encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Boolean_True">
            <summary>
            The boolean value true.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Boolean_False">
            <summary>
            The boolean value char.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Char">
            <summary>
            A character value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int8">
            <summary>
            An Int8 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int16">
            <summary>
            An Int16 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32">
            <summary>
            An Int32 value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_1Byte">
            <summary>
            An Int32 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_2Bytes">
            <summary>
            An Int32 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_0">
            <summary>
            The Int32 value 0
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_1">
            <summary>
            The Int32 value 1
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_2">
            <summary>
            The Int32 value 2
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_3">
            <summary>
            The Int32 value 3
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_4">
            <summary>
            The Int32 value 4
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_5">
            <summary>
            The Int32 value 5
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_6">
            <summary>
            The Int32 value 6
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_7">
            <summary>
            The Int32 value 7
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_8">
            <summary>
            The Int32 value 8
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_9">
            <summary>
            The Int32 value 9
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_10">
            <summary>
            The Int32 value 10
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int64">
            <summary>
            An Int64 value encoded as 8 bytes
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt8">
            <summary>
            A UInt8 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt16">
            <summary>
            A UIn16 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32">
            <summary>
            A UInt32 value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_1Byte">
            <summary>
            A UInt32 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_2Bytes">
            <summary>
            A UInt32 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_0">
            <summary>
            The UInt32 value 0
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_1">
            <summary>
            The UInt32 value 1
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_2">
            <summary>
            The UInt32 value 2
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_3">
            <summary>
            The UInt32 value 3
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_4">
            <summary>
            The UInt32 value 4
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_5">
            <summary>
            The UInt32 value 5
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_6">
            <summary>
            The UInt32 value 6
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_7">
            <summary>
            The UInt32 value 7
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_8">
            <summary>
            The UInt32 value 8
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_9">
            <summary>
            The UInt32 value 9
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_10">
            <summary>
            The UInt32 value 10
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt64">
            <summary>
            A UInt64 value encoded as 8 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Float4">
            <summary>
            A float value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Float8">
            <summary>
            A double value encoded as 8 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Decimal">
            <summary>
            A decimal value encoded as 12 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.DateTime">
            <summary>
            A DateTime value
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array">
            <summary>
            An array with length encoded as compressed uint
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_0">
            <summary>
            An array with zero elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_1">
            <summary>
            An array with one element
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_2">
            <summary>
            An array with 2 elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_3">
            <summary>
            An array with 3 elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.BooleanType">
            <summary>
            The boolean type
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringType">
            <summary>
            The string type
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.EncodingName">
            <summary>
            Encoding serialized as <see cref="P:System.Text.Encoding.WebName"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SerializationThreadPool.ImmediateBackgroundThreadPool">
            <summary>
            Naive thread pool focused on reducing the latency to execution of chunky work items as much as possible.
            If a thread is ready to process a work item the moment a work item is queued, it's used, otherwise
            a new thread is created. This is meant as a stop-gap measure for workloads that would otherwise be
            creating a new thread for every work item.
            </summary>
            <remarks>
            This class is derived from <see href="https://github.com/dotnet/machinelearning/blob/ebc431f531436c45097c88757dfd14fe0c1381b3/src/Microsoft.ML.Core/Utilities/ThreadUtils.cs">dotnet/machinelearning</see>.
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.SerializationThreadPool.ImmediateBackgroundThreadPool.s_idleTimeout">
            <summary>How long should threads wait around for additional work items before retiring themselves.</summary>
        </member>
        <member name="F:Roslyn.Utilities.SerializationThreadPool.ImmediateBackgroundThreadPool.s_queue">
            <summary>The queue of work items. Also used as a lock to protect all relevant state.</summary>
        </member>
        <member name="F:Roslyn.Utilities.SerializationThreadPool.ImmediateBackgroundThreadPool.s_availableThreads">
            <summary>The number of threads currently waiting in <c>tryDequeue</c> for work to arrive.</summary>
        </member>
        <member name="M:Roslyn.Utilities.SerializationThreadPool.ImmediateBackgroundThreadPool.QueueAsync(System.Func{System.Object})">
            <summary>
            Queues a <see cref="T:System.Func`1"/> delegate to be executed immediately on another thread,
            and returns a <see cref="T:System.Threading.Tasks.Task"/> that represents its eventual completion. The task will
            always end in the <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion"/> state; if the delegate throws
            an exception, it'll be allowed to propagate on the thread, crashing the process.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.SerializationThreadPool.ImmediateBackgroundThreadPool.QueueAsync(System.Func{System.Object,System.Object},System.Object)">
            <summary>
            Queues a <see cref="T:System.Func`2"/> delegate and associated state to be executed immediately on
            another thread, and returns a <see cref="T:System.Threading.Tasks.Task"/> that represents its eventual completion.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.PerformanceSensitiveAttribute">
            <summary>
            Indicates that a code element is performance sensitive under a known scenario.
            </summary>
            <remarks>
            <para>When applying this attribute, only explicitly set the values for properties specifically indicated by the
            test/measurement technique described in the associated <see cref="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri">
            <summary>
            Gets the location where the original problem is documented, likely with steps to reproduce the issue and/or
            validate performance related to a change in the method.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Constraint">
            <summary>
            Gets or sets a description of the constraint imposed by the original performance issue.
            </summary>
            <remarks>
            <para>Constraints are normally specified by other specific properties that allow automated validation of the
            constraint. This property supports documenting constraints which cannot be described in terms of other
            constraint properties.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowCaptures">
            <summary>
            Gets or sets a value indicating whether captures are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowImplicitBoxing">
            <summary>
            Gets or sets a value indicating whether implicit boxing of value types is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowGenericEnumeration">
            <summary>
            Gets or sets a value indicating whether enumeration of a generic
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowLocks">
            <summary>
            Gets or sets a value indicating whether locks are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.OftenCompletesSynchronously">
            <summary>
            Gets or sets a value indicating whether the asynchronous state machine typically completes synchronously.
            </summary>
            <remarks>
            <para>When <see langword="true"/>, validation of this performance constraint typically involves analyzing
            the method to ensure synchronous completion of the state machine does not require the allocation of a
            <see cref="T:System.Threading.Tasks.Task"/>, either through caching the result or by using
            <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.IsParallelEntry">
            <summary>
            Gets or sets a value indicating whether this is an entry point to a parallel algorithm.
            </summary>
            <remarks>
            <para>Parallelization APIs and algorithms, e.g. <c>Parallel.ForEach</c>, may be efficient for parallel entry
            points (few direct calls but large amounts of iterative work), but are problematic when called inside the
            iterations themselves. Performance-sensitive code should avoid the use of heavy parallelization APIs except
            for known entry points to the parallel portion of code.</para>
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InternalImplementationOnlyAttribute">
            <summary>
            This is a marker attribute that can be put on an interface to denote that only internal implementations
            of that interface should exist.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>Gets the names of the arguments that should be passed to the handler.</summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>Indicates the attributed type is to be used as an interpolated string handler.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute.#ctor">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute"/>.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Linq.EnumerableExtensions">
            <summary>
            Declare the following extension methods in System.Linq namespace to avoid accidental boxing of ImmutableArray{T} that implements IEnumerable{T}.
            The boxing would occur if the methods were defined in Roslyn.Utilities and the file calling these methods has <c>using Roslyn.Utilities</c>
            but not <c>using System.Linq</c>.
            </summary>
        </member>
        <member name="T:System.Linq.ImmutableSegmentedListExtensions">
            <seealso cref="T:System.Linq.ImmutableArrayExtensions"/>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
    </members>
</doc>
