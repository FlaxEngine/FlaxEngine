<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.CSharp</name>
    </assembly>
    <members>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder">
            <summary>
            A Binder converts names in to symbols and syntax nodes into bound trees. It is context
            dependent, relative to a location in source code.
            </summary>
            <summary>
            This portion of the binder converts a AnonymousObjectCreationExpressionSyntax into 
            a bound anonymous object creation node
            </summary>
            <summary>
            This portion of the binder converts an AwaitExpressionSyntax into a BoundExpression
            </summary>
            <summary>
            This portion of the binder converts deconstruction-assignment syntax (AssignmentExpressionSyntax nodes with the left
            being a tuple expression or declaration expression) into a BoundDeconstructionAssignmentOperator (or bad node).
            The BoundDeconstructionAssignmentOperator will have:
            - a BoundTupleLiteral as its Left,
            - a BoundConversion as its Right, holding:
                - a tree of Conversion objects with Kind=Deconstruction, information about a Deconstruct method (optional) and
                    an array of nested Conversions (like a tuple conversion),
                - a BoundExpression as its Operand.
            </summary>
            <summary>
            This portion of the binder converts an <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax"/> into a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundExpression"/>.
            </summary>
            <summary>
            This portion of the binder converts an <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax"/> into a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundExpression"/>.
            </summary>
            <summary>
            This portion of the binder converts a QueryExpressionSyntax into a BoundExpression
            </summary>
            <summary>
            This portion of the binder reports errors arising from resolving queries.
            </summary>
            <summary>
            This portion of the binder converts StatementSyntax nodes into BoundStatements
            </summary>
            <summary>
            This portion of the binder converts a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax"/> into a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundExpression"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.#ctor(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Used to create a root binder.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.Next">
            <summary>
            Get the next binder in which to look up a name, if not found by this binder.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.NextRequired">
            <summary>
            Get the next binder in which to look up a name, if not found by this binder, asserting if `Next` is null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.CheckOverflow">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Enabled"/> if we are in an explicitly checked context (within checked block or expression).
            <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Disabled"/> if we are in an explicitly unchecked context (within unchecked block or expression).
            <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Implicit"/> otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.CheckOverflowAtRuntime">
            <summary>
            True if instructions that check overflow should be generated.
            </summary>
            <remarks>
            Spec 7.5.12:
            For non-constant expressions (expressions that are evaluated at run-time) that are not 
            enclosed by any checked or unchecked operators or statements, the default overflow checking
            context is unchecked unless external factors (such as compiler switches and execution 
            environment configuration) call for checked evaluation.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.CheckOverflowAtCompileTime">
            <summary>
            True if the compiler should check for overflow while evaluating constant expressions.
            </summary>
            <remarks>
            Spec 7.5.12:
            For constant expressions (expressions that can be fully evaluated at compile-time), 
            the default overflow checking context is always checked. Unless a constant expression 
            is explicitly placed in an unchecked context, overflows that occur during the compile-time 
            evaluation of the expression always cause compile-time errors.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetBinder(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Some nodes have special binders for their contents (like Blocks)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetRequiredBinder(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets a binder for a node that must be not null, and asserts
            if it is not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetDeclaredLocalsForScope(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Get locals declared immediately in scope designated by the node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetDeclaredLocalFunctionsForScope(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Get local functions declared immediately in scope designated by the node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ScopeDesignator">
            <summary>
            If this binder owns a scope for locals, return syntax node that is used
            as the scope designator. Otherwise, null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.IsNestedFunctionBinder">
            <summary>
            True if this is the top-level binder for a local function or lambda
            (including implicit lambdas from query expressions).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ContainingMemberOrLambda">
            <summary>
            The member containing the binding context.  Note that for the purposes of the compiler,
            a lambda expression is considered a "member" of its enclosing method, field, or lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.AreNullableAnnotationsEnabled(Microsoft.CodeAnalysis.SyntaxTree,System.Int32)">
            <summary>
            Are we in a context where un-annotated types should be interpreted as non-null?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.IsInMethodBody">
            <summary>
            Is the contained code within a member method body?
            </summary>
            <remarks>
            May be false in lambdas that are outside of member method bodies, e.g. lambdas in
            field initializers.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.IsDirectlyInIterator">
            <summary>
            Is the contained code within an iterator block?
            </summary>
            <remarks>
            Will be false in a lambda in an iterator.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.IsIndirectlyInIterator">
            <summary>
            Is the contained code within the syntactic span of an
            iterator method?
            </summary>
            <remarks>
            Will be true in a lambda in an iterator.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.BreakLabel">
            <summary>
            If we are inside a context where a break statement is legal,
            returns the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedLabelSymbol"/> that a break statement would branch to.
            Returns null otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ContinueLabel">
            <summary>
            If we are inside a context where a continue statement is legal,
            returns the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedLabelSymbol"/> that a continue statement would branch to.
            Returns null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetIteratorElementType">
            <summary>
            Get the element type of this iterator.
            </summary>
            <returns>Element type of the current iterator, or an error type.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ImportChain">
            <summary>
            The imports for all containing namespace declarations (innermost-to-outermost, including global),
            or null if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.QuickAttributeChecker">
            <summary>
            Get <see cref="P:Microsoft.CodeAnalysis.CSharp.Binder.QuickAttributeChecker"/> that can be used to quickly
            check for certain attribute applications in context of this binder.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ContainingType">
            <summary>
            The type containing the binding context
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.BindingTopLevelScriptCode">
            <summary>
            Returns true if the binder is binding top-level script code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportDiagnosticsIfObsolete(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Issue an error or warning for a symbol if it is Obsolete. If there is not enough
            information to report diagnostics, then store the symbols so that diagnostics
            can be reported at a later stage.
            </summary>
            <remarks>
            This method is introduced to move the implicit conversion operator call from the caller
            so as to reduce the caller stack frame size
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportDiagnosticsIfObsolete(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.SyntaxNodeOrToken,System.Boolean)">
            <summary>
            Issue an error or warning for a symbol if it is Obsolete. If there is not enough
            information to report diagnostics, then store the symbols so that diagnostics
            can be reported at a later stage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Report diagnostics that should be reported when using a synthesized attribute. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.WrapWithVariablesAndLocalFunctionsIfAny(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Should only be used with scopes that could declare local functions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Implicit">
            <summary>
            Outside of <c>checked</c>, <c>unchecked</c> expression/block.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Disabled">
            <summary>
            Within <c>unchecked</c> expression/block.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Enabled">
            <summary>
            Within <c>checked</c> expression/block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.RangeVariableMap">
            <summary>
            We represent the set of query variables in scope at a particular point by a RangeVariableMap.
            Each query variable in scope has a key in this map.  If the corresponding value is empty, then
            that query variable is represented directly by a lambda parameter.  If it is non-empty, then
            to get the value of that query variable one starts with the first parameter of the current
            lambda (the first parameter is always the transparent one), and dot through its members using
            the names in the value list, in reverse order.  So, for example, if the query variable "x" has
            a value in this map of ["Item2", "Item1", "Item1"], then the way to compute the value of that
            query variable is starting with the current lambda's first parameter P, compute "P.Item1.Item1.Item2".
            See also WithQueryLambdaParametersBinder.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.MixableDestination">
            <summary>
            The destination in a method arguments must match (MAMM) check. This is 
            created primarily for ref and out arguments of a ref struct. It also applies
            to function pointer this and arglist arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.MixableDestination.Parameter">
            <summary>
            In the case this is the argument for a ref / out parameter this will refer
            to the corresponding parameter. This will be null in cases like arguments 
            passed to an arglist.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.MixableDestination.EscapeLevel">
            <summary>
            This destination can only be written to by arguments that have an equal or
            wider escape level. An destination that is <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.EscapeLevel.CallingMethod"/>
            can never be written to by an argument that has a level of <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.EscapeLevel.ReturnOnly"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.EscapeArgument">
            <summary>
            Represents an argument being analyzed for escape analysis purposes. This represents the
            argument as written. For example a `ref x` will only be represented by a single 
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Binder.EscapeArgument"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.EscapeArgument.Parameter">
            <summary>
            This will be null in cases like arglist or a function pointer receiver.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.EscapeValue">
            <summary>
            Represents a value being analyzed for escape analysis purposes. This represents the value 
            as it contributes to escape analysis which means arguments can show up multiple times. For
            example `ref x` will be represented as both a val and ref escape.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.EscapeValue.Parameter">
            <summary>
            This will be null in cases like arglist or a function pointer receiver.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.EscapeValue.EscapeLevel">
            <summary>
            This is _only_ useful when calculating MAMM as it dictates to what level the value 
            escaped to. That allows it to be filtered against the parameters it could possibly
            write to.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.CallingMethodScope">
            <summary>
            For the purpose of escape verification we operate with the depth of local scopes.
            The depth is a uint, with smaller number representing shallower/wider scopes.
            0, 1 and 2 are special scopes - 
            0 is the "calling method" scope that is outside of the containing method/lambda. 
              If something can escape to scope 0, it can escape to any scope in a given method through a ref parameter or return.
            1 is the "return-only" scope that is outside of the containing method/lambda. 
              If something can escape to scope 1, it can escape to any scope in a given method or can be returned, but it can't escape through a ref parameter.
            2 is the "current method" scope that is just inside the containing method/lambda. 
              If something can escape to scope 1, it can escape to any scope in a given method, but cannot be returned.
            n + 1 corresponds to scopes immediately inside a scope of depth n. 
              Since sibling scopes do not intersect and a value cannot escape from one to another without 
              escaping to a wider scope, we can use simple depth numbering without ambiguity.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind">
            <summary>
            Expression capabilities and requirements.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.RValue">
            <summary>
            Expression can be an RHS of an assignment operation.
            </summary>
            <remarks>
            The following are rvalues: values, variables, null literals, properties
            and indexers with getters, events. 
            
            The following are not rvalues:
            namespaces, types, method groups, anonymous functions.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.Assignable">
            <summary>
            Expression can be the LHS of a simple assignment operation.
            Example: 
              property with a setter
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.RefersToLocation">
            <summary>
            Expression represents a location. Often referred as a "variable"
            Examples:
             local variable, parameter, field
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.RefAssignable">
            <summary>
            Expression can be the LHS of a ref-assign operation.
            Example:
             ref local, ref parameter, out parameter, ref field
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.RValueOrMethodGroup">
            <summary>
            Expression is the RHS of an assignment operation
            and may be a method group.
            Basically an RValue, but could be treated differently for the purpose of error reporting
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.CompoundAssignment">
            <summary>
            Expression can be an LHS of a compound assignment
            operation (such as +=).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.IncrementDecrement">
            <summary>
            Expression can be the operand of an increment or decrement operation.
            Same as CompoundAssignment, the distinction is really just for error reporting.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.ReadonlyRef">
            <summary>
            Expression is a r/o reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.AddressOf">
            <summary>
            Expression can be the operand of an address-of operation (&amp;).
            Same as ReadonlyRef. The difference is just for error reporting.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.FixedReceiver">
            <summary>
            Expression is the receiver of a fixed buffer field access
            Same as ReadonlyRef. The difference is just for error reporting.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.RefOrOut">
            <summary>
            Expression is passed as a ref or out parameter or assigned to a byref variable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.RefReturn">
            <summary>
            Expression is returned by an ordinary r/w reference.
            Same as RefOrOut. The difference is just for error reporting.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckValue(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Check the expression is of the required lvalue and rvalue specified by valueKind.
            The method returns the original expression if the expression is of the required
            type. Otherwise, an appropriate error is added to the diagnostics bag and the
            method returns a BoundBadExpression node. The method returns the original
            expression without generating any error if the expression has errors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckValueKind(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
             <summary>
             The purpose of this method is to determine if the expression satisfies desired capabilities. 
             If it is not then this code gives an appropriate error message.
            
             To determine the appropriate error message we need to know two things:
            
             (1) What capabilities we need - increment it, assign, return as a readonly reference, . . . ?
            
             (2) Are we trying to determine if the left hand side of a dot is a variable in order
                 to determine if the field or property on the right hand side of a dot is assignable?
                 
             (3) The syntax of the expression that started the analysis. (for error reporting purposes).
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.RequiresVariableReceiver(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            SPEC: When a property or indexer declared in a struct-type is the target of an 
            SPEC: assignment, the instance expression associated with the property or indexer 
            SPEC: access must be classified as a variable. If the instance expression is 
            SPEC: classified as a value, a compile-time error occurs. Because of 7.6.4, 
            SPEC: the same rule also applies to fields.
            </summary>
            <remarks>
            NOTE: The spec fails to impose the restriction that the event receiver must be classified
            as a variable (unlike for properties - 7.17.1).  This seems like a bug, but we have
            production code that won't build with the restriction in place (see DevDiv #15674).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetInvocationEscapeScope(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},System.Collections.Immutable.ImmutableArray{System.Int32},System.UInt32,System.Boolean)">
            <summary>
            Computes the scope to which the given invocation can escape
            NOTE: the escape scope for ref and val escapes is the same for invocations except for trivial cases (ordinary type returned by val) 
                  where escape is known otherwise. Therefore we do not have two ref/val variants of this.
                  
            NOTE: we need scopeOfTheContainingExpression as some expressions such as optional <c>in</c> parameters or <c>ref dynamic</c> behave as 
                  local variables declared at the scope of the invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckInvocationEscape(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},System.Collections.Immutable.ImmutableArray{System.Int32},System.Boolean,System.UInt32,System.UInt32,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <summary>
            Validates whether given invocation can allow its results to escape from <paramref name="escapeFrom"/> level to <paramref name="escapeTo"/> level.
            The result indicates whether the escape is possible. 
            Additionally, the method emits diagnostics (possibly more than one, recursively) that would help identify the cause for the failure.
            
            NOTE: we need scopeOfTheContainingExpression as some expressions such as optional <c>in</c> parameters or <c>ref dynamic</c> behave as 
                  local variables declared at the scope of the invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetInvocationArgumentsForEscape(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},System.Collections.Immutable.ImmutableArray{System.Int32},System.Boolean,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.MixableDestination},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.EscapeArgument})">
            <summary>
            Returns the set of arguments to be considered for escape analysis of a method invocation.
            Each argument is returned with the correponding parameter and ref kind. Arguments are not
            filtered - all arguments are included exactly once in the array, and the caller is responsible for
            determining which arguments affect escape analysis. This method is used for method invocation
            analysis, regardless of whether UseUpdatedEscapeRules is set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetFilteredInvocationArgumentsForEscapeWithUpdatedRules(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},System.Collections.Immutable.ImmutableArray{System.Int32},System.Boolean,System.Boolean,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.EscapeValue})">
            <summary>
            Returns the set of arguments to be considered for escape analysis of a method
            invocation. Each argument is returned with the correponding parameter and
            whether analysis should consider value or ref escape. Not all method arguments
            are included, and some arguments may be included twice - once for value, once for ref.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetEscapeValuesForUpdatedRules(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},System.Collections.Immutable.ImmutableArray{System.Int32},System.Boolean,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.MixableDestination},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.EscapeValue})">
            <summary>
            Returns the set of <see cref="T:Microsoft.CodeAnalysis.CSharp.Binder.EscapeValue"/> to an invocation that impact ref analysis. 
            This will filter out everything that could never meaningfully contribute to ref analysis. For
            example: 
              - For ref arguments it will return an <see cref="T:Microsoft.CodeAnalysis.CSharp.Binder.EscapeValue"/> for both ref and 
                value escape (if appropriate based on scoped-ness of associated parameters).
              - It will remove value escape for args which correspond to scoped parameters. 
              - It will remove value escape for non-ref struct.
              - It will remove ref escape for args which correspond to scoped refs.
            Optionally this will also return all of the <see cref="T:Microsoft.CodeAnalysis.CSharp.Binder.MixableDestination" /> that 
            result from this invocation. That is useful for MAMM analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckInvocationArgMixing(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},System.Collections.Immutable.ImmutableArray{System.Int32},System.UInt32,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Validates whether the invocation is valid per no-mixing rules.
            Returns <see langword="false"/> when it is not valid and produces diagnostics (possibly more than one recursively) that helps to figure the reason.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ValidateEscape(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.UInt32,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Checks whether given expression can escape from the current scope to the <paramref name="escapeTo"/>
            In a case if it cannot a bad expression is returned and diagnostics is produced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetRefEscape(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.UInt32)">
            <summary>
            Computes the widest scope depth to which the given expression can escape by reference.
            
            NOTE: in a case if expression cannot be passed by an alias (RValue and similar), the ref-escape is scopeOfTheContainingExpression
                  There are few cases where RValues are permitted to be passed by reference which implies that a temporary local proxy is passed instead.
                  We reflect such behavior by constraining the escape value to the narrowest scope possible. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckRefEscape(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.UInt32,System.UInt32,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            A counterpart to the GetRefEscape, which validates if given escape demand can be met by the expression.
            The result indicates whether the escape is possible. 
            Additionally, the method emits diagnostics (possibly more than one, recursively) that would help identify the cause for the failure.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.UInt32)">
            <summary>
            Computes the widest scope depth to which the given expression can escape by value.
            
            NOTE: unless the type of expression is ref-like, the result is Binder.ExternalScope since ordinary values can always be returned from methods. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckValEscape(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.UInt32,System.UInt32,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            A counterpart to the GetValEscape, which validates if given escape demand can be met by the expression.
            The result indicates whether the escape is possible.
            Additionally, the method emits diagnostics (possibly more than one, recursively) that would help identify the cause for the failure.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.HasHome(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Binder.AddressKind,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol})">
            <summary>
            Checks if expression directly or indirectly represents a value with its own home. In
            such cases it is possible to get a reference without loading into a temporary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.HasHome(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess,Microsoft.CodeAnalysis.CSharp.Binder.AddressKind,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol})">
            <summary>
            Special HasHome for fields. 
            Fields have readable homes when they are not constants.
            Fields have writeable homes unless they are readonly and used outside of the constructor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsAnonymousTypesAllowed">
            <summary>
            Actually, defines if an error ERR_AnonymousTypeNotAvailable is to be generated; 
            
            Dev10 rules (which are based on BindingContext::InMethod()) are difficult to 
            reproduce, so this implementation checks both current symbol as well as syntax nodes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetAnonymousTypeFieldType(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean@)">
            <summary>
            Returns the type to be used as a field type; generates errors in case the type is not
            supported for anonymous type fields.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindAttributeArguments(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            The caller is responsible for freeing <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.AnalyzedAttributeArguments.ConstructorArguments"/> and <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.AnalyzedAttributeArguments.NamedArguments"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetRewrittenAttributeConstructorArguments(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TypedConstant},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Collections.Immutable.ImmutableArray{System.Int32},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean,System.Boolean@)">
            <summary>
            Gets the rewritten attribute constructor arguments, i.e. the arguments
            are in the order of parameters, which may differ from the source
            if named constructor arguments are used.
            
            For example:
                void Goo(int x, int y, int z, int w = 3);
            
                Goo(0, z: 2, y: 1);
                
                Arguments returned: 0, 1, 2, 3
            </summary>
            <returns>Rewritten attribute constructor arguments</returns>
            <remarks>
            CONSIDER: Can we share some code will call rewriting in the local rewriter?
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.AttributeExpressionVisitor">
            <summary>
            Walk a custom attribute argument bound node and return a TypedConstant.  Verify that the expression is a constant expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CouldBeAwaited(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Return true iff an await with this subexpression would be legal where the expression appears.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ContextForbidsAwait">
            <summary>
            Assuming we are in an async method, return true if we're in a context where await would be illegal.
            Specifically, return true if we're in a lock or catch filter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportBadAwaitWithoutAsync(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Reports an error if the await expression did not occur in an async context.
            </summary>
            <returns>True if the expression contains errors.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportBadAwaitContext(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Report diagnostics if the await expression occurs in a context where it is not allowed.
            </summary>
            <returns>True if errors were found.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetAwaitableExpressionInfo(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression@,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Finds and validates the required members of an awaitable expression, as described in spec 7.7.7.1.
            </summary>
            <returns>True if the expression is awaitable; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ValidateAwaitedExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Validates the awaited expression, returning true if no errors are found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetGetAwaiterMethod(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.BoundExpression@)">
            <summary>
            Finds the GetAwaiter method of an awaitable expression.
            </summary>
            <remarks>
            Spec 7.7.7.1:
            An awaitable expression t has an accessible instance or extension method called GetAwaiter with no
            parameters and no type parameters, and a return type A that meets the additional requirements for an
            Awaiter.
            NOTE: this is an error in the spec.  An extension method of the form
            Awaiter&lt;T&gt; GetAwaiter&lt;T&gt;(this Task&lt;T&gt;) may be used.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetIsCompletedProperty(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol@)">
            <summary>
            Finds the IsCompleted property of an Awaiter type.
            </summary>
            <remarks>
            Spec 7.7.7.1:
            An Awaiter A has an accessible, readable instance property IsCompleted of type bool.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.AwaiterImplementsINotifyCompletion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Checks that the Awaiter implements System.Runtime.CompilerServices.INotifyCompletion.
            </summary>
            <remarks>
            Spec 7.7.7.1:
            An Awaiter A implements the interface System.Runtime.CompilerServices.INotifyCompletion.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetGetResultMethod(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@,Microsoft.CodeAnalysis.CSharp.BoundExpression@)">
            <summary>
            Finds the GetResult method of an Awaiter type.
            </summary>
            <remarks>
            Spec 7.7.7.1:
            An Awaiter A has an accessible instance method GetResult with no parameters and no type parameters.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeParameterConstraintClauses(Microsoft.CodeAnalysis.CSharp.Symbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol},Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean,System.Boolean)">
            <summary>
            Return a collection of bound constraint clauses indexed by type parameter
            ordinal. All constraint clauses are bound, even if there are multiple constraints
            for the same type parameter, or constraints for unrecognized type parameters.
            Extra constraints are not included in the returned collection however.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeParameterConstraints(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Bind and return a single type parameter constraint clause along with syntax nodes corresponding to type constraints.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.RemoveInvalidConstraints(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintClause},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax}},System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Constraints are checked for invalid types, duplicate types, and accessibility. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsValidConstraint(Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintKind,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Returns true if the constraint is valid. Otherwise
            returns false and generates a diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ConvertConditionalExpression(Microsoft.CodeAnalysis.CSharp.BoundUnconvertedConditionalOperator,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Nullable{Microsoft.CodeAnalysis.CSharp.Conversion},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <summary>
            Rewrite the subexpressions in a conditional expression to convert the whole thing to the destination type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ConvertSwitchExpression(Microsoft.CodeAnalysis.CSharp.BoundUnconvertedSwitchExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Nullable{Microsoft.CodeAnalysis.CSharp.Conversion},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <summary>
            Rewrite the expressions in the switch expression arms to add a conversion to the destination type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MemberGroupFinalValidation(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <summary>
            This method implements the algorithm in spec section 7.6.5.1.
            
            For method group conversions, there are situations in which the conversion is
            considered to exist ("Otherwise the algorithm produces a single best method M having
            the same number of parameters as D and the conversion is considered to exist"), but
            application of the conversion fails.  These are the "final validation" steps of
            overload resolution.
            </summary>
            <returns>
            True if there is any error, except lack of runtime support errors.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MemberGroupFinalValidationAccessibilityChecks(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
             <summary>
             Performs the following checks:
             
             Spec 7.6.5: Invocation expressions (definition of Final Validation) 
               The method is validated in the context of the method group: If the best method is a static method, 
               the method group must have resulted from a simple-name or a member-access through a type. If the best 
               method is an instance method, the method group must have resulted from a simple-name, a member-access
               through a variable or value, or a base-access. If neither of these requirements is true, a binding-time
               error occurs.
               (Note that the spec omits to mention, in the case of an instance method invoked through a simple name, that
               the invocation must appear within the body of an instance method)
            
             Spec 7.5.4: Compile-time checking of dynamic overload resolution 
               If F is a static method, the method group must have resulted from a simple-name, a member-access through a type, 
               or a member-access whose receiver can't be classified as a type or value until after overload resolution (see §7.6.4.1). 
               If F is an instance method, the method group must have resulted from a simple-name, a member-access through a variable or value,
               or a member-access whose receiver can't be classified as a type or value until after overload resolution (see §7.6.4.1).
             </summary>
             <returns>
             True if there is any error.
             </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.WasImplicitReceiver(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Was the receiver expression compiler-generated?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MethodIsCompatibleWithDelegateOrFunctionPointer(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            This method implements the checks in spec section 15.2.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MethodGroupConversionHasErrors(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            This method combines final validation (section 7.6.5.1) and delegate compatibility (section 15.2).
            </summary>
            <param name="syntax">CSharpSyntaxNode of the expression requiring method group conversion.</param>
            <param name="conversion">Conversion to be performed.</param>
            <param name="receiverOpt">Optional receiver.</param>
            <param name="isExtensionMethod">Method invoked as extension method.</param>
            <param name="delegateOrFuncPtrType">Target delegate type.</param>
            <param name="diagnostics">Where diagnostics should be added.</param>
            <returns>True if a diagnostic has been added.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MethodGroupConversionDoesNotExistOrHasErrors(Microsoft.CodeAnalysis.CSharp.BoundMethodGroup,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Conversion@)">
            <summary>
            This method is a wrapper around MethodGroupConversionHasErrors.  As a preliminary step,
            it checks whether a conversion exists.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeSymbolInCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>
            We can't use BindNamespaceOrTypeSymbol, since it doesn't return inaccessible symbols (directly).
            </summary>
            <remarks>
            Guaranteed not to return null.
            
            CONSIDER: As in dev11, we don't handle ambiguity at this level.  Hypothetically,
            we could just pick one, though an "ideal" solution would probably involve a search
            down all ambiguous branches.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ComputeSortedCrefMembers(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.String,System.Int32,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Perform lookup (optionally, in a specified container).  If nothing is found and the member name matches the containing type
            name, then use the instance constructors of the type instead.  The resulting symbols are sorted since tie-breaking is based
            on order and we want cref binding to be repeatable.
            </summary>
            <remarks>
            Never returns null.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ProcessCrefMemberLookupResults(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Symbol@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Given a list of viable lookup results (based on the name, arity, and containing symbol),
            attempt to select one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ProcessParameterlessCrefMemberLookupResults(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Symbol@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            At this point, we have a list of viable symbols and no parameter list with which to perform
            overload resolution.  We'll just return the first symbol, giving a diagnostic if there are
            others.
            Caveat: If there are multiple candidates and only one is from source, then the source symbol
            wins and no diagnostic is reported.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetCrefOverloadResolutionCandidates(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Replace any named type in the symbol list with its instance constructors.
            Construct all candidates with the implicitly-declared CrefTypeParameterSymbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.PerformCrefOverloadResolution(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax,Microsoft.CodeAnalysis.CSharp.Symbol@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Given a list of method and/or property candidates, choose the first one (if any) with a signature
            that matches the parameter list in the cref.  Return null if there isn't one.
            </summary>
            <remarks>
            Produces a diagnostic for ambiguous matches, but not for unresolved members - WRN_BadXMLRef is
            handled in BindMemberCref.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ConstructWithCrefTypeParameters(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            If the member is generic, construct it with the CrefTypeParameterSymbols that should be in scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindCrefParameterOrReturnType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <remarks>
            Keep in sync with CSharpSemanticModel.GetSpeculativelyBoundExpressionWithoutNullability.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindDeconstruction(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax@,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax@,System.Boolean,Microsoft.CodeAnalysis.CSharp.BoundDeconstructValuePlaceholder)">
            <summary>
            Bind a deconstruction assignment.
            </summary>
            <param name="deconstruction">The deconstruction operation</param>
            <param name="left">The left (tuple) operand</param>
            <param name="right">The right (deconstructable) operand</param>
            <param name="diagnostics">Where to report diagnostics</param>
            <param name="declaration">A variable set to the first variable declaration found in the left</param>
            <param name="expression">A variable set to the first expression in the left that isn't a declaration or discard</param>
            <param name="resultIsUsedOverride">The expression evaluator needs to bind deconstructions (both assignments and declarations) as expression-statements
                and still access the returned value</param>
            <param name="rightPlaceholder"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.FixTupleLiteral(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.DeconstructionVariable},Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>When boundRHS is a tuple literal, fix it up by inferring its types.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MakeDeconstructionConversion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.UInt32,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.DeconstructionVariable},Microsoft.CodeAnalysis.CSharp.Conversion@)">
             <summary>
             Recursively builds a Conversion object with Kind=Deconstruction including information about any necessary
             Deconstruct method and any element-wise conversion.
            
             Note that the variables may either be plain or nested variables.
             The variables may be updated with inferred types if they didn't have types initially.
             Returns false if there was an error.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.SetInferredTypes(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.DeconstructionVariable},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Inform the variables about found types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.FailRemainingInferencesAndSetValEscape(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.DeconstructionVariable},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.UInt32)">
            <summary>
            Find any deconstruction locals that are still pending inference and fail their inference.
            Set the safe-to-escape scope for all deconstruction locals.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.DeconstructionVariable">
            <summary>
            Holds the variables on the LHS of a deconstruction as a tree of bound expressions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MakeMergedTupleType(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.DeconstructionVariable},Microsoft.CodeAnalysis.CSharp.BoundTupleLiteral,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            For cases where the RHS of a deconstruction-declaration is a tuple literal, we merge type information from both the LHS and RHS.
            For cases where the RHS of a deconstruction-assignment is a tuple literal, the type information from the LHS determines the merged type, since all variables have a type.
            Returns null if a merged tuple type could not be fabricated.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ExtractDeconstructResultElementName(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>Extract inferred name from a single deconstruction variable.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MakeDeconstructInvocationExpression(System.Int32,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundDeconstructValuePlaceholder}@,System.Boolean@,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.DeconstructionVariable})">
            <summary>
            Find the Deconstruct method for the expression on the right, that will fit the number of assignable variables on the left.
            Returns an invocation expression if the Deconstruct method is found.
                If so, it outputs placeholders that were coerced to the output types of the resolved Deconstruct method.
            The overload resolution is similar to writing <c>receiver.Deconstruct(out var x1, out var x2, ...)</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindDeconstructionVariables(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax@,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax@)">
            <summary>
            Prepares locals (or fields in global statement) and lvalue expressions corresponding to the variables of the declaration.
            The locals/fields/lvalues are kept in a tree which captures the nesting of variables.
            Each local or field is either a simple local or field access (when its type is known) or a deconstruction variable pending inference.
            The caller is responsible for releasing the nested ArrayBuilders.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindDeconstructionVariable(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            In embedded statements, returns a BoundLocal when the type was explicit.
            In global statements, returns a BoundFieldAccess when the type was explicit.
            Otherwise returns a DeconstructionVariablePendingInference when the type is implicit.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.HasThis(System.Boolean,System.Boolean@)">
            <summary>
            Determines whether "this" reference is available within the current context.
            </summary>
            <param name="isExplicit">The reference was explicitly specified in syntax.</param>
            <param name="inStaticContext">True if "this" is not available due to the current method/property/field initializer being static.</param>
            <returns>True if a reference to "this" is available.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsUnboundTypeAllowed(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax)">
            <summary>
            Returns true if the node is in a position where an unbound type
            such as (C&lt;,&gt;) is allowed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, and the given bound child.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, and the given bound children.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind)">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookup resultKind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookup resultKind and the given bound child.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookupResultKind and given symbols for GetSemanticInfo API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookupResultKind and given symbols for GetSemanticInfo API,
            and the given bound child.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Boolean)">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookupResultKind and given symbols for GetSemanticInfo API,
            and the given bound children.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ToBadExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.LookupResultKind)">
            <summary>
            Helper method to generate a bound expression with HasErrors set to true.
            Returned bound expression is guaranteed to have a non-null type, except when <paramref name="expr"/> is an unbound lambda.
            If <paramref name="expr"/> already has errors and meets the above type requirements, then it is returned unchanged.
            Otherwise, if <paramref name="expr"/> is a BoundBadExpression, then it is updated with the <paramref name="resultKind"/> and non-null type.
            Otherwise, a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> wrapping <paramref name="expr"/> is returned. 
            </summary>
            <remarks>
            Returned expression need not be a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/>, but is guaranteed to have HasErrors set to true.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindValue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind)">
            <summary>
            Bind the expression and verify the expression matches the combination of lvalue and
            rvalue requirements given by valueKind. If the expression was bound successfully, but
            did not meet the requirements, the return value will be a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> that
            (typically) wraps the subexpression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeOrRValue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            When binding a switch case's expression, it is possible that it resolves to a type (technically, a type pattern).
            This implementation permits either an rvalue or a BoundTypeExpression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindToNaturalType(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <summary>
            Bind an rvalue expression to its natural type.  For example, a switch expression that has not been
            converted to another type has to be converted to its own natural type by applying a conversion to
            that type to each of the arms of the switch expression.  This method is a bottleneck for ensuring
            that such a conversion occurs when needed.  It also handles tuple expressions which need to be
            converted to their own natural type because they may contain switch expressions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationVariablesForErrorRecovery(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Bind a declaration variable where it isn't permitted. The caller is expected to produce a diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.RemoveDuplicateInferredTupleNamesAndFreeIfEmptied(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.String}@,System.Collections.Generic.HashSet{System.String})">
            <summary>
            Removes duplicate entries in <paramref name="inferredElementNames"/> and frees it if only nulls remain.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            This can be reached for the qualified name on the right-hand-side of an `is` operator.
            For compatibility we parse it as a qualified name, as the is-type expression only permitted
            a type on the right-hand-side in C# 6. But the same syntax now, in C# 7 and later, can
            refer to a constant, which would normally be represented as a *simple member access expression*.
            Since the parser cannot distinguish, it parses it as before and depends on the binder
            to handle a qualified name appearing as an expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckDisallowedAttributeDependentType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>Called when an "attribute-dependent" type such as 'dynamic', 'string?', etc. is not permitted.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckManagedAddr(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <returns>true if managed type-related errors were found, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckManagedAddr(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.ManagedKind,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <returns>true if managed type-related errors were found, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindIdentifier(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Binds a simple identifier.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.FallBackOnDiscard(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Is this is an _ identifier in a context where discards are allowed?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindExplicitNullableCastFromNonNullable(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
             <summary>
             This implements the casting behavior described in section 6.2.3 of the spec:
             
             - If the nullable conversion is from S to T?, the conversion is evaluated as the underlying conversion 
               from S to T followed by a wrapping from T to T?.
            
             This particular check is done in the binder because it involves conversion processing rules (like overflow
             checking and constant folding) which are not handled by Conversions.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetNameSyntax(Microsoft.CodeAnalysis.SyntaxNode,System.String@)">
            <summary>
            Gets the NameSyntax associated with the syntax node
            If no syntax is attached it sets the nameString to plain text
            name and returns a null NameSyntax
            </summary>
            <param name="syntax">Syntax node</param>
            <param name="nameString">Plain text name</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetName(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Gets the plain text name associated with the expression syntax node
            </summary>
            <param name="syntax">Expression syntax node</param>
            <returns>Plain text name</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckRestrictedTypeInAsyncMethod(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if a bad special by ref local was found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentExpression(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.RefKind,System.Boolean)">
            <summary>
            Bind argument and verify argument matches rvalue or out param requirements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindArrayInitializerExpressions(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Int32,System.Int32)">
            <summary>
            This method walks through the array's InitializerExpressionSyntax and binds all the initializer expressions recursively.
            NOTE: It doesn't convert the bound initializer expressions to array's element type.
            NOTE: This is done separately in ConvertAndBindArrayInitialization method below.
            </summary>
            <param name="initializer">Initializer Syntax.</param>
            <param name="exprBuilder">Bound expression builder.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="dimension">Current array dimension being processed.</param>
            <param name="rank">Rank of the array type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ConvertAndBindArrayInitialization(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol,System.Nullable{System.Int32}[],System.Int32,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Int32@,System.Boolean)">
            <summary>
            Given an array of bound initializer expressions, this method converts these bound expressions
            to array's element type and generates a BoundArrayInitialization with the converted initializers.
            </summary>
            <param name="diagnostics">Diagnostics.</param>
            <param name="node">Initializer Syntax.</param>
            <param name="type">Array type.</param>
            <param name="knownSizes">Known array bounds.</param>
            <param name="dimension">Current array dimension being processed.</param>
            <param name="boundInitExpr">Array of bound initializer expressions.</param>
            <param name="boundInitExprIndex">
            Index into the array of bound initializer expressions to fetch the next bound expression.
            </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Bind the (implicit or explicit) constructor initializer of a constructor symbol (in source).
            </summary>
            <param name="initializerArgumentListOpt">
            Null for implicit, 
            <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax.ArgumentList"/>, or 
            <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax.ArgumentList"/> for explicit.</param>
            <param name="constructor">Constructor containing the initializer.</param>
            <param name="diagnostics">Accumulates errors (e.g. unable to find constructor to invoke).</param>
            <returns>A bound expression for the constructor initializer call.</returns>
            <remarks>
            This method should be kept consistent with Compiler.BindConstructorInitializer (e.g. same error codes).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MakeConstructorInvocation(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Helper method to create a synthesized constructor invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MakeBadExpressionForObjectCreation(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <param name="typeSyntax">Shouldn't be null if <paramref name="initializerOpt"/> is not null.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.TryPerformConstructorOverloadResolution(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,System.String,Microsoft.CodeAnalysis.Location,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.MemberResolutionResult{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol}@,System.Boolean,System.Boolean)">
            <summary>
            Given the type containing constructors, gets the list of candidate instance constructors and uses overload resolution to determine which one should be called.
            </summary>
            <param name="typeContainingConstructors">The containing type of the constructors.</param>
            <param name="analyzedArguments">The already bound arguments to the constructor.</param>
            <param name="errorName">The name to use in diagnostics if overload resolution fails.</param>
            <param name="errorLocation">The location at which to report overload resolution result diagnostics.</param>
            <param name="suppressResultDiagnostics">True to suppress overload resolution result diagnostics (but not argument diagnostics).</param>
            <param name="diagnostics">Where diagnostics will be reported.</param>
            <param name="memberResolutionResult">If this method returns true, then it will contain a valid MethodResolutionResult.
            Otherwise, it may contain a MethodResolutionResult for an inaccessible constructor (in which case, it will incorrectly indicate success) or nothing at all.</param>
            <param name="candidateConstructors">Candidate instance constructors of type <paramref name="typeContainingConstructors"/> used for overload resolution.</param>
            <param name="allowProtectedConstructorsOfBaseType">It is always legal to access a protected base class constructor
            via a constructor initializer, but not from an object creation expression.</param>
            <returns>True if overload resolution successfully chose an accessible constructor.</returns>
            <remarks>
            The two-pass algorithm (accessible constructors, then all constructors) is the reason for the unusual signature
            of this method (i.e. not populating a pre-existing <see cref="T:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1"/>).
            Presently, rationalizing this behavior is not worthwhile.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindMemberAccess(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Binds a member access expression
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindLeftOfPotentialColorColorMemberAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Attempt to bind the LHS of a member access expression.  If this is a Color Color case (spec 7.6.4.1),
            then return a BoundExpression if we can easily disambiguate or a BoundTypeOrValueExpression if we
            cannot.  If this is not a Color Color case, then return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindMemberAccessWithBoundLeft(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Bind the RHS of a member access expression, given the bound LHS.
            It is assumed that CheckValue has not been called on the LHS.
            </summary>
            <remarks>
            If new checks are added to this method, they will also need to be added to <see cref="M:Microsoft.CodeAnalysis.CSharp.Binder.MakeQueryInvocation(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.String,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MakeMemberAccessValue(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Create a value from the expression that can be used as a left-hand-side
            of a member access. This method special-cases method and property
            groups only. All other expressions are returned as is.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindMemberAccessReportError(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.DiagnosticInfo,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Report the error from member access lookup. Or, if there
            was no explicit error from lookup, report "no such member".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ImplementsWinRTAsyncInterface(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return true if the given type is or implements a WinRTAsyncInterface.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindMemberAccessBadResult(Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.DiagnosticInfo,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.LookupResultKind)">
            <summary>
            Return a BoundExpression representing the invalid member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CombineExtensionMethodArguments(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments)">
            <summary>
            Combine the receiver and arguments of an extension method
            invocation into a single argument list to allow overload resolution
            to treat the invocation as a static method invocation with no receiver.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindMemberOfType(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.String,System.Int32,System.Boolean,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.BoundMethodGroupFlags,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Binds a static or instance member access.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetSymbolOrMethodOrPropertyGroup(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.SyntaxNode,System.String,System.Int32,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean@,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol)">
            <summary>
            Given a viable LookupResult, report any ambiguity errors and return either a single
            non-method symbol or a method or property group. If the result set represents a
            collection of methods or a collection of properties where at least one of the properties
            is an indexed property, then 'methodOrPropertyGroup' is populated with the method or
            property group and the method returns null. Otherwise, the method returns a single
            symbol and 'methodOrPropertyGroup' is empty. (Since the result set is viable, there
            must be at least one symbol.) If the result set is ambiguous - either containing multiple
            members of different member types, or multiple properties but no indexed properties -
            then a diagnostic is reported for the ambiguity and a single symbol is returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.TryBindIndexOrRangeImplicitIndexerParts(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundImplicitIndexerReceiverPlaceholder,System.Boolean,Microsoft.CodeAnalysis.CSharp.BoundExpression@,Microsoft.CodeAnalysis.CSharp.BoundExpression@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundImplicitIndexerValuePlaceholder}@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Finds pattern-based implicit indexer and Length/Count property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroup(Microsoft.CodeAnalysis.CSharp.BoundMethodGroup,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,System.Boolean,Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.CallingConventionInfo@)">
            <summary>
            Perform lookup and overload resolution on methods defined directly on the class and any
            extension methods in scope. Lookup will occur for extension methods in all nested scopes
            as necessary until an appropriate method is found. If analyzedArguments is null, the first
            method group is returned, without overload resolution being performed. That method group
            will either be the methods defined on the receiver class directly (no extension methods)
            or the first set of extension methods.
            </summary>
            <param name="node">The node associated with the method group</param>
            <param name="analyzedArguments">The arguments of the invocation (or the delegate type, if a method group conversion)</param>
            <param name="isMethodGroupConversion">True if it is a method group conversion</param>
            <param name="useSiteInfo"></param>
            <param name="inferWithDynamic"></param>
            <param name="returnRefKind">If a method group conversion, the desired ref kind of the delegate</param>
            <param name="returnType">If a method group conversion, the desired return type of the delegate.
            May be null during inference if the return type of the delegate needs to be computed.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetUniqueSignatureFromMethodGroup(Microsoft.CodeAnalysis.CSharp.BoundMethodGroup)">
            <summary>
            Returns one of the methods from the method group if all methods in the method group
            have the same signature, ignoring parameter names and custom modifiers. The particular
            method returned is not important since the caller is interested in the signature only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.BinderWithContainingMemberOrLambda">
            <summary>
            Represents a small change from the enclosing/next binder.
            Can specify a BindingLocation and a ContainingMemberOrLambda.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.BinderWithConditionalReceiver">
            <summary>
            Represents a small change from the enclosing/next binder.
            Can specify a receiver Expression for containing conditional member access.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.WithAdditionalFlagsAndContainingMemberOrLambda(Microsoft.CodeAnalysis.CSharp.BinderFlags,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            It seems to be common to do both of these things at once, so provide a way to do so
            without adding two links to the binder chain.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindRegularCSharpFieldInitializers(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer}},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundInitializer},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.ImportChain@)">
            <summary>
            In regular C#, all field initializers are assignments to fields and the assigned expressions
            may not reference instance members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindScriptFieldInitializers(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedInteractiveInitializerMethod,System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer}},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundInitializer},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.ImportChain@)">
            <summary>
            In script C#, some field initializers are assignments to fields and others are global
            statements.  There are no restrictions on accessing instance members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MakeInvocationExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Collections.Immutable.ImmutableArray{System.Nullable{System.ValueTuple{System.String,Microsoft.CodeAnalysis.Location}}},Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Helper method to create a synthesized method invocation expression.
            </summary>
            <param name="node">Syntax Node.</param>
            <param name="receiver">Receiver for the method call.</param>
            <param name="methodName">Method to be invoked on the receiver.</param>
            <param name="args">Arguments to the method call.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="typeArgsSyntax">Optional type arguments syntax.</param>
            <param name="typeArgs">Optional type arguments.</param>
            <param name="queryClause">The syntax for the query clause generating this invocation expression, if any.</param>
            <param name="allowFieldsAndProperties">True to allow invocation of fields and properties of delegate type. Only methods are allowed otherwise.</param>
            <param name="allowUnexpandedForm">False to prevent selecting a params method in unexpanded form.</param>
            <returns>Synthesized method invocation expression.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Bind an expression as a method invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Boolean)">
            <summary>
            Bind an expression as a method invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpressionContinued(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol},Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,Microsoft.CodeAnalysis.CSharp.MethodGroup,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Perform overload resolution on the method group or expression (BoundMethodGroup)
            and arguments and return a BoundExpression representing the invocation.
            </summary>
            <param name="node">Invocation syntax node.</param>
            <param name="expression">The syntax for the invoked method, including receiver.</param>
            <param name="methodName">Name of the invoked method.</param>
            <param name="result">Overload resolution result for method group executed by caller.</param>
            <param name="analyzedArguments">Arguments bound by the caller.</param>
            <param name="methodGroup">Method group if the invocation represents a potentially overloaded member.</param>
            <param name="delegateTypeOpt">Delegate type if method group represents a delegate.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="queryClause">The syntax for the query clause generating this invocation expression, if any.</param>
            <returns>BoundCall or error expression representing the invocation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckImplicitThisCopyInReadOnlyMember(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Returns false if an implicit 'this' copy will occur due to an instance member invocation in a readonly member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetLocationForOverloadResolutionDiagnostic(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <param name="node">Invocation syntax node.</param>
            <param name="expression">The syntax for the invoked method, including receiver.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReplaceTypeOrValueReceiver(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Replace a BoundTypeOrValueExpression with a BoundExpression for either a type (if useType is true)
            or a value (if useType is false).  Any other node is bound to its natural type.
            </summary>
            <remarks>
            Call this once overload resolution has succeeded on the method group of which the BoundTypeOrValueExpression
            is the receiver.  Generally, useType will be true if the chosen method is static and false otherwise.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetDelegateType(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Return the delegate type if this expression represents a delegate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetCorrespondingParameterType(Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,System.Int32,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol})">
            <summary>
            Compute the type of the corresponding parameter, if any. This is used to improve error recovery,
            for bad invocations, not for semantic analysis of correct invocations, so it is a heuristic.
            If no parameter appears to correspond to the given argument, we return null.
            </summary>
            <param name="analyzedArguments">The analyzed argument list</param>
            <param name="i">The index of the argument</param>
            <param name="parameterList">The parameter list to match against</param>
            <returns>The type of the corresponding parameter.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BuildArgumentsForErrorRecovery(Microsoft.CodeAnalysis.CSharp.AnalyzedArguments)">
            <summary>
            Absent parameter types to bind the arguments, we simply use the arguments provided for error recovery.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckSyntaxForNameofArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.String@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <summary>
            Returns true if syntax form is OK (so no errors were reported)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.InvocableNameofInScope">
            <summary>
            Helper method that checks whether there is an invocable 'nameof' in scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupSymbolsSimpleName(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.Int32,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.LookupOptions,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Performs name lookup for simple generic or non-generic name
            within an optional qualifier namespace or type symbol.
            If LookupOption.AttributeTypeOnly is set, then it performs
            attribute type lookup which involves attribute name lookup
            with and without "Attribute" suffix.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupSymbolsWithFallback(Microsoft.CodeAnalysis.CSharp.LookupResult,System.String,System.Int32,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <summary>
            Look for any symbols in scope with the given name and arity.
            </summary>
            <remarks>
            Makes a second attempt if the results are not viable, in order to produce more detailed failure information (symbols and diagnostics).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupSymbolsOrMembersInternal(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.Int32,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.LookupOptions,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            If qualifierOpt is null, look for any symbols in
            scope with the given name and arity.
            Otherwise look for symbols that are members of the specified qualifierOpt.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupMembersWithFallback(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <summary>
            Look for symbols that are members of the specified namespace or type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupMembersInSubmissions(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax,System.Boolean,System.String,System.Int32,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Binder,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Lookup a member name in a submission chain.
            </summary>
            <remarks>
            We start with the current submission class and walk the submission chain back to the first submission.
            The search has two phases
            1) We are looking for any symbol matching the given name, arity, and options. If we don't find any the search is over.
               If we find and overloadable symbol(s) (a method or an indexer) we start looking for overloads of this kind 
               (lookingForOverloadsOfKind) of symbol in phase 2.
            2) If a visited submission contains a matching member of a kind different from lookingForOverloadsOfKind we stop 
               looking further. Otherwise, if we find viable overload(s) we add them into the result.
               
            Note that indexers are not supported in script but we deal with them here to handle errors.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupExtensionMethodsInSingleBinder(Microsoft.CodeAnalysis.CSharp.ExtensionMethodScope,Microsoft.CodeAnalysis.CSharp.LookupResult,System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Lookup extension methods by name and arity in the given binder and
            check viability in this binder. The lookup is performed on a single
            binder because extension method search stops at the first applicable
            method group from the nearest enclosing namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupAttributeType(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.Int32,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.LookupOptions,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Lookup attribute name in the given binder. By default two name lookups are performed:
                (1) With the provided name
                (2) With an Attribute suffix added to the provided name
            Lookup with Attribute suffix is performed only if LookupOptions.VerbatimAttributeName is not set.
            
            If either lookup is ambiguous, we return the corresponding result with ambiguous symbols.
            Else if exactly one result is single viable attribute type, we return that result.
            Otherwise, we return a non-viable result with LookupResult.NotAnAttributeType or an empty result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetCandidateExtensionMethods(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol},System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Return the extension methods from this specific binding scope that match the name and optional
            arity. Since the lookup of extension methods is iterative, proceeding one binding scope at a time,
            GetCandidateExtensionMethods should not defer to the next binding scope. Instead, the caller is
            responsible for walking the nested binding scopes from innermost to outermost. This method is overridden
            to search the available members list in binding types that represent types, namespaces, and usings.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.AddWinRTMembers(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Binder,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            If the type implements one of a select few WinRT interfaces, the interface type is
            projected to the CLR collection type (e.g., IVector to IList).
            When importing a winmd type it may implement one or more winmd collection
            interfaces. When the collection interfaces are projected, we may need
            to add the projected members to the imported type so that calls to those
            members succeed as normal. This method adds the interface methods to
            the lookup, if necessary. The CLR understands that a call to the .NET interface
            should be projected onto the WinRT interface method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsMethodOrIndexer(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            This helper is used to determine whether this symbol hides / is hidden
            based on its signature, as opposed to its name.
            </summary>
            <remarks>
            CONSIDER: It might be nice to generalize this - maybe an extension method
            on Symbol (e.g. IsOverloadable or HidesByName).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckViability(Microsoft.CodeAnalysis.CSharp.Symbol,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <remarks>
            Distinguish from <see cref="M:Microsoft.CodeAnalysis.CSharp.Binder.CanAddLookupSymbolInfo(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.LookupSymbolsInfo,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol)"/>, which performs an analogous task for Add*LookupSymbolsInfo*.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CanAddLookupSymbolInfo(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.LookupSymbolsInfo,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol)">
            <summary>
            Used by Add*LookupSymbolsInfo* to determine whether the symbol is of interest.
            Distinguish from <see cref="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckViability(Microsoft.CodeAnalysis.CSharp.Symbol,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})"/>, which performs an analogous task for LookupSymbols*.
            </summary>
            <remarks>
            Does not consider <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.CanBeReferencedByName"/> - that is left to the caller.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsCrefAccessible(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            A symbol is accessible for referencing in a cref if it is in the same assembly as the reference
            or the symbols's effective visibility is not private.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Check whether "symbol" is accessible from this binder.
            Also checks protected access via "accessThroughType".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Check whether "symbol" is accessible from this binder.
            Also checks protected access via "accessThroughType", and sets "failedThroughTypeCheck" if fails
            the protected access check.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsAccessibleHelper(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <remarks>
            Should only be called by <see cref="M:Microsoft.CodeAnalysis.CSharp.Binder.IsAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})"/>,
            which will already have checked for <see cref="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.IgnoreAccessibility"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.AddLookupSymbolsInfo(Microsoft.CodeAnalysis.CSharp.LookupSymbolsInfo,Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <summary>
            Look for names in scope
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.AddMemberLookupSymbolsInfo(Microsoft.CodeAnalysis.CSharp.LookupSymbolsInfo,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Look for names of members
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ValidateNameConflictsInScope(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.Location,System.String,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <remarks>
            Don't call this one directly - call one of the helpers.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindEventAssignment(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BoundEventAccess,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            For "receiver.event += expr", produce "receiver.add_event(expr)".
            For "receiver.event -= expr", produce "receiver.remove_event(expr)".
            </summary>
            <remarks>
            Performs some validation of the accessor that couldn't be done in CheckEventValueKind, because
            the specific accessor wasn't known.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.TryFoldingNullableEquality(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            If one of the (unconverted) operands has constant value null and the other has
            a null constant value other than null, then they are definitely not equal
            and we can give a constant value for either == or !=.  This is a spec violation
            that we retain from Dev10.
            </summary>
            <param name="kind">The operator kind.  Nothing will happen if it is not a lifted equality operator.</param>
            <param name="left">The left-hand operand of the operation (possibly wrapped in a conversion).</param>
            <param name="right">The right-hand operand of the operation (possibly wrapped in a conversion).</param>
            <returns>
            If the operator represents lifted equality, then constant value true if both arguments have constant
            value null, constant value false if exactly one argument has constant value null, and null otherwise.
            If the operator represents lifted inequality, then constant value false if both arguments have constant
            value null, constant value true if exactly one argument has constant value null, and null otherwise.
            </returns>
            <remarks>
            SPEC VIOLATION: according to the spec (section 7.19) constant expressions cannot
            include implicit nullable conversions or nullable subexpressions.  However, Dev10
            specifically folds over lifted == and != (see ExpressionBinder::TryFoldingNullableEquality).
            Dev 10 does do compile-time evaluation of simple lifted operators, but it does so
            in a rewriting pass (see NullableRewriter) - they are not treated as constant values.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.FoldStringConcatenation(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            Returns ConstantValue.Bad if, and only if, the resulting string length exceeds <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckConstraintLanguageVersionAndRuntimeSupportForOperator(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Returns false if reported an error, true otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsMoveableVariable(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbol@)">
            <summary>
            Checks to see whether an expression is a "moveable" variable according to the spec. Moveable
            variables have underlying memory which may be moved by the runtime. The spec defines anything
            not fixed as moveable and specifies the expressions which are fixed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetIsOperatorConstantResult(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.ConversionKind,Microsoft.CodeAnalysis.ConstantValue,System.Boolean)">
            <summary>
            Possible return values:
             - <see cref="P:Microsoft.CodeAnalysis.ConstantValue.False"/>
             - <see cref="P:Microsoft.CodeAnalysis.ConstantValue.True"/>
             - <see cref="P:Microsoft.CodeAnalysis.ConstantValue.Bad"/> - compiler doesn't support the type check, i.e. cannot perform it, even at runtime
             - 'null' value - result is not known at compile time    
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetAsOperatorConstantResult(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.ConversionKind,Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            Possible return values:
             - <see cref="P:Microsoft.CodeAnalysis.ConstantValue.Null"/>
             - <see cref="P:Microsoft.CodeAnalysis.ConstantValue.Bad"/> - compiler doesn't support the type check, i.e. cannot perform it, even at runtime
             - 'null' value - result is not known at compile time    
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindConditionalOperator(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
             <remarks>
             From ExpressionBinder::EnsureQMarkTypesCompatible:
            
             The v2.0 specification states that the types of the second and third operands T and S of a conditional operator
             must be TT and TS such that either (a) TT==TS, or (b), TT->TS or TS->TT but not both.
            
             Unfortunately that is not what we implemented in v2.0.  Instead, we implemented
             that either (a) TT=TS or (b) T->TS or S->TT but not both.  That is, we looked at the
             convertibility of the expressions, not the types.
            
            
             Changing that to the algorithm in the standard would be a breaking change.
            
             b ? (Func&lt;int&gt;)(delegate(){return 1;}) : (delegate(){return 2;})
            
             and
            
             b ? 0 : myenum
            
             would suddenly stop working.  (The first because o2 has no type, the second because 0 goes to
             any enum but enum doesn't go to int.)
            
             It gets worse.  We would like the 3.0 language features which require type inference to use
             a consistent algorithm, and that furthermore, the algorithm be smart about choosing the best
             of a set of types.  However, the language committee has decided that this algorithm will NOT
             consume information about the convertibility of expressions. Rather, it will gather up all
             the possible types and then pick the "largest" of them.
            
             To maintain backwards compatibility while still participating in the spirit of consistency,
             we implement an algorithm here which picks the type based on expression convertibility, but
             if there is a conflict, then it chooses the larger type rather than producing a type error.
             This means that b?0:myshort will have type int rather than producing an error (because 0->short,
             myshort->int).
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.FoldConditionalOperator(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Constant folding for conditional (aka ternary) operators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsCountableAndIndexable(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol@)">
            <summary>
            Types which list-patterns can be used on (ie. countable and indexable ones) are assumed to have
            non-negative lengths.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionOrTypeForPattern(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Boolean@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.ConstantValue@,System.Boolean@,Microsoft.CodeAnalysis.CSharp.Conversion@)">
            <summary>
            Binds the expression for a pattern.  Sets <paramref name="wasExpression"/> if it was a type rather than an expression,
            and in that case it returns a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundTypeExpression"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionForPattern(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Boolean@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.ConstantValue@,System.Boolean@,Microsoft.CodeAnalysis.CSharp.Conversion@)">
            <summary>
            Binds the expression for an is-type right-hand-side, in case it does not bind as a type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckValidPatternType(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Check that the pattern type is valid for the operand. Return true if an error was reported.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ExpressionOfTypeMatchesPatternType(Microsoft.CodeAnalysis.CSharp.Conversions,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Microsoft.CodeAnalysis.CSharp.Conversion@,Microsoft.CodeAnalysis.ConstantValue,System.Boolean)">
            <summary>
            Does an expression of type <paramref name="expressionType"/> "match" a pattern that looks for
            type <paramref name="patternType"/>?
             - <see cref="P:Microsoft.CodeAnalysis.ConstantValue.True"/> if the matched type catches all of them
             - <see cref="P:Microsoft.CodeAnalysis.ConstantValue.False"/> if it catches none of them
             - <see cref="P:Microsoft.CodeAnalysis.ConstantValue.Bad"/> - compiler doesn't support the type check, i.e. cannot perform it, even at runtime
             - 'null' if it might catch some of them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.UInt32)">
            <summary>
            Compute the val escape of an expression of the given <paramref name="type"/>, which is known to be derived
            from an expression whose escape scope is <paramref name="possibleValEscape"/>. By the language rules, the
            result is either that same scope (if the type is a ref struct type) or <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.CallingMethodScope"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckIsTupleElement(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Check that the given name designates a tuple element at the given index, and return that element.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.RelationalOperatorType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Compute the type code for the comparison operator to be used.  When comparing `byte`s for example,
            the compiler actually uses the operator on the type `int` as there is no corresponding operator for
            the type `byte`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportQueryLookupFailed(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            This is a clone of the Dev10 logic for reporting query errors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.LockedOrDisposedVariables">
            <summary>
            This is the set of parameters and local variables that were used as arguments to
            lock or using statements in enclosing scopes.
            </summary>
            <remarks>
            using (x) { } // x counts
            using (IDisposable y = null) { } // y does not count
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <remarks>
            Noteworthy override is in MemberSemanticModel.IncrementalBinder (used for caching).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckForUnobservedAwaitable(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Report an error if this is an awaitable async method invocation that is not being awaited.
            </summary>
            <remarks>
            The checks here are equivalent to StatementBinder::CheckForUnobservedAwaitable() in the native compiler.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.TryFindDisposePatternMethod(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Checks for a Dispose method on <paramref name="expr"/> and returns its <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/> if found.
            </summary>
            <param name="expr">Expression on which to perform lookup</param>
            <param name="syntaxNode">The syntax node to perform lookup on</param>
            <param name="diagnostics">Populated with invocation errors, and warnings of near misses</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/> of the Dispose method if one is found, otherwise null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetFixedLocalCollectionInitializer(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Wrap the initializer in a BoundFixedLocalCollectionInitializer so that the rewriter will have the
            information it needs (e.g. conversions, helper methods).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetBadEventUsageDiagnosticInfo(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol)">
            <summary>
            There are two BadEventUsage error codes and this method decides which one should
            be used for a given event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.LocalScopeDepth">
            <summary>
            Returns a value that tells how many local scopes are visible, including the current.
            I.E. outside of any method will be 0
                 immediately inside a method - 1
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindForEachDeconstruction(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Like BindForEachParts, but only bind the deconstruction part of the foreach, for purpose of inferring the types of the declared locals.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CreateBlockFromExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Wrap a given expression e into a block as either { e; } or { return e; }
            Shared between lambda and expression-bodied method binding.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionBodyAsBlock(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Binds an expression-bodied member with expression e as either { return e; } or { e; }.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindLambdaExpressionAsBlock(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Binds a lambda with expression e as either { return e; } or { e; }.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindImplicitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Bind the implicit constructor initializer of a constructor symbol.
            </summary>
            <param name="constructor">Constructor method.</param>
            <param name="diagnostics">Accumulates errors (e.g. access "this" in constructor initializer).</param>
            <param name="compilation">Used to retrieve binder.</param>
            <returns>A bound expression for the constructor initializer call.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ExternAliases">
            <summary>
            If this binder owns the scope that can declare extern aliases, a set of declared aliases should be returned (even if empty).
            Otherwise, a default instance should be returned. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.UsingAliases">
            <summary>
            If this binder owns the scope that can declare using aliases, a set of declared aliases should be returned (even if empty).
            Otherwise, a default instance should be returned. 
            Note, only aliases syntactically declared within the enclosing declaration are included. For example, global aliases
            declared in a different compilation units are not included.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.PerformPatternMethodLookup(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@)">
            <summary>
            Perform a lookup for the specified method on the specified expression by attempting to invoke it
            </summary>
            <param name="receiver">The expression to perform pattern lookup on</param>
            <param name="methodName">Method to search for.</param>
            <param name="syntaxNode">The expression for which lookup is being performed</param>
            <param name="diagnostics">Populated with binding diagnostics.</param>
            <param name="result">The method symbol that was looked up, or null</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.CSharp.PatternLookupResult"/> value with the outcome of the lookup</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeOrVarKeyword(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean@)">
            <summary>
            Binds the type for the syntax taking into account possibility of "var" type.
            </summary>
            <param name="syntax">Type syntax to bind.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="isVar">
            Set to false if syntax binds to a type in the current context and true if
            syntax is "var" and it binds to "var" keyword in the current context.
            </param>
            <returns>
            Bound type if syntax binds to a type in the current context and
            null if syntax binds to "var" keyword in the current context.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeOrConstraintKeyword(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Binder.ConstraintContextualKeyword@)">
            <summary>
            Binds the type for the syntax taking into account possibility of "unmanaged" type.
            </summary>
            <param name="syntax">Type syntax to bind.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="keyword">
            Set to <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.ConstraintContextualKeyword.None"/> if syntax binds to a type in the current context, otherwise
            syntax binds to the corresponding keyword in the current context.
            </param>
            <returns>
            Bound type if syntax binds to a type in the current context and
            null if syntax binds to a contextual constraint keyword.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeOrVarKeyword(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean@,Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol@)">
            <summary>
            Binds the type for the syntax taking into account possibility of "var" type.
            </summary>
            <param name="syntax">Type syntax to bind.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="isVar">
            Set to false if syntax binds to a type in the current context and true if
            syntax is "var" and it binds to "var" keyword in the current context.
            </param>
            <param name="alias">Alias symbol if syntax binds to an alias.</param>
            <returns>
            Bound type if syntax binds to a type in the current context and
            null if syntax binds to "var" keyword in the current context.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeOrAliasOrVarKeyword(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean@)">
            <summary>
            Binds the type for the syntax taking into account possibility of "var" type.
            If the syntax binds to an alias symbol to a type, it returns the alias symbol.
            </summary>
            <param name="syntax">Type syntax to bind.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="isVar">
            Set to false if syntax binds to a type or alias to a type in the current context and true if
            syntax is "var" and it binds to "var" keyword in the current context.
            </param>
            <returns>
            Bound type or alias if syntax binds to a type or alias to a type in the current context and
            null if syntax binds to "var" keyword in the current context.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeOrAliasOrKeyword(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean@)">
            <summary>
            Binds the type for the syntax taking into account possibility of the type being a keyword.
            If the syntax binds to an alias symbol to a type, it returns the alias symbol.
            PREREQUISITE: syntax should be checked to match the keyword, like <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax.IsVar"/> or <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax.IsUnmanaged"/>.
            Otherwise, call <see cref="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeOrAlias(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},System.Boolean)"/> instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetContainingNamespaceOrType(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            The immediately containing namespace or named type, or the global
            namespace if containing symbol is neither a namespace or named type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},System.Boolean)">
            <summary>
            This method is used in deeply recursive parts of the compiler and requires a non-trivial amount of stack
            space to execute. Preventing inlining here to keep recursive frames small.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeOrAliasSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},System.Boolean)">
             <summary>
             Bind the syntax into a namespace, type or alias symbol.
             </summary>
             <remarks>
             This method is used in deeply recursive parts of the compiler. Specifically this and
             <see cref="M:Microsoft.CodeAnalysis.CSharp.Binder.BindQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},System.Boolean)"/>
             are mutually recursive. The non-recursive parts of this method tend to reserve significantly large
             stack frames due to their use of large struct like <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations"/>.
            
             To keep the stack frame size on recursive paths small the non-recursive parts are factored into local
             functions. This means we pay their stack penalty only when they are used. They are themselves big
             enough they should be disqualified from inlining. In the future when attributes are allowed on
             local functions we should explicitly mark them as <see cref="F:System.Runtime.CompilerServices.MethodImplOptions.NoInlining"/>
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindSimpleNamespaceOrTypeOrAliasSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol)">
            <summary>
            Binds a simple name or the simple name portion of a qualified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindNativeIntegerSymbolIfAny(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            If the node is "nint" or "nuint" and not alone inside nameof, return the corresponding native integer symbol.
            Otherwise return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ConstructNamedTypeUnlessTypeArgumentOmitted(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <remarks>
            Keep check and error in sync with ConstructBoundMethodGroupAndReportOmittedTypeArguments.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ConstructBoundMemberGroupAndReportOmittedTypeArguments(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},Microsoft.CodeAnalysis.CSharp.BoundExpression,System.String,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.BoundMethodGroupFlags,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <remarks>
            Keep check and error in sync with ConstructNamedTypeUnlessTypeArgumentOmitted.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ShouldCheckConstraints">
            <summary>
            Check generic type constraints unless the type is used as part of a type or method
            declaration. In those cases, constraints checking is handled by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the special
            member isn't found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUseSite(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Reports use-site diagnostics and dependencies for the specified symbol.
            </summary>
            <returns>
            True if there was an error among the reported diagnostics
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUseSite(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.Location)">
            <summary>
            Reports use-site diagnostics and dependencies for the specified symbol.
            </summary>
            <returns>
            True if there was an error among the reported diagnostics
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the well-known
            type isn't found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.Location)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the well-known
            type isn't found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetWellKnownType(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.WellKnownType,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the well-known
            type isn't found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the well-known
            type isn't found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetWellKnownTypeMember(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Retrieves a well-known type member and reports diagnostics.
            </summary>
            <returns>Null if the symbol is missing.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo.Index">
            <summary>
            Returns -1 if None.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo.Sort(Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo@,Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo@)">
            <summary>
            Prefers symbols from source module, then from added modules, then from referenced assemblies.
            Returns true if values were swapped.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo.IsSecondLocationBetter(Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolLocation,Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolLocation)">
            <summary>
            Returns true if the second is a better location than the first.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetBestSymbolInfo(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo@)">
            <summary>
            Prefer symbols from source module, then from added modules, then from referenced assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.NotFound(Microsoft.CodeAnalysis.SyntaxNode,System.String,System.Int32,System.String,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.String,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <remarks>
            This is only intended to be called when the type isn't found (i.e. not when it is found but is inaccessible, has the wrong arity, etc).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetForwardedToAssembly(System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.Location)">
            <summary>
            Look for a type forwarder for the given type in the containing assembly and any referenced assemblies.
            </summary>
            <param name="name">The name of the (potentially) forwarded type.</param>
            <param name="arity">The arity of the forwarded type.</param>
            <param name="qualifierOpt">The namespace of the potentially forwarded type. If none is provided, will
            try Usings of the current import for eligible namespaces and return the namespace of the found forwarder,
            if any.</param>
            <param name="diagnostics">Will be used to report non-fatal errors during look up.</param>
            <param name="location">Location to report errors on.</param>
            <returns>Returns the Assembly to which the type is forwarded, or null if none is found.</returns>
            <remarks>
            Since this method is intended to be used for error reporting, it stops as soon as it finds
            any type forwarder (or an error to report). It does not check other assemblies for consistency or better results.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTupleBinaryOperator(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            If the left and right are tuples of matching cardinality, we'll try to bind the operator element-wise.
            When that succeeds, the element-wise conversions are collected. We keep them for semantic model.
            The element-wise binary operators are collected and stored as a tree for lowering.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTupleBinaryOperatorInfo(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Binds:
            1. dynamically, if either side is dynamic
            2. as tuple binary operator, if both sides are tuples of matching cardinalities
            3. as regular binary operator otherwise
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.PrepareBoolConversionAndTruthOperator(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.BoundExpression@,Microsoft.CodeAnalysis.CSharp.BoundValuePlaceholder@,Microsoft.CodeAnalysis.CSharp.UnaryOperatorSignature@)">
            <summary>
            If an element-wise binary operator returns a non-bool type, we will either:
            - prepare a conversion to bool if one exists
            - prepare a truth operator: op_false in the case of an equality (<c>a == b</c> will be lowered to <c>!((a == b).op_false)</c>) or op_true in the case of inequality,
                with the conversion being used for its input.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportNamesMismatchesIfAny(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
             <summary>
             If an element in a tuple literal has an explicit name which doesn't match the name on the other side, we'll warn.
             The user can either remove the name, or fix it.
            
             This method handles two expressions, each of which is either a tuple literal or an expression with tuple type.
             In a tuple literal, each element can have an explicit name, an inferred name or no name.
             In an expression of tuple type, each element can have a name or not.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetTupleArgumentsOrPlaceholders(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Given a tuple literal or expression, we'll get two arrays:
            - the elements from the literal, or some placeholder with proper type (for tuple expressions)
            - the elements' names
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MakeConvertedType(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Make a tuple type (with appropriate nesting) from the types (on the left or on the right) collected
            from binding element-wise binary operators.
            If any of the elements is typeless, then the tuple is typeless too.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.InUnsafeRegion">
            <summary>
            True if we are currently in an unsafe region (type, member, or block).
            </summary>
            <remarks>
            Does not imply that this compilation allows unsafe regions (could be in an error recovery scenario).
            To determine that, check this.Compilation.Options.AllowUnsafe.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUnsafeIfNotAllowed(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <returns>True if a diagnostic was reported</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUnsafeIfNotAllowed(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <returns>True if a diagnostic was reported</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.GetMethodName(Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Get the name of the method so that it can be looked up in the containing type.
            </summary>
            <param name="baseMethodDeclarationSyntax">Non-null declaration syntax.</param>
            <param name="outerBinder">Binder for the scope around the method (may be null for operators, constructors, and destructors).</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.GetPropertyOrEventName(Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Get the name of the property, indexer, or event so that it can be looked up in the containing type.
            </summary>
            <param name="basePropertyDeclarationSyntax">Non-null declaration syntax.</param>
            <param name="outerBinder">Non-null binder for the scope around the member.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.InSpan(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if the location is within the syntax tree and span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.InSpan(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if one of the locations is within the syntax tree and span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.IsInUsing(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Returns true if containingNode has a child that contains the specified position
            and has kind UsingDirective.
            </summary>
            <remarks>
            Usings can't see other usings, so this is extra info when looking at a namespace
            or compilation unit scope.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax)">
            <remarks>
            Used to detect whether we are in a cref parameter type.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax)">
            <remarks>
            Used to detect whether we are in a cref return type.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.GetParameterNameAttributeValueBinder(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            We're in a &lt;param&gt; or &lt;paramref&gt; element, so we want a binder that can see
            the parameters of the associated member and nothing else.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.GetTypeParameterNameAttributeValueBinder(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Boolean,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            We're in a &lt;typeparam&gt; or &lt;typeparamref&gt; element, so we want a binder that can see
            the type parameters of the associated member and nothing else.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.MakeCrefBinder(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.BinderFactory,System.Boolean)">
            <summary>
            Given a CrefSyntax and an associated member declaration syntax node,
            construct an appropriate binder for binding the cref.
            </summary>
            <param name="crefSyntax">Cref that will be bound.</param>
            <param name="memberSyntax">The member to which the documentation comment (logically) containing
            the cref syntax applies.</param>
            <param name="factory">Corresponding binder factory.</param>
            <param name="inParameterOrReturnType">True to get a special binder for cref parameter and return types.</param>
            <remarks>
            The CrefSyntax does not actually have to be within the documentation comment on the member - it
            could be included from another file.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.MakeCrefBinderInternal(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.CSharp.Binder,System.Boolean)">
            <summary>
            Internal version of MakeCrefBinder that allows the caller to explicitly set the underlying binder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.GetEnclosingDocumentationComment(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Walk up from an XML syntax node (attribute or tag) to the enclosing documentation comment trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.GetBinder(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Return binder for binding at node.
            <paramref name="memberDeclarationOpt"/> and <paramref name="memberOpt"/>
            are optional syntax and symbol for the member containing <paramref name="node"/>.
            If provided, the <see cref="T:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor"/> will use the member symbol rather
            than looking up the member in the containing type, allowing this method to be called
            while calculating the member list.
            </summary>
            <remarks>
            Note, there is no guarantee that the factory always gives back the same binder instance for the same node.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BinderFlags">
            <summary>
            A specific location for binding.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.UnsafeRegion">
            <summary>
            Indicates that the current context allows unsafe constructs.
            </summary>
            <remarks>
            NOTE: Dev10 doesn't seem to treat attributes as being within the unsafe region.
            Fortunately, not following this behavior should not be a breaking change since
            attribute arguments have to be constants and there are no constants of unsafe
            types.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.SuppressUnsafeDiagnostics">
            <summary>
            Indicates that the unsafe diagnostics are not reported in the current context, regardless
            of whether or not it is (part of) an unsafe region.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.SemanticModel">
            <summary>
            Indicates that this binder is being used to answer SemanticModel questions (i.e. not
            for batch compilation).
            </summary>
            <remarks>
            Imports touched by a binder with this flag set are not consider "used".
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.CheckedRegion">
            <summary>Remarks, mutually exclusive with <see cref="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.UncheckedRegion"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.UncheckedRegion">
            <summary>Remarks, mutually exclusive with <see cref="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.CheckedRegion"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.AllowMoveableAddressOf">
            <summary>
            In the debugger, one can take the address of a moveable variable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.AllowAwaitInUnsafeContext">
            <summary>
            In the debugger, the context is always unsafe, but one can still await.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.IgnoreCorLibraryDuplicatedTypes">
            <summary>
            Ignore duplicate types from the cor library.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.InContextualAttributeBinder">
            <summary>
            This is a <see cref="T:Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder"/>, or has <see cref="T:Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder"/> as its parent.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.InEEMethodBinder">
            <summary>
            Are we binding for the purpose of an Expression Evaluator
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.SuppressTypeArgumentBinding">
            <summary>
            Skip binding type arguments (we use <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.PlaceholderTypeArgumentSymbol"/> instead).
            For example, currently used when type constraints are bound in some scenarios.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.InExpressionTree">
            <summary>
            The current context is an expression tree
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BinderFlagsExtensions">
            <summary>
            Extension methods for the <see cref="T:Microsoft.CodeAnalysis.CSharp.BinderFlags"/> type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BuckStopsHereBinder">
            <summary>
            A binder that knows no symbols and will not delegate further.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BuckStopsHereBinder.AssociatedFileIdentifier">
            <summary>
            * In non-speculative scenarios, the identifier for the file being bound.
            * In speculative scenarios, the identifier for the file from the original compilation used as the speculation context.
            * In EE scenarios, the identifier for the file from the original compilation used as the evaluation context.
            
            This is <see langword="null"/> in some scenarios, such as the binder used for <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Conversions" />
            or the binder used to bind usings in <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.UsingsFromOptionsAndDiagnostics"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BuckStopsHereBinder.QuickAttributeChecker">
            <summary>
            Get <see cref="P:Microsoft.CodeAnalysis.CSharp.BuckStopsHereBinder.QuickAttributeChecker"/> that can be used to quickly
            check for certain attribute applications in context of this binder.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConstantFieldsInProgress">
            <summary>
            This is used while computing the values of constant fields.  Since they can depend on each
            other, we need to keep track of which ones we are currently computing in order to avoid (and
            report) cycles.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConstantFieldsInProgressBinder">
            <summary>
            This binder keeps track of the set of constant fields that are currently being evaluated
            so that the set can be passed into the next call to SourceFieldSymbol.ConstantValue (and
            its callers).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder">
            <summary>
            Each application of an attribute is effectively a constructor call.  Since the attribute constructor
            might have a CallerMemberName parameter, we need to keep track of which method/property/event
            the attribute is on/in (e.g. on a parameter) so that we can use the name of that member as the 
            CallerMemberName argument.
            This binder is also needed when a <see cref="T:Microsoft.CodeAnalysis.CSharp.NameofBinder"/> introduces type parameters to a scope within an attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder.#ctor(Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <param name="enclosing">Next binder in the chain (enclosing).</param>
            <param name="symbol">Symbol to which the attribute was applied (e.g. a parameter).</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder.AttributedMember">
            <summary>
            We're binding an attribute and this is the member to/in which the attribute was applied.
            </summary>
            <remarks>
            Method, property, event, or null.
            A virtual property on Binder (i.e. our usual pattern) would be more robust, but the applicability
            of this property is so narrow that it doesn't seem worthwhile.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder.GetAttributedMember(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Walk up to the nearest method/property/event.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder">
            <summary>
            <para>
            A utility class for making a decision dag (directed acyclic graph) for a pattern-matching construct.
            A decision dag is represented by
            the class <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDecisionDag"/> and is a representation of a finite state automaton that performs a
            sequence of binary tests. Each node is represented by a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode"/>. There are four
            kind of nodes: <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundTestDecisionDagNode"/> performs one of the binary tests;
            <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundEvaluationDecisionDagNode"/> simply performs some computation and stores it in one or more
            temporary variables for use in subsequent nodes (think of it as a node with a single successor);
            <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundWhenDecisionDagNode"/> represents the test performed by evaluating the expression of the
            when-clause of a switch case; and <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundLeafDecisionDagNode"/> represents a leaf node when we
            have finally determined exactly which case matches. Each test processes a single input, and there are
            four kinds:<see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDagExplicitNullTest"/> tests a value for null; <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDagNonNullTest"/>
            tests that a value is not null; <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDagTypeTest"/> checks if the value is of a given type;
            and <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDagValueTest"/> checks if the value is equal to a given constant. Of the evaluations,
            there are <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDagDeconstructEvaluation"/> which represents an invocation of a type's
            "Deconstruct" method; <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDagFieldEvaluation"/> reads a field; <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDagPropertyEvaluation"/>
            reads a property; and <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDagTypeEvaluation"/> converts a value from one type to another (which
            is performed only after testing that the value is of that type).
            </para>
            <para>
            In order to build this automaton, we start (in
            <see cref="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.MakeBoundDecisionDag(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.StateForCase})"/>
            by computing a description of the initial state in a <see cref="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState"/>, and then
            for each such state description we decide what the test or evaluation will be at
            that state, and compute the successor state descriptions.
            A state description represented by a <see cref="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState"/> is a collection of partially matched
            cases represented
            by <see cref="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.StateForCase"/>, in which some number of the tests have already been performed
            for each case.
            When we have computed <see cref="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState"/> descriptions for all of the states, we create a new
            <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode"/> for each of them, containing
            the state transitions (including the test to perform at each node and the successor nodes) but
            not the state descriptions. A <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDecisionDag"/> containing this
            set of nodes becomes part of the bound nodes (e.g. in <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundSwitchStatement"/> and
            <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundUnconvertedSwitchExpression"/>) and is used for semantic analysis and lowering.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder._forLowering">
            <summary>
            We might need to build a dedicated dag for lowering during which we
            avoid synthesizing tests to relate alternative indexers. This won't 
            affect code semantics but it results in a better code generation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.CreateDecisionDagForSwitchStatement(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundSwitchSection},Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <summary>
            Create a decision dag for a switch statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.CreateDecisionDagForSwitchExpression(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundSwitchExpressionArm},Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <summary>
            Create a decision dag for a switch expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.CreateDecisionDagForIsPattern(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundPattern,Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <summary>
            Translate the pattern of an is-pattern expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.CreateDecisionDagForSwitchExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundSwitchExpressionArm})">
            <summary>
            Used to create a decision dag for a switch expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.MakeTestsForPattern(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundDagTemp,Microsoft.CodeAnalysis.CSharp.BoundPattern,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol)">
            <summary>
            Compute the set of remaining tests for a pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.MakeTestsAndBindings(Microsoft.CodeAnalysis.CSharp.BoundDagTemp,Microsoft.CodeAnalysis.CSharp.BoundPattern,Microsoft.CodeAnalysis.CSharp.BoundDagTemp@,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundPatternBinding})">
            <summary>
            Make the tests and variable bindings for the given pattern with the given input.  The pattern's
            "output" value is placed in <paramref name="output"/>.  The output is defined as the input
            narrowed according to the pattern's *narrowed type*; see https://github.com/dotnet/csharplang/issues/2850.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.OriginalInput(Microsoft.CodeAnalysis.CSharp.BoundDagTemp,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Get the earliest input of which the symbol is a member.
            A BoundDagTypeEvaluation doesn't change the underlying object being pointed to.
            So two evaluations act on the same input so long as they have the same original input.
            We use this method to compute the original input for an evaluation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.MakeConvertToType(Microsoft.CodeAnalysis.CSharp.BoundDagTemp,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests})">
            <summary>
            Generate a not-null check and a type check.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.MakeBoundDecisionDag(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.StateForCase})">
            <summary>
            Compute and translate the decision dag, given a description of its initial state and a default
            decision when no decision appears to match. This implementation is nonrecursive to avoid
            overflowing the compiler's evaluation stack when compiling a large switch statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.MakeDecisionDag(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.StateForCase})">
            <summary>
            Make a <see cref="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DecisionDag"/> (state machine) starting with the given set of cases in the root node,
            and return the node for the root.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.ComputeBoundDecisionDagNodes(Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DecisionDag,Microsoft.CodeAnalysis.CSharp.BoundLeafDecisionDagNode)">
            <summary>
            Compute the <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDecisionDag"/> corresponding to each <see cref="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState"/> of the given <see cref="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DecisionDag"/>
            and store it in <see cref="F:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState.Dag"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.CheckConsistentDecision(Microsoft.CodeAnalysis.CSharp.BoundDagTest,Microsoft.CodeAnalysis.CSharp.BoundDagTest,Microsoft.CodeAnalysis.CSharp.IValueSet,Microsoft.CodeAnalysis.CSharp.IValueSet,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>
            Given that the test <paramref name="test"/> has occurred and produced a true/false result,
            set some flags indicating the implied status of the <paramref name="other"/> test.
            </summary>
            <param name="test"></param>
            <param name="other"></param>
            <param name="whenTrueValues">The possible values of test.Input when <paramref name="test"/> has succeeded.</param>
            <param name="whenFalseValues">The possible values of test.Input when <paramref name="test"/> has failed.</param>
            <param name="trueTestPermitsTrueOther">set if <paramref name="test"/> being true would permit <paramref name="other"/> to succeed</param>
            <param name="falseTestPermitsTrueOther">set if a false result on <paramref name="test"/> would permit <paramref name="other"/> to succeed</param>
            <param name="trueTestImpliesTrueOther">set if <paramref name="test"/> being true means <paramref name="other"/> has been proven true</param>
            <param name="falseTestImpliesTrueOther">set if <paramref name="test"/> being false means <paramref name="other"/> has been proven true</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.CheckInputRelation(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState,Microsoft.CodeAnalysis.CSharp.BoundDagTest,Microsoft.CodeAnalysis.CSharp.BoundDagTest,Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests@,Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests@)">
            <summary>Returns true if the tests are related i.e. they have the same input, otherwise false.</summary>
            <param name="relationCondition">The pre-condition under which these tests are related.</param>
            <param name="relationEffect">A possible assignment node which will correspond two non-identical but related test inputs.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.ExpressionOfTypeMatchesPatternTypeForLearningFromSuccessfulTypeTest(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Determine what we can learn from one successful runtime type test about another planned
            runtime type test for the purpose of building the decision tree.
            We accommodate a special behavior of the runtime here, which does not match the language rules.
            A value of type `int[]` is an "instanceof" (i.e. result of the `isinst` instruction) the type
            `uint[]` and vice versa.  It is similarly so for every pair of same-sized numeric types, and
            arrays of enums are considered to be their underlying type.  We need the dag construction to
            recognize this runtime behavior, so we pretend that matching one of them gives no information
            on whether the other will be matched.  That isn't quite correct (nothing reasonable we do
            could be), but it comes closest to preserving the existing C#7 behavior without undesirable
            side-effects, and permits the code-gen strategy to preserve the dynamic semantic equivalence
            of a switch (on the one hand) and a series of if-then-else statements (on the other).
            See, for example, https://github.com/dotnet/roslyn/issues/35661
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DecisionDag">
            <summary>
            A representation of the entire decision dag and each of its states.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DecisionDag.RootNode">
            <summary>
            The starting point for deciding which case matches.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DecisionDag.Successor(Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState)">
            <summary>
            A successor function used to topologically sort the DagState set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DecisionDag.TryGetTopologicallySortedReachableStates(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState}@)">
            <summary>
            Produce the states in topological order.
            </summary>
            <param name="result">Topologically sorted <see cref="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState"/> nodes.</param>
            <returns>True if the graph was acyclic.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState">
            <summary>
            The state at a given node of the decision finite state automaton. This is used during computation of the state
            machine (<see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDecisionDag"/>), and contains a representation of the meaning of the state. Because we always make
            forward progress when a test is evaluated (the state description is monotonically smaller at each edge), the
            graph of states is acyclic, which is why we call it a dag (directed acyclic graph).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState.RemainingValues">
            <summary>
            For each dag temp of a type for which we track such things (the integral types, floating-point types, and bool),
            the possible values it can take on when control reaches this state.
            If this dictionary is mutated after <see cref="F:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState.TrueBranch"/>, <see cref="F:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState.FalseBranch"/>,
            and <see cref="F:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState.Dag"/> are computed (for example to merge states), they must be cleared and recomputed,
            as the set of possible values can affect successor states.
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDagTemp"/> absent from this dictionary means that all values of the type are possible.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState.Cases">
            <summary>
            The set of cases that may still match, and for each of them the set of tests that remain to be tested.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState.ComputeSelectedTest">
            <summary>
            Decide on what test to use at this node of the decision dag. This is the principal
            heuristic we can change to adjust the quality of the generated decision automaton.
            See https://www.cs.tufts.edu/~nr/cs257/archive/norman-ramsey/match.pdf for some ideas.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagStateEquivalence">
            <summary>
            An equivalence relation between dag states used to dedup the states during dag construction.
            After dag construction is complete we treat a DagState as using object equality as equivalent
            states have been merged.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.StateForCase">
            <summary>
            As part of the description of a node of the decision automaton, we keep track of what tests
            remain to be done for each case.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.StateForCase.Index">
            <summary>
            A number that is distinct for each case and monotonically increasing from earlier to later cases.
            Since we always keep the cases in order, this is only used to assist with debugging (e.g.
            see DecisionDag.Dump()).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.StateForCase.IsFullyMatched">
            <summary>
            Is the pattern in a state in which it is fully matched and there is no when clause?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.StateForCase.PatternIsSatisfied">
            <summary>
            Is the pattern fully matched and ready for the when clause to be evaluated (if any)?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.StateForCase.IsImpossible">
            <summary>
            Is the clause impossible?  We do not consider a when clause with a constant false value to cause the branch to be impossible.
            Note that we do not include the possibility that a when clause is the constant false.  That is treated like any other expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.StateForCase.RewriteNestedLengthTests">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests.RewriteNestedLengthTests"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests">
            <summary>
            A set of tests to be performed.  This is a discriminated union; see the options (nested types) for more details.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests.Filter(Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder,Microsoft.CodeAnalysis.CSharp.BoundDagTest,Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.DagState,Microsoft.CodeAnalysis.CSharp.IValueSet,Microsoft.CodeAnalysis.CSharp.IValueSet,Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests@,Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests@,System.Boolean@)">
            <summary>
            Take the set of tests and split them into two, one for when the test has succeeded, and one for when the test has failed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests.RewriteNestedLengthTests">
            <summary>
            Rewrite nested length tests in slice subpatterns to check the top-level length property instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests.True">
            <summary>
            No tests to be performed; the result is true (success).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests.False">
            <summary>
            No tests to be performed; the result is false (failure).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests.One">
            <summary>
            A single test to be performed, described by a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDagTest"/>.
            Note that the test might be a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundDagEvaluation"/>, in which case it is deemed to have
            succeeded after being evaluated.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests.AndSequence">
            <summary>
            A sequence of tests that must be performed, each of which must succeed.
            The sequence is deemed to succeed if no element fails.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DecisionDagBuilder.Tests.OrSequence">
            <summary>
            A sequence of tests that must be performed, any of which must succeed.
            The sequence is deemed to succeed if some element succeeds.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EarlyWellKnownAttributeBinder">
            <summary>
            This is a special binder used for decoding some special well-known attributes very early in the attribute binding phase.
            It only binds those attribute argument syntax which can produce valid attribute arguments, but doesn't report any diagnostics.
            Subsequent binding phase will rebind such erroneous attributes and generate appropriate diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EarlyWellKnownAttributeBinder.CanBeValidAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Binder)">
            <remarks>
            Since this method is expected to be called on every nested expression of the argument, it doesn't
            need to recurse (directly).
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EmbeddedStatementBinder">
            <summary>
            This binder owns the scope for an embedded statement.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExecutableCodeBinder">
            <summary>
            This binder owns and lazily creates the map of SyntaxNodes to Binders associated with
            the syntax with which it is created. This binder is not created in reaction to any
            specific syntax node type. It is inserted into the binder chain
            between the binder which it is constructed with and those that it constructs via
            the LocalBinderFactory. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ExpressionVariableFinder`1.MakeDeclarationExpressionVariable(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Make a variable for a declaration expression other than a deconstruction left-hand-side. The only
            other legal place for a declaration expression today is an out variable declaration; this method
            handles that and the error cases as well.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ExpressionVariableFinder`1.MakeDeconstructionVariable(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax)">
            <summary>
            Make a variable for a declaration expression appearing as one of the declared variables of the left-hand-side
            of a deconstruction assignment.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExtensionMethodScope">
            <summary>
            A distinct scope that may expose extension methods. For a particular Binder,  there
            are two possible scopes: one for the namespace, and another for any using statements
            in the namespace. The namespace scope is searched before the using scope.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExtensionMethodScopes">
            <summary>
            An enumerable collection of extension method scopes in search
            order, from the given Binder, out through containing Binders.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExtensionMethodScopeEnumerator">
            <summary>
            An enumerator over ExtensionMethodScopes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo">
            <summary>
            Information to be deduced while binding a foreach loop so that the loop can be lowered
            to a while over an enumerator.  Not applicable to the array or string forms.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder">
            <summary>
            A loop binder that (1) knows how to bind foreach loops and (2) has the foreach iteration variable in scope.
            </summary>
            <remarks>
            This binder produces BoundForEachStatements.  The lowering described in the spec is performed in ControlFlowRewriter.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.BindForEachParts(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Bind the ForEachStatementSyntax at the root of this binder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.BindForEachDeconstruction(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Like BindForEachParts, but only bind the deconstruction part of the foreach, for purpose of inferring the types of the declared locals.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.GetEnumeratorInfo(Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo.Builder@,Microsoft.CodeAnalysis.CSharp.BoundExpression@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            The spec describes an algorithm for finding the following types:
              1) Collection type
              2) Enumerator type
              3) Element type
              
            The implementation details are a bit different.  If we're iterating over a string or an array, then we don't need to record anything
            but the inferredType (in case the iteration variable is implicitly typed).  If we're iterating over anything else, then we want the 
            inferred type plus a ForEachEnumeratorInfo.Builder with:
              1) Collection type
              2) Element type
              3) GetEnumerator (or GetAsyncEnumerator) method of the collection type (return type will be the enumerator type from the spec)
              4) Current property and MoveNext (or MoveNextAsync) method of the enumerator type
              
            The caller will have to do some extra conversion checks before creating a ForEachEnumeratorInfo for the BoundForEachStatement.
            </summary>
            <param name="builder">Builder to fill in (partially, all but conversions).</param>
            <param name="collectionExpr">The expression over which to iterate.</param>
            <param name="diagnostics">Populated with binding diagnostics.</param>
            <returns>Partially populated (all but conversions) or null if there was an error.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.SatisfiesGetEnumeratorPattern(Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo.Builder@,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Check for a GetEnumerator (or GetAsyncEnumerator) method on collectionExprType.  Failing to satisfy the pattern is not an error -
            it just means that we have to check for an interface instead.
            </summary>
            <param name="collectionExpr">Expression over which to iterate.</param>
            <param name="diagnostics">Populated with *warnings* if there are near misses.</param>
            <param name="builder">Builder to fill in. <see cref="F:Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo.Builder.GetEnumeratorInfo"/> set if the pattern in satisfied.</param>
            <returns>True if the method was found (still have to verify that the return (i.e. enumerator) type is acceptable).</returns>
            <remarks>
            Only adds warnings, so does not affect control flow (i.e. no need to check for failure).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.FindForEachPatternMethod(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.String,Microsoft.CodeAnalysis.CSharp.LookupResult,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <summary>
            Perform a lookup for the specified method on the specified type.  Perform overload resolution
            on the lookup results.
            </summary>
            <param name="patternType">Type to search.</param>
            <param name="methodName">Method to search for.</param>
            <param name="lookupResult">Passed in for reusability.</param>
            <param name="warningsOnly">True if failures should result in warnings; false if they should result in errors.</param>
            <param name="diagnostics">Populated with binding diagnostics.</param>
            <returns>The desired method or null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.PerformForEachPatternOverloadResolution(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol},System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <summary>
            The overload resolution portion of FindForEachPatternMethod.
            If no arguments are passed in, then an empty argument list will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.SatisfiesForEachPattern(Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo.Builder@,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Called after it is determined that the expression being enumerated is of a type that
            has a GetEnumerator (or GetAsyncEnumerator) method.  Checks to see if the return type of the GetEnumerator
            method is suitable (i.e. has Current and MoveNext for regular case, 
            or Current and MoveNextAsync for async case).
            </summary>
            <param name="builder">Must be non-null and contain a non-null GetEnumeratorMethod.</param>
            <param name="diagnostics">Will be populated with pattern diagnostics.</param>
            <returns>True if the return type has suitable members.</returns>
            <remarks>
            It seems that every failure path reports the same diagnostics, so that is left to the caller.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.AllInterfacesContainsIEnumerable(Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo.Builder@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean@)">
            <summary>
            Checks if the given type implements (or extends, in the case of an interface),
            System.Collections.IEnumerable or System.Collections.Generic.IEnumerable&lt;T&gt;,
            (or System.Collections.Generic.IAsyncEnumerable&lt;T&gt;)
            for at least one T.
            </summary>
            <param name="builder">builder to fill in CollectionType.</param>
            <param name="type">Type to check.</param>
            <param name="diagnostics" />
            <param name="foundMultiple">True if multiple T's are found.</param>
            <returns>True if some IEnumerable is found (may still be ambiguous).</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.ReportPatternMemberLookupDiagnostics(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.String,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Report appropriate diagnostics when lookup of a pattern member (i.e. GetEnumerator, Current, or MoveNext) fails.
            </summary>
            <param name="lookupResult">Failed lookup result.</param>
            <param name="patternType">Type in which member was looked up.</param>
            <param name="memberName">Name of looked up member.</param>
            <param name="warningsOnly">True if failures should result in warnings; false if they should result in errors.</param>
            <param name="diagnostics">Populated appropriately.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.BindDefaultArguments(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean)">
            <param name="extensionReceiverOpt">If method is an extension method, this must be non-null.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ImplicitlyTypedFieldBinder">
            <summary>
            Tracks fields that are being bound while binding their initializers.
            </summary>
            <remarks>
            Used to detect circular references like:
            var x = y;
            var y = x;
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Imports">
            <summary>
            Represents symbols imported to the binding scope via using namespace, using alias, and extern alias.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Imports.Concat(Microsoft.CodeAnalysis.CSharp.Imports)">
            <remarks>
            Does not preserve diagnostics.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.InContainerBinder">
            <summary>
            A binder that places the members of a symbol in scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InContainerBinder.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Creates a binder for a container.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.InMethodBinder">
            <summary>
            A binder for a method body, which places the method's parameters in scope
            and notes if the method is an iterator method.
            Note: instances of this type can be re-used across different attempts at compiling the same method (caching by binder factory).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.InSubmissionClassBinder">
            <summary>
            A binder that places the members of a submission class and aliases in scope.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.InSubmissionClassBinder.QuickAttributeChecker">
            <summary>
            Get <see cref="P:Microsoft.CodeAnalysis.CSharp.InSubmissionClassBinder.QuickAttributeChecker"/> that can be used to quickly
            check for certain attribute applications in context of this binder.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalBinderFactory">
             <summary>
             The LocalBinderFactory is used to build up the map of all Binders within a method body, and the associated
             CSharpSyntaxNode. To do so it traverses all the statements, handling blocks and other
             statements that create scopes. For efficiency reasons, it does not traverse into all
             expressions. This means that blocks within lambdas and queries are not created. 
             Blocks within lambdas are bound by their own LocalBinderFactory when they are 
             analyzed.
            
             For reasons of lifetime management, this type is distinct from the BinderFactory 
             which also creates a map from CSharpSyntaxNode to Binder. That type owns its binders
             and that type's lifetime is that of the compilation. Therefore we do not store
             binders local to method bodies in that type's cache. 
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalBinderFactory.GetBinderForPossibleEmbeddedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode@)">
            <summary>
            Some statements by default do not introduce its own scope for locals. 
            For example: Expression Statement, Return Statement, etc. However, 
            when a statement like that is an embedded statement (like IfStatementSyntax.Statement), 
            then it should introduce a scope for locals declared within it. 
            Here we are detecting such statements and creating a binder that should own the scope.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalInProgressBinder">
            <summary>
            This binder keeps track of the local variable (if any) that is currently being evaluated
            so that it can be passed into the next call to LocalSymbol.GetConstantValue (and
            its callers).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalScopeBinder.LookupLocal(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Call this when you are sure there is a local declaration on this token.  Returns the local.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LockOrUsingBinder">
            <remarks>
            This type exists to share code between UsingStatementBinder and LockBinder.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LockOrUsingBinder.ExpressionAndDiagnostics">
            <remarks>
            This class exists so these two fields can be set atomically.
            CONSIDER: If this causes too many allocations, we could use start and end flags plus spinlocking
            as for completion parts.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LookupOptions">
            <summary>
            Options that can be used to modify the symbol lookup mechanism. 
            </summary>
            <remarks>
            Multiple options can be combined together.  LookupOptions.AreValid checks for valid combinations.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.Default">
            <summary>
            Consider all symbols, using normal accessibility rules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.NamespaceAliasesOnly">
            <summary>
            Consider only namespace aliases and extern aliases.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.NamespacesOrTypesOnly">
            <summary>
            Consider only namespaces and types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustBeInvocableIfMember">
            <summary>
            Consider non-members, plus invocable members.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustBeInstance">
            <summary>
            Consider only symbols that are instance members. Valid with IncludeExtensionMethods
            since extension methods are invoked on an instance.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustNotBeInstance">
            <summary>
            Do not consider symbols that are instance members.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustNotBeNamespace">
            <summary>
            Do not consider symbols that are namespaces.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.AllMethodsOnArityZero">
            <summary>
            Consider methods of any arity when arity zero is specified. Because type parameters can be inferred, it is
            often desired to consider generic methods when no type arguments were present.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.LabelsOnly">
            <summary>
            Look only for label symbols.  This must be exclusive of all other options.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.UseBaseReferenceAccessibility">
            <summary>
            Usually, when determining if a member is accessible, both the type of the receiver
            and the type containing the access are used.  If this flag is specified, then only
            the containing type will be used (i.e. as if you've written base.XX).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.IncludeExtensionMethods">
            <summary>
            Include extension methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.AttributeTypeOnly">
            <summary>
            Consider only attribute types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.VerbatimNameAttributeTypeOnly">
            <summary>
            Consider lookup name to be a verbatim identifier.
            If this flag is specified, then only one lookup is performed for attribute name: lookup with the given name,
            and attribute name lookup with "Attribute" suffix is skipped.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.AllNamedTypesOnArityZero">
            <summary>
            Consider named types of any arity when arity zero is specified. It is specifically desired for nameof in such situations: nameof(System.Collections.Generic.List)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustNotBeMethodTypeParameter">
            <summary>
            Do not consider symbols that are method type parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustBeAbstractOrVirtual">
            <summary>
            Consider only symbols that are abstract or virtual.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LookupOptionExtensions.AreValid(Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <summary>
            Are these options valid in their current combination?
            </summary>
            <remarks>
            Some checks made here:
            
            - Default is valid.
            - If LabelsOnly is set, it must be the only option.
            - If one of MustBeInstance or MustNotBeInstance are set, the other one must not be set.
            - If any of MustNotBeInstance, MustBeInstance, or MustNotBeNonInvocableMember are set,
              the options are considered valid.
            - If MustNotBeNamespace is set, neither NamespaceAliasesOnly nor NamespacesOrTypesOnly must be set.
            - Otherwise, only one of NamespaceAliasesOnly, NamespacesOrTypesOnly, or AllMethodsOnArityZero must be set.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LookupFilter">
            <summary>
            represents one-to-one symbol -> SingleLookupResult filter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LookupResult">
            <summary>
            A LookupResult summarizes the result of a name lookup within a scope It also allows
            combining name lookups from different scopes in an easy way.
            
            A LookupResult can be ONE OF:
               empty - nothing found.
               a viable result - this kind of result prevents lookup into further scopes of lower priority.
                                 Viable results should be without error; ambiguity is handled in the caller.
                                 (Note that handling multiple "viable" results is not the same as in the VB compiler)
               a non-accessible result - this kind of result means that search continues into further scopes of lower priority for
                                 a viable result. An error is attached with the inaccessibility errors. Non-accessible results take priority over
                                 non-viable results.
               a non-viable result - a result that means that the search continues into further scopes of lower priority for
                                     a viable or non-accessible result. An error is attached with the error that indicates
                                     why the result is non-viable.  A typical reason would be that it is the wrong kind of symbol.
            
            Note that the class is poolable so its instances can be obtained from a pool via GetInstance.
            Also it is a good idea to call Free on instances after they no longer needed.
            
            The typical pattern is "caller allocates / caller frees" -
               
               var result = LookupResult.GetInstance();
             
               scope.Lookup(result, "goo");
               ... use result ...
                    
               result.Clear();
               anotherScope.Lookup(result, "moo");
               ... use result ...
            
               result.Free();   //result and its content is invalid after this
               
            
            
            </summary>
            <remarks>
            Currently LookupResult is intended only for name lookup, not for overload resolution. It is
            not clear if overload resolution will work with the structure as is, require enhancements,
            or be best served by an alternate mechanism.
            
            We might want to extend this to a more general priority scheme.
            
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.LookupResult.SingleSymbolOrDefault">
            <summary>
            Return the single symbol if there is exactly one, otherwise null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.LookupResult.IsMultiViable">
            <summary>
            Is the result viable with one or more symbols?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.LookupResult.IsSingleViable">
            <summary>
            NOTE: Even there is a single viable symbol, it may be an error type symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LookupResult.SetFrom(Microsoft.CodeAnalysis.CSharp.SingleLookupResult)">
            <summary>
            Set current result according to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LookupResult.SetFrom(Microsoft.CodeAnalysis.CSharp.LookupResult)">
            <summary>
            Set current result according to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LookupResult.MergeEqual(Microsoft.CodeAnalysis.CSharp.LookupResult)">
            <summary>
            Merge another result with this one, with the symbols combined if both
            this and other are viable. Otherwise the highest priority result wins (this if equal 
            priority and non-viable.)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LookupResultKind">
            <summary>
            Classifies the different ways in which a found symbol might be incorrect.
            Higher values are considered "better" than lower values. These values are used
            in a few different places:
               1) Inside a LookupResult to indicate the quality of a symbol from lookup.
               2) Inside a bound node (for example, BoundBadExpression), to indicate
                  the "binding quality" of the symbols referenced by that bound node.
               3) Inside an error type symbol, to indicate the reason that the candidate symbols
                  in the error type symbols were not good.
                  
            While most of the values can occur in all places, some of the problems are not
            detected at lookup time (e.g., NotAVariable), so only occur in bound nodes.
            </summary>
            <remarks>
            This enumeration is parallel to and almost the same as the CandidateReason enumeration.
            Changes to one should usually result in changes to the other.
            
            There are two enumerations because:
              1) CandidateReason in language-independent, while this enum is language specific.
              2) The name "CandidateReason" didn't make much sense in the way LookupResultKind is used internally.
              3) Viable isn't used in CandidateReason, but we need it in LookupResultKind, and there isn't a 
                 a way to have internal enumeration values.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LookupResultKindExtensions.ToCandidateReason(Microsoft.CodeAnalysis.CSharp.LookupResultKind)">
            <summary>
            Maps a LookupResultKind to a CandidateReason. Should not be called on LookupResultKind.Viable!
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MethodArgumentInfo">
            <summary>
            Information about the arguments of a call that can turned into a BoundCall later without recalculating
            default arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodArgumentInfo.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{System.Int32},Microsoft.CodeAnalysis.BitVector,System.Boolean)">
            <summary>
            Information about the arguments of a call that can turned into a BoundCall later without recalculating
            default arguments.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MethodGroupResolution">
            <summary>
            Packages up the various parts returned when resolving a method group. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NameofBinder">
            <summary>
            If a proper method named "nameof" exists in the outer scopes, <see cref="P:Microsoft.CodeAnalysis.CSharp.NameofBinder.IsNameofOperator"/> is false and this binder does nothing.
            Otherwise, it relaxes the instance-vs-static requirement for top-level member access expressions
            and when inside an attribute on a method it adds type parameters from the target of that attribute.
            To do so, it works together with <see cref="T:Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder"/>.
            
            For other attributes (on types, type parameters or parameters) we use a WithTypeParameterBinder directly
            in the binder chain and some filtering (<see cref="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustNotBeMethodTypeParameter"/>) to keep
            pre-existing behavior.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PatternExplainer.ShortestPathToNode(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode},Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,System.Boolean,System.Boolean@)">
            <summary>
            Find the shortest path from the root node to the node of interest.
            </summary>
            <param name="nodes">The set of nodes in topological order.</param>
            <param name="node">The node of interest.</param>
            <param name="nullPaths">Whether to permit following paths that test for null.</param>
            <param name="requiresFalseWhenClause">set to true if the returned path requires some when clause to evaluate to 'false'</param>
            <returns>The shortest path, excluding the node of interest.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PatternExplainer.SamplePatternForPathToDagNode(Microsoft.CodeAnalysis.CSharp.BoundDagTemp,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode},Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,System.Boolean,System.Boolean@,System.Boolean@)">
            <summary>
            Return a sample pattern that would lead to the given decision dag node.
            </summary>
            <param name="nodes">A topologically sorted list of nodes in the decision dag.</param>
            <param name="targetNode">A node of interest (typically, the default node for a non-exhaustive switch).</param>
            <param name="nullPaths">Permit the use of "null" paths on tests which check for null.</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PatternLookupResult.Success">
            <summary>
            The Lookup was successful
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PatternLookupResult.NotAMethod">
            <summary>
            A member was found, but it was not a method
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PatternLookupResult.NotCallable">
            <summary>
            A member was found, but it was not callable
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PatternLookupResult.NoResults">
            <summary>
            The lookup failed to find anything
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PatternLookupResult.ResultHasErrors">
            <summary>
            One or more errors occurred while performing the lookup
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AccessCheck">
            <summary>
            Contains the code for determining C# accessibility rules.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within type 'within', with
            an optional qualifier of type "throughTypeOpt".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Checks if 'symbol' is accessible from within type 'within', with
            a qualifier of type "throughTypeOpt". Sets "failedThroughTypeCheck" to true
            if it failed the "through type" check.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsEffectivelyPublicOrInternal(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean@)">
            <summary>
            Returns true if the symbol is effectively public or internal based on
            the declared accessibility of the symbol and any containing symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsSymbolAccessibleCore(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Checks if 'symbol' is accessible from within 'within', which must be a NamedTypeSymbol
            or an AssemblySymbol. 
            </summary>
            <remarks>
            Note that NamedTypeSymbol, if available, is the type that is associated with the binder 
            that found the 'symbol', not the inner-most type that contains the access to the
            'symbol'.
            <para>
            If 'symbol' is accessed off of an expression then 'throughTypeOpt' is the type of that
            expression. This is needed to properly do protected access checks. Sets
            "failedThroughTypeCheck" to true if this protected check failed.
            </para>
            <para>
            This function is expected to be called a lot.  As such, it avoids memory
            allocations in the function itself (including not making any iterators).  This means
            that certain helper functions that could otherwise be called are inlined in this method to
            prevent the overhead of returning collections or enumerators.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsNamedTypeAccessible(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Is the named type <paramref name="type"/> accessible from within <paramref name="within"/>,
            which must be a named type or an assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsNonNestedTypeAccessible(Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Is a top-level type with accessibility "declaredAccessibility" inside assembly "assembly"
            accessible from "within", which must be a named type of an assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsMemberAccessible(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Is a member with declared accessibility "declaredAccessibility" accessible from within
            "within", which must be a named type or an assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsProtectedSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Boolean@,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Is a protected symbol inside "originalContainingType" accessible from within "within",
            which much be a named type or an assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsNestedWithinOriginalContainingType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Is the type "withinType" nested within the original type "originalContainingType".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.InheritsFromOrImplementsIgnoringConstruction(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Determine if "type" inherits from or implements "baseType", ignoring constructed types, and dealing
            only with original types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.HasInternalAccessTo(Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <summary>
            Does the assembly has internal accessibility to "toAssembly"?
            </summary>
            <param name="fromAssembly">The assembly wanting access.</param>
            <param name="toAssembly">The assembly possibly providing symbols to be accessed.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BestTypeInferrer.InferBestType(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.ConversionsBase,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,System.Boolean@)">
            <remarks>
            This method finds the best common type of a set of expressions as per section 7.5.2.14 of the specification.
            NOTE: If some or all of the expressions have error types, we return error type as the inference result.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BestTypeInferrer.InferBestTypeForConditionalOperator(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Conversions,System.Boolean@,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <remarks>
            This method implements best type inference for the conditional operator ?:.
            NOTE: If either expression is an error type, we return error type as the inference result.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BestTypeInferrer.Better(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.ConversionsBase,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Returns the better type amongst the two, with some possible modifications (dynamic/object or tuple names).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Conversion">
            <summary>
            Summarizes whether a conversion is allowed, and if so, which kind of conversion (and in some cases, the
            associated symbol).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.Exists">
            <summary>
            Returns true if the conversion exists, either as an implicit or explicit conversion.
            </summary>
            <remarks>
            The existence of a conversion does not necessarily imply that the conversion is valid.
            For example, an ambiguous user-defined conversion may exist but may not be valid.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsImplicit">
            <summary>
            Returns true if the conversion is implicit.
            </summary>
            <remarks>
            Implicit conversions are described in section 6.1 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsExplicit">
            <summary>
            Returns true if the conversion is explicit.
            </summary>
            <remarks>
            Explicit conversions are described in section 6.2 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsIdentity">
            <summary>
            Returns true if the conversion is an identity conversion.
            </summary>
            <remarks>
            Identity conversions are described in section 6.1.1 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsStackAlloc">
            <summary>
            Returns true if the conversion is a stackalloc conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsNumeric">
            <summary>
            Returns true if the conversion is an implicit numeric conversion or explicit numeric conversion. 
            </summary>
            <remarks>
            Implicit and explicit numeric conversions are described in sections 6.1.2 and 6.2.1 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsEnumeration">
            <summary>
            Returns true if the conversion is an implicit enumeration conversion or explicit enumeration conversion.
            </summary>
            <remarks>
            Implicit and explicit enumeration conversions are described in sections 6.1.3 and 6.2.2 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsThrow">
            <summary>
            Returns true if the conversion is an implicit throw conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsObjectCreation">
            <summary>
            Returns true if the conversion is an implicit object creation expression conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsSwitchExpression">
            <summary>
            Returns true if the conversion is an implicit switch expression conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsConditionalExpression">
            <summary>
            Returns true if the conversion is an implicit conditional expression conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsInterpolatedString">
            <summary>
            Returns true if the conversion is an interpolated string conversion.
            </summary>
            <remarks>
            The interpolated string conversion described in section 6.1.N of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsInterpolatedStringHandler">
            <summary>
            Returns true if the conversion is an interpolated string builder conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsNullable">
            <summary>
            Returns true if the conversion is an implicit nullable conversion or explicit nullable conversion.
            </summary>
            <remarks>
            Implicit and explicit nullable conversions are described in sections 6.1.4 and 6.2.3 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsTupleLiteralConversion">
            <summary>
            Returns true if the conversion is an implicit tuple literal conversion or explicit tuple literal conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsTupleConversion">
            <summary>
            Returns true if the conversion is an implicit tuple conversion or explicit tuple conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsReference">
            <summary>
            Returns true if the conversion is an implicit reference conversion or explicit reference conversion.
            </summary>
            <remarks>
            Implicit and explicit reference conversions are described in sections 6.1.6 and 6.2.4 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsUserDefined">
            <summary>
            Returns true if the conversion is an implicit user-defined conversion or explicit user-defined conversion.
            </summary>
            <remarks>
            Implicit and explicit user-defined conversions are described in section 6.4 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsBoxing">
            <summary>
            Returns true if the conversion is an implicit boxing conversion.
            </summary>
            <remarks>
            Implicit boxing conversions are described in section 6.1.7 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsUnboxing">
            <summary>
            Returns true if the conversion is an explicit unboxing conversion.
            </summary>
            <remarks>
            Explicit unboxing conversions as described in section 6.2.5 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsNullLiteral">
            <summary>
            Returns true if the conversion is an implicit null literal conversion.
            </summary>
            <remarks>
            Null literal conversions are described in section 6.1.5 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsDefaultLiteral">
            <summary>
            Returns true if the conversion is an implicit default literal conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsDynamic">
            <summary>
            Returns true if the conversion is an implicit dynamic conversion. 
            </summary>
            <remarks>
            Implicit dynamic conversions are described in section 6.1.8 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsConstantExpression">
            <summary>
            Returns true if the conversion is an implicit constant expression conversion.
            </summary>
            <remarks>
            Implicit constant expression conversions are described in section 6.1.9 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsAnonymousFunction">
            <summary>
            Returns true if the conversion is an implicit anonymous function conversion.
            </summary>
            <remarks>
            Implicit anonymous function conversions are described in section 6.5 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsMethodGroup">
            <summary>
            Returns true if the conversion is an implicit method group conversion.
            </summary>
            <remarks>
            Implicit method group conversions are described in section 6.6 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsPointer">
            <summary>
            Returns true if the conversion is a pointer conversion 
            </summary>
            <remarks>
            Pointer conversions are described in section 18.4 of the C# language specification.
            
            Returns true if the conversion is a conversion 
             a) from a pointer type to void*, 
             b) from a pointer type to another pointer type (other than void*),
             c) from the null literal to a pointer type,
             d) from an integral numeric type to a pointer type,
             e) from a pointer type to an integral numeric type, or
             d) from a function pointer type to a function pointer type.
            
            Does not return true for user-defined conversions to/from pointer types.
            Does not return true for conversions between pointer types and IntPtr/UIntPtr.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsIntPtr">
            <summary>
            Returns true if the conversion is a conversion to or from IntPtr or UIntPtr.
            </summary>
            <remarks>
            Returns true if the conversion is a conversion to or from IntPtr or UIntPtr.
            This includes:
              IntPtr to/from int
              IntPtr to/from long
              IntPtr to/from void*
              UIntPtr to/from int
              UIntPtr to/from long
              UIntPtr to/from void*
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.MethodSymbol">
            <summary>
            Returns the method used to create the delegate for a method group conversion if <see cref="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsMethodGroup"/> is true 
            or the method used to perform the conversion for a user-defined conversion if <see cref="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsUserDefined"/> is true.
            Otherwise, returns null.
            </summary>
            <remarks>
            Method group conversions are described in section 6.6 of the C# language specification.
            User-defined conversions are described in section 6.4 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.ConstrainedToType">
            <summary>
            Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="P:Microsoft.CodeAnalysis.CSharp.Conversion.MethodSymbol" />, if any.
            Null if <see cref="P:Microsoft.CodeAnalysis.CSharp.Conversion.MethodSymbol" /> is resolved statically, or is null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.ResultKind">
            <summary>
            Gives an indication of how successful the conversion was.
            Viable - found a best built-in or user-defined conversion.
            Empty - found no applicable built-in or user-defined conversions.
            OverloadResolutionFailure - found applicable conversions, but no unique best.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.UserDefinedFromConversion">
            <summary>
            Conversion applied to operand of the user-defined conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.UserDefinedToConversion">
            <summary>
            Conversion applied to the result of the user-defined conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.OriginalUserDefinedConversions">
            <summary>
            The user-defined operators that were considered when attempting this conversion
            (i.e. the arguments to overload resolution).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.ToCommonConversion">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Operations.CommonConversion"/> from this C# conversion.
            </summary>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Operations.CommonConversion"/> that represents this conversion.</returns>
            <remarks>
            This is a lossy conversion; it is not possible to recover the original <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/>
            from the <see cref="T:Microsoft.CodeAnalysis.Operations.CommonConversion"/> struct.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.ToString">
            <summary>
            Returns a string that represents the <see cref="P:Microsoft.CodeAnalysis.CSharp.Conversion.Kind"/> of the conversion.
            </summary>
            <returns>A string that represents the <see cref="P:Microsoft.CodeAnalysis.CSharp.Conversion.Kind"/> of the conversion.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object is equal to the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.
            </summary>
            <param name="obj">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object to compare with the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <returns>true if the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object is equal to the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.Equals(Microsoft.CodeAnalysis.CSharp.Conversion)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object is equal to the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.
            </summary>
            <param name="other">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object to compare with the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <returns>true if the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object is equal to the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.GetHashCode">
            <summary>
            Returns a hash code for the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.
            </summary>
            <returns>A hash code for the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.op_Equality(Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Conversion)">
            <summary>
            Returns true if the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> objects are equal and false otherwise.
            </summary>
            <param name="left">The first <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <param name="right">The second <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.op_Inequality(Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Conversion)">
            <summary>
            Returns false if the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> objects are equal and true otherwise.
            </summary>
            <param name="left">The first <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <param name="right">The second <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DeconstructMethodInfo">
            <summary>Stores all the information from binding for calling a Deconstruct method.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ConversionsBase._lazyOtherNullability">
            <summary>
            An optional clone of this instance with distinct IncludeNullability.
            Used to avoid unnecessary allocations when calling WithNullability() repeatedly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.WithNullability(System.Boolean)">
            <summary>
            Returns this instance if includeNullability is correct, and returns a
            cached clone of this instance with distinct IncludeNullability otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ConversionsBase.Compilation">
            <summary>
            Derived types should provide non-null value for proper classification of conversions from expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitConversionFromExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Determines if the source expression is convertible to the destination type via
            any built-in or user-defined implicit conversion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitConversionFromType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any built-in or user-defined implicit conversion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitConversionFromTypeWhenNeitherOrBothFunctionTypes(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Helper method that calls <see cref="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitConversionFromType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)"/> or
            <see cref="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.HasImplicitFunctionTypeToFunctionTypeConversion(Microsoft.CodeAnalysis.CSharp.Symbols.FunctionTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.FunctionTypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)"/> depending on whether the
            types are <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionTypeSymbol"/> instances.
            Used by method type inference and best common type only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyConversionFromExpressionType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Determines if the source expression of given type is convertible to the destination type via
            any built-in or user-defined conversion.
            
            This helper is used in rare cases involving synthesized expressions where we know the type of an expression, but do not have the actual expression.
            The reason for this helper (as opposed to ClassifyConversionFromType) is that conversions from expressions could be different
            from conversions from type. For example expressions of dynamic type are implicitly convertable to any type, while dynamic type itself is not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyConversionFromExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,System.Boolean)">
            <summary>
            Determines if the source expression is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source expression to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the implicit conversion or explicit depending on "forCast"
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyConversionFromType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,System.Boolean)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source type to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the implicit conversion or explicit depending on "forCast"
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyConversionFromExpressionForCast(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Determines if the source expression is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source expression to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the built-in conversion.
            
            An implicit conversion exists from an expression of a dynamic type to any type.
            An explicit conversion exists from a dynamic type to any type. 
            When casting we prefer the explicit conversion.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyConversionFromTypeForCast(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source type to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the built-in conversion.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.FastClassifyConversion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Attempt a quick classification of builtin conversions.  As result of "no conversion"
            means that there is no built-in conversion, though there still may be a user-defined
            conversion if compiling against a custom mscorlib.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyStandardConversion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any standard implicit or standard explicit conversion.
            </summary>
            <remarks>
            Not all built-in explicit conversions are standard explicit conversions.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyStandardConversion(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any standard implicit or standard explicit conversion.
            </summary>
            <remarks>
            Not all built-in explicit conversions are standard explicit conversions.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.IsBaseInterface(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            IsBaseInterface returns true if baseType is on the base interface list of derivedType or
            any base class of derivedType. It may be on the base interface list either directly or
            indirectly.
            * baseType must be an interface.
            * type parameters do not have base interfaces. (They have an "effective interface list".)
            * an interface is not a base of itself.
            * this does not check for variance conversions; if a type inherits from
              IEnumerable&lt;string> then IEnumerable&lt;object> is not a base interface.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ExplicitConversionMayDifferFromImplicit(Microsoft.CodeAnalysis.CSharp.Conversion)">
            <summary>
            returns true when implicit conversion is not necessarily the same as explicit conversion
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.HasTopLevelNullabilityIdentityConversion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations)">
            <summary>
            Returns true if:
            - Either type has no nullability information (oblivious).
            - Both types cannot have different nullability at the same time,
              including the case of type parameters that by themselves can represent nullable and not nullable reference types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.HasTopLevelNullabilityImplicitConversion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations)">
            <summary>
            Returns false if source type can be nullable at the same time when destination type can be not nullable, 
            including the case of type parameters that by themselves can represent nullable and not nullable reference types.
            When either type has no nullability information (oblivious), this method returns true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.HasAnyNullabilityImplicitConversion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations)">
            <summary>
            Returns false if the source does not have an implicit conversion to the destination
            because of either incompatible top level or nested nullability.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.AnalyzeImplicitUserDefinedConversions(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <remarks>
            NOTE: Keep this method in sync with <see cref="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.AnalyzeImplicitUserDefinedConversionForV6SwitchGoverningType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ComputeApplicableUserDefinedImplicitConversionSet(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.ValueTuple{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol}},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.UserDefinedConversionAnalysis},Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,System.Boolean)">
            <summary>
            This method find the set of applicable user-defined and lifted conversion operators, u.
            The set consists of the user-defined and lifted implicit conversion operators declared by
            the classes and structs in d that convert from a type encompassing source to a type encompassed by target.
            However if allowAnyTarget is true, then it considers all operators that convert from a type encompassing source
            to any target. This flag must be set only if we are computing user defined conversions from a given source
            type to any target type.
            </summary>
            <remarks>
            Currently allowAnyTarget flag is only set to true by <see cref="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.AnalyzeImplicitUserDefinedConversionForV6SwitchGoverningType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)"/>,
            where we must consider user defined implicit conversions from the type of the switch expression to
            any of the possible switch governing types.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.MostSpecificConversionOperator(System.Func{Microsoft.CodeAnalysis.CSharp.UserDefinedConversionAnalysis,System.Boolean},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.UserDefinedConversionAnalysis})">
            <summary>
            Find the most specific among a set of conversion operators, with the given constraint on the conversion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.AnalyzeImplicitUserDefinedConversionForV6SwitchGoverningType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <remarks>
            NOTE: Keep this method in sync with AnalyzeImplicitUserDefinedConversion.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversions.ResolveDelegateOrFunctionPointerMethodGroup(Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.BoundMethodGroup,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.CallingConventionInfo@,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Resolve method group based on the optional delegate invoke method.
            If the invoke method is null, ignore arguments in resolution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversions.GetDelegateInvokeOrFunctionPointerMethodIfAvailable(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return the Invoke method symbol if the type is a delegate
            type and the Invoke method is available, otherwise null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversions.WithNullability(System.Boolean)">
            <summary>
            Returns this instance if includeNullability is correct, and returns a
            cached clone of this instance with distinct IncludeNullability otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolution.RemoveDelegateConversionsWithWrongReturnType``1(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.MemberResolutionResult{``0}},Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,System.Nullable{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Remove candidates to a delegate conversion where the method's return ref kind or return type is wrong.
            </summary>
            <param name="returnRefKind">The ref kind of the delegate's return, if known. This is only unknown in
            error scenarios, such as a delegate type that has no invoke method.</param>
            <param name="returnType">The return type of the delegate, if known. It isn't
            known when we're attempting to infer the return type of a method group for type inference.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolution.IsMoreDerivedOverride(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Does <paramref name="moreDerivedOverride"/> override <paramref name="member"/> or the
            thing that it originally overrides, but in a more derived class?
            </summary>
            <param name="checkOverrideContainingType">Set to false if the caller has already checked that
            <paramref name="moreDerivedOverride"/> is in a type that derives from the type containing
            <paramref name="member"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolution.MemberGroupContainsMoreDerivedOverride``1(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},``0,System.Boolean,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Does the member group <paramref name="members"/> contain an override of <paramref name="member"/> or the method it
            overrides, but in a more derived type?
            </summary>
            <param name="checkOverrideContainingType">Set to false if the caller has already checked that
            <paramref name="members"/> are all in a type that derives from the type containing
            <paramref name="member"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolution.HidesByName(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            This is specifically a private helper function (rather than a public property or extension method)
            because applying this predicate to a non-method member doesn't have a clear meaning.  The goal was
            simply to avoid repeating ad-hoc code in a group of related collections.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolution.GetParameterType(Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.MemberAnalysisResult)">
            <summary>
            Returns the parameter type (considering params).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolution.GetParameter(System.Int32,Microsoft.CodeAnalysis.CSharp.MemberAnalysisResult,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol})">
            <summary>
            Returns the parameter corresponding to the given argument index.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolution.RequiredFunctionType``1(Microsoft.CodeAnalysis.CSharp.MemberResolutionResult{``0})">
            <summary>
            Returns true if the overload required a function type conversion to infer
            generic method type arguments or to convert to parameter types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinaryOperatorSignature.Priority">
            <summary>
            To duplicate native compiler behavior for some scenarios we force a priority among
            operators. If two operators are both applicable and both have a non-null Priority,
            the one with the numerically lower Priority value is preferred.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberAnalysisResult.HasAnyRefOmittedArgument">
            <summary>
            Omit ref feature for COM interop: We can pass arguments by value for ref parameters if we are invoking a method/property on an instance of a COM imported type.
            This property returns a flag indicating whether we had any ref omitted argument for the given call.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberAnalysisResult.HasUseSiteDiagnosticToReportFor(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            Returns false for <see cref="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.UnsupportedMetadata"/>
            because those diagnostics are only reported if no other candidates are
            available.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind">
            <summary>
            Indicates why the compiler accepted or rejected the member during overload resolution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.None">
            <summary>
            No resolution has (yet) been determined.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.ApplicableInNormalForm">
            <summary>
            The candidate member was accepted in its normal (non-expanded) form.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.ApplicableInExpandedForm">
            <summary>
            The candidate member was accepted in its expanded form, after expanding a "params" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.InaccessibleTypeArgument">
            <summary>
            The candidate member was rejected because an inferred type argument is inaccessible.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.NoCorrespondingParameter">
            <summary>
            The candidate member was rejected because an argument was specified that did not have a corresponding
            parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.NoCorrespondingNamedParameter">
            <summary>
            The candidate member was rejected because a named argument was specified that did not have a corresponding
            parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.DuplicateNamedArgument">
            <summary>
            The candidate member was rejected because there were two named arguments with the same parameter name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.RequiredParameterMissing">
            <summary>
            The candidate member was rejected because a required parameter had no corresponding argument.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.NameUsedForPositional">
            <summary>
            The candidate member was rejected because a named argument was used that corresponded to a previously-given positional argument.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.BadNonTrailingNamedArgument">
            <summary>
            The candidate member was rejected because a named argument was used out-of-position and followed by unnamed arguments.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.UseSiteError">
            <summary>
            The candidate member was rejected because it is not supported by the language or cannot be used 
            given the current set of assembly references.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.UnsupportedMetadata">
            <summary>
            The candidate member was rejected because it is not supported by the language.
            </summary>
            <remarks>
            No diagnostics will be reported for such candidates unless they "win" overload resolution.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.BadArgumentConversion">
            <summary>
            The candidate member was rejected because an argument could not be converted to the appropriate parameter
            type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.TypeInferenceFailed">
            <summary>
            The candidate member was rejected because type inference failed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.TypeInferenceExtensionInstanceArgument">
            <summary>
            The extension method candidate was rejected because type
            inference based on the "instance" argument failed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.ConstructedParameterFailedConstraintCheck">
            <summary>
            The candidate member was rejected because a constraint on the type of a parameter was not satisfied.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.ConstraintFailure">
            <summary>
            The candidate method's type arguments do not satisfy their constraints.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.StaticInstanceMismatch">
            <summary>
            The candidate member was rejected because it was an instance member accessed from a type,
            or a static member accessed from an instance.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.WrongCallingConvention">
            <summary>
            The candidate member was rejected because its calling convention did not match the function pointer
            calling convention.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.WrongRefKind">
            <summary>
            The candidate method in a delegate conversion was rejected because the ref kind of its return does not match the delegate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.WrongReturnType">
            <summary>
            The candidate method in a delegate conversion was rejected because its return type does not match the return type of the delegate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.LessDerived">
            <summary>
            The candidate member was rejected because another member further down in the inheritance hierarchy was
            present.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.Worse">
            <summary>
            The candidate member was rejected because it was considered worse that another member (according to section
            7.5.3.2 of the language specification).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.Worst">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.Worse"/>, but the candidate shouldn't be mentioned in an ambiguity diagnostics.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1">
            <summary>
            Represents the results of overload resolution for a single member.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1.HasTypeArgumentInferredFromFunctionType">
            <summary>
            At least one type argument was inferred from a function type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1.Member">
            <summary>
            The member considered during overload resolution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1.LeastOverriddenMember">
            <summary>
            The least overridden member that is accessible from the call site that performed overload resolution. 
            Typically a virtual or abstract method (but not necessarily).
            </summary>
            <remarks>
            The member whose parameter types and params modifiers were considered during overload resolution.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1.Resolution">
            <summary>
            Indicates why the compiler accepted or rejected the member during overload resolution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1.IsValid">
            <summary>
            Returns true if the compiler accepted this member as the sole correct result of overload resolution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1.Result">
            <summary>
            The result of member analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodTypeInferenceResult.HasTypeArgumentInferredFromFunctionType">
            <summary>
            At least one type argument was inferred from a function type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MethodTypeInferrer.NumberArgumentsToProcess">
            <summary>
            For error recovery, we allow a mismatch between the number of arguments and parameters
            during type inference. This sometimes enables inferring the type for a lambda parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodTypeInferrer.GetInterfaceInferenceBound(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol},Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Return the interface with an original definition matches
            the original definition of the target. If the are no matches,
            or multiple matches, the return value is null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodTypeInferrer.GetInferredTypeArguments(System.Boolean@)">
            <summary>
            Return the inferred type arguments using null
            for any type arguments that were not inferred.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MethodTypeInferrer.EqualsIgnoringDynamicTupleNamesAndNullabilityComparer">
            <summary>
            This is a comparer that ignores differences in dynamic-ness and tuple names.
            But it has a special case for top-level object vs. dynamic for purpose of method type inference.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1">
            <summary>
            Summarizes the results of an overload resolution analysis, as described in section 7.5 of
            the language specification. Describes whether overload resolution succeeded, and which
            method was selected if overload resolution succeeded, as well as detailed information about
            each method that was considered. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.Succeeded">
            <summary>
            True if overload resolution successfully selected a single best method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.ValidResult">
            <summary>
            If overload resolution successfully selected a single best method, returns information
            about that method. Otherwise returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.BestResult">
            <summary>
            If there was a method that overload resolution considered better than all others,
            returns information about that method. A method may be returned even if that method was
            not considered a successful overload resolution, as long as it was better that any other
            potential method considered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.Results">
            <summary>
            Returns information about each method that was considered during overload resolution,
            and what the results of overload resolution were for that method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.HasAnyApplicableMember">
            <summary>
            Returns true if one or more of the members in the group are applicable. (Note that
            Succeeded implies IsApplicable but IsApplicable does not imply Succeeded.  It is possible
            that no applicable member was better than all others.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.GetAllApplicableMembers">
            <summary>
            Returns all methods in the group that are applicable, <see cref="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.HasAnyApplicableMember"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.ReportDiagnostics``1(Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.String,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,System.Collections.Immutable.ImmutableArray{``0},Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Boolean,System.Nullable{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Called when overload resolution has failed.  Figures out the best way to describe what went wrong.
            </summary>
            <remarks>
            Overload resolution (effectively) starts out assuming that all candidates are valid and then
            gradually disqualifies them.  Therefore, our strategy will be to perform our checks in the
            reverse order - the farther a candidate got through the process without being flagged, the
            "better" it was.
            
            Note that "final validation" is performed after overload resolution,
            so final validation errors are not seen here. Final validation errors include
            violations of constraints on method type parameters, static/instance mismatches,
            and so on.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.UnwrapIfParamsArray(Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,System.Boolean)">
            <summary>
            If an argument fails to convert to the type of the corresponding parameter and that
            parameter is a params array, then the error message should reflect the element type
            of the params array - not the array type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbol">
            <summary>
            The base class for all symbols (namespaces, classes, method, parameters, etc.) that are 
            exposed by the compiler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within named type 'within'.  If 'symbol' is accessed off
            of an expression then 'throughTypeOpt' is the type of that expression. This is needed to
            properly do protected access checks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.  
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.CheckDefinitionInvariant">
            <summary>
            Checks if this symbol is a definition and its containing module is a SourceModuleSymbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsDefinitionOrDistinct">
            <summary>
            Return whether the symbol is either the original definition
            or distinct from the original. Intended for use in Debug.Assert
            only since it may include a deep comparison.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetCustomAttributesToEmit(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData},System.Boolean,System.Boolean)">
            <summary>
            Returns a list of attributes to emit to CustomAttribute table.
            The <paramref name="synthesized"/> builder is freed after all its items are enumerated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.RequiresCompletion">
            <summary>
            True if this Symbol should be completed by calling ForceComplete.
            Intuitively, true for source entities (from any compilation).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.MetadataName">
            <summary>
            Gets the name of a symbol as it appears in metadata. Most of the time, this
            is the same as the Name property, with the following exceptions:
            1) The metadata name of generic types includes the "`1", "`2" etc. suffix that
            indicates the number of type parameters (it does not include, however, names of
            containing types or namespaces).
            2) The metadata name of explicit interface names have spaces removed, compared to
            the name property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.MetadataToken">
            <summary>
            Gets the token for this symbol as it appears in metadata. Most of the time this is 0,
            as it is when the symbol is not loaded from metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ContainingSymbol">
            <summary>
            Get the symbol that logically contains this symbol. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ContainingType">
            <summary>
            Returns the nearest lexically enclosing type, or null if there is none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ContainingNamespace">
            <summary>
            Gets the nearest enclosing namespace for this namespace or type. For a nested type,
            returns the namespace that contains its container.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ContainingAssembly">
            <summary>
            Returns the assembly containing this symbol. If this symbol is shared across multiple
            assemblies, or doesn't belong to an assembly, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.DeclaringCompilation">
            <summary>
            For a source assembly, the associated compilation.
            For any other assembly, null.
            For a source module, the DeclaringCompilation of the associated source assembly.
            For any other module, null.
            For any other symbol, the DeclaringCompilation of the associated module.
            </summary>
            <remarks>
            We're going through the containing module, rather than the containing assembly,
            because of /addmodule (symbols in such modules should return null).
            
            Remarks, not "ContainingCompilation" because it isn't transitive.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ContainingModule">
            <summary>
            Returns the module containing this symbol. If this symbol is shared across multiple
            modules, or doesn't belong to a module, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.MemberIndexOpt">
            <summary>
            The index of this member in the containing symbol. This is an optional
            property, implemented by anonymous type properties only, for comparing
            symbols in flow analysis.
            </summary>
            <remarks>
            Should this be used for tuple fields as well?
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsDefinition">
            <summary>
            Returns true if this is the original definition of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetLexicalSortKey">
            <summary>
            <para>
            Get a source location key for sorting. For performance, it's important that this
            be able to be returned from a symbol without doing any additional allocations (even
            if nothing is cached yet.)
            </para>
            <para>
            Only (original) source symbols and namespaces that can be merged
            need implement this function if they want to do so for efficiency.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.Locations">
            <summary>
            Gets the locations where this symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.DeclaringSyntaxReferences">
            <summary>
            <para>
            Get the syntax node(s) where this symbol was declared in source. Some symbols (for
            example, partial classes) may be defined in more than one location. This property should
            return one or more syntax nodes only if the symbol was declared in source code and also
            was not implicitly declared (see the <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsImplicitlyDeclared"/> property). 
            </para>
            <para>
            Note that for namespace symbol, the declaring syntax might be declaring a nested
            namespace. For example, the declaring syntax node for N1 in "namespace N1.N2 {...}" is
            the entire <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax"/> for N1.N2. For the global namespace, the declaring
            syntax will be the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax"/>.
            </para>
            </summary>
            <returns>
            The syntax node(s) that declared the symbol. If the symbol was declared in metadata or
            was implicitly declared, returns an empty read-only array.
            </returns>
            <remarks>
            To go the opposite direction (from syntax node to symbol), see <see
            cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetDeclaringSyntaxReferenceHelper``1(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})">
            <summary>
            Helper for implementing <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.DeclaringSyntaxReferences"/> for derived classes that store a location but not a 
            <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> or <see cref="T:Microsoft.CodeAnalysis.SyntaxReference"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns <see cref="F:Microsoft.CodeAnalysis.Accessibility.NotApplicable"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the <c>static</c> modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the <c>virtual</c> modifier. Does not return true for
            members declared as abstract or override.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the <c>override</c> modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
            <remarks>
            Even for metadata symbols, <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsOverride"/> = true does not imply that <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.OverriddenMethod"/> will
            be non-null.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the <c>abstract</c> modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the <c>sealed</c> modifier. Also set for
            types that do not allow a derived class (declared with <c>sealed</c> or <c>static</c> or <c>struct</c>
            or <c>enum</c> or <c>delegate</c>).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            <c>extern</c> modifier. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsImplicitlyDeclared">
            <summary>
            Returns true if this symbol was automatically created by the compiler, and does not
            have an explicit corresponding source code declaration.  
            
            This is intended for symbols that are ordinary symbols in the language sense,
            and may be used by code, but that are simply declared implicitly rather than
            with explicit language syntax.
            
            Examples include (this list is not exhaustive):
              the default constructor for a class or struct that is created if one is not provided,
              the BeginInvoke/Invoke/EndInvoke methods for a delegate,
              the generated backing field for an auto property or a field-like event,
              the "this" parameter for non-static methods,
              the "value" parameter for a property setter,
              the parameters on indexer accessor methods (not on the indexer itself),
              methods in anonymous types,
              anonymous functions
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.CanBeReferencedByName">
            <summary>
            Returns true if this symbol can be referenced by its name in code. Examples of symbols
            that cannot be referenced by name are:
               constructors, destructors, operators, explicit interface implementations,
               accessor methods for properties and events, array types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.CanBeReferencedByNameIgnoringIllegalCharacters">
            <summary>
            As an optimization, viability checking in the lookup code should use this property instead
            of <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.CanBeReferencedByName"/>. The full name check will then be performed in the <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel"/>.
            </summary>
            <remarks>
            This property exists purely for performance reasons.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.AfterAddingTypeMembersChecks(Microsoft.CodeAnalysis.CSharp.ConversionsBase,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Perform additional checks after the member has been
            added to the member list of the containing type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.op_Equality(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Compare two symbol objects to see if they refer to the same symbol. You should always
            use <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.op_Equality(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol)"/> and <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.op_Inequality(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol)"/>, or the <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.Equals(System.Object)"/> method, to compare two symbols for equality.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.op_Inequality(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Compare two symbol objects to see if they refer to the same symbol. You should always
            use == and !=, or the Equals method, to compare two symbols for equality.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.ToString">
            <summary>
            Returns a string representation of this symbol, suitable for debugging purposes, or
            for placing in an error message.
            </summary>
            <remarks>
            This will provide a useful representation, but it would be clearer to call <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.ToDisplayString(Microsoft.CodeAnalysis.SymbolDisplayFormat)"/>
            directly and provide an explicit format.
            Sealed so that <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.ToString"/> and <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.ToDisplayString(Microsoft.CodeAnalysis.SymbolDisplayFormat)"/> can't get out of sync.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.AddSynthesizedAttributes(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData}@)">
            <summary>
            Build and add synthesized attributes for this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.AddSynthesizedAttribute(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData}@,Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData)">
            <summary>
            Convenience helper called by subclasses to add a synthesized attribute to a collection of attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetEffectiveDefaultMarshallingCharSet">
            <summary>
            <see cref="T:System.Runtime.InteropServices.CharSet"/> effective for this symbol (type or DllImport method).
            Nothing if <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> isn't applied on the containing module or it doesn't apply on this symbol.
            </summary>
            <remarks>
            Determined based upon value specified via <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> applied on the containing module.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.Dangerous_IsFromSomeCompilation">
            <summary>
            Always prefer <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsFromCompilation(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)"/>.
            </summary>
            <remarks>
            <para>
            Unfortunately, when determining overriding/hiding/implementation relationships, we don't 
            have the "current" compilation available.  We could, but that would clutter up the API 
            without providing much benefit.  As a compromise, we consider all compilations "current".
            </para>
            <para>
            Unlike in VB, we are not allowing retargeting symbols.  This method is used as an approximation
            for <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsFromCompilation(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)"/> when a compilation is not available and that method will never return
            true for retargeting symbols.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetDocumentationCommentId">
            <summary>
            Returns the Documentation Comment ID for the symbol, or null if the symbol doesn't
            support documentation comments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetDocumentationCommentXml(System.Globalization.CultureInfo,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Fetches the documentation comment for this element with a cancellation token.
            </summary>
            <param name="preferredCulture">Optionally, retrieve the comments formatted for a particular culture. No impact on source documentation comments.</param>
            <param name="expandIncludes">Optionally, expand <![CDATA[<include>]]> elements. No impact on non-source documentation comments.</param>
            <param name="cancellationToken">Optionally, allow cancellation of documentation comment retrieval.</param>
            <returns>The XML that would be written to the documentation file for the symbol.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.HasUseSiteError">
            <summary>
            True if the symbol has a use-site diagnostic with error severity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetUseSiteInfo">
            <summary>
            Returns diagnostic info that should be reported at the use site of the symbol, or default if there is none.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsHighestPriorityUseSiteErrorCode(System.Int32)">
            <summary>
            Returns true if the error code is the highest priority while calculating use site error for this symbol. 
            Supposed to be ErrorCode, but it causes inconsistent accessibility error.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.HasUnsupportedMetadata">
            <summary>
            Indicates that this symbol uses metadata that cannot be supported by the language.
            
            Examples include:
               - Pointer types in VB
               - ByRef return type
               - Required custom modifiers
               
            This is distinguished from, for example, references to metadata symbols defined in assemblies that weren't referenced.
            Symbols where this returns true can never be used successfully, and thus should never appear in any IDE feature.
            
            This is set for metadata symbols, as follows:
            Type - if a type is unsupported (e.g., a pointer type, etc.)
            Method - parameter or return type is unsupported
            Field - type is unsupported
            Event - type is unsupported
            Property - type is unsupported
            Parameter - type is unsupported
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.MergeUseSiteDiagnostics(Microsoft.CodeAnalysis.DiagnosticInfo@,Microsoft.CodeAnalysis.DiagnosticInfo)">
            <summary>
            Merges given diagnostic to the existing result diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.MergeUseSiteInfo(Microsoft.CodeAnalysis.UseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Microsoft.CodeAnalysis.UseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol})">
            <summary>
            Merges given diagnostic and dependencies to the existing result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.ReportUseSiteDiagnostic(Microsoft.CodeAnalysis.DiagnosticInfo,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.Location)">
            <summary>
            Reports specified use-site diagnostic to given diagnostic bag. 
            </summary>
            <remarks>
            This method should be the only method adding use-site diagnostics to a diagnostic bag. 
            It performs additional adjustments of the location for unification related diagnostics and 
            may be the place where to add more use-site location post-processing.
            </remarks>
            <returns>True if the diagnostic has error severity.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.DeriveUseSiteInfoFromType(Microsoft.CodeAnalysis.UseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Derive use-site info from a type symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the <see cref="T:System.ObsoleteAttribute"/> attribute. 
            This property returns <see cref="F:Microsoft.CodeAnalysis.ThreeState.Unknown"/> if the <see cref="T:System.ObsoleteAttribute"/> attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from <see cref="T:System.ObsoleteAttribute"/> attribute or null if there is no <see cref="T:System.ObsoleteAttribute"/> attribute.
            This property returns <see cref="F:Microsoft.CodeAnalysis.ObsoleteAttributeData.Uninitialized"/> if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetGuidStringDefaultImplementation(System.String@)">
            <summary>
            Returns true and a <see cref="T:System.String"/> from the first <see cref="T:System.Runtime.InteropServices.GuidAttribute"/> on the symbol, 
            the string might be null or an invalid guid representation. False, 
            if there is no <see cref="T:System.Runtime.InteropServices.GuidAttribute"/> with string argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsCaptured(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol)">
            <summary>
            True if the symbol is declared outside of the scope of the containing
            symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetAttributes">
            <summary>
            Gets the attributes for this symbol. Returns an empty <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> if
            there are no attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetAttributeTarget">
            <summary>
            Gets the attribute target kind corresponding to the symbol kind
            If attributes cannot be applied to this symbol kind, returns
            an invalid AttributeTargets value of 0
            </summary>
            <returns>AttributeTargets or 0</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.EarlyDecodeWellKnownAttributeType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>
            Method to early decode the type of well-known attribute which can be queried during the BindAttributeType phase.
            This method is called first during attribute binding so that any attributes that affect semantics of type binding
            can be decoded here.
            </summary>
            <remarks>
            NOTE: If you are early decoding any new well-known attribute, make sure to update PostEarlyDecodeWellKnownAttributeTypes 
            to default initialize this data.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.PostEarlyDecodeWellKnownAttributeTypes">
            <summary>
            This method is called during attribute binding after EarlyDecodeWellKnownAttributeTypes has been executed.
            Symbols should default initialize the data for early decoded well-known attributes here.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.EarlyDecodeWellKnownAttribute(Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.CSharp.EarlyWellKnownAttributeBinder,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation}@)">
            <summary>
            Method to early decode applied well-known attribute which can be queried by the binder.
            This method is called during attribute binding after we have bound the attribute types for all attributes,
            but haven't yet bound the attribute arguments/attribute constructor.
            Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol
            when binding the attribute arguments/attribute constructor without causing attribute binding cycle.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.DecodeWellKnownAttribute(Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation}@)">
            <summary>
            This method is called by the binder when it is finished binding a set of attributes on the symbol so that
            the symbol can extract data from the attribute arguments and potentially perform validation specific to
            some well known attributes.
            <para>
            NOTE: If we are decoding a well-known attribute that could be queried by the binder, consider decoding it during early decoding pass.
            </para>
            </summary>
            <remarks>
            <para>
            Symbol types should override this if they want to handle a specific well-known attribute.
            If the attribute is of a type that the symbol does not wish to handle, it should delegate back to
            this (base) method.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.PostDecodeWellKnownAttributes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,Microsoft.CodeAnalysis.WellKnownAttributeData)">
            <summary>
            Called to report attribute related diagnostics after all attributes have been bound and decoded.
            Called even if there are no attributes.
            </summary>
            <remarks>
            This method is called by the binder from <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany{Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax}},Microsoft.CodeAnalysis.CustomAttributesBag{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData}@,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,System.Boolean,Microsoft.CodeAnalysis.CSharp.Binder,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Boolean},System.Action{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax},System.Action{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax})"/> after it has finished binding attributes on the symbol,
            has executed <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.DecodeWellKnownAttribute(Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation}@)"/> for attributes applied on the symbol and has stored the decoded data in the
            lazyCustomAttributesBag on the symbol. Bound attributes haven't been stored on the bag yet.
            
            Post-validation for attributes that is dependent on other attributes can be done here.
            
            This method should not have any side effects on the symbol, i.e. it SHOULD NOT change the symbol state.
            </remarks>
            <param name="boundAttributes">Bound attributes.</param>
            <param name="allAttributeSyntaxNodes">Syntax nodes of attributes in order they are specified in source, or null if there are no attributes.</param>
            <param name="diagnostics">Diagnostic bag.</param>
            <param name="symbolPart">Specific part of the symbol to which the attributes apply, or <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation.None"/> if the attributes apply to the symbol itself.</param>
            <param name="decodedData">Decoded well-known attribute data, could be null.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany{Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax}},Microsoft.CodeAnalysis.CustomAttributesBag{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData}@,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,System.Boolean,Microsoft.CodeAnalysis.CSharp.Binder,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Boolean},System.Action{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax},System.Action{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax})">
            <summary>
            This method does the following set of operations in the specified order:
            (1) GetAttributesToBind: Merge attributes from the given attributesSyntaxLists and filter out attributes by attribute target.
            (2) BindAttributeTypes: Bind all the attribute types to enable early decode of certain well-known attributes by type.
            (3) EarlyDecodeWellKnownAttributes: Perform early decoding of certain well-known attributes that could be queried by the binder in subsequent steps.
                (NOTE: This step has the side effect of updating the symbol state based on the data extracted from well known attributes).
            (4) GetAttributes: Bind the attributes (attribute arguments and constructor) using bound attribute types.
            (5) DecodeWellKnownAttributes: Decode and validate bound well known attributes.
                (NOTE: This step has the side effect of updating the symbol state based on the data extracted from well known attributes).
            (6) StoreBoundAttributesAndDoPostValidation:
                (a) Store the bound attributes in lazyCustomAttributes in a thread safe manner.
                (b) Perform some additional post attribute validations, such as
                    1) Duplicate attributes, attribute usage target validation, etc.
                    2) Post validation for attributes dependent on other attributes
                    These validations cannot be performed prior to step 6(a) as we might need to
                    perform a GetAttributes() call on a symbol which can introduce a cycle in attribute binding.
                    We avoid this cycle by performing such validations in PostDecodeWellKnownAttributes after lazyCustomAttributes have been set.
                NOTE: PostDecodeWellKnownAttributes SHOULD NOT change the symbol state.
            </summary>
            <remarks>
            Current design of early decoding well-known attributes doesn't permit decoding attribute arguments/constructor as this can lead to binding cycles.
            For well-known attributes used by the binder, where we need the decoded arguments, we must handle them specially in one of the following possible ways:
              (a) Avoid decoding the attribute arguments during binding and delay the corresponding binder tasks to a separate post-pass executed after binding.
              (b) As the cycles can be caused only when we are binding attribute arguments/constructor, special case the corresponding binder tasks based on the current BinderFlags.
            </remarks>
            <param name="attributesSyntaxLists"></param>
            <param name="lazyCustomAttributesBag"></param>
            <param name="symbolPart">Specific part of the symbol to which the attributes apply, or <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation.None"/> if the attributes apply to the symbol itself.</param>
            <param name="earlyDecodingOnly">Indicates that only early decoding should be performed.  WARNING: the resulting bag will not be sealed.</param>
            <param name="binderOpt">Binder to use. If null, <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.DeclaringCompilation"/> GetBinderFactory will be used.</param>
            <param name="attributeMatchesOpt">If specified, only load attributes that match this predicate, and any diagnostics produced will be dropped.</param>
            <param name="beforeAttributePartBound">If specified, invoked before any part of the attribute syntax is bound.</param>
            <param name="afterAttributePartBound">If specified, invoked after any part of the attribute syntax is bound.</param>
            <returns>Flag indicating whether lazyCustomAttributes were stored on this thread. Caller should check for this flag and perform NotePartComplete if true.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetAttributesToBind(Roslyn.Utilities.OneOrMany{Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax}},Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Boolean},Microsoft.CodeAnalysis.CSharp.Binder,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Binder}@)">
            <summary>
            Method to merge attributes from the given attributesSyntaxLists and filter out attributes by attribute target.
            This is the first step in attribute binding.
            </summary>
            <remarks>
            This method can generate diagnostics for few cases where we have an invalid target specifier and the parser hasn't generated the necessary diagnostics.
            It should not perform any bind operations as it can lead to an attribute binding cycle.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.EarlyDecodeWellKnownAttributes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Binder},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax},Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData[],Microsoft.CodeAnalysis.CSharp.BoundAttribute[])">
            <summary>
            Method to early decode certain well-known attributes which can be queried by the binder.
            This method is called during attribute binding after we have bound the attribute types for all attributes,
            but haven't yet bound the attribute arguments/attribute constructor.
            Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol
            when binding the attribute arguments/attribute constructor without causing attribute binding cycle.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.ValidateAttributeUsageAndDecodeWellKnownAttributes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Binder},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation)">
            <summary>
            This method validates attribute usage for each bound attribute and calls <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.DecodeWellKnownAttributeImpl(Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation}@)"/>
            on attributes with valid attribute usage.
            This method is called by the binder when it is finished binding a set of attributes on the symbol so that
            the symbol can extract data from the attribute arguments and potentially perform validation specific to
            some well known attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.ValidateAttributeUsage(Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol})">
            <summary>
            Validate attribute usage target and duplicate attributes.
            </summary>
            <param name="attribute">Bound attribute</param>
            <param name="node">Syntax node for attribute specification</param>
            <param name="compilation">Compilation</param>
            <param name="symbolPart">Symbol part to which the attribute has been applied.</param>
            <param name="diagnostics">Diagnostics</param>
            <param name="uniqueAttributeTypes">Set of unique attribute types applied to the symbol</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.ForceCompleteObsoleteAttribute">
            <summary>
            Ensure that attributes are bound and the ObsoleteState of this symbol is known.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SimpleProgramBinder">
            <summary>
            This binder owns the scope for Simple Program top-level statements.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SimpleProgramUnitBinder">
            <summary>
            This binder provides a context for binding within a specific compilation unit, but outside of top-level statements.
            It ensures that locals are in scope, however it is not responsible
            for creating the symbols. That task is actually owned by <see cref="T:Microsoft.CodeAnalysis.CSharp.SimpleProgramBinder"/> and
            this binder simply delegates to it when appropriate. That ensures that the same set of symbols is 
            shared across all compilation units.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SingleLookupResult">
            <summary>
            Represents a result of lookup operation over a 0 or 1 symbol (as opposed to a scope). The
            typical use is to represent that a particular symbol is good/bad/unavailable.
            
            For more explanation of Kind, Symbol, Error - see LookupResult.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SwitchBinder.BindSwitchStatementCore(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Bind the switch statement, reporting in the process any switch labels that are subsumed by previous cases.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SwitchBinder.BindPatternSwitchLabelForInference(Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Bind a pattern switch label in order to force inference of the type of pattern variables.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SwitchBinder.BindSwitchSections(Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.BoundSwitchLabel@)">
            <summary>
            Bind the pattern switch labels.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SwitchBinder.BindSwitchSection(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.BoundSwitchLabel@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Bind the pattern switch section.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SwitchExpressionArmBinder">
            <summary>
            Binder for one of the arms of a switch expression. For example, in the one-armed switch expression
            "e switch { p when c => v }", this could be the binder for the arm "p when c => v".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SwitchExpressionBinder.CheckSwitchExpressionExhaustive(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundSwitchExpressionArm},Microsoft.CodeAnalysis.CSharp.BoundDecisionDag@,Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Build the decision dag, giving an error if some cases are subsumed and a warning if the switch expression is not exhaustive.
            </summary>
            <param name="node"></param>
            <param name="boundInputExpression"></param>
            <param name="switchArms"></param>
            <param name="decisionDag"></param>
            <param name="diagnostics"></param>
            <returns>true if there was a non-exhaustive warning reported</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SwitchExpressionBinder.InferResultType(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundSwitchExpressionArm},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Infer the result type of the switch expression by looking for a common type
            to which every arm's expression can be converted.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TypeofBinder">
            <summary>
            This binder is for binding the argument to typeof.  It traverses
            the syntax marking each open type ("unbound generic type" in the
            C# spec) as either allowed or not allowed, so that BindType can 
            appropriately return either the corresponding type symbol or an 
            error type.  It also indicates whether the argument as a whole 
            should be considered open so that the flag can be set 
            appropriately in BoundTypeOfOperator.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TypeofBinder.OpenTypeVisitor">
            <summary>
            This visitor walks over a type expression looking for open types.
            Open types are allowed if an only if:
              1) There is no constructed generic type elsewhere in the visited syntax; and
              2) The open type is not used as a type argument or array/pointer/nullable
                   element type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeofBinder.OpenTypeVisitor.Visit(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax,System.Boolean}@,System.Boolean@)">
            <param name="typeSyntax">The argument to typeof.</param>
            <param name="allowedMap">
            Keys are GenericNameSyntax nodes representing unbound generic types.
            Values are false if the node should result in an error and true otherwise.
            </param>
            <param name="isUnboundGenericType">True if no constructed generic type was encountered.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.WithClassTypeParametersBinder">
            <summary>
            A binder that places class/interface/struct/delegate type parameters in scope
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.WithCrefTypeParametersBinder">
            <summary>
            The scope within a documentation cref.  Contains the implicitly declared type parameters
            of the cref (see <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.CrefTypeParameterSymbol"/> for details).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.WithExternAliasesBinder">
            <summary>
            A binder that brings extern aliases into the scope and deals with looking up names in them.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.WithExternAndUsingAliasesBinder">
            <summary>
            A binder that brings both extern and using aliases into the scope and deals with looking up names in them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.WithExternAndUsingAliasesBinder.Create(Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            This overload is added to shadow the one from the base.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.WithExternAndUsingAliasesBinder.FromSyntax.QuickAttributeChecker">
            <summary>
            Get <see cref="P:Microsoft.CodeAnalysis.CSharp.WithExternAndUsingAliasesBinder.FromSyntax.QuickAttributeChecker"/> that can be used to quickly
            check for certain attribute applications in context of this binder.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.WithMethodTypeParametersBinder">
            <summary>
            A binder that places method type parameters in scope.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.WithParametersBinder">
            <summary>
            Binder used to place the parameters of a method, property, indexer, or delegate
            in scope when binding &lt;param&gt; tags inside of XML documentation comments
            and `nameof` in certain attribute positions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.WithUsingNamespacesAndTypesBinder">
            <summary>
            A binder that represents a scope introduced by 'using' namespace or type directives and deals with looking up names in it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.WithUsingNamespacesAndTypesBinder.GetForwardedToAssemblyInUsingNamespaces(System.String,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.Location)">
            <summary>
            Look for a type forwarder for the given type in any referenced assemblies, checking any using namespaces in
            the current imports.
            </summary>
            <param name="name">The metadata name of the (potentially) forwarded type, without qualifiers.</param>
            <param name="qualifierOpt">Will be used to return the namespace of the found forwarder, 
            if any.</param>
            <param name="diagnostics">Will be used to report non-fatal errors during look up.</param>
            <param name="location">Location to report errors on.</param>
            <returns>Returns the Assembly to which the type is forwarded, or null if none is found.</returns>
            <remarks>
            Since this method is intended to be used for error reporting, it stops as soon as it finds
            any type forwarder (or an error to report). It does not check other assemblies for consistency or better results.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundDagEvaluation.IsEquivalentTo(Microsoft.CodeAnalysis.CSharp.BoundDagEvaluation)">
            <summary>
            Check if this is equivalent to the <paramref name="other"/> node, ignoring the input.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundDagTemp.IsOriginalInput">
            <summary>
            Does this dag temp represent the original input of the pattern-matching operation?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundDagTemp.IsEquivalentTo(Microsoft.CodeAnalysis.CSharp.BoundDagTemp)">
            <summary>
            Check if this is equivalent to the <paramref name="other"/> node, ignoring the source.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundDecisionDag.TopologicallySortedNodes">
            <summary>
            A list of all the nodes reachable from the root node, in a topologically sorted order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundDecisionDag.Rewrite(System.Func{Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,System.Collections.Generic.IReadOnlyDictionary{Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode},Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode})">
            <summary>
            Rewrite a decision dag, using a mapping function that rewrites one node at a time. That function
            takes as its input the node to be rewritten and a function that returns the previously computed
            rewritten node for successor nodes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundDecisionDag.TrivialReplacement(Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,System.Collections.Generic.IReadOnlyDictionary{Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode})">
            <summary>
            A trivial node replacement function for use with <see cref="M:Microsoft.CodeAnalysis.CSharp.BoundDecisionDag.Rewrite(System.Func{Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,System.Collections.Generic.IReadOnlyDictionary{Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode},Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode})"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundDecisionDag.SimplifyDecisionDagIfConstantInput(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Given a decision dag and a constant-valued input, produce a simplified decision dag that has removed all the
            tests that are unnecessary due to that constant value. This simplification affects flow analysis (reachability
            and definite assignment) and permits us to simplify the generated code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundExpression.SuppressVirtualCalls">
            <summary>
            Returns true if calls and delegate invocations with this
            expression as the receiver should be non-virtual calls.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundExpression.Display">
            <summary>
            Returns a serializable object that is used for displaying this expression in a diagnostic message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundConversion.ConversionHasSideEffects">
            <summary>
            Returns true when conversion itself (not the operand) may have side-effects
            A typical side-effect of a conversion is an exception when conversion is unsuccessful.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundConversion.SynthesizedNonUserDefined(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.ConstantValue)">
            <remarks>
            This method is intended for passes other than the LocalRewriter.
            Use MakeConversion helper method in the LocalRewriter instead,
            it generates a synthesized conversion in its lowered form.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundConversion.Synthesized(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Conversion,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.ConversionGroup,Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <remarks>
            NOTE:    This method is intended for passes other than the LocalRewriter.
            NOTE:    Use MakeConversion helper method in the LocalRewriter instead,
            NOTE:    it generates a synthesized conversion in its lowered form.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundObjectCreationExpression.UpdateArgumentsAndInitializer(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.CSharp.BoundObjectInitializerExpressionBase,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Build an object creation expression without performing any rewriting
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundLambda.GetInferredReturnType(Microsoft.CodeAnalysis.CSharp.ConversionsBase,Microsoft.CodeAnalysis.CSharp.NullableWalker.VariableState,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,System.Boolean@)">
            <summary>
            Infer return type. If `nullableState` is non-null, nullability is also inferred and `NullableWalker.Analyze`
            uses that state to set the inferred nullability of variables in the enclosing scope. `conversions` is
            only needed when nullability is inferred.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundLambda.NoReturnExpression">
            <summary>
            Indicates the type of return statement with no expression. Used in InferReturnType.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundLambda.InferReturnTypeImpl(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.ValueTuple{Microsoft.CodeAnalysis.CSharp.BoundReturnStatement,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations}},Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.ConversionsBase,System.Boolean)">
            <summary>
            Behavior of this function should be kept aligned with <see cref="T:Microsoft.CodeAnalysis.CSharp.UnboundLambdaState.ReturnInferenceCacheKey"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundTupleExpression.VisitAllElements``1(System.Action{Microsoft.CodeAnalysis.CSharp.BoundExpression,``0},``0)">
            <summary>
            Applies action to all the nested elements of this tuple.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions.GetRefKind(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Returns the RefKind if the expression represents a symbol
            that has a RefKind, or RefKind.None otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BoundLocalDeclarationKind">
            <summary>
            Indicates whether a bound local is also a declaration, and if so was it a declaration with an explicit or an inferred type.
            Ex:
            - In `M(x)`, `x` has `LocalDeclarationKind.None`
            - In `M(out int x)`, `x` has `LocalDeclarationKind.WithExplicitType`
            - In `M(out var x)`, `x` has `LocalDeclarationKind.WithInferredType`
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundMethodGroupFlags.HasImplicitReceiver">
            <summary>
            Set if the group has a receiver but one was not specified in syntax.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundNode.Syntax">
            <summary>
            Sequence points permit Syntax to be null.  But all other contexts require a non-null Syntax,
            so we annotate it for the majority of uses.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundNode.BoundNodeAttributes.WasCompilerGeneratedIsChecked">
            <summary>
            Captures the fact that consumers of the node already checked the state of the WasCompilerGenerated bit.
            Allows to assert on attempts to set WasCompilerGenerated bit after that.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundNode.BoundNodeAttributes.WasConverted">
            <summary>
            Captures the fact that the node was either converted to some type, or converted to its natural
            type.  This is used to check the fact that every rvalue must pass through one of the two,
            so that expressions like tuple literals and switch expressions can reliably be rewritten once
            the target type is known.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundNode.HasAnyErrors">
            <summary>
            Determines if a bound node, or associated syntax or type has an error (not a warning) 
            diagnostic associated with it.
            
            Typically used in the binder as a way to prevent cascading errors. 
            In most other cases a more lightweight HasErrors should be used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundNode.HasErrors">
            <summary>
            Determines if a bound node, or any child, grandchild, etc has an error (not warning)
            diagnostic associated with it. The HasError bit is initially set for a node by providing it
            to the node constructor. If any child nodes of a node have
            the HasErrors bit set, then it is automatically set to true on the parent bound node.
            
            HasErrors indicates that the tree is not emittable and used to short-circuit lowering/emit stages.
            NOTE: not having HasErrors does not guarantee that we do not have any diagnostic associated
                  with corresponding syntax or type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundNode.WasCompilerGenerated">
            <remarks>
            NOTE: not generally set in rewriters.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundNode.TopLevelNullability">
            <summary>
            Top level nullability for the node. This should not be used by flow analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundNode.TopLevelNullabilityCore">
            <summary>
            This is for debugger display use only: <see cref="P:Microsoft.CodeAnalysis.CSharp.BoundNode.TopLevelNullability"/> will set the BoundNodeAttributes.WasTopLevelNullabilityChecked
            bit in the boundnode properties, which will break debugging. This allows the debugger to display the current value without setting the bit.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundNode.WithHasErrors">
            <summary>
            Return a clone of the current node with the HasErrors flag set.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundNode.Children">
            <summary>
            Override this property to return the child bound nodes if the IOperation API corresponding to this bound node is not yet designed or implemented.
            </summary>
            <remarks>Note that any of the child bound nodes may be null.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundNodeExtensions.VisitBinaryOperatorInterpolatedString``2(Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator,``1,System.Func{``0,``1,System.Boolean},System.Action{Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator,``1})">
            <summary>
            Visits the binary operator tree of interpolated string additions in a depth-first pre-order visit,
            meaning parent, left, then right.
            <paramref name="stringCallback"/> controls whether to continue the visit by returning true or false:
            if true, the visit will continue. If false, the walk will be cut off.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundNodeExtensions.RewriteInterpolatedStringAddition``3(Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator,``1,System.Func{``0,System.Int32,``1,``2},System.Func{Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator,``2,``2,``1,``2})">
            <summary>
            Rewrites a BoundBinaryOperator composed of interpolated strings (either converted or unconverted) iteratively, without
            recursion on the left side of the tree. Nodes of the tree are rewritten in a depth-first post-order fashion, meaning
            left, then right, then parent.
            </summary>
            <param name="binary">The original top of the binary operations.</param>
            <param name="arg">The callback args.</param>
            <param name="interpolatedStringFactory">
            Rewriter for the BoundInterpolatedString or BoundUnconvertedInterpolatedString parts of the binary operator. Passed the callback
            parameter, the original interpolated string, and the index of the interpolated string in the tree.
            </param>
            <param name="binaryOperatorFactory">
            Rewriter for the BoundBinaryOperator parts fo the binary operator. Passed the callback parameter, the original binary operator, and
            the rewritten left and right components.
            </param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingOperatorResultKind">
            <summary>
            Represents the operand type used for the result of a null-coalescing
            operator. Used when determining nullability.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingOperatorResultKind.NoCommonType">
            <summary>
            No valid type for operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingOperatorResultKind.LeftType">
            <summary>
            Type of left operand is used.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingOperatorResultKind.LeftUnwrappedType">
            <summary>
            Nullable underlying type of left operand is used.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingOperatorResultKind.RightType">
            <summary>
            Type of right operand is used.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingOperatorResultKind.LeftUnwrappedRightType">
            <summary>
            Type of right operand is used and nullable left operand is converted
            to underlying type before converting to right operand type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingOperatorResultKind.RightDynamicType">
            <summary>
            Type of right operand is dynamic and is used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundPattern.IsNegated(Microsoft.CodeAnalysis.CSharp.BoundPattern@)">
            <summary>
            Sets <paramref name="innerPattern"/> to the inner pattern after stripping off outer
            <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundNegatedPattern"/>s, and returns true if the original pattern is a
            negated form of the inner pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(System.Int32@,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Consumers must provide implementation for <see cref="M:Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithoutStackGuard(Microsoft.CodeAnalysis.CSharp.BoundExpression)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithoutStackGuard(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            We should be intentional about behavior of derived classes regarding guarding against stack overflow.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard">
            <summary>
            Note: do not use a static/singleton instance of this type, as it holds state.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator">
            <summary>
            Note: do not use a static/singleton instance of this type, as it holds state.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConversionGroup">
            <summary>
            A group is a common instance referenced by all BoundConversion instances
            generated from a single Conversion. The group is used by NullableWalker to
            determine which BoundConversion nodes should be considered as a unit.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ConversionGroup.IsExplicitConversion">
            <summary>
            True if the conversion is an explicit conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ConversionGroup.Conversion">
            <summary>
            The conversion (from Conversions.ClassifyConversionFromExpression for
            instance) from which all BoundConversions in the group were created.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ConversionGroup.ExplicitType">
            <summary>
            The target type of the conversion specified explicitly in source,
            or null if not an explicit conversion.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IBoundInvalidNode">
            <summary>
            For nodes that can generate an <see cref="T:Microsoft.CodeAnalysis.Operations.IInvalidOperation"/>, this allows the Lazy implementation
            to get the children of this node on demand.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.InterpolatedStringHandlerData.ScopeOfContainingExpression">
            <summary>
            The scope of the expression that contained the interpolated string during initial binding. This is used to determine the SafeToEscape rules
            for the builder during lowering.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.InterpolatedStringHandlerData.ArgumentPlaceholders">
            <summary>
            The placeholders that are used for <see cref="F:Microsoft.CodeAnalysis.CSharp.InterpolatedStringHandlerData.Construction"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InterpolatedStringHandlerData.GetValidConstructor">
            <summary>
            Simple helper method to get the object creation expression for this data. This should only be used in
            scenarios where the data in <see cref="F:Microsoft.CodeAnalysis.CSharp.InterpolatedStringHandlerData.Construction"/> is known to be valid, or it will throw.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.PseudoVariableExpressions">
            <summary>
            BoundExpressions to be used for emit. The expressions are assumed
            to be lowered and will not be visited by <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundTreeWalker"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TupleBinaryOperatorInfo">
             <summary>
             A tree of binary operators for tuple comparisons.
            
             For <c>(a, (b, c)) == (d, (e, f))</c> we'll hold a Multiple with two elements.
             The first element is a Single (describing the binary operator and conversions that are involved in <c>a == d</c>).
             The second element is a Multiple containing two Singles (one for the <c>b == e</c> comparison and the other for <c>c == f</c>).
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TupleBinaryOperatorInfo.Single">
            <summary>
            Holds the information for an element-wise comparison (like <c>a == b</c> as part of <c>(a, ...) == (b, ...)</c>)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TupleBinaryOperatorInfo.Multiple">
            <summary>
            Holds the information for a tuple comparison, either at the top-level (like <c>(a, b) == ...</c>) or nested (like <c>(..., (a, b)) == (..., ...)</c>).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TupleBinaryOperatorInfo.NullNull">
            <summary>
            Represents an element-wise null/null comparison.
            For instance, <c>(null, ...) == (null, ...)</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UnboundLambdaState.GetLambdaExpressionBody(Microsoft.CodeAnalysis.CSharp.BoundBlock)">
            <summary>
            Return the bound expression if the lambda has an expression body and can be reused easily.
            This is an optimization only. Implementations can return null to skip reuse.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UnboundLambdaState.CreateBlockFromLambdaExpressionBody(Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Produce a bound block for the expression returned from GetLambdaExpressionBody.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UnboundLambdaState.ReturnInferenceCacheKey">
            <summary>
            Behavior of this key should be kept aligned with <see cref="M:Microsoft.CodeAnalysis.CSharp.BoundLambda.InferReturnTypeImpl(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.ValueTuple{Microsoft.CodeAnalysis.CSharp.BoundReturnStatement,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations}},Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.ConversionsBase,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UnboundLambdaState.CanonicallyCompareDiagnostics(Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            What we need to do is find a *repeatable* arbitrary way to choose between
            two errors; we can for example simply take the one whose arguments are lower in alphabetical
            order when converted to a string.  As an optimization, we compare error codes
            first and skip string comparison if they differ.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator._indirectReturnState">
            <summary>
            In some cases returns are handled as gotos to return epilogue.
            This is used to track the state of the epilogue.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator._savedSequencePoints">
            <summary>
            Used to implement <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundSavePreviousSequencePoint"/> and <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundRestorePreviousSequencePoint"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator._sawStackalloc">
            <summary>
            True if there was a <see cref="F:System.Reflection.Metadata.ILOpCode.Localloc"/> anywhere in the method. This will
            affect whether or not we require the locals init flag to be marked, since locals init
            affects <see cref="F:System.Reflection.Metadata.ILOpCode.Localloc"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAddress(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Binder.AddressKind)">
            <summary>
            Emits address as in &amp; 
            
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitConditionalOperatorAddress(Microsoft.CodeAnalysis.CSharp.BoundConditionalOperator,Microsoft.CodeAnalysis.CSharp.Binder.AddressKind)">
            <summary>
            Emit code for a conditional (aka ternary) operator.
            </summary>
            <remarks>
            (b ? x : y) becomes
                push b
                if pop then goto CONSEQUENCE
                push y
                goto DONE
              CONSEQUENCE:
                push x
              DONE:
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitLocalAddress(Microsoft.CodeAnalysis.CSharp.BoundLocal,Microsoft.CodeAnalysis.CSharp.Binder.AddressKind)">
            <summary>
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitDupAddress(Microsoft.CodeAnalysis.CSharp.BoundDup,Microsoft.CodeAnalysis.CSharp.Binder.AddressKind)">
            <summary>
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAddressOfTempClone(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Emits address of a temp.
            Used in cases where taking address directly is not possible 
            (typically because expression does not have a home)
            
            Introduce a temp which it will return.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSequenceAddress(Microsoft.CodeAnalysis.CSharp.BoundSequence,Microsoft.CodeAnalysis.CSharp.Binder.AddressKind)">
            <summary>
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitFieldAddress(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess,Microsoft.CodeAnalysis.CSharp.Binder.AddressKind)">
            <summary>
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.HasHome(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Binder.AddressKind)">
            <summary>
            Checks if expression directly or indirectly represents a value with its own home. In
            such cases it is possible to get a reference without loading into a temporary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitReceiverRef(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Binder.AddressKind)">
            <summary>
            Emits receiver in a form that allows member accesses ( O or &amp; ). 
            For verifier-reference types it is the actual reference. 
            For the value types it is an address of the receiver.
            For generic types it is either a boxed receiver or the address of the receiver with readonly intent. 
            
            addressKind - kind of address that is needed in case if receiver is not a reference type.
            
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitInstanceFieldAddress(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess,Microsoft.CodeAnalysis.CSharp.Binder.AddressKind)">
            <summary>
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArrayInitializers(Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundArrayInitialization)">
            <summary>
            Entry point to the array initialization.
            Assumes that we have newly created array on the stack.
            
            inits could be an array of values for a single dimensional array
            or an array (of array)+ of values for a multidimensional case
            
            in either case it is expected that number of leaf values will match number 
            of elements in the array and nesting level should match the rank of the array.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.IndexDesc">
            <summary>
            To handle array initialization of arbitrary rank it is convenient to 
            approach multidimensional initialization as a recursively nested.
            
            ForAll{i, j, k} Init(i, j, k) ===> 
            ForAll{i} ForAll{j, k} Init(i, j, k) ===>
            ForAll{i} ForAll{j} ForAll{k} Init(i, j, k)
            
            This structure is used for capturing initializers of a given index and 
            the index value itself.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAllElementInitializersRecursive(Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.IndexDesc},System.Boolean)">
            <summary>
            Emits all initializers that match indices on the stack recursively.
            
            Example: 
             if array has [0..2, 0..3, 0..2] shape
             and we have {1, 2} indices on the stack
             initializers for 
                         [1, 2, 0]
                         [1, 2, 1]
                         [1, 2, 2]
            
             will be emitted and the top index will be pushed off the stack 
             as at that point we would be completely done with emitting initializers 
             corresponding to that index.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EnableEnumArrayBlockInitialization">
            <summary>
            Determine if enum arrays can be initialized using block initialization.
            </summary>
            <returns>True if it's safe to use block initialization for enum arrays.</returns>
            <remarks>
            In NetFx 4.0, block array initializers do not work on all combinations of {32/64 X Debug/Retail} when array elements are enums.
            This is fixed in 4.5 thus enabling block array initialization for a very common case.
            We look for the presence of <see cref="F:System.Runtime.GCLatencyMode.SustainedLowLatency"/> which was introduced in .NET Framework 4.5
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.InitializerCountRecursive(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Int32@,System.Int32@)">
            <summary>
            Count of all nontrivial initializers and count of those that are constants.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetRawData(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            Produces a serialized blob of all constant initializers.
            Non-constant initializers are matched with a zero of corresponding size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.IsMultidimensionalInitializer(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            Check if it is a regular collection of expressions or there are nested initializers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.TryGetRawDataForArrayInit(Microsoft.CodeAnalysis.CSharp.BoundArrayInitialization,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
             Returns a byte blob that matches serialized content of single array initializer.    
             returns -1 if the initializer is null or not an array of literals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.DefineAndRecordLocals(Microsoft.CodeAnalysis.CSharp.BoundSequence)">
            <summary>
            Defines sequence locals and record them so that they could be retained for the duration of the encompassing expression
            Use this when taking a reference of the sequence, which can indirectly refer to any of its locals.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.CloseScopeAndKeepLocals(Microsoft.CodeAnalysis.CSharp.BoundSequence)">
            <summary>
            Closes the visibility/debug scopes for the sequence locals, but keep the local slots from reuse
            for the duration of the encompassing expression.
            Use this paired with DefineAndRecordLocals when taking a reference of the sequence, which can indirectly refer to any of its locals.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetArgumentRefKind(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},System.Int32)">
            <summary>
            Computes the desired refkind of the argument.
            Considers all the cases - where ref kinds are explicit, omitted, vararg cases.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.CanUseCallOnRefTypeReceiver(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Used to decide if we need to emit call or callvirt.
            It basically checks if the receiver expression cannot be null, but it is not 100% precise. 
            There are cases where it really can be null, but we do not care.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.IsThisReceiver(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            checks if receiver is effectively ldarg.0
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.MayUseCallForStructMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Used to decide if we need to emit 'call' or 'callvirt' for structure method.
            It basically checks if the method overrides any other and method's defining type
            is not a 'special' or 'special-by-ref' type. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            When array operation get long or ulong arguments the args should be 
            cast to native int.
            Note that the cast is always checked.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.ConstructorNotSideEffecting(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Recognizes constructors known to not have side-effects (which means they can be skipped unless the constructed object is used)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitVectorElementStore(Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Emit an element store instruction for a single dimensional array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitConditionalOperator(Microsoft.CodeAnalysis.CSharp.BoundConditionalOperator,System.Boolean)">
            <summary>
            Emit code for a conditional (aka ternary) operator.
            </summary>
            <remarks>
            (b ? x : y) becomes
                push b
                if pop then goto CONSEQUENCE
                push y
                goto DONE
              CONSEQUENCE:
                push x
              DONE:
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitNullCoalescingOperator(Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingOperator,System.Boolean)">
            <summary>
            Emit code for a null-coalescing operator.
            </summary>
            <remarks>
            x ?? y becomes
              push x
              dup x
              if pop != null goto LEFT_NOT_NULL
                pop 
                push y
              LEFT_NOT_NULL:
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.CodeForJump(Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator,System.Boolean,System.Reflection.Metadata.ILOpCode@)">
            <summary>
            Produces opcode for a jump that corresponds to given operation and sense.
            Also produces a reverse opcode - opcode for the same condition with inverted sense.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCatchBlock(Microsoft.CodeAnalysis.CSharp.BoundCatchBlock)">
             <remarks>
             The interesting part in the following method is the support for exception filters. 
             === Example:
            
             try
             {
                TryBlock
             }
             catch (ExceptionType ex) when (Condition)
             {
                Handler
             }
            
             gets emitted as something like ===>
            
             Try
                 TryBlock
             Filter 
                 var tmp = Pop() as {ExceptionType}
                 if (tmp == null)
                 {
                     Push 0
                 }
                 else
                 {
                     ex = tmp
                     Push Condition ? 1 : 0
                 }
             End Filter // leaves 1 or 0 on the stack
             Catch      // gets called after finalization of nested exception frames if condition above produced 1
                 Pop    // CLR pushes the exception object again
                 variable ex can be used here
                 Handler
             EndCatch
             
             When evaluating `Condition` requires additional statements be executed first, those
             statements are stored in `catchBlock.ExceptionFilterPrologueOpt` and emitted before the condition.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStringCompareAndBranch(Microsoft.CodeAnalysis.CodeGen.LocalOrParameter,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ConstantValue,System.Object,Microsoft.Cci.IReference)">
            <summary>
            Delegate to emit string compare call and conditional branch based on the compare result.
            </summary>
            <param name="key">Key to compare</param>
            <param name="syntaxNode">Node for diagnostics.</param>
            <param name="stringConstant">Case constant to compare the key against</param>
            <param name="targetLabel">Target label to branch to if key = stringConstant</param>
            <param name="stringEqualityMethodRef">String equality method</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCharCompareAndBranch(Microsoft.CodeAnalysis.CodeGen.LocalOrParameter,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ConstantValue,System.Object,Microsoft.Cci.IReference,Microsoft.Cci.IReference)">
            <summary>
            Delegate to emit ReadOnlySpanChar compare with string and conditional branch based on the compare result.
            </summary>
            <param name="key">Key to compare</param>
            <param name="syntaxNode">Node for diagnostics.</param>
            <param name="stringConstant">Case constant to compare the key against</param>
            <param name="targetLabel">Target label to branch to if key = stringConstant</param>
            <param name="sequenceEqualsRef">String equality method</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetLocal(Microsoft.CodeAnalysis.CSharp.BoundLocal)">
            <summary>
            Gets already declared and initialized local.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetLocalDebugName(Microsoft.CodeAnalysis.Symbols.ILocalSymbolInternal,Microsoft.CodeAnalysis.CodeGen.LocalDebugId@)">
            <summary>
            Gets the name and id of the local that are going to be generated into the debug metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.FreeLocal(Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol)">
            <summary>
            Releases a local.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.AllocateTemp(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.LocalSlotConstraints)">
            <summary>
            Allocates a temp without identity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.FreeTemp(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
            <summary>
            Frees a temp.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.FreeOptTemp(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
            <summary>
            Frees an optional temp.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.FinallyCloner">
            <summary>
            Clones all labels used in a finally block.
            This allows creating an emittable clone of finally.
            It is safe to do because no branches can go in or out of the finally handler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.FinallyCloner.MakeFinallyClone(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            The argument is BoundTryStatement (and not a BoundBlock) specifically 
            to support only Finally blocks where it is guaranteed to not have incoming or leaving branches.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.Optimizer.Optimize(Microsoft.CodeAnalysis.CSharp.BoundStatement,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol}@)">
            <summary>
            Perform IL specific optimizations (mostly reduction of local slots)
            </summary>
            <param name="src">Method body to optimize</param>
            <param name="debugFriendly">
            When set, do not perform aggressive optimizations that degrade debugging experience.
            In particular we do not do the following:
            
            1) Do not elide any user defined locals, even if never read from. 
               Example:
                 {
                   var dummy = Goo();    // should not become just "Goo"
                 }
                   
               User might want to examine dummy in the debugger.
            
            2) Do not carry values on the stack between statements
               Example:
                 {
                   var temp = Goo();
                   temp.ToString();       // should not become   Goo().ToString();
                 }
                  
               User might want to examine temp in the debugger.
                   
            </param>
            <param name="stackLocals">
            Produced list of "ephemeral" locals.
            Essentially, these locals do not need to leave the evaluation stack.
            As such they do not require an allocation of a local slot and 
            their load/store operations are implemented trivially.
            </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.LocalDefUseSpan.ConflictsWith(Microsoft.CodeAnalysis.CSharp.CodeGen.LocalDefUseSpan)">
            <summary>
            when current and other use spans are regular spans we can have only 2 conflict cases:
            [1, 3) conflicts with [0, 2)
            [1, 3) conflicts with [2, 4)
            
            NOTE: with regular spans, it is not possible for two spans to share an edge point 
            unless they belong to the same local. (because we cannot access two real locals at the same time)
            
            specifically:
            [1, 3) does not conflict with [0, 1)   since such spans would need to belong to the same local
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.LocalDefUseSpan.ConflictsWithDummy(Microsoft.CodeAnalysis.CSharp.CodeGen.LocalDefUseSpan)">
            <summary>
            Dummy locals represent implicit control flow
            It is not allowed for a regular local span to cross into or 
            be immediately adjacent to a dummy span.
            
            specifically:
            [1, 3) does conflict with [0, 1)   since that would imply a value flowing into or out of a span surrounded by a branch/label
            
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.IsFixedBufferAssignmentToRefLocal(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Fixed-sized buffers are lowered as field accesses with pointer type, but
            we want to assign them to pinned ref locals before creating the pointer
            type, so this results in an assignment with mismatched types (pointer to managed
            ref). This is legal according to the CLR, but not how we usually represent things
            in lowering.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CodeGen.DummyLocal.ValEscapeScope">
            <summary>
            Compiler should always be synthesizing locals with correct escape semantics.
            Checking escape scopes is not valid here.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CodeGen.DummyLocal.RefEscapeScope">
            <summary>
            Compiler should always be synthesizing locals with correct escape semantics.
            Checking escape scopes is not valid here.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CommandLineDiagnosticFormatter.RelativizeNormalizedPath(System.String)">
            <summary>
            Get the path name starting from the <see cref="F:Microsoft.CodeAnalysis.CSharp.CommandLineDiagnosticFormatter._baseDirectory"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments">
            <summary>
            The command line arguments to a C# <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpCompiler"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments.CompilationOptions">
            <summary>
            Gets the compilation options for the C# <see cref="T:Microsoft.CodeAnalysis.Compilation"/>
            created from the <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpCompiler"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments.ParseOptions">
            <summary>
            Gets the parse options for the C# <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments.ShouldIncludeErrorEndLocation">
            <value>
            Should the format of error messages include the line and column of
            the end of the offending text.
            </value>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser.Parse(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String)">
            <summary>
            Parses a command line.
            </summary>
            <param name="args">A collection of strings representing the command line arguments.</param>
            <param name="baseDirectory">The base directory used for qualifying file locations.</param>
            <param name="sdkDirectory">The directory to search for mscorlib, or null if not available.</param>
            <param name="additionalReferenceDirectories">A string representing additional reference paths.</param>
            <returns>a commandlinearguments object representing the parsed command line.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser.AddDiagnostic(System.Collections.Generic.IList{Microsoft.CodeAnalysis.Diagnostic},System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic},Microsoft.CodeAnalysis.CSharp.ErrorCode,System.Object[])">
            <summary>
            Diagnostic for the errorCode added if the warningOptions does not mention suppressed for the errorCode.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompiler.GetOutputFileName(Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
             <summary>
             Given a compilation and a destination directory, determine three names:
               1) The name with which the assembly should be output.
               2) The path of the assembly/module file.
               3) The path of the pdb file.
            
             When csc produces an executable, but the name of the resulting assembly
             is not specified using the "/out" switch, the name is taken from the name
             of the file (note: file, not class) containing the assembly entrypoint
             (as determined by binding and the "/main" switch).
            
             For example, if the command is "csc /target:exe a.cs b.cs" and b.cs contains the
             entrypoint, then csc will produce "b.exe" and "b.pdb" in the output directory,
             with assembly name "b" and module name "b.exe" embedded in the file.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompiler.PrintLogo(System.IO.TextWriter)">
            <summary>
            Print compiler logo
            </summary>
            <param name="consoleOutput"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompiler.PrintHelp(System.IO.TextWriter)">
            <summary>
            Print Commandline help message (up to 80 English characters per line)
            </summary>
            <param name="consoleOutput"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AttributeSemanticModel">
            <summary>
            A binding for an attribute.  Represents the result of binding an attribute constructor and
            the positional and named arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AttributeSemanticModel.Create(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Binder,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Creates an AttributeSemanticModel that allows asking semantic questions about an attribute node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AttributeSemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol,Microsoft.CodeAnalysis.CSharp.Binder,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol},System.Int32)">
            <summary>
            Creates a speculative AttributeSemanticModel that allows asking semantic questions about an attribute node that did not appear in the original source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo">
            <summary>
            Structure containing all semantic information about an await expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BuiltInOperators">
            <summary>
            Internal cache of built-in operators.
            Cache is compilation-specific because it uses compilation-specific SpecialTypes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation">
            <summary>
            The compilation object is an immutable representation of a single invocation of the
            compiler. Although immutable, a compilation is also on-demand, and will realize and cache
            data as necessary. A compilation can produce a new compilation from existing compilation
            with the application of small deltas. In many cases, it is more efficient than creating a
            new compilation from scratch, as the new compilation can reuse information from the old
            compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyImportInfos">
            <summary>
            All imports (using directives and extern aliases) in syntax trees in this compilation.
            NOTE: We need to de-dup since the Imports objects that populate the list may be GC'd
            and re-created.
            Values are the sets of dependencies for corresponding directives.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Conversions">
            <summary>
            A conversions object that ignores nullability.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._anonymousTypeManager">
            <summary>
            Manages anonymous types declared in this compilation. Unifies types that are structurally equivalent.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyAssemblySymbol">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol"/> for this compilation. Do not access directly, use Assembly property
            instead. This field is lazily initialized by ReferenceManager, ReferenceManager.CacheLockObject must be locked
            while ReferenceManager "calculates" the value and assigns it, several threads must not perform duplicate
            "calculation" simultaneously.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._referenceManager">
            <summary>
            Holds onto data related to reference binding.
            The manager is shared among multiple compilations that we expect to have the same result of reference binding.
            In most cases this can be determined without performing the binding. If the compilation however contains a circular
            metadata reference (a metadata reference that refers back to the compilation) we need to avoid sharing of the binding results.
            We do so by creating a new reference manager for such compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyEntryPoint">
            <summary>
            Contains the main method of this assembly, if there is one.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyEmitNullablePublicOnly">
            <summary>
            Emit nullable attributes for only those members that are visible outside the assembly
            (public, protected, and if any [InternalsVisibleTo] attributes, internal members).
            If false, attributes are emitted for all members regardless of visibility.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyCompilationUnitCompletedTrees">
            <summary>
            The set of trees for which a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent"/> has been added to the queue.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._usageOfUsingsRecordedInTrees">
            <summary>
            The set of trees for which enough analysis was performed in order to record usage of using directives.
            Once all trees are processed the value is set to null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.TestOnlyCompilationData">
            <summary>
            Optional data collected during testing only.
            Used for instance for nullable analysis (<see cref="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.NullableAnalysisData"/>)
            and inferred delegate types (<see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.InferredDelegateTypeData"/>).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Options">
            <summary>
            The options the compilation was created with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.FeatureStrictEnabled">
            <summary>
            True when the compiler is run in "strict" mode, in which it enforces the language specification
            in some cases even at the expense of full compatibility. Such differences typically arise when
            earlier versions of the compiler failed to enforce the full language specification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.IsPeVerifyCompatEnabled">
            <summary>
            True when the "peverify-compat" feature flag is set or the language version is below C# 7.2.
            With this flag we will avoid certain patterns known not be compatible with PEVerify.
            The code may be less efficient and may deviate from spec in corner cases.
            The flag is only to be used if PEVerify pass is extremely important.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.IsNullableAnalysisEnabledIn(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if nullable analysis is enabled in the text span represented by the syntax node.
            </summary>
            <remarks>
            This overload is used for member symbols during binding, or for cases other
            than symbols such as attribute arguments and parameter defaults.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.IsNullableAnalysisEnabledIn(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if nullable analysis is enabled in the text span.
            </summary>
            <remarks>
            This overload is used for member symbols during binding, or for cases other
            than symbols such as attribute arguments and parameter defaults.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.IsNullableAnalysisEnabledIn(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Returns true if nullable analysis is enabled for the method. For constructors, the
            region considered may include other constructors and field and property initializers.
            </summary>
            <remarks>
            This overload is intended for callers that rely on symbols rather than syntax. The overload
            uses the cached value calculated during binding (from potentially several spans)
            from <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.IsNullableAnalysisEnabledIn(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.IsNullableAnalysisEnabledAlways">
            <summary>
            Returns true if nullable analysis is enabled for all methods regardless
            of the actual nullable context.
            If this property returns true but IsNullableAnalysisEnabled returns false,
            any nullable analysis should be enabled but results should be ignored.
            </summary>
            <remarks>
            For DEBUG builds, we treat nullable analysis as enabled for all methods
            unless explicitly disabled, so that analysis is run, even though results may
            be ignored, to increase the chance of catching nullable regressions
            (e.g. https://github.com/dotnet/roslyn/issues/40136).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetNullableAnalysisValue">
            <summary>
            Returns Feature("run-nullable-analysis") as a bool? value:
            true for "always"; false for "never"; and null otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.LanguageVersion">
            <summary>
            The language version that was used to parse the syntax trees of this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions)">
            <summary>
            Creates a new compilation from scratch. Methods such as AddSyntaxTrees or AddReferences
            on the returned object will allow to continue building up the Compilation incrementally.
            </summary>
            <param name="assemblyName">Simple assembly name.</param>
            <param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
            <param name="references">The references for the new compilation.</param>
            <param name="options">The compiler options to use.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CreateScriptCompilation(System.String,Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.Type,System.Type)">
            <summary>
            Creates a new compilation that can be used in scripting.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Clone">
            <summary>
            Create a duplicate of this compilation with different symbol instances.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithAssemblyName(System.String)">
            <summary>
            Creates a new compilation with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
             <summary>
             Creates a new compilation with the specified references.
             </summary>
             <remarks>
             The new <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation"/> will query the given <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/> for the underlying
             metadata as soon as the are needed.
            
             The new compilation uses whatever metadata is currently being provided by the <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/>.
             E.g. if the current compilation references a metadata file that has changed since the creation of the compilation
             the new compilation is going to use the updated version, while the current compilation will be using the previous (it doesn't change).
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithOptions(Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions)">
            <summary>
            Creates a new compilation with the specified compilation options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithScriptCompilationInfo(Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo)">
            <summary>
            Returns a new compilation with the given compilation set as the previous submission.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithSemanticModelProvider(Microsoft.CodeAnalysis.SemanticModelProvider)">
            <summary>
            Returns a new compilation with the given semantic model provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithEventQueue(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue{Microsoft.CodeAnalysis.Diagnostics.CompilationEvent})">
            <summary>
            Returns a new compilation with a given event queue.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.SyntaxTrees">
            <summary>
            The syntax trees (parsed from source code) that this compilation was created with.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns true if this compilation contains the specified tree.  False otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveAllSyntaxTrees">
            <summary>
            Creates a new compilation without any syntax trees. Preserves metadata info
            from this compilation for use with trees added later.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Creates a new compilation without the old tree but with the new tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol"/> for a metadata reference used to create this compilation.
            </summary>
            <returns><see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol"/> corresponding to the given reference or null if there is none.</returns>
            <remarks>
            Uses object identity when comparing two references.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceDirectives">
            <summary>
            All reference directives used in this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDirectiveReference(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax)">
            <summary>
            Returns a metadata reference that a given #r resolves to.
            </summary>
            <param name="directive">#r directive.</param>
            <returns>Metadata reference the specified directive resolves to, or null if the <paramref name="directive"/> doesn't match any #r directive in the compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveAllReferences">
            <summary>
            Creates a new compilation without any metadata references
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReplaceReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Creates a new compilation with an old metadata reference replaced with a new metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetAllUnaliasedModules(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol})">
            <summary>
            Get all modules in this compilation, including the source module, added modules, and all
            modules of referenced assemblies that do not come from an assembly with an extern alias.
            Metadata imported from aliased assemblies is not visible at the source level except through
            the use of an extern alias directive. So exclude them from this list which is used to construct
            the global namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetUnaliasedReferencedAssemblies(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol})">
            <summary>
            Return a list of assembly symbols than can be accessed without using an alias.
            For example:
              1) /r:A.dll /r:B.dll -> A, B
              2) /r:Goo=A.dll /r:B.dll -> B
              3) /r:Goo=A.dll /r:A.dll -> A
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/> that corresponds to the assembly symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.SourceAssembly">
            <summary>
            The AssemblySymbol that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Assembly">
            <summary>
            The AssemblySymbol that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.SourceModule">
            <summary>
            Get a ModuleSymbol that refers to the module being created by compiling all of the code.
            By getting the GlobalNamespace property of that module, all of the namespaces and types
            defined in source code can be obtained.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GlobalNamespace">
            <summary>
            Gets the root namespace that contains all namespaces and types defined in source code or in
            referenced metadata, merged into a single namespace hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)">
            <summary>
            Given for the specified module or assembly namespace, gets the corresponding compilation
            namespace (merged namespace representation for all namespace declarations and references
            with contributions for the namespaceSymbol).  Can return null if no corresponding
            namespace can be bound in this compilation with the same name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ScriptClass">
            <summary>
            A symbol representing the implicit Script class. This is null if the class is not
            defined in the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.BindScriptClass">
            <summary>
            Resolves a symbol that represents script container (Script class). Uses the
            full name of the container class stored in <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.ScriptClassName"/> to find the symbol.
            </summary>
            <returns>The Script class symbol or null if it is not defined.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GlobalImports">
            <summary>
            Global imports (including those from previous submissions, if there are any).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.UsingsFromOptions">
            <summary>
            Global imports not including those from previous submissions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSubmissionImports">
            <summary>
            Imports declared by this submission (null if this isn't one).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetPreviousSubmissionImports">
            <summary>
            Imports from all previous submissions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Get the symbol for the predefined type from the COR Library referenced by this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Get the symbol for the predefined type member from the COR Library referenced by this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetTypeByMetadataName(System.String)">
            <summary>
            Gets the type within the compilation's assembly and all referenced assemblies (other than
            those that can only be referenced via an extern alias) using its canonical CLR metadata name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.DynamicType">
            <summary>
            The TypeSymbol for the type 'dynamic' in this Compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ObjectType">
            <summary>
            The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
            Error if there was no COR Library in this Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.HasEntryPointSignature(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Checks if the method has an entry point compatible signature, i.e.
            - the return type is either void, int, or returns a <see cref="T:System.Threading.Tasks.Task" />,
            or <see cref="T:System.Threading.Tasks.Task`1" /> where the return type of GetAwaiter().GetResult()
            is either void or int.
            - has either no parameter or a single parameter of type string[]
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ClassifyConversion(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Classifies a conversion from <paramref name="source"/> to <paramref name="destination"/>.
            </summary>
            <param name="source">Source type of value to be converted</param>
            <param name="destination">Destination type of value to be converted</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> that classifies the conversion from the
            <paramref name="source"/> type to the <paramref name="destination"/> type.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ClassifyCommonConversion(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Classifies a conversion from <paramref name="source"/> to <paramref name="destination"/> according
            to this compilation's programming language.
            </summary>
            <param name="source">Source type of value to be converted</param>
            <param name="destination">Destination type of value to be converted</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.Operations.CommonConversion"/> that classifies the conversion from the
            <paramref name="source"/> type to the <paramref name="destination"/> type.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Int32,Microsoft.CodeAnalysis.CSharp.NullableAnnotation)">
            <summary>
            Returns a new ArrayTypeSymbol representing an array type tied to the base types of the
            COR Library in this Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CreatePointerTypeSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.NullableAnnotation)">
            <summary>
            Returns a new PointerTypeSymbol representing a pointer type tied to a type in this Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Gets a new SyntaxTreeSemanticModel for the specified syntax tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.DeclarationDiagnostics">
            <summary>
            The bag in which semantic analysis should deposit its diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AdditionalCodegenWarnings">
            <summary>
            A bag in which diagnostics that should be reported after code gen can be deposited.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetParseDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during the parsing stage of a compilation. There are no diagnostics for declarations or accessor or
            method bodies, for example.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during symbol declaration headers.  There are no diagnostics for accessor or
            method bodies, for example.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetMethodBodyDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during the analysis of method bodies and field initializers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the all the diagnostics for the compilation, including syntax, declaration, and binding. Does not
            include any diagnostics that might be produced during emit.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ContainsSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Return true if there is a source declaration symbol name that meets given predicate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Return source declaration symbols whose name meets given predicate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ContainsSymbolsWithName(System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Return true if there is a source declaration symbol name that matches the provided name.
            This will be faster than <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ContainsSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)"/>
            when predicate is just a simple string check.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSymbolsWithName(System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Return source declaration symbols whose name matches the provided name.  This will be
            faster than <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)"/> when predicate is just a simple string check.  <paramref
            name="name"/> is case sensitive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.HasDynamicEmitAttributes(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.Location)">
            <summary>
            Returns if the compilation has all of the members necessary to emit metadata about
            dynamic types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CanEmitBoolean">
            <summary>
            Returns whether the compilation has the Boolean type and if it's good.
            </summary>
            <returns>Returns true if Boolean is present and healthy.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.EnableEnumArrayBlockInitialization">
            <summary>
            Determine if enum arrays can be initialized using block initialization.
            </summary>
            <returns>True if it's safe to use block initialization for enum arrays.</returns>
            <remarks>
            In NetFx 4.0, block array initializers do not work on all combinations of {32/64 X Debug/Retail} when array elements are enums.
            This is fixed in 4.5 thus enabling block array initialization for a very common case.
            We look for the presence of <see cref="F:System.Runtime.GCLatencyMode.SustainedLowLatency"/> which was introduced in .NET Framework 4.5
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyWellKnownTypes">
            <summary>
            An array of cached well known types available for use in this Compilation.
            Lazily filled by GetWellKnownType method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyWellKnownTypeMembers">
            <summary>
            Lazy cache of well known members.
            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetNeedsGeneratedAttributes">
            <summary>
            Returns a value indicating which embedded attributes should be generated during emit phase.
            The value is set during binding the symbols that need those attributes, and is frozen on first trial to get it.
            Freezing is needed to make sure that nothing tries to modify the value after the value is read.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetWellKnownTypeMember(Microsoft.CodeAnalysis.WellKnownMember)">
            <summary>
            Lookup member declaration in well known type used by this Compilation.
            </summary>
            <remarks>
            If a well-known member of a generic type instantiation is needed use this method to get the corresponding generic definition and 
            <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.AsMember(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)"/> to construct an instantiation.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType)">
            <summary>
            This method handles duplicate types in a few different ways:
            - for types before C# 7, the first candidate is returned with a warning
            - for types after C# 7, the type is considered missing
            - in both cases, when BinderFlags.IgnoreCorLibraryDuplicatedTypes is set, type from corlib will not count as a duplicate
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.TrySynthesizeAttribute(Microsoft.CodeAnalysis.WellKnownMember,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TypedConstant},System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.TypedConstant}},System.Boolean)">
            <summary>
            Synthesizes a custom attribute. 
            Returns null if the <paramref name="constructor"/> symbol is missing,
            or any of the members in <paramref name="namedArguments" /> are missing.
            The attribute is synthesized only if present.
            </summary>
            <param name="constructor">
            Constructor of the attribute. If it doesn't exist, the attribute is not created.
            </param>
            <param name="arguments">Arguments to the attribute constructor.</param>
            <param name="namedArguments">
            Takes a list of pairs of well-known members and constants. The constants
            will be passed to the field/property referenced by the well-known member.
            If the well-known member does not exist in the compilation then no attribute
            will be synthesized.
            </param>
            <param name="isOptionalUse">
            Indicates if this particular attribute application should be considered optional.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.SynthesizeDynamicAttribute(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Int32,Microsoft.CodeAnalysis.RefKind)">
            <summary>
            Given a type <paramref name="type"/>, which is either dynamic type OR is a constructed type with dynamic type present in it's type argument tree,
            returns a synthesized DynamicAttribute with encoded dynamic transforms array.
            </summary>
            <remarks>This method is port of AttrBind::CompileDynamicAttr from the native C# compiler.</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.DynamicTransformsEncoder">
            <summary>
            Used to generate the dynamic attributes for the required typesymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager">
            <summary>
            ReferenceManager encapsulates functionality to create an underlying SourceAssemblySymbol 
            (with underlying ModuleSymbols) for Compilation and AssemblySymbols for referenced
            assemblies (with underlying ModuleSymbols) all properly linked together based on
            reference resolution between them.
            
            ReferenceManager is also responsible for reuse of metadata readers for imported modules
            and assemblies as well as existing AssemblySymbols for referenced assemblies. In order
            to do that, it maintains global cache for metadata readers and AssemblySymbols
            associated with them. The cache uses WeakReferences to refer to the metadata readers and
            AssemblySymbols to allow memory and resources being reclaimed once they are no longer
            used. The tricky part about reusing existing AssemblySymbols is to find a set of
            AssemblySymbols that are created for the referenced assemblies, which (the
            AssemblySymbols from the set) are linked in a way, consistent with the reference
            resolution between the referenced assemblies.
            
            When existing Compilation is used as a metadata reference, there are scenarios when its
            underlying SourceAssemblySymbol cannot be used to provide symbols in context of the new
            Compilation. Consider classic multi-targeting scenario: compilation C1 references v1 of
            Lib.dll and compilation C2 references C1 and v2 of Lib.dll. In this case,
            SourceAssemblySymbol for C1 is linked to AssemblySymbol for v1 of Lib.dll. However,
            given the set of references for C2, the same reference for C1 should be resolved against
            v2 of Lib.dll. In other words, in context of C2, all types from v1 of Lib.dll leaking
            through C1 (through method signatures, etc.) must be retargeted to the types from v2 of
            Lib.dll. In this case, ReferenceManager creates a special RetargetingAssemblySymbol for
            C1, which is responsible for the type retargeting. The RetargetingAssemblySymbols could
            also be reused for different Compilations, ReferenceManager maintains a cache of
            RetargetingAssemblySymbols (WeakReferences) for each Compilation.
            
            The only public entry point of this class is CreateSourceAssembly() method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.CheckPropertiesConsistency(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Checks if the properties of <paramref name="duplicateReference"/> are compatible with properties of <paramref name="primaryReference"/>.
            Reports inconsistencies to the given diagnostic bag.
            </summary>
            <returns>True if the properties are compatible and hence merged, false if the duplicate reference should not merge it's properties with primary reference.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.WeakIdentityPropertiesEquivalent(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            C# only considers culture when comparing weak identities.
            It ignores versions of weak identities and reports an error if there are two weak assembly 
            references passed to a compilation that have the same simple name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.CreatePEAssemblyForAssemblyMetadata(Microsoft.CodeAnalysis.AssemblyMetadata,Microsoft.CodeAnalysis.MetadataImportOptions,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity}@)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol"/> from specified metadata. 
            </summary>
            <remarks>
            Used by EnC to create symbols for emit baseline. The PE symbols are used by <see cref="T:Microsoft.CodeAnalysis.CSharp.Emit.CSharpSymbolMatcher"/>.
            
            The assembly references listed in the metadata AssemblyRef table are matched to the resolved references 
            stored on this <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager"/>. We assume that the dependencies of the baseline metadata are 
            the same as the dependencies of the current compilation. This is not exactly true when the dependencies use 
            time-based versioning pattern, e.g. AssemblyVersion("1.0.*"). In that case we assume only the version
            changed and nothing else.
            
            Each AssemblyRef is matched against the assembly identities using an exact equality comparison modulo version. 
            AssemblyRef with lower version in metadata is matched to a PE assembly symbol with the higher version 
            (provided that the assembly name, culture, PKT and flags are the same) if there is no symbol with the exactly matching version. 
            If there are multiple symbols with higher versions selects the one with the minimal version among them.
            
            Matching to a higher version is necessary to support EnC for projects whose P2P dependencies use time-based versioning pattern. 
            The versions of the dependent projects seen from the IDE will be higher than 
            the one written in the metadata at the time their respective baselines are built.
            
            No other unification or further resolution is performed.
            </remarks>
            <param name="metadata"></param>
            <param name="importOptions"></param>
            <param name="assemblyReferenceIdentityMap">
            A map of the PE assembly symbol identities to the identities of the original metadata AssemblyRefs.
            This map will be used in emit when serializing AssemblyRef table of the delta. For the delta to be compatible with
            the original metadata we need to map the identities of the PE assembly symbols back to the original AssemblyRefs (if different).
            In other words, we pretend that the versions of the dependencies haven't changed.
            </param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.AssemblyDataForFile.CachedSymbols">
            <summary>
            Guarded by <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.AssemblyDataForFile._compilationImportOptions">
            <summary>
            Import options of the compilation being built.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.IsSourceAssemblySymbolCreated(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            For testing purposes only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.IsReferenceManagerInitialized(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            For testing purposes only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilationReference">
            <summary>
            Represents a reference to another C# compilation. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilationReference.Compilation">
            <summary>
            Returns the referenced Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilationReference.#ctor(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean)">
            <summary>
            Create a metadata reference to a compilation.
            </summary>
            <param name="compilation">The compilation to reference.</param>
            <param name="aliases">Extern aliases for this reference.</param>
            <param name="embedInteropTypes">Should interop types be embedded in the created assembly?</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFilter">
            <summary>
            Applies C#-specific modification and filtering of <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFilter.Filter(Microsoft.CodeAnalysis.Diagnostic,System.Int32,Microsoft.CodeAnalysis.NullableContextOptions,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic},Microsoft.CodeAnalysis.SyntaxTreeOptionsProvider,System.Threading.CancellationToken)">
            <summary>
            Modifies an input <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> per the given options. For example, the
            severity may be escalated, or the <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> may be filtered out entirely
            (by returning null).
            </summary>
            <param name="d">The input diagnostic</param>
            <param name="warningLevelOption">The maximum warning level to allow. Diagnostics with a higher warning level will be filtered out.</param>
            <param name="generalDiagnosticOption">How warning diagnostics should be reported</param>
            <param name="nullableOption">Whether Nullable Reference Types feature is enabled globally</param>
            <param name="specificDiagnosticOptions">How specific diagnostics should be reported</param>
            <returns>A diagnostic updated to reflect the options, or null if it has been filtered out</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFilter.GetDiagnosticReport(Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.String,System.Int32,Microsoft.CodeAnalysis.Location,System.String,System.Int32,Microsoft.CodeAnalysis.NullableContextOptions,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic},Microsoft.CodeAnalysis.SyntaxTreeOptionsProvider,System.Threading.CancellationToken,System.Boolean@)">
             <summary>
             Take a warning and return the final disposition of the given warning,
             based on both command line options and pragmas. The diagnostic options
             have precedence in the following order:
                 1. Warning level
                 2. Command line options (/nowarn, /warnaserror)
                 3. Editor config options (syntax tree level)
                 4. Global analyzer config options (compilation level)
                 5. Global warning level
            
             Pragmas are considered separately. If a diagnostic would not otherwise
             be suppressed, but is suppressed by a pragma, <paramref name="hasPragmaSuppression"/>
             is true but the diagnostic is not reported as suppressed.
             </summary> 
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel">
            <summary>
            Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,
            an instance is obtained by a call to <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Compilation"/>.<see
            cref="M:Microsoft.CodeAnalysis.Compilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)"/>. 
            </summary>
            <remarks>
            <para>An instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel"/> caches local symbols and semantic
            information. Thus, it is much more efficient to use a single instance of <see
            cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel"/> when asking multiple questions about a syntax tree, because
            information from the first question may be reused. This also means that holding onto an
            instance of SemanticModel for a long time may keep a significant amount of memory from being
            garbage collected.
            </para>
            <para>
            When an answer is a named symbol that is reachable by traversing from the root of the symbol
            table, (that is, from an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> of the <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Compilation"/>),
            that symbol will be returned (i.e. the returned value will be reference-equal to one
            reachable from the root of the symbol table). Symbols representing entities without names
            (e.g. array-of-int) may or may not exhibit reference equality. However, some named symbols
            (such as local variables) are not reachable from the root. These symbols are visible as
            answers to semantic questions. When the same SemanticModel object is used, the answers
            exhibit reference-equality.  
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Compilation">
            <summary>
            The compilation this object was obtained from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Root">
            <summary>
            The root node of the syntax tree that this binding is based on.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="options">Options to control behavior.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetCollectionInitializerSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about the 'Add' method corresponding to an expression syntax <paramref name="node"/> within collection initializer.
            This is the worker function that is overridden in various derived kinds of Semantic Models. It can assume that 
            CheckSyntaxNode has already been called and the <paramref name="node"/> is in the right place in the syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativelyBoundExpression(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption,Microsoft.CodeAnalysis.CSharp.Binder@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol}@)">
            <summary>
            Binds the provided expression in the given context.
            </summary>
            <param name="position">The position to bind at.</param>
            <param name="expression">The expression to bind</param>
            <param name="bindingOption">How to speculatively bind the given expression. If this is <see cref="F:Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsTypeOrNamespace"/>
            then the provided expression should be a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax"/>.</param>
            <param name="binder">The binder that was used to bind the given syntax.</param>
            <param name="crefSymbols">The symbols used in a cref. If this is not default, then the return is null.</param>
            <returns>The expression that was bound. If <paramref name="crefSymbols"/> is not default, this is null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetMemberGroupWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
            <summary>
            Gets a list of method or indexed property symbols for a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="options"></param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetIndexerGroupWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
            <summary>
            Gets a list of indexer symbols for a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="options"></param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetConstantValueWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the constant value for a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativelyBoundExpressionWithoutNullability(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption,Microsoft.CodeAnalysis.CSharp.Binder@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol}@)">
            <summary>
            Bind the given expression speculatively at the given position, and return back
            the resulting bound node. May return null in some error cases.
            </summary>
            <remarks>
            Keep in sync with Binder.BindCrefParameterOrReturnType.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativelyBoundAttribute(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Binder@)">
            <summary>
            Bind the given attribute speculatively at the given position, and return back
            the resulting bound node. May return null in some error cases.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information for an ordering clause in an orderby query clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a select or group clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the SymbolInfo for the Deconstruct method used for a deconstruction pattern clause, if any.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given expression syntax bound to in the program.
            
            An AliasSymbol will never be returned by this method. What the alias refers to will be
            returned instead. To get information about aliases, call GetAliasInfo.
            
            If binding the type name C in the expression "new C(...)" the actual constructor bound to
            will be returned (or all constructor if overload resolution failed). This occurs as long as C
            unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple
            types, or C binds to a static class, then type(s) are returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TypeFromVariable(Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a variable designation (typically in the left-hand-side of a deconstruction declaration statement),
            figure out its type by looking at the declared symbol of the corresponding variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax 
            within <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax.Initializer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
            </summary>
            <param name="constructorInitializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
            </summary>
            <param name="constructorInitializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given attribute syntax bound to in the program.
            </summary>
            <param name="attributeSyntax">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a documentation comment cref.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The symbol information for the topmost node of the expression.</returns>
            <remarks>
            The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".
            
            <paramref name="bindingOption"/> is ignored if <paramref name="position"/> is within a documentation
            comment cref attribute value.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>
            Bind the attribute in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about an attribute
            that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel. In order to obtain
            the correct scoping rules for the attribute, position should be the Start position of the Span of the symbol that
            the attribute is being applied to.
            </param>
            <param name="attribute">A syntax node that represents a parsed attribute. This syntax node
            need not and typically does not appear in the source code referred to SemanticModel instance.</param>
            <returns>The semantic information for the topmost node of the attribute.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)">
            <summary>
            Bind the constructor initializer in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about a constructor
            initializer that did not actually appear in the source code.
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            Furthermore, it must be within the span of an existing constructor initializer.
            </param>
            <param name="constructorInitializer">A syntax node that represents a parsed constructor initializer. This syntax node
            need not and typically does not appear in the source code referred to SemanticModel instance.</param>
            <returns>The semantic information for the topmost node of the constructor initializer.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax)">
            <summary>
            Bind the constructor initializer in the context of the specified location and get semantic information
            about symbols. This method is used to get semantic information about a constructor
            initializer that did not actually appear in the source code.
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the span of an existing constructor initializer.
            </param>
            <param name="constructorInitializer">A syntax node that represents a parsed constructor initializer. This syntax node
            need not and typically does not appear in the source code referred to SemanticModel instance.</param>
            <returns>The semantic information for the topmost node of the constructor initializer.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions)">
            <summary>
            Bind the cref in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about a cref
            that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel. In order to obtain
            the correct scoping rules for the cref, position should be the Start position of the Span of the original cref.
            </param>
            <param name="cref">A syntax node that represents a parsed cref. This syntax node
            need not and typically does not appear in the source code referred to SemanticModel instance.</param>
            <param name="options">SymbolInfo options.</param>
            <returns>The semantic information for the topmost node of the cref.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a constructor initializer.
            </summary>
            <param name="constructorInitializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about an expression.
            </summary>
            <param name="expression">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about an attribute.
            </summary>
            <param name="attributeSyntax">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetConversion(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the conversion that occurred between the expression's type and type implied by the expression's context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeTypeInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the expression in the context of the specified location and gets type information.
            This method is used to get type information about an expression that did not actually
            appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The type information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeConversion(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Gets the conversion that occurred between the expression's type and type implied by the expression's context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetMemberGroup(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets a list of method or indexed property symbols for a syntax node.
            </summary>
            <param name="expression">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetMemberGroup(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets a list of method or indexed property symbols for a syntax node.
            </summary>
            <param name="attribute">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetMemberGroup(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets a list of method symbols for a syntax node.
            </summary>
            <param name="initializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetIndexerGroup(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.
            </summary>
            <param name="expression">Potential indexer receiver.</param>
            <param name="cancellationToken">To cancel the computation.</param>
            <returns>Accessible, non-hidden indexers.</returns>
            <remarks>
            If the receiver is an indexer expression, the list will contain the indexers that could be applied to the result
            of accessing the indexer, not the set of candidates that were considered during construction of the indexer expression.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetQueryClauseInfo(Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a query clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetAliasInfo(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)">
            <summary>
            If <paramref name="nameSyntax"/> resolves to an alias name, return the AliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeAliasInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <remarks>The passed in name is interpreted as a stand-alone name, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetEnclosingBinder(System.Int32)">
            <summary>
            Gets the binder that encloses the position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetMemberModel(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the MemberSemanticModel that contains the node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.CheckAndAdjustPosition(System.Int32)">
            <summary>
            Given a position, locates the containing token.  If the position is actually within the
            leading trivia of the containing token or if that token is EOF, moves one token to the
            left.  Returns the start position of the resulting token.
            
            This has the effect of moving the position left until it hits the beginning of a non-EOF
            token.
            
            Throws an ArgumentOutOfRangeException if position is not within the root of this model.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetAdjustedNodePosition(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            A convenience method that determines a position from a node.  If the node is missing,
            then its position will be adjusted using CheckAndAdjustPosition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.Boolean)">
            <summary>
            Gets the available named symbols in the context of the specified location and optional container. Only
            symbols that are accessible and visible from the given location are returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the enclosing declaration
            scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <param name="includeReducedExtensionMethods">Consider (reduced) extension methods.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            
            Labels are not considered (see <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupLabels(System.Int32,System.String)"/>).
            
            Non-reduced extension methods are considered regardless of the value of <paramref name="includeReducedExtensionMethods"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupBaseMembers(System.Int32,System.String)">
            <summary>
            Gets the available base type members in the context of the specified location.  Akin to
            calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.Boolean)"/> with the container set to the immediate base type of
            the type in which <paramref name="position"/> occurs.  However, the accessibility rules
            are different: protected members of the base type will be visible.
            
            Consider the following example:
            
              public class Base
              {
                  protected void M() { }
              }
              
              public class Derived : Base
              {
                  void Test(Base b)
                  {
                      b.M(); // Error - cannot access protected member.
                      base.M();
                  }
              }
            
            Protected members of an instance of another type are only accessible if the instance is known
            to be "this" instance (as indicated by the "base" keyword).
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible.
            
            Non-reduced extension methods are considered, but reduced extension methods are not.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String)">
            <summary>
            Gets the available named static member symbols in the context of the specified location and optional container.
            Only members that are accessible and visible from the given location are returned.
            
            Non-reduced extension methods are considered, since they are static methods.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the enclosing declaration
            scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String)">
            <summary>
            Gets the available named namespace and type symbols in the context of the specified location and optional container.
            Only members that are accessible and visible from the given location are returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the enclosing declaration
            scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            
            Does not return NamespaceOrTypeSymbol, because there could be aliases.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupLabels(System.Int32,System.String)">
            <summary>
            Gets the available named label symbols in the context of the specified location and optional container.
            Only members that are accessible and visible from the given location are returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupSymbolsInternal(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,Microsoft.CodeAnalysis.CSharp.LookupOptions,System.Boolean)">
            <summary>
            Gets the available named symbols in the context of the specified location and optional
            container. Only symbols that are accessible and visible from the given location are
            returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the
            enclosing declaration scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <param name="options">Additional options that affect the lookup process.</param>
            <param name="useBaseReferenceAccessibility">Ignore 'throughType' in accessibility checking. 
            Used in checking accessibility of symbols accessed via 'MyBase' or 'base'.</param>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if
            "container" is specified, the "position" location is significant for determining which
            members of "containing" are accessible. 
            </remarks>
            <exception cref="T:System.ArgumentException">Throws an argument exception if the passed lookup options are invalid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.RemapSymbolIfNecessaryCore(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Remaps a local, parameter, localfunction, or lambda symbol, if that symbol or its containing
            symbols were reinferred. This should only be called when nullable semantic analysis is enabled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.IsAccessible(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Determines if the symbol is accessible from the specified location. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="symbol">The symbol that we are checking to see if it accessible.</param>
            <returns>
            True if "symbol is accessible, false otherwise.</returns>
            <remarks>
            This method only checks accessibility from the point of view of the accessibility
            modifiers on symbol and its containing types. Even if true is returned, the given symbol
            may not be able to be referenced for other reasons, such as name hiding.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.IsEventUsableAsField(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol)">
            <summary>
            Field-like events can be used as fields in types that can access private
            members of the declaring type of the event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first statement to be included in the analysis.</param>
            <param name="lastStatement">The last statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="statement">The statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)">
            <summary>
            Analyze data-flow within an <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax"/>. 
            </summary>
            <param name="constructorInitializer">The ctor-init within the associated SyntaxTree to analyze.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax)">
            <summary>
            Analyze data-flow within an <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax.ArgumentList"/>. 
            </summary>
            <param name="primaryConstructorBaseType">The node within the associated SyntaxTree to analyze.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Analyze data-flow within an <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax"/>. 
            </summary>
            <param name="expression">The expression within the associated SyntaxTree to analyze.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first statement to be included in the analysis.</param>
            <param name="lastStatement">The last statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="statement">The statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModelForMethodBody(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position"/> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel and must be
            within the FullSpan of a Method body within the Root syntax node.</param>
            <param name="method">A syntax node that represents a parsed method declaration. This method should not be
            present in the syntax tree associated with this object, but must have identical signature to the method containing
            the given <paramref name="position"/> in this SemanticModel.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="method"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="method"/> node is contained any SyntaxTree in the current Compilation</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="method"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModelForMethodBody(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position"/> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel and must be
            within the FullSpan of a Method body within the Root syntax node.</param>
            <param name="accessor">A syntax node that represents a parsed accessor declaration. This accessor should not be
            present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="accessor"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="accessor"/> node is contained any SyntaxTree in the current Compilation</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="accessor"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Get a SemanticModel object that is associated with a type syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a type syntax that did not appear in source code. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            </param>
            <param name="type">A syntax node that represents a parsed expression. This expression should not be
            present in the syntax tree associated with this object.</param>
            <param name="bindingOption">Indicates whether to bind the expression as a full expression,
            or as a type or namespace.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="type"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="type"/> node is contained any SyntaxTree in the current Compilation</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="type"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a statement that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a statement that did not appear in source code. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.</param>
            <param name="statement">A syntax node that represents a parsed statement. This statement should not be
            present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="statement"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="statement"/> node is contained any SyntaxTree in the current Compilation</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="statement"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a field initializer or default parameter value that did not appear in source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            </param>
            <param name="initializer">A syntax node that represents a parsed initializer. This initializer should not be
            present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="initializer"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="initializer"/> node is contained any SyntaxTree in the current Compilation.</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="initializer"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an expression body that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression body that did not appear in source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            </param>
            <param name="expressionBody">A syntax node that represents a parsed expression body. This node should not be
            present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="expressionBody"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="expressionBody"/> node is contained any SyntaxTree in the current Compilation.</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="expressionBody"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a constructor initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a constructor initializer that did not appear in source code. 
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            Furthermore, it must be within the span of an existing constructor initializer.
            </param>
            <param name="constructorInitializer">A syntax node that represents a parsed constructor initializer.
            This node should not be present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="constructorInitializer"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="constructorInitializer"/> node is contained any SyntaxTree in the current Compilation.</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="constructorInitializer"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a constructor initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a constructor initializer that did not appear in source code. 
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the span of an existing constructor initializer.
            </param>
            <param name="constructorInitializer">A syntax node that represents a parsed constructor initializer.
            This node should not be present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="constructorInitializer"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="constructorInitializer"/> node is contained any SyntaxTree in the current Compilation.</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="constructorInitializer"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a cref that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a cref that did not appear in source code. 
            
            NOTE: This will only work in locations where there is already a cref.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            Furthermore, it must be within the span of an existing cref.
            </param>
            <param name="crefSyntax">A syntax node that represents a parsed cref syntax.
            This node should not be present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="crefSyntax"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="crefSyntax"/> node is contained any SyntaxTree in the current Compilation.</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="crefSyntax"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an attribute that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an attribute that did not appear in source code. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.</param>
            <param name="attribute">A syntax node that represents a parsed attribute. This attribute should not be
            present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="attribute"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="attribute"/> node is contained any SyntaxTree in the current Compilation.</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="attribute"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.ParentModel">
            <summary>
            If this is a speculative semantic model, then returns its parent semantic model.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SyntaxTree">
            <summary>
            The SyntaxTree that this object is associated with.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.ClassifyConversion(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
            <param name="expression">An expression which much occur within the syntax tree
            associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <param name="isExplicitInSource">True if the conversion should be determined as for a cast expression.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.ClassifyConversion(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="expression">The expression to classify. This expression does not need to be
            present in the syntax tree associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <param name="isExplicitInSource">True if the conversion should be determined as for a cast expression.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.ClassifyConversionForCast(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type using an explicit cast.
            </summary>
            <param name="expression">An expression which much occur within the syntax tree
            associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.ClassifyConversionForCast(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type using an explicit cast.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="expression">The expression to classify. This expression does not need to be
            present in the syntax tree associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a member declaration syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for following subtypes of MemberDeclarationSyntax:
            NOTE:   (1) GlobalStatementSyntax as they don't declare any symbols.
            NOTE:   (2) IncompleteMemberSyntax as there are no symbols for incomplete members.
            NOTE:   (3) BaseFieldDeclarationSyntax or its subtypes as these declarations can contain multiple variable declarators.
            NOTE:       GetDeclaredSymbol should be called on the variable declarators directly.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a local function declaration syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a compilation unit syntax, get the corresponding Simple Program entry point symbol.
            </summary>
            <param name="declarationSyntax">The compilation unit that declares the entry point member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a namespace.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The namespace symbol that was declared by the namespace declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a namespace.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The namespace symbol that was declared by the namespace declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a type.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseTypeDeclarationSyntax as all of them return a NamedTypeSymbol.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a delegate.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an enum member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a method.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseMethodDeclarationSyntax as all of them return a MethodSymbol.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property, indexer or an event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an indexer.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.
            </summary>
            <param name="declaratorSyntax">The syntax node that declares a property.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.
            </summary>
            <param name="declaratorSyntax">The syntax node that declares an anonymous object.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of a tuple expression, get the tuple type symbol.
            </summary>
            <param name="declaratorSyntax">The tuple expression node.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of an argument expression, get the declared symbol.
            </summary>
            <param name="declaratorSyntax">The argument syntax node.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            Generally ArgumentSyntax nodes do not declare symbols, except when used as arguments of a tuple literal.
            Example:  var x = (Alice: 1, Bob: 2);
                      ArgumentSyntax "Alice: 1" declares a tuple element field "(int Alice, int Bob).Alice"
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property or member accessor, get the corresponding
            symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an accessor.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares an expression body, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an expression body.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a variable.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a variable designation syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a variable.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the labeled statement.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the switch label.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a using declaration get the corresponding symbol for the using alias that was
            introduced.
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared.</returns>
            <remarks>
            If the using directive is an error because it attempts to introduce an alias for which an existing alias was
            previously declared in the same scope, the result is a newly-constructed AliasSymbol (i.e. not one from the
            symbol table).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared, or null if a duplicate alias symbol was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a parameter declaration syntax node, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a parameter.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The parameter that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbols(Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base field declaration syntax, get the corresponding symbols.
            </summary>
            <param name="declarationSyntax">The syntax node that declares one or more fields or events.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbols that were declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="typeParameter"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a foreach statement, get the symbol for the iteration variable
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="forEachStatement"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetAdjustedLocalSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol)">
            <summary>
            Given a local symbol, gets an updated version of that local symbol adjusted for nullability analysis
            if the analysis affects the local.
            </summary>
            <param name="originalSymbol">The original symbol from initial binding.</param>
            
            <returns>The nullability-adjusted local, or the original symbol if the nullability analysis made no adjustments or was not run.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a catch declaration, get the symbol for the exception variable
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="catchDeclaration"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the query range variable declared in a join into clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the query range variable declared in a query continuation clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetIndexerGroupSemanticSymbols(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Returns a list of accessible, non-hidden indexers that could be invoked with the given expression
            as a receiver.
            </summary>
            <remarks>
            If the given expression is an indexer access, then this method will return the list of indexers
            that could be invoked on the result, not the list of indexers that were considered.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.FilterOverriddenOrHiddenMethods(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol})">
             <remarks>
             The method group can contain "duplicate" symbols that we do not want to display in the IDE analysis.
            
             For example, there could be an overriding virtual method and the method it overrides both in
             the method group. This, strictly speaking, is a violation of the C# specification because we are
             supposed to strip out overriding methods from the method group before overload resolution; overload
             resolution is supposed to treat overridden methods as being methods of the less derived type. However,
             in the IDE we want to display information about the overriding method, not the overridden method, and
             therefore we leave both in the method group. The overload resolution algorithm has been written
             to handle this departure from the specification.
            
             Similarly, we might have two methods in the method group where one is a "new" method that hides 
             another. Again, in overload resolution this would be handled by the rule that says that methods
             declared on more derived types take priority over methods declared on less derived types. Both
             will be in the method group, but in the IDE we want to only display information about the 
             hiding method, not the hidden method.
            
             We can also have "diamond" inheritance of interfaces leading to multiple copies of the same
             method ending up in the method group:
             
             interface IB { void M(); }
             interface IL : IB {}
             interface IR : IB {}
             interface ID : IL, IR {}
             ...
             id.M();
            
             We only want to display one symbol in the IDE, even if the member lookup algorithm is unsophisticated
             and puts IB.M in the member group twice. (Again, this is a mild spec violation since a method group
             is supposed to be a set, without duplicates.)
            
             Finally, the interaction of multiple inheritance of interfaces and hiding can lead to some subtle
             situations. Suppose we make a slight modification to the scenario above:
            
             interface IL : IB { new void M(); } 
            
             Again, we only want to display one symbol in the method group. The fact that there is a "path"
             to IB.M from ID via IR is irrelevant; if the symbol IB.M is hidden by IL.M then it is hidden
             in ID, period.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetNamedArgumentSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the semantic info of a named argument in an invocation-like expression (e.g. `x` in `M(x: 3)`)
            or the name in a Subpattern (e.g. either `Name` in `e is (Name: 3){Name: 3}`).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.FindNamedParameter(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.String)">
            <summary>
            Find the first parameter named "argumentName".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.CreateReducedExtensionMethodsFromOriginalsIfNecessary(Microsoft.CodeAnalysis.CSharp.BoundCall,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            If the call represents an extension method invocation with an explicit receiver, return the original
            methods as ReducedExtensionMethodSymbols. Otherwise, return the original methods unchanged.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.CreateReducedExtensionMethodIfPossible(Microsoft.CodeAnalysis.CSharp.BoundCall)">
            <summary>
            If the call represents an extension method with an explicit receiver, return a
            ReducedExtensionMethodSymbol if it can be constructed. Otherwise, return the 
            original call method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetForEachStatementInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)">
            <summary>
            Gets for each statement info.
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetForEachStatementInfo(Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax)">
            <summary>
            Gets for each statement info.
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeconstructionInfo(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax)">
            <summary>
            Gets deconstruction assignment info.
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeconstructionInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax)">
            <summary>
            Gets deconstruction foreach info.
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)">
            <summary>
            Gets await expression info.
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)">
            <summary>
            If the given node is within a preprocessing directive, gets the preprocessing symbol info for it.
            </summary>
            <param name="node">Preprocessing symbol identifier node.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions">
            <summary>
            Options to control the internal working of GetSymbolInfoWorker. Not currently exposed
            to public clients, but could be if desired.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions.PreferTypeToConstructors">
            <summary>
            When binding "C" new C(...), return the type C and do not return information about
            which constructor was bound to. Bind "new C(...)" to get information about which constructor
            was chosen.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions.PreferConstructorsToType">
            <summary>
            When binding "C" new C(...), return the constructor of C that was bound to, if C unambiguously
            binds to a single type with at least one constructor. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions.ResolveAliases">
            <summary>
            When binding a name X that was declared with a "using X=OtherTypeOrNamespace", return OtherTypeOrNamespace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions.PreserveAliases">
            <summary>
            When binding a name X that was declared with a "using X=OtherTypeOrNamespace", return the alias symbol X.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetEnclosingSymbol(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a position in the SyntaxTree for this SemanticModel returns the innermost
            NamedType that the position is considered inside of.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a tuple element syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a tuple element.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo">
             <summary>
             The representation of a deconstruction as a tree of Deconstruct methods and conversions.
             Methods only appear in non-terminal nodes. All terminal nodes have a Conversion.
            
             Here's an example:
             A deconstruction like <c>(int x1, (long x2, long x3)) = deconstructable1</c> with
             <c>Deconstructable1.Deconstruct(out int y1, out Deconstructable2 y2)</c> and
             <c>Deconstructable2.Deconstruct(out int z1, out int z2)</c> is represented as 5 DeconstructionInfo nodes.
            
             The top-level node has a <see cref="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Method"/> (Deconstructable1.Deconstruct), no <see cref="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Conversion"/>, but has two <see cref="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Nested"/> nodes.
             Its first nested node has no <see cref="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Method"/>, but has a <see cref="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Conversion"/> (Identity).
             Its second nested node has a <see cref="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Method"/> (Deconstructable2.Deconstruct), no <see cref="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Conversion"/>, and two <see cref="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Nested"/> nodes.
             Those last two nested nodes have no <see cref="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Method"/>, but each have a <see cref="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Conversion"/> (ImplicitNumeric, from int to long).
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Method">
            <summary>
            The Deconstruct method (if any) for this non-terminal position in the deconstruction tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Conversion">
            <summary>
            The conversion for a terminal position in the deconstruction tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.DeconstructionInfo.Nested">
            <summary>
            The children for this deconstruction node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo">
            <summary>
            Structure containing all semantic information about a for each statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.IsAsynchronous">
            <summary>
            Whether this is an asynchronous foreach.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.GetEnumeratorMethod">
            <summary>
            Gets the &quot;GetEnumerator&quot; method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.MoveNextMethod">
            <summary>
            Gets the &quot;MoveNext&quot; method (or &quot;MoveNextAsync&quot; in an asynchronous foreach).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.CurrentProperty">
            <summary>
            Gets the &quot;Current&quot; property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.DisposeMethod">
            <summary>
            Gets the &quot;Dispose&quot; method (or &quot;DisposeAsync&quot; in an asynchronous foreach).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.ElementType">
            <summary>
            The intermediate type to which the output of the <see cref="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.CurrentProperty"/> is converted
            before being converted to the iteration variable type.
            </summary>
            <remarks>
            As you might hope, for an array, it is the element type of the array.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.ElementConversion">
            <summary>
            The conversion from the <see cref="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.ElementType"/> to the iteration variable type.
            </summary>
            <remarks>
            May be user-defined.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.CurrentConversion">
            <summary>
            The conversion from the type of the <see cref="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.CurrentProperty"/> to the <see cref="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.ElementType"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.#ctor(System.Boolean,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Conversion)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo" /> structure.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel">
            <summary>
            A binding for a field initializer, property initializer, constructor
            initializer, or a parameter default value.
            Represents the result of binding a value expression rather than a
            block (for that, use a <see cref="T:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel.Create(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Creates a SemanticModel for a true field initializer (field = value) of a named type (incl. Enums).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel.Create(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Creates a SemanticModel for an autoprop initializer of a named type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel.Create(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.Binder,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Creates a SemanticModel for a parameter default value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Binder,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol},System.Int32)">
            <summary>
            Creates a speculative SemanticModel for an initializer node (field initializer, constructor initializer, or parameter default value)
            that did not appear in the original source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LexicalOrderSymbolComparer">
            <summary>
            This is an implementation of a special symbol comparer, which is supposed to be used for sorting
            original definition symbols (explicitly or implicitly declared in source within the same compilation)
            in lexical order of their declarations. It will not work on anything that uses non-source locations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel">
            <summary>
            Binding info for expressions and statements that are part of a member declaration.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel._parentSnapshotManagerOpt">
            <summary>
            Only used when this is a speculative semantic model.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel._containingSemanticModelOpt">
            <summary>
            Field specific to a non-speculative MemberSemanticModel that must have a containing semantic model.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.MemberSymbol">
            <summary>
            The member symbol 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSnapshotManager">
            <remarks>
            This will cause the bound node cache to be populated if nullable semantic analysis is enabled.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundRoot">
            <summary>
            Get the bound node corresponding to the root.
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetUpperBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Boolean)">
            <summary>
            Get the highest bound node in the tree associated with a particular syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Get the lowest bound node in the tree associated with a particular syntax node. Lowest is defined as last
            in a pre-order traversal of the bound tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.TestOnlyTryGetBoundNodesFromMap(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Internal for test purposes only
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetEnclosingBinderInternal(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Int32)">
            <summary>
            This overload exists for callers who already have a node in hand 
            and don't want to search through the tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetQueryEnclosingBinder(System.Int32,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundQueryClause)">
            <remarks>
            Returned binder doesn't need to have <see cref="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.SemanticModel"/> set - the caller will add it.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLambdaEnclosingBinder(System.Int32,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Performs the same function as GetEnclosingBinder, but is known to take place within a
            specified lambda.  Walks up the syntax hierarchy until a node with an associated binder
            is found.
            </summary>
            <remarks>
            CONSIDER: can this share code with MemberSemanticModel.GetEnclosingBinder?
            
            Returned binder doesn't need to have <see cref="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.SemanticModel"/> set - the caller will add it.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.EnsureNullabilityAnalysisPerformedIfNecessary">
            <summary>
            If we're doing nullable analysis, we need to fully bind this member, and then run
            nullable analysis on the resulting nodes before putting them in the map. Nullable
            analysis does not run a subset of code, so we need to fully bind the entire member
            first
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.RewriteNullableBoundNodesWithSnapshots(Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean,Microsoft.CodeAnalysis.CSharp.NullableWalker.SnapshotManager@,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol}@)">
            <summary>
            Rewrites the given bound node with nullability information, and returns snapshots for later speculative analysis at positions inside this member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.AnalyzeBoundNodeNullability(Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
            <summary>
            Performs the analysis step of getting nullability information for a semantic model but
            does not actually use the results. This gives us extra verification of nullable flow analysis.
            It is only used in contexts where nullable analysis is disabled in the compilation but requested
            through "run-nullable-analysis=always" or when the compiler is running in DEBUG.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Get all bounds nodes associated with a node, ordered from highest to lowest in the bound tree.
            Strictly speaking, the order is that of a pre-order traversal of the bound tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBindableParentNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            If the node is an expression, return the nearest parent node
            with semantic meaning. Otherwise return null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder">
            <summary>
            The incremental binder is used when binding statements. Whenever a statement
            is bound, it checks the bound node cache to see if that statement was bound, 
            and returns it instead of rebinding it. 
            
            For example, we might have:
               while (x > goo())
               {
                 y = y * x;
                 z = z + y;
               }
            
            We might first get semantic info about "z", and thus bind just the statement
            "z = z + y". Later, we might bind the entire While block. While binding the while
            block, we can reuse the binding we did of "z = z + y".
            </summary>
            <remarks>
            NOTE: any member overridden by this binder should follow the BuckStopsHereBinder pattern.
            Otherwise, a subsequent binder in the chain could suppress the caching behavior.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.GetBinder(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            We override GetBinder so that the BindStatement override is still
            in effect on nested binders.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.NodeMapBuilder.AddToMap(Microsoft.CodeAnalysis.CSharp.BoundNode,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundNode}},Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Walks the bound tree and adds all non compiler generated bound nodes whose syntax matches the given one
            to the cache.
            </summary>
            <param name="root">The root of the bound tree.</param>
            <param name="map">The cache.</param>
            <param name="node">The syntax node where to add bound nodes for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.NodeMapBuilder.ShouldAddNode(Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Decides whether to the add the bound node to the cache or not.
            </summary>
            <param name="currentBoundNode">The bound node.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.SpeculativeMemberSemanticModel">
            <summary>
            Allows asking semantic questions about a TypeSyntax (or its descendants) within a member, that did not appear in the original source code.
            Typically, an instance is obtained by a call to SemanticModel.TryGetSpeculativeSemanticModel. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.SpeculativeMemberSemanticModel.#ctor(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.NullableWalker.SnapshotManager,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol},System.Int32)">
            <summary>
            Creates a speculative SemanticModel for a TypeSyntax node at a position within an existing MemberSemanticModel.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.InitialState">
            <summary>
            Initial state for a MethodBodySemanticModel. Shared between here and the <see cref="T:Microsoft.CodeAnalysis.CSharp.MethodCompiler"/>. Used to make a <see cref="T:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel"/>
            with the required syntax and optional precalculated starting state for the model.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Create(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.InitialState)">
            <summary>
            Creates a SemanticModel for the method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.NullableWalker.SnapshotManager,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol},System.Int32)">
            <summary>
            Creates a speculative SemanticModel for a method body that did not appear in the original source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.CSharp.Binder,System.Int32)">
            <summary>
            Creates a speculative SemanticModel for an expression body that did not appear in the original source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.CSharp.Binder,System.Int32)">
            <summary>
            Creates a speculative SemanticModel for a constructor initializer that did not appear in the original source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax,Microsoft.CodeAnalysis.CSharp.Binder,System.Int32)">
            <summary>
            Creates a speculative SemanticModel for a constructor initializer that did not appear in the original source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.QueryClauseInfo">
            <summary>
            Semantic information associated with a query clause in a C# query expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.QueryClauseInfo.CastInfo">
            <summary>
            The .Cast&lt;T&gt;() operation generated from the query range variable's type restriction,
            or null if the type restriction isn't specified. 
            </summary>
            <remarks>
            The operation, when present is implemented via <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>.
            To access the type, when this is non-null use <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.TypeArguments"/>[0].
            If it is an extension method, it is returned in reduced form.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.QueryClauseInfo.OperationInfo">
            <summary>
            The operation (e.g. Select(), Where(), etc) that implements the given clause.
            </summary>
            <remarks>
            The clause can be implemented via <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>, or 
            <see cref="T:Microsoft.CodeAnalysis.IFieldSymbol"/> or <see cref="T:Microsoft.CodeAnalysis.IPropertySymbol"/> that return a delegate.
            If it is an extension method, it is returned in reduced form.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SpeculativeSyntaxTreeSemanticModel">
            <summary>
            Allows asking semantic questions about a tree of syntax nodes that did not appear in the original source code.
            Typically, an instance is obtained by a call to SemanticModel.TryGetSpeculativeSemanticModel. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxAndDeclarationManager.AppendAllSyntaxTrees(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.SyntaxTree},Microsoft.CodeAnalysis.SyntaxTree,System.String,Microsoft.CodeAnalysis.SourceReferenceResolver,Microsoft.CodeAnalysis.CommonMessageProvider,System.Boolean,System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.SyntaxTree,System.Int32},System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.LoadDirective}},System.Collections.Generic.IDictionary{System.String,Microsoft.CodeAnalysis.SyntaxTree},System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.SyntaxTree,System.Lazy{Microsoft.CodeAnalysis.CSharp.RootSingleNamespaceDeclaration}},Microsoft.CodeAnalysis.CSharp.DeclarationTable@)">
            <summary>
            Appends all trees (including any trees from #load'ed files).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxAndDeclarationManager.GetRemoveSet(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxTree},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.SyntaxTree,System.Int32},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.LoadDirective}},System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.SyntaxTree},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.SyntaxTree},System.Int32@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.LoadDirective}@)">
            <summary>
            Collects all the trees #load'ed by <paramref name="oldTree"/> (as well as
            <paramref name="oldTree"/> itself) and populates <paramref name="removeSet"/>
            with all the trees that are safe to remove (not #load'ed by any other tree).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel">
            <summary>
            Allows asking semantic questions about any node in a SyntaxTree within a Compilation.
            </summary>
            <summary>
            Allows asking semantic questions about any node in a SyntaxTree within a Compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel._memberModels">
            <summary>
            Note, the name of this field could be somewhat confusing because it is also 
            used to store models for attributes and default parameter values, which are
            not members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.Compilation">
            <summary>
            The compilation this object was obtained from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.Root">
            <summary>
            The root node of the syntax tree that this object is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.SyntaxTree">
            <summary>
            The SyntaxTree that this object is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.IgnoresAccessibility">
            <summary>
            Returns true if this is a SemanticModel that ignores accessibility rules when answering semantic questions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetEnclosingBinderInternal(System.Int32)">
            <summary>
            Gets the enclosing binder associated with the node
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.TestOnlyMemberModels">
            <summary>
            Internal for test purposes only
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a type.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseTypeDeclarationSyntax as all of them return a NamedTypeSymbol.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a delegate.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a member declaration syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for following subtypes of MemberDeclarationSyntax:
            NOTE:   (1) GlobalStatementSyntax as they don't declare any symbols.
            NOTE:   (2) IncompleteMemberSyntax as there are no symbols for incomplete members.
            NOTE:   (3) BaseFieldDeclarationSyntax or its subtypes as these declarations can contain multiple variable declarators.
            NOTE:       GetDeclaredSymbol should be called on the variable declarators directly.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a local function declaration syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an enum member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a method.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseMethodDeclarationSyntax as all of them return a MethodSymbol.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property, indexer or an event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property, indexer or an event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an indexer.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property or member accessor, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an accessor.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredMember(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,Microsoft.CodeAnalysis.Text.TextSpan,System.String)">
            <summary>
            Finds the member in the containing symbol which is inside the given declaration span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a variable.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the labeled statement.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the switch label.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a using declaration get the corresponding symbol for the using alias that was introduced.  
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared.</returns>
            <remarks>
            If the using directive is an error because it attempts to introduce an alias for which an existing alias was
            previously declared in the same scope, the result is a newly-constructed AliasSymbol (i.e. not one from the
            symbol table).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared, or null if a duplicate alias symbol was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbols(Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base field declaration syntax, get the corresponding symbols.
            </summary>
            <param name="declarationSyntax">The syntax node that declares one or more fields or events.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The field symbols that were declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a parameter declaration syntax node, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a parameter.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The parameter that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
            <param name="typeParameter"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpTypeInfo.Type">
            <summary>
            The type of the expression represented by the syntax node. For expressions that do not
            have a type, null is returned. If the type could not be determined due to an error, than
            an object derived from ErrorTypeSymbol is returned.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpTypeInfo.ConvertedType">
            <summary>
            The type of the expression after it has undergone an implicit conversion. If the type
            did not undergo an implicit conversion, returns the same as Type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpTypeInfo.ImplicitConversion">
            <summary>
            If the expression underwent an implicit conversion, return information about that
            conversion. Otherwise, returns an identity conversion.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager">
            <summary>
            Manages anonymous types created in owning compilation. All requests for 
            anonymous type symbols go via the instance of this class.
            </summary>
            <summary>
            Manages anonymous types created on module level. All requests for anonymous type symbols 
            go via the instance of this class, the symbol will be either created or returned from cache.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeConstructorSymbol">
            <summary>
            Represents an anonymous type constructor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePropertyGetAccessorSymbol">
            <summary>
            Represents a getter for anonymous type property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeEqualsMethodSymbol">
            <summary>
            Represents an anonymous type 'Equals' method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeGetHashCodeMethodSymbol">
            <summary>
            Represents an anonymous type 'GetHashCode' method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeToStringMethodSymbol">
            <summary>
            Represents an anonymous type 'ToString' method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.Compilation">
            <summary> 
            Current compilation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.ConstructAnonymousTypeSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor)">
            <summary>
            Given anonymous type descriptor provided constructs an anonymous type symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetAnonymousTypeProperty(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Int32)">
            <summary>
            Get a symbol of constructed anonymous type property by property index
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetAnonymousTypeFieldTypes(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Retrieves anonymous type field types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.ConstructAnonymousTypeSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations})">
            <summary>
            Given an anonymous type and new field types construct a new anonymous type symbol; 
            a new type symbol will reuse type descriptor from the constructed type with new type arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.ReportMissingOrErroneousSymbols(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Reports all use site errors in special or well known symbols required for anonymous types
            </summary>
            <returns>true if there was at least one error</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager._lazyAnonymousTypeTemplates">
            <summary>
            Cache of created anonymous type templates used as an implementation of anonymous 
            types in emit phase.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager._lazyAnonymousDelegates">
            <summary>
            Maps delegate signature shape (number of parameters and their ref-ness) to a synthesized generic delegate symbol.
            Currently used for dynamic call-sites and inferred delegate types whose signature doesn't match any of the well-known Func or Action types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.ConstructAnonymousTypeImplementationSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePublicSymbol)">
            <summary>
            Given anonymous type provided constructs an implementation type symbol to be used in emit phase; 
            if the anonymous type has at least one field the implementation type symbol will be created based on 
            a generic type template generated for each 'unique' anonymous type structure, otherwise the template
            type will be non-generic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AssignTemplatesNamesAndCompile(Microsoft.CodeAnalysis.CSharp.MethodCompiler,Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Resets numbering in anonymous type names and compiles the
            anonymous type methods. Also seals the collection of templates.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetCreatedAnonymousTypeTemplates(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol})">
            <summary>
            The set of anonymous type templates created by
            this AnonymousTypeManager, in fixed order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetCreatedAnonymousDelegates(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousDelegateTemplateSymbol})">
            <summary>
            The set of synthesized delegates created by
            this AnonymousTypeManager.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetAllCreatedTemplates">
            <summary>
            Returns all templates owned by this type manager
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.IsAnonymousTypeTemplate(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Returns true if the named type is an implementation template for an anonymous type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetAnonymousTypeHiddenMethods(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Retrieves methods of anonymous type template which are not placed to symbol table.
            In current implementation those are overridden 'ToString', 'Equals' and 'GetHashCode'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.TranslateAnonymousTypeSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Translates anonymous type public symbol into an implementation type symbol to be used in emit.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Translates anonymous type method symbol into an implementation method symbol to be used in emit.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateComparer">
            <summary> 
            Comparator being used for stable ordering in anonymous type or delegate indices.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegatePublicSymbol.Manager">
            <summary> Anonymous type manager owning this template </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegatePublicSymbol.TypeDescriptor">
            <summary> Anonymous type descriptor </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePublicSymbol">
            <summary>
            Represents an anonymous type 'public' symbol which is used in binding and lowering.
            In emit phase it is being substituted with implementation symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePublicSymbol.Properties">
            <summary> Properties defined in the type </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePublicSymbol._nameToSymbols">
            <summary> Maps member names to symbol(s) </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousDelegateTemplateSymbol.HasFixedTypes">
            <summary>
            True if any of the delegate parameter types or return type are
            fixed types rather than type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousDelegateTemplateSymbol.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager,System.String,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.RefKindVector)">
            <summary>
            A delegate type where the parameter types and return type
            of the delegate signature are type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousDelegateTemplateSymbol.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager,Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol})">
            <summary>
            A delegate type where at least one of the parameter types or return type
            of the delegate signature is a fixed type not a type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeFieldSymbol">
            <summary>
            Represents a baking field for an anonymous type template property symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePropertySymbol">
            <summary>
            Represents an anonymous type template's property symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.SynthesizedMethodBase">
            <summary>
            Represents a base implementation for anonymous type synthesized methods.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol">
            <summary>
            Represents an anonymous type 'template' which is a generic type to be used for all 
            anonymous types having the same structure, i.e. the same number of fields and field names.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol.SpecialMembers">
            <summary> This list consists of synthesized method symbols for ToString, 
            Equals and GetHashCode which are not part of symbol table </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol.Properties">
            <summary> Properties defined in the template </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol._nameToSymbols">
            <summary> Maps member names to symbol(s) </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol.TrySynthesizeDebuggerDisplayAttribute">
            <summary>
            Returns a synthesized debugger display attribute or null if one
            could not be synthesized.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol._nameAndIndex">
            <summary> Name to be used as metadata name during emit </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol._smallestLocation">
            <summary> Smallest location of the template, actually contains the smallest location 
            of all the anonymous type instances created using this template during EMIT </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.Manager">
            <summary> Anonymous type manager owning this template </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.SmallestLocation">
            <summary>
            Smallest location of the template, actually contains the smallest location 
            of all the anonymous type instances created using this template during EMIT;
            
            NOTE: if this property is queried, smallest location must not be null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.AdjustLocation(Microsoft.CodeAnalysis.Location)">
            <summary>
            In emit phase every time a created anonymous type is referenced we try to store the lowest 
            location of the template. It will be used for ordering templates and assigning emitted type names.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeParameterSymbol">
            <summary>
            Represents an anonymous type template's type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStringSwitchHashMethod">
            <summary>
            Represents a compiler generated synthesized method symbol
            representing string switch hash function
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStringSwitchHashMethod.ComputeStringHash(System.String)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <remarks>
            This method should be kept consistent with MethodBodySynthesizer.ConstructStringSwitchHashFunctionBody
            The control flow in this method mimics lowered "for" loop. It is exactly what we want to emit
            to ensure that JIT can do range check hoisting.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStringSwitchHashMethod.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <remarks>
            This method should be kept consistent with <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStringSwitchHashMethod.ComputeStringHash(System.String)"/>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSpanSwitchHashMethod">
            <summary>
            The synthesized method for computing the hash from a ReadOnlySpan&lt;char&gt; or Span&lt;char&gt;.
            Matches the corresponding method for string <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStringSwitchHashMethod"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSpanSwitchHashMethod.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <remarks>
            This method should be kept consistent with <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStringSwitchHashMethod.ComputeStringHash(System.String)"/>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedExplicitImplementationForwardingMethod">
            <summary>
            When C# interface implementation differs from CLR interface implementation,
            we insert a synthesized explicit interface implementation that delegates
            to the method that C# considers an implicit implementation.
            There are two key scenarios for this:
            1) A single source method is implicitly implementing one or more interface
               methods from metadata and the interface methods have different custom
               modifiers.  In this case, we explicitly implement the interface methods
               and have (all) implementations delegate to the source method.
            2) A non-virtual, non-source method in a base type is implicitly implementing
               an interface method.  Since we can't change the "virtualness" of the 
               non-source method, we introduce an explicit implementation that delegates
               to it instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedExplicitImplementationForwardingMethod.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Given a SynthesizedExplicitImplementationMethod (effectively a tuple (interface method, implementing method, implementing type)),
            construct a BoundBlock body.  Consider the tuple (Interface.Goo, Base.Goo, Derived).  The generated method will look like:
            
            R Interface.Goo&lt;T1, T2, ...&gt;(A1 a1, A2 a2, ...)
            {
                //don't return the output if the return type is void
                return this.Goo&lt;T1, T2, ...&gt;(a1, a2, ...);
            }
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSealedPropertyAccessor">
            <summary>
            If a sealed override property defines fewer accessors than the
            original virtual property, it is necessary to synthesize a sealed
            accessor so that the accessor will not be overridable from metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSealedPropertyAccessor.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Given a SynthesizedSealedPropertyAccessor (an accessor with a reference to the accessor it overrides),
            construct a BoundBlock body.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter">
            <summary>
            a bound node rewriter that rewrites types properly (which in some cases the automatically-generated
            base class does not).  This is used in the lambda rewriter, the iterator rewriter, and the async rewriter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.BaseMethodWrapperSymbol">
            <summary>
            A wrapper method that is created for non-virtually calling a base-class 
            virtual method from other classes (like those created for lambdas...).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.BaseMethodWrapperSymbol.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Given a SynthesizedSealedPropertyAccessor (an accessor with a reference to the accessor it overrides),
            construct a BoundBlock body.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.CompilationState">
            <summary> A not-null collection of synthesized methods generated for the current source type. </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.NeedsProxy(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Returns true if the specified local/parameter needs to be hoisted to a field.
            Variable may be hoisted even if it is not captured, to improve debugging experience.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodBodySynthesizer">
            <summary>
            Contains methods related to synthesizing bound nodes in lowered form 
            that does not need any processing before passing to codegen
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodBodySynthesizer.GenerateFieldEquals(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol},Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory)">
            <summary>
            Given a set of fields, produce an expression that is true when all of the given fields on
            `this` are equal to the fields on <paramref name="otherReceiver" /> according to the
            default EqualityComparer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodBodySynthesizer.ConstructSingleInvocationMethodBody(Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean)">
            <summary>
            Construct a body for a method containing a call to a single other method with the same signature (modulo name).
            </summary>
            <param name="F">Bound node factory.</param>
            <param name="methodToInvoke">Method to invoke in constructed body.</param>
            <param name="useBaseReference">True for "base.", false for "this.".</param>
            <returns>Body for implementedMethod.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol">
            <summary>
            An ArrayTypeSymbol represents an array type, such as int[] or object[,].
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.Rank">
            <summary>
            Gets the number of dimensions of the array. A regular single-dimensional array
            has rank 1, a two-dimensional array has rank 2, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.IsSZArray">
            <summary>
            Is this a zero-based one-dimensional array, i.e. SZArray in CLR terms.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.Sizes">
            <summary>
            Specified sizes for dimensions, by position. The length can be less than <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.Rank"/>,
            meaning that some trailing dimensions don't have the size specified.
            The most common case is none of the dimensions have the size specified - an empty array is returned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.LowerBounds">
            <summary>
            Specified lower bounds for dimensions, by position. The length can be less than <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.Rank"/>,
            meaning that some trailing dimensions don't have the lower bound specified.
            The most common case is all dimensions are zero bound - a default array is returned in this case.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.HasSameSizesAndLowerBoundsAs(Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol)">
            <summary>
            Note, <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.Rank"/> equality should be checked separately!!!
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.HasDefaultSizesAndLowerBounds">
            <summary>
            Normally C# arrays have default sizes and lower bounds - sizes are not specified and all dimensions are zero bound.
            This property should return false for any deviations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.ElementTypeWithAnnotations">
            <summary>
            Gets the type of the elements stored in the array along with its annotations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.ElementType">
            <summary>
            Gets the type of the elements stored in the array.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.SZArray">
            <summary>
            Represents SZARRAY - zero-based one-dimensional array 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.SZArray.IsSZArray">
            <summary>
            SZArray is an array type encoded in metadata with ELEMENT_TYPE_SZARRAY (always single-dim array with 0 lower bound).
            Non-SZArray type is encoded in metadata with ELEMENT_TYPE_ARRAY and with optional sizes and lower bounds. Even though 
            non-SZArray can also be a single-dim array with 0 lower bound, the encoding of these types in metadata is distinct.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.MDArray">
            <summary>
            Represents MDARRAY - multi-dimensional array (possibly of rank 1)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData">
            <summary>
            Represents an attribute applied to a Symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.AttributeClass">
            <summary>
            Gets the attribute class being applied.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.AttributeConstructor">
            <summary>
            Gets the constructor used in this application of the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.ApplicationSyntaxReference">
            <summary>
            Gets a reference to the source for this application of the attribute. Returns null for applications of attributes on metadata Symbols.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.ConstructorArguments">
            <summary>
            Gets the list of constructor arguments specified by this application of the attribute.  This list contains both positional arguments
            and named arguments that are formal parameters to the constructor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.NamedArguments">
            <summary>
            Gets the list of named field or property value arguments specified by this application of the attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.IsTargetAttribute(System.String,System.String)">
            <summary>
            Compares the namespace and type name with the attribute's namespace and type name.
            Returns true if they are the same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.IsTargetEarlyAttribute(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Checks if an applied attribute with the given attributeType matches the namespace name and type name of the given early attribute's description
            and the attribute description has a signature with parameter count equal to the given attribute syntax's argument list count.
            NOTE: We don't allow early decoded attributes to have optional parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.ToString">
            <summary>
            Returns the <see cref="T:System.String"/> that represents the current AttributeData.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current AttributeData.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.CommonAttributeClass">
            <summary>
            Gets the attribute class being applied as an <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.CommonAttributeConstructor">
            <summary>
            Gets the constructor used in this application of the attribute as an <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.CommonApplicationSyntaxReference">
            <summary>
            Gets a reference to the source for this application of the attribute. Returns null for applications of attributes on metadata Symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.DecodePermissionSetAttribute(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
             <summary>
             Decodes PermissionSetAttribute applied in source to determine if it needs any fixup during codegen.
             </summary>
             <remarks>
             PermissionSetAttribute needs fixup when it contains an assignment to the 'File' property as a single named attribute argument.
             Fixup performed is ported from SecurityAttributes::FixUpPermissionSetAttribute.
             It involves following steps:
              1) Verifying that the specified file name resolves to a valid path.
              2) Reading the contents of the file into a byte array.
              3) Convert each byte in the file content into two bytes containing hexadecimal characters.
              4) Replacing the 'File = fileName' named argument with 'Hex = hexFileContent' argument, where hexFileContent is the converted output from step 3) above.
            
             Step 1) is performed in this method, i.e. during binding.
             Remaining steps are performed during serialization as we want to avoid retaining the entire file contents throughout the binding/codegen pass.
             See <see cref="T:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference"/> for remaining fixup steps.
             </remarks>
             <returns>String containing the resolved file path if PermissionSetAttribute needs fixup during codegen, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.ShouldEmitAttribute(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,System.Boolean)">
            <summary>
            This method determines if an applied attribute must be emitted.
            Some attributes appear in symbol model to reflect the source code,
            but should not be emitted.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpCustomModifier">
            <summary>
            Represents a custom modifier (modopt/modreq).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpCustomModifier.Modifier">
            <summary>
            A type used as a tag that indicates which type of modification applies.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol">
            <summary>
            Represents an event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.TypeWithAnnotations">
            <summary>
            The type of the event along with its annotations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.Type">
            <summary>
            The type of the event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.AddMethod">
            <summary>
            The 'add' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.RemoveMethod">
            <summary>
            The 'remove' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.RequiresInstanceReceiver">
            <summary>
            Returns true if this symbol requires an instance reference as the implicit receiver. This is false if the symbol is static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.IsWindowsRuntimeEvent">
            <summary>
            True if this is a Windows Runtime-style event.
            
            A normal C# event, "event D E", has accessors
                void add_E(D d)
                void remove_E(D d)
            
            A Windows Runtime event, "event D E", has accessors
                EventRegistrationToken add_E(D d)
                void remove_E(EventRegistrationToken t)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.IsDirectlyExcludedFromCodeCoverage">
            <summary>
            True if the event itself is excluded from code coverage instrumentation.
            True for source events marked with <see cref="F:Microsoft.CodeAnalysis.AttributeDescription.ExcludeFromCodeCoverageAttribute"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.GetFieldAttributes">
            <summary>
            Gets the attributes on event's associated field, if any.
            Returns an empty <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> if
            there are no attributes.
            </summary>
            <remarks>
            This publicly exposes the attributes of the internal backing field.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.OverriddenEvent">
            <summary>
            Returns the overridden event, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.IsExplicitInterfaceImplementation">
            <summary>
            Source: Was the member name qualified with a type name?
            Metadata: Is the member an explicit implementation?
            </summary>
            <remarks>
            Will not always agree with ExplicitInterfaceImplementations.Any()
            (e.g. if binding of the type part of the name fails).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface events explicitly implemented by this event.
            </summary>
            <remarks>
            Events imported from metadata can explicitly implement more than one event.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol">
            <summary>
            Represents a field in a class, struct or enum
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.TypeWithAnnotations">
            <summary>
            Gets the type of this field along with its annotations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.Type">
            <summary>
            Gets the type of this field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.AssociatedSymbol">
            <summary>
            If this field serves as a backing variable for an automatically generated
            property or a field-like event, returns that 
            property/event. Otherwise returns null.
            Note, the set of possible associated symbols might be expanded in the future to 
            reflect changes in the languages.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsReadOnly">
            <summary>
            Returns true if this field was declared as "readonly". 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsVolatile">
            <summary>
            Returns true if this field was declared as "volatile". 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.RequiresInstanceReceiver">
            <summary>
            Returns true if this symbol requires an instance reference as the implicit receiver. This is false if the symbol is static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsFixedSizeBuffer">
            <summary>
            Returns true if this field was declared as "fixed".
            Note that for a fixed-size buffer declaration, this.Type will be a pointer type, of which
            the pointed-to type will be the declared element type of the fixed-size buffer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.FixedSize">
            <summary>
            If IsFixedSizeBuffer is true, the value between brackets in the fixed-size-buffer declaration.
            If IsFixedSizeBuffer is false FixedSize is 0.
            Note that for fixed-a size buffer declaration, this.Type will be a pointer type, of which
            the pointed-to type will be the declared element type of the fixed-size buffer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.FixedImplementationType(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder)">
            <summary>
            If this.IsFixedSizeBuffer is true, returns the underlying implementation type for the
            fixed-size buffer when emitted.  Otherwise returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsCapturedFrame">
            <summary>
            Returns true when field is a backing field for a captured frame pointer (typically "this").
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsConst">
            <summary>
            Returns true if this field was declared as "const" (i.e. is a constant declaration).
            Also returns true for an enum member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.ConstantValue">
            <summary>
            If IsConst returns true, then returns the constant value of the field or enum member. If IsConst returns
            false, then returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsAbstract">
            <summary>
            Returns false because field can't be abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsExtern">
            <summary>
            Returns false because field can't be defined externally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsOverride">
            <summary>
            Returns false because field can't be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsSealed">
            <summary>
            Returns false because field can't be sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsVirtual">
            <summary>
            Returns false because field can't be virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.HasRuntimeSpecialName">
            <summary>
            True if this symbol has a runtime-special name (metadata flag RuntimeSpecialName is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsNotSerialized">
            <summary>
            True if this field is not serialized (metadata flag NotSerialized is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.HasPointerType">
            <summary>
            True if this field has a pointer type.
            </summary>
            <remarks>
            By default we defer to this.Type.IsPointerOrFunctionPointer() 
            However in some cases this may cause circular dependency via binding a
            pointer that points to the type that contains the current field.
            Fortunately in those cases we do not need to force binding of the field's type 
            and can just check the declaration syntax if the field type is not yet known.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.MarshallingInformation">
            <summary>
            Describes how the field is marshalled when passed to native code.
            Null if no specific marshalling information is available for the field.
            </summary>
            <remarks>PE symbols don't provide this information and always return null.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.MarshallingType">
            <summary>
            Returns the marshalling type of this field, or 0 if marshalling information isn't available.
            </summary>
            <remarks>
            By default this information is extracted from <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.MarshallingInformation"/> if available. 
            Since the compiler does only need to know the marshalling type of symbols that aren't emitted 
            PE symbols just decode the type from metadata and don't provide full marshalling information.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.TypeLayoutOffset">
            <summary>
            Offset assigned to the field when the containing type is laid out by the VM.
            Null if unspecified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsRequired">
            <summary>
            Returns true if this field is required to be set in an object initializer on object creation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsHighestPriorityUseSiteErrorCode(System.Int32)">
            <summary>
            Returns true if the error code is highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsVirtualTupleField">
            <summary>
            Returns True when field symbol is not mapped directly to a field in the underlying tuple struct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsDefaultTupleElement">
            <summary>
            Returns true if this is a field representing a Default element like Item1, Item2...
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.TupleUnderlyingField">
            <summary>
            If this is a field of a tuple type, return corresponding underlying field from the
            tuple underlying type. Otherwise, null. In case of a malformed underlying type
            the corresponding underlying field might be missing, return null in this case too.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.CorrespondingTupleField">
            <summary>
            If this field represents a tuple element, returns a corresponding default element field.
            Otherwise returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsTupleElement">
            <summary>
            Returns true if a given field is a tuple element
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.TupleElementIndex">
            <summary>
            If this is a field representing a tuple element,
            returns the index of the element (zero-based).
            Otherwise returns -1
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerTypeSymbol.FunctionPointerMethodSignature">
            <summary>
            We need to be able to differentiate between a FunctionPointer used as a type and a function pointer used
            as a StandaloneMethodSig. To do this, we wrap the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerMethodSymbol"/> in a
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerTypeSymbol.FunctionPointerMethodSignature"/>, to hide its implementation of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerTypeSymbol.CreateFromPartsForTests(Microsoft.Cci.CallingConvention,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier},Microsoft.CodeAnalysis.RefKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Creates a function pointer from individual parts. This method should only be used when diagnostics are not needed. This is
            intended for use in test code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerTypeSymbol.CreateFromParts(Microsoft.Cci.CallingConvention,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier},Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.RefKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Creates a function pointer from individual parts. This method should only be used when diagnostics are not needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerTypeSymbol.RefKindEquals(Microsoft.CodeAnalysis.TypeCompareKind,Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.RefKind)">
            <summary>
            For scenarios such as overriding with differing ref kinds (such as out vs in or ref)
            we need to compare function pointer parameters assuming that Ref matches RefReadonly/In
            and Out. This is done because you cannot overload on ref vs out vs in in regular method
            signatures, and we are disallowing similar overloads in source with function pointers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerTypeSymbol.GetRefKindForHashCode(Microsoft.CodeAnalysis.RefKind)">
            <summary>
            For scenarios such as overriding with differing ref kinds (such as out vs in or ref)
            we need to compare function pointer parameters assuming that Ref matches RefReadonly/In
            and Out. For that reason, we must also ensure that GetHashCode returns equal hashcodes
            for types that only differ by the type of ref they have.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerTypeSymbol.IsCallingConventionModifier(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Return true if the given type is valid as a calling convention modifier type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol">
            <summary>
            Represents a method or method-like symbol (including constructor,
            destructor, operator, or property/event accessor).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsMetadataNewSlot(System.Boolean)">
            <summary>
            This method indicates whether or not the runtime will regard the method
            as newslot (as indicated by the presence of the "newslot" modifier in the
            signature).
            WARN WARN WARN: We won't have a final value for this until declaration
            diagnostics have been computed for all <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol"/>s, so pass
            ignoringInterfaceImplementationChanges: true if you need a value sooner
            and aren't concerned about tweaks made to satisfy interface implementation 
            requirements.
            NOTE: Not ignoring changes can only result in a value that is more true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsMetadataVirtual(System.Boolean)">
            <summary>
            This method indicates whether or not the runtime will regard the method
            as virtual (as indicated by the presence of the "virtual" modifier in the
            signature).
            WARN WARN WARN: We won't have a final value for this until declaration
            diagnostics have been computed for all <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol"/>s, so pass
            ignoringInterfaceImplementationChanges: true if you need a value sooner
            and aren't concerned about tweaks made to satisfy interface implementation 
            requirements.
            NOTE: Not ignoring changes can only result in a value that is more true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.MethodKind">
            <summary>
            Gets what kind of method this is. There are several different kinds of things in the
            C# language that are represented as methods. This property allow distinguishing those things
            without having to decode the name of the method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.Arity">
            <summary>
            Returns the arity of this method, or the number of type parameters it takes.
            A non-generic method has zero arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsGenericMethod">
            <summary>
            Returns whether this method is generic; i.e., does it have any type parameters?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.RequiresInstanceReceiver">
            <summary>
            Returns true if this symbol requires an instance reference as the implicit receiver. This is false if the symbol is static, or a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.LocalFunctionSymbol"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsDirectlyExcludedFromCodeCoverage">
            <summary>
            True if the method itself is excluded from code coverage instrumentation.
            True for source methods marked with <see cref="F:Microsoft.CodeAnalysis.AttributeDescription.ExcludeFromCodeCoverageAttribute"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.NotNullMembers">
            <summary>
            If a method is annotated with `[MemberNotNull(...)]` attributes, returns the list of members
            listed in those attributes.
            Otherwise, an empty array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetUnmanagedCallersOnlyAttributeData(System.Boolean)">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.UnmanagedCallersOnlyAttributeData"/> data for this method, if there is any. If forceComplete
            is false and the data has not yet been loaded or only early attribute binding has occurred, then either
            <see cref="F:Microsoft.CodeAnalysis.UnmanagedCallersOnlyAttributeData.Uninitialized"/> or
            <see cref="F:Microsoft.CodeAnalysis.UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound"/> will be returned, respectively.
            If passing true for forceComplete, ensure that cycles will not occur by not calling in the process of binding
            an attribute argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsExtensionMethod">
            <summary>
            Returns true if this method is an extension method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ImplementationAttributes">
            <summary>
            Misc implementation metadata flags (ImplFlags in metadata).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.HasDeclarativeSecurity">
            <summary>
            True if the type has declarative security information (HasSecurity flags).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetDllImportData">
            <summary>
            Platform invoke information, or null if the method isn't a P/Invoke.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetSecurityInformation">
            <summary>
            Declaration security information associated with this type, or null if there is none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReturnValueMarshallingInformation">
            <summary>
            Marshalling information for return value (FieldMarshal in metadata).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.RequiresSecurityObject">
            <summary>
            True if the method calls another method containing security code (metadata flag RequiresSecurityObject is set).
            </summary>
            <remarks>
            A method can me marked as RequiresSecurityObject by applying the DynamicSecurityMethodAttribute in source.
            DynamicSecurityMethodAttribute is a pseudo custom attribute defined as an internal class in System.Security namespace.
            This attribute is set on certain security methods defined within mscorlib.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.HidesBaseMethodsByName">
            <summary>
            Returns true if this method hides base methods by name. This cannot be specified directly
            in the C# language, but can be true for methods defined in other languages imported from
            metadata. The equivalent of the "hidebyname" flag in metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsVararg">
             <summary>
             Returns whether this method is using CLI VARARG calling convention. This is used for C-style variable
             argument lists. This is used extremely rarely in C# code and is represented using the undocumented "__arglist" keyword.
            
             Note that methods with "params" on the last parameter are indicated with the "IsParams" property on ParameterSymbol, and
             are not represented with this property.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsCheckedBuiltin">
            <summary>
            Returns whether this built-in operator checks for integer overflow.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReturnsVoid">
            <summary>
            Returns true if this method has no return type; i.e., returns "void".
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsAsync">
            <summary>
            Source: Returns whether this method is async; i.e., does it have the async modifier?
            Metadata: Returns false; methods from metadata cannot be async.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReturnsByRef">
            <summary>
            Indicates whether or not the method returns by reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReturnsByRefReadonly">
            <summary>
            Indicates whether or not the method returns by ref readonly
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.RefKind">
            <summary>
            Gets the ref kind of the method's return value
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReturnTypeWithAnnotations">
            <summary>
            Gets the return type of the method along with its annotations
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReturnType">
            <summary>
            Gets the return type of the method
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.FlowAnalysisAnnotations">
            <summary>
            Flow analysis annotations on the method itself (ie. DoesNotReturn)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TypeArgumentsWithAnnotations">
            <summary>
            Returns the type arguments that have been substituted for the type parameters.
            If nothing has been substituted for a given type parameter,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TypeParameters">
            <summary>
            Get the type parameters on this method. If the method has not generic,
            returns an empty list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ThisParameter">
            <summary>
            Call <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TryGetThisParameter(Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol@)"/> and throw if it returns false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TryGetThisParameter(Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol@)">
            <returns>
            True if this <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/> type supports retrieving the this parameter
            and false otherwise.  Note that a return value of true does not guarantee a non-null
            <paramref name="thisParameter"/> (e.g. fails for static methods).
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ParameterCount">
            <summary>
            Optimization: in many cases, the parameter count (fast) is sufficient and we
            don't need the actual parameter symbols (slow).
            </summary>
            <remarks>
            The default implementation is always correct, but may be unnecessarily slow.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.Parameters">
            <summary>
            Gets the parameters of this method. If this method has no parameters, returns
            an empty list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ConstructedFrom">
            <summary>
            Returns the method symbol that this method was constructed from. The resulting
            method symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsExplicitInterfaceImplementation">
            <summary>
            Source: Was the member name qualified with a type name?
            Metadata: Is the member an explicit implementation?
            </summary>
            <remarks>
            Will not always agree with ExplicitInterfaceImplementations.Any()
            (e.g. if binding of the type part of the name fails).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsDeclaredReadOnly">
            <summary>
            Indicates whether the method is declared readonly, i.e.
            whether the 'this' receiver parameter is 'ref readonly'.
            See also <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsEffectivelyReadOnly"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsInitOnly">
            <summary>
            Indicates whether the accessor is marked with the 'init' modifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsEffectivelyReadOnly">
            <summary>
            Indicates whether the method is effectively readonly,
            by either the method or the containing type being marked readonly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface methods explicitly implemented by this method.
            </summary>
            <remarks>
            Methods imported from metadata can explicitly implement more than one method,
            that is why return type is ImmutableArray.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.RefCustomModifiers">
            <summary>
            Custom modifiers associated with the ref modifier, or an empty array if there are none.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetReturnTypeAttributes">
            <summary>
            Gets the attributes on method's return type.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.AssociatedSymbol">
            <summary>
            If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
            returns the property that this method is the getter or setter for.
            If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
            returns the event that this method is the adder or remover for.
            Note, the set of possible associated symbols might be expanded in the future to
            reflect changes in the languages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetLeastOverriddenMethod(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Returns the original virtual or abstract method which a given method symbol overrides,
            ignoring any other overriding methods in base classes.
            </summary>
            <param name="accessingTypeOpt">The search must respect accessibility from this type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetLeastOverriddenMethodCore(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Boolean)">
            <summary>
            Returns the original virtual or abstract method which a given method symbol overrides,
            ignoring any other overriding methods in base classes.
            </summary>
            <param name="accessingTypeOpt">The search must respect accessibility from this type.</param>
            <param name="requireSameReturnType">The returned method must have the same return type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetConstructedLeastOverriddenMethod(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Boolean)">
            <summary>
            Returns the original virtual or abstract method which a given method symbol overrides,
            ignoring any other overriding methods in base classes.
            Also, if the given method symbol is generic then the resulting virtual or abstract method is constructed with the
            same type arguments as the given method.
            </summary>
            <param name="requireSameReturnType">The returned method must have the same return type.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.OverriddenMethod">
            <summary>
            If this method overrides another method (because it both had the override modifier
            and there correctly was a method to override), returns the overridden method.
            Note that if an overriding method D.M overrides C.M, which in turn overrides
            virtual method A.M, the "overridden method" of D.M is C.M, not the original virtual
            method A.M. Note also that constructed generic methods are not considered to
            override anything.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.CallsAreOmitted(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns true if calls to this method are omitted in this syntax tree. Calls are omitted
            when the called method is a partial method with no implementation part, or when the
            called method is a conditional method whose condition is not true in the source file
            corresponding to the given syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.CallsAreConditionallyOmitted(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Calls are conditionally omitted if both the following requirements are true:
             (a) IsConditional == true, i.e. it has at least one applied/inherited conditional attribute AND
             (b) None of conditional symbols corresponding to these conditional attributes are defined in the given syntaxTree.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetAppliedConditionalSymbols">
            <summary>
            Returns a sequence of preprocessor symbols specified in <see cref="T:System.Diagnostics.ConditionalAttribute"/> applied on this symbol, or null if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsConditional">
            <summary>
            Returns a flag indicating whether this symbol has at least one applied/inherited conditional attribute.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.HasSetsRequiredMembers">
            <summary>
            Returns true if this is a constructor attributed with HasSetsRequiredMembers
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.CanOverrideOrHide(Microsoft.CodeAnalysis.MethodKind)">
            <summary>
            Some method kinds do not participate in overriding/hiding (e.g. constructors).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.Kind">
            <summary>
            Returns value 'Method' of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsScriptConstructor">
            <summary>
            Returns true if this symbol represents a constructor of a script class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsImplicitConstructor">
            <summary>
            Returns if the method is implicit constructor (normal and static)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsImplicitInstanceConstructor">
            <summary>
            Returns if the method is implicit instance constructor
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsSubmissionConstructor">
            <summary>
            Returns true if this symbol represents a constructor of an interactive submission class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsEntryPointCandidate">
            <summary>
            Determines whether this method is a candidate for a default assembly entry point
            (i.e. it is a static method called "Main").
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReduceExtensionMethod(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            If this is an extension method that can be applied to a receiver of the given type,
            returns a reduced extension method symbol thus formed. Otherwise, returns null.
            </summary>
            <param name="compilation">The compilation in which constraints should be checked.
            Should not be null, but if it is null we treat constraints as we would in the latest
            language version.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReduceExtensionMethod">
            <summary>
            If this is an extension method, returns a reduced extension method
            symbol representing the method. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.CallsiteReducedFromMethod">
            <summary>
            If this method is a reduced extension method, returns the extension method that
            should be used at call site during ILGen. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.PartialImplementationPart">
            <summary>
            If this is a partial method declaration without a body, and the method also
            has a part that implements it with a body, returns that implementing
            definition.  Otherwise null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.PartialDefinitionPart">
            <summary>
            If this is a partial method with a body, returns the corresponding
            definition part (without a body).  Otherwise null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReducedFrom">
            <summary>
            If this method is a reduced extension method, gets the extension method definition that
            this method was reduced from. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReceiverType">
            <summary>
            If this method can be applied to an object, returns the type of object it is applied to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetTypeInferredDuringReduction(Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol)">
            <summary>
            If this method is a reduced extension method, returns a type inferred during reduction process for the type parameter.
            </summary>
            <param name="reducedFromTypeParameter">Type parameter of the corresponding <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReducedFrom"/> method.</param>
            <returns>Inferred type or Nothing if nothing was inferred.</returns>
            <exception cref="T:System.InvalidOperationException">If this is not a reduced extension method.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="reducedFromTypeParameter"/> is null.</exception>
            <exception cref="T:System.ArgumentException">If <paramref name="reducedFromTypeParameter"/> doesn't belong to the corresponding <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReducedFrom"/> method.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.Construct(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol[])">
            <summary>
            Apply type substitution to a generic method to create a method symbol with the given type parameters supplied.
            </summary>
            <param name="typeArguments"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.Construct(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Apply type substitution to a generic method to create a method symbol with the given type parameters supplied.
            </summary>
            <param name="typeArguments"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol._lazyParameterSignature">
            <summary>
            As a performance optimization, cache parameter types and refkinds - overload resolution uses them a lot.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ParameterRefKinds">
            <summary>
            Null if no parameter is ref/out. Otherwise the RefKind for each parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TypeSubstitution">
            <summary>
            Returns the map from type parameters to type arguments.
            If this is not a generic method instantiation, returns null.
            The map targets the original definition of the method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.CheckAndReportValidUnmanagedCallersOnlyTarget(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Determines if this method is a valid target for UnmanagedCallersOnly, reporting an error in the given diagnostic
            bag if it is not null. <paramref name="location"/> and <paramref name="diagnostics"/> should both be null, or 
            neither should be null. If an error would be reported (whether or not diagnostics is null), true is returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsHighestPriorityUseSiteErrorCode(System.Int32)">
            <summary>
            Returns true if the error code is highest priority while calculating use site error for this symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IteratorElementTypeWithAnnotations">
            <summary>
            If the method was written as an iterator method (i.e. with yield statements in its body) returns the
            element type of the iterator.  Otherwise returns default(TypeWithAnnotations).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Generates bound block representing method's body for methods in lowered form and adds it to
            a collection of method bodies of the current module. This method is supposed to only be
            called for method symbols which return SynthesizesLoweredBoundBody == true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.SynthesizesLoweredBoundBody">
            <summary>
            Returns true for synthesized symbols which generate synthesized body in lowered form
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GenerateDebugInfo">
            <summary>
            Return true iff the method contains user code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.CalculateLocalSyntaxOffset(System.Int32,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Calculates a syntax offset for a local (user-defined or long-lived synthesized) declared at <paramref name="localPosition"/>.
            Must be implemented by all methods that may contain user code.
            </summary>
            <remarks>
            Syntax offset is a unique identifier for the local within the emitted method body.
            It's based on position of the local declarator. In single-part method bodies it's simply the distance
            from the start of the method body syntax span. If a method body has multiple parts (such as a constructor
            comprising of code for member initializers and constructor initializer calls) the offset is calculated
            as if all source these parts were concatenated together and prepended to the constructor body.
            The resulting syntax offset is then negative for locals defined outside of the constructor body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.AddSynthesizedReturnTypeAttributes(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData}@)">
            <summary>
            Build and add synthesized return type attributes for this method symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.AreLocalsZeroed">
            <summary>
            Returns true if locals are to be initialized
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol">
            <summary>
            Represents a type other than an array, a pointer, a type parameter, and dynamic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetInterfacesToEmit">
            <summary>
            Gets the set of interfaces to emit on this type. This set can be different from the set returned by Interfaces property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.InterfacesVisit(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol}@)">
            <summary>
            Add the type to the builder and then recurse on its interfaces.
            </summary>
            <remarks>
            Pre-order depth-first search.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetMethodsToEmit">
            <summary>
            To represent a gap in interface's v-table null value should be returned in the appropriate position,
            unless the gap has a symbol (happens if it is declared in source, for example).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol._lazyRequiredMembers">
            <summary>
            <see langword="default"/> if uninitialized. <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.RequiredMembersErrorSentinel"/> if there are errors. <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Empty"/> if
            there are no required members. Otherwise, the required members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Arity">
            <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TypeParameters">
            <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ImmutableArray.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a give type parameters,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.ConstructedFrom">
            <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.KnownCircularStruct">
            <summary>
            Returns true for a struct type containing a cycle.
            This property is intended for flow analysis only
            since it is only implemented for source types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsExplicitDefinitionOfNoPiaLocalType">
            <summary>
            Is this a NoPia local type explicitly declared in source, i.e.
            top level type with a TypeIdentifier attribute on it?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetGuidString(System.String@)">
            <summary>
            Returns true and a string from the first GuidAttribute on the type, 
            the string might be null or an invalid guid representation. False, 
            if there is no GuidAttribute with string argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.DelegateInvokeMethod">
            <summary>
            For delegate types, gets the delegate's invoke method.  Returns null on
            all other kinds of types.  Note that it is possible to have an ill-formed
            delegate type imported from metadata which does not have an Invoke method.
            Such a type will be classified as a delegate but its DelegateInvokeMethod
            would be null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetOperators(System.String)">
            <summary>
            Get the operators for this type by their metadata name
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.InstanceConstructors">
            <summary>
            Get the instance constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.StaticConstructors">
            <summary>
            Get the static constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Constructors">
            <summary>
            Get the instance and static constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Indexers">
            <summary>
            Get the indexers for this type.
            </summary>
            <remarks>
            Won't include indexers that are explicit interface implementations.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.MightContainExtensionMethods">
            <summary>
            Returns true if this type might contain extension methods. If this property
            returns false, there are no extension methods in this type.
            </summary>
            <remarks>
            This property allows the search for extension methods to be narrowed quickly.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetAttributeUsageInfo">
            <summary>
            Gets the associated attribute usage info for an attribute type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsScriptClass">
            <summary>
            Returns true if the type is a Script class. 
            It might be an interactive submission class or a Script class in a csx file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsImplicitClass">
            <summary>
            Returns true if the type is the implicit class that holds onto invalid global members (like methods or
            statements in a non script file).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.MetadataName">
            <summary>
            Return the name including the metadata arity suffix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.AssociatedFileIdentifier">
            <summary>
            If this type is a file-local type, returns an identifier for the file this type was declared in. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.MangleName">
            <summary>
            Should the name returned by Name property be mangled with [`arity] suffix in order to get metadata name.
            Must return False for a type with Arity == 0.
            </summary>
            <remarks>
            Some types with Arity > 0 still have MangleName == false. For example, EENamedTypeSymbol.
            Note that other differences between source names and metadata names exist and are not controlled by this property,
            such as the 'AssociatedFileIdentifier' prefix for file types.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.MemberNames">
            <summary>
            Collection of names of members declared within this type. May return duplicates.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.HasDeclaredRequiredMembers">
            <summary>
            True if this type declares any required members. It does not recursively check up the tree for _all_ required members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.HasRequiredMembersError">
            <summary>
            Whether the type encountered an error while trying to build its complete list of required members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.HasAnyRequiredMembers">
            <summary>
            Returns true if there are any required members. Prefer calling this over checking <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.AllRequiredMembers"/> for empty, as
            this will avoid calculating base type requirements if not necessary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.AllRequiredMembers">
            <summary>
            The full list of all required members for this type, including from base classes. If <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.HasRequiredMembersError"/> is true,
            this returns empty.
            </summary>
            <remarks>
            Do not call this API if all you need are the required members declared on this type. Use <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetMembers"/> instead, filtering for
            required members, instead of calling this API. If you only need to determine whether this type or any base types have required members, call
            <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.HasAnyRequiredMembers"/>, which will avoid calling this API if not required.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TryCalculateRequiredMembers(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{System.String,Microsoft.CodeAnalysis.CSharp.Symbol}.Builder@)">
            <summary>
            Attempts to calculate the required members for this type. Returns false if there were errors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.HasPossibleWellKnownCloneMethod">
            <summary>
            A lightweight check for whether this type has a possible clone method. This is less costly than GetMembers,
            particularly for PE symbols, and can be used as a cheap heuristic for whether to fully search through all
            members of this type for a valid clone method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetInstanceFieldsAndEvents">
            <summary>
            Get all instance field and event members.
            </summary>
            <remarks>
            For source symbols may be called while calculating
            <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetMembersUnordered"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Used to implement visitor pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetEarlyAttributeDecodingMembers">
            <summary>
            During early attribute decoding, we consider a safe subset of all members that will not
            cause cyclic dependencies.  Get all such members for this symbol.
            </summary>
            <remarks>
            Never returns null (empty instead).
            Expected implementations: for source, return type and field members; for metadata, return all members.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetEarlyAttributeDecodingMembers(System.String)">
            <summary>
            During early attribute decoding, we consider a safe subset of all members that will not
            cause cyclic dependencies.  Get all such members for this symbol that have a particular name.
            </summary>
            <remarks>
            Never returns null (empty instead).
            Expected implementations: for source, return type and field members; for metadata, return all members.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Equals(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.TypeCompareKind)">
            <summary>
            Compares this type to another type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.EqualsComplicatedCases(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.TypeCompareKind)">
            <summary>
            Helper for more complicated cases of Equals like when we have generic instantiations or types nested within them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.MergeEquivalentTypeArguments(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.VarianceKind,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations})">
            <summary>
            Merges nullability of all type arguments from the `typeA` and `typeB`.
            The type parameters are added to `allTypeParameters`; the merged
            type arguments are added to `allTypeArguments`; and the method
            returns true if there were changes from the original `typeA`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Construct(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol[])">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Construct(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Construct(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.ConstructUnboundGenericType">
            <summary>
            Returns an unbound generic type of this named type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.HasCodeAnalysisEmbeddedAttribute">
            <summary>
            Gets a value indicating whether this type has an EmbeddedAttribute or not.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsInterpolatedStringHandlerType">
            <summary>
            Gets a value indicating whether this type has System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute or not.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsGenericType">
            <summary>
            True if this type or some containing type has type parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsUnboundGenericType">
            <summary>
            True if this is a reference to an <em>unbound</em> generic type.  These occur only
            within a <c>typeof</c> expression.  A generic type is considered <em>unbound</em>
            if all of the type argument lists in its fully qualified name are empty.
            Note that the type arguments of an unbound generic type will be returned as error
            types because they do not really have type arguments.  An unbound generic type
            yields null for its BaseType and an empty result for its Interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TypeSubstitution">
            <summary>
            Returns the map from type parameters to type arguments.
            If this is not a generic type instantiation, returns null.
            The map targets the original definition of the type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsDirectlyExcludedFromCodeCoverage">
            <summary>
            True if the type itself is excluded from code coverage instrumentation.
            True for source types marked with <see cref="F:Microsoft.CodeAnalysis.AttributeDescription.ExcludeFromCodeCoverageAttribute"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsComImport">
            <summary>
            Returns a flag indicating whether this symbol is ComImport.
            </summary>
            <remarks>
            A type can me marked as a ComImport type in source by applying the <see cref="T:System.Runtime.InteropServices.ComImportAttribute"/>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsWindowsRuntimeImport">
            <summary>
            True if the type is a Windows runtime type.
            </summary>
            <remarks>
            A type can me marked as a Windows runtime type in source by applying the WindowsRuntimeImportAttribute.
            WindowsRuntimeImportAttribute is a pseudo custom attribute defined as an internal class in System.Runtime.InteropServices.WindowsRuntime namespace.
            This is needed to mark Windows runtime types which are redefined in mscorlib.dll and System.Runtime.WindowsRuntime.dll.
            These two assemblies are special as they implement the CLR's support for WinRT.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.ShouldAddWinRTMembers">
            <summary>
            True if the type should have its WinRT interfaces projected onto .NET types and
            have missing .NET interface members added to the type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsConditional">
            <summary>
            Returns a flag indicating whether this symbol has at least one applied/inherited conditional attribute.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsSerializable">
            <summary>
            True if the type is serializable (has Serializable metadata flag).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.AreLocalsZeroed">
            <summary>
            Returns true if locals are to be initialized
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Layout">
            <summary>
            Type layout information (ClassLayout metadata and layout kind flags).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.DefaultMarshallingCharSet">
            <summary>
            The default charset used for type marshalling. 
            Can be changed via <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> applied on the containing module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.MarshallingCharSet">
            <summary>
            Marshalling charset of string data fields within the type (string formatting flags in metadata).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.HasDeclarativeSecurity">
            <summary>
            True if the type has declarative security information (HasSecurity flags).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetSecurityInformation">
            <summary>
            Declaration security information associated with this type, or null if there is none.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetAppliedConditionalSymbols">
            <summary>
            Returns a sequence of preprocessor symbols specified in <see cref="T:System.Diagnostics.ConditionalAttribute"/> applied on this symbol, or null if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.ComImportCoClass">
            <summary>
            If <see cref="T:System.Runtime.InteropServices.CoClassAttribute"/> was applied to the type and the attribute argument is a valid named type argument, i.e. accessible class type, then it returns the type symbol for the argument.
            Otherwise, returns null.
            </summary>
            <remarks>
            <para>
            This property invokes force completion of attributes. If you are accessing this property
            from the binder, make sure that we are not binding within an Attribute context.
            This could lead to a possible cycle in attribute binding.
            We can avoid this cycle by first checking if we are within the context of an Attribute argument,
            i.e. if(!binder.InAttributeArgument) { ...  namedType.ComImportCoClass ... }
            </para>
            <para>
            CONSIDER: We can remove the above restriction and possibility of cycle if we do an
            early binding of some well known attributes.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.FixedElementField">
            <summary>
            If class represents fixed buffer, this property returns the FixedElementField
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsInterface">
            <summary>
            Requires less computation than <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.TypeKind"/> == <see cref="F:Microsoft.CodeAnalysis.TypeKind.Interface"/>.
            </summary>
            <remarks>
            Metadata types need to compute their base types in order to know their TypeKinds, and that can lead
            to cycles if base types are already being computed.
            </remarks>
            <returns>True if this is an interface type.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsTupleTypeOfCardinality(System.Int32@)">
            <summary>
            Verify if the given type can be used to back a tuple type 
            and return cardinality of that tuple type in <paramref name="tupleCardinality"/>. 
            </summary>
            <param name="tupleCardinality">If method returns true, contains cardinality of the compatible tuple type.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.AsNativeInteger">
            <summary>
            Returns an instance of a symbol that represents a native integer
            if this underlying symbol represents System.IntPtr or System.UIntPtr.
            For platforms that support numeric IntPtr/UIntPtr, those types are returned as-is.
            For other symbols, throws <see cref="T:System.InvalidOperationException"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.NativeIntegerUnderlyingType">
            <summary>
            If this is a native integer, returns the symbol for the underlying type,
            either <see cref="T:System.IntPtr"/> or <see cref="T:System.UIntPtr"/>.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.CreateTuple(Microsoft.CodeAnalysis.Location,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.Boolean,System.Boolean,System.Collections.Immutable.ImmutableArray{System.Boolean},Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Helps create a tuple type from source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.WithElementTypes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations})">
            <summary>
            Copy this tuple, but modify it to use the new element types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.WithElementNames(System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableArray{System.Boolean},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})">
            <summary>
            Copy this tuple, but modify it to use the new element names.
            Also applies new location of the whole tuple as well as each element.
            Drops the inferred positions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetUnderlyingTypeChain(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol})">
             <summary>
             Decompose the underlying tuple type into its links and store them into the underlyingTupleTypeChain.
            
             For instance, ValueTuple&lt;..., ValueTuple&lt; int >> (the underlying type for an 8-tuple)
             will be decomposed into two links: the first one is the entire thing, and the second one is the ValueTuple&lt; int >
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.NumberOfValueTuples(System.Int32,System.Int32@)">
            <summary>
            Returns the number of nestings required to represent numElements as nested ValueTuples.
            For example, for 8 elements, you need 2 ValueTuples and the remainder (ie the size of the last nested ValueTuple) is 1.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.VerifyTupleTypePresent(System.Int32,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            For tuples with no natural type, we still need to verify that an underlying type of proper arity exists, and report if otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetTupleType(System.Int32)">
            <summary>
            Find the well-known ValueTuple type of a given arity.
            For example, for arity=2:
            returns WellKnownType.System_ValueTuple_T2
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetTupleCtor(System.Int32)">
             <summary>
             Find the constructor for a well-known ValueTuple type of a given arity.
            
             For example, for arity=2:
             returns WellKnownMember.System_ValueTuple_T2__ctor
            
             For arity=12:
             return System_ValueTuple_TRest__ctor
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetTupleTypeMember(System.Int32,System.Int32)">
            <summary>
            Find the well-known members to the ValueTuple type of a given arity and position.
            For example, for arity=3 and position=1:
            returns WellKnownMember.System_ValueTuple_T3__Item1
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TupleMemberName(System.Int32)">
            <summary>
            Returns "Item1" for position=1
            Returns "Item12" for position=12
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsTupleElementNameReserved(System.String)">
             <summary>
             Checks whether the field name is reserved and tells us which position it's reserved for.
            
             For example:
             Returns 3 for "Item3".
             Returns 0 for "Rest", "ToString" and other members of System.ValueTuple.
             Returns -1 for names that aren't reserved.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetWellKnownMemberInType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Lookup well-known member declaration in provided type and reports diagnostics.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TupleExtraData">
            <summary>
            The main purpose of this type is to store element names and also cache some information related to tuples.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TupleExtraData.ElementNames">
            <summary>
            Element names, if provided.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TupleExtraData.ElementLocations">
            <summary>
            Declaration locations for individual elements, if provided.
            Declaration location for this tuple type symbol
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TupleExtraData.ErrorPositions">
            <summary>
            Which element names were inferred and therefore cannot be used.
            If none of the element names were inferred, or inferred names can be used (no tracking necessary), leave as default.
            This information is ignored in type equality and comparison.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TupleExtraData._lazyElementTypes">
            <summary>
            Element types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TupleExtraData.TupleUnderlyingType">
            <summary>
            The same named type, but without element names.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol">
            <summary>
            Represents a namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.GetNamespaceMembers">
            <summary>
            Get all the members of this symbol that are namespaces.
            </summary>
            <returns>An IEnumerable containing all the namespaces that are members of this symbol.
            If this symbol has no namespace members, returns an empty IEnumerable. Never returns
            null.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.IsGlobalNamespace">
            <summary>
            Returns whether this namespace is the unnamed, global namespace that is 
            at the root of all namespaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.NamespaceKind">
            <summary>
            The kind of namespace: Module, Assembly or Compilation.
            Module namespaces contain only members from the containing module that share the same namespace name.
            Assembly namespaces contain members for all modules in the containing assembly that share the same namespace name.
            Compilation namespaces contain all members, from source or referenced metadata (assemblies and modules) that share the same namespace name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.ContainingCompilation">
            <summary>
            The containing compilation for compilation namespaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.ConstituentNamespaces">
            <summary>
            If a namespace has Assembly or Compilation extent, it may be composed of multiple
            namespaces that are merged together. If so, ConstituentNamespaces returns
            all the namespaces that were merged. If this namespace was not merged, returns
            an array containing only this namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.ContainingAssembly">
            <summary>
            Containing assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.ImplicitType">
            <summary>
            Returns an implicit type symbol for this namespace or null if there is none. This type
            wraps misplaced global code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.LookupNestedNamespace(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Lookup a nested namespace.
            </summary>
            <param name="names">
            Sequence of names for nested child namespaces.
            </param>
            <returns>
            Symbol for the most nested namespace, if found. Nothing 
            if namespace or any part of it can not be found.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.GetExtensionMethods(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol},System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <summary>
            Add all extension methods in this namespace to the given list. If name or arity
            or both are provided, only those extension methods that match are included.
            </summary>
            <param name="methods">Methods list</param>
            <param name="nameOpt">Optional method name</param>
            <param name="arity">Method arity</param>
            <param name="options">Lookup options</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol">
            <summary>
            Represents a parameter of a method or indexer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.Microsoft#Cci#IParameterDefinition#GetDefaultValue(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Gets constant value to be stored in metadata Constant table.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.TypeWithAnnotations">
            <summary>
            Gets the type of the parameter along with its annotations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.Type">
            <summary>
            Gets the type of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.RefKind">
            <summary>
            Determines if the parameter ref, out or neither.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsDiscard">
            <summary>
            Returns true if the parameter is a discard parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.RefCustomModifiers">
            <summary>
            Custom modifiers associated with the ref modifier, or an empty array if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.MarshallingInformation">
            <summary>
            Describes how the parameter is marshalled when passed to native code.
            Null if no specific marshalling information is available for the parameter.
            </summary>
            <remarks>PE symbols don't provide this information and always return null.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.MarshallingType">
            <summary>
            Returns the marshalling type of this parameter, or 0 if marshalling information isn't available.
            </summary>
            <remarks>
            By default this information is extracted from <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.MarshallingInformation"/> if available. 
            Since the compiler does only need to know the marshalling type of symbols that aren't emitted 
            PE symbols just decode the type from metadata and don't provide full marshalling information.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.Ordinal">
            <summary>
            Gets the ordinal position of the parameter. The first parameter has ordinal zero.
            The "'this' parameter has ordinal -1.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsParams">
            <summary>
            Returns true if the parameter was declared as a parameter array.
            Note: it is possible for any parameter to have the [ParamArray] attribute (for instance, in IL),
                even if it is not the last parameter. So check for that.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsOptional">
            <summary>
            Returns true if the parameter is semantically optional.
            </summary>
            <remarks>
            True if and only if the parameter has a default argument syntax, 
            or the parameter is not a params-array and Optional metadata flag is set.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsMetadataOptional">
            <summary>
            True if Optional flag is set in metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsMetadataIn">
            <summary>
            True if In flag is set in metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsMetadataOut">
            <summary>
            True if Out flag is set in metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.HasExplicitDefaultValue">
            <summary>
            Returns true if the parameter explicitly specifies a default value to be passed
            when no value is provided as an argument to a call. 
            </summary>
            <remarks>
            True if the parameter has a default argument syntax, 
            or the parameter is from source and <see cref="T:System.Runtime.InteropServices.DefaultParameterValueAttribute"/> is applied, 
            or the parameter is from metadata and HasDefault metadata flag is set. See
            <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsOptional"/> to determine if the parameter will be considered optional by
            overload resolution.
            
            The default value can be obtained with <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.ExplicitDefaultValue"/> property.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.ExplicitDefaultValue">
            <summary>
            Returns the default value of the parameter. If <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.HasExplicitDefaultValue"/>
            returns false then DefaultValue throws an InvalidOperationException.
            </summary>
            <remarks>
            If the parameter type is a struct and the default value of the parameter
            is the default value of the struct type or of type parameter type which is 
            not known to be a referenced type, then this property will return null.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The parameter has no default value.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.ExplicitDefaultConstantValue">
            <summary>
            Returns the default value constant of the parameter, 
            or null if the parameter doesn't have a default value or 
            the parameter type is a struct and the default value of the parameter
            is the default value of the struct type or of type parameter type which is 
            not known to be a referenced type.
            </summary>
            <remarks>
            This is used for emitting.  It does not reflect the language semantics
            (i.e. even non-optional parameters can have default values).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the "virtual" modifier. Does not return true for
            members declared as abstract or override.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the "override" modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            "extern" modifier. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsThis">
            <summary>
            Returns true if the parameter is the hidden 'this' parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.InterpolatedStringHandlerArgumentIndexes">
            <summary>
            Indexes of the parameters that will be passed to the constructor of the interpolated string handler type
            when an interpolated string handler conversion occurs. These indexes are ordered in the order to be passed
            to the constructor.
            <para/>
            Indexes greater than or equal to 0 are references to parameters defined on the containing method or indexer.
            Indexes less than 0 are constants defined on <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundInterpolatedStringArgumentPlaceholder"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.HasInterpolatedStringHandlerArgumentError">
            <summary>
            True if the parameter is attributed with <c>InterpolatedStringHandlerArgumentAttribute</c> and the attribute
            has some error (such as invalid names).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.EffectiveScope">
            <summary>
            The effective scope. This is from the declared scope, implicit scope and any
            <c>UnscopedRefAttribute</c>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol">
            <summary>
            Represents a pointer type such as "int *". Pointer types
            are used only in unsafe code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations)">
            <summary>
            Create a new PointerTypeSymbol.
            </summary>
            <param name="pointedAtType">The type being pointed at.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol.PointedAtTypeWithAnnotations">
            <summary>
            Gets the type of the storage location that an instance of the pointer type points to, along with its annotations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol.PointedAtType">
            <summary>
            Gets the type of the storage location that an instance of the pointer type points to.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol._lazyParameterSignature">
            <summary>
            As a performance optimization, cache parameter types and refkinds - overload resolution uses them a lot.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.NotNullMembers">
            <summary>
            If a property is annotated with `[MemberNotNull(...)]` attributes, returns the list of members
            listed in those attributes.
            Otherwise, an empty array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.ReturnsByRef">
            <summary>
            Indicates whether or not the property returns by reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.ReturnsByRefReadonly">
            <summary>
            Indicates whether or not the property returns a readonly reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.RefKind">
            <summary>
            Gets the ref kind of the property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.TypeWithAnnotations">
            <summary>
            The type of the property along with its annotations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.Type">
            <summary>
            The type of the property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.RefCustomModifiers">
            <summary>
            Custom modifiers associated with the ref modifier, or an empty array if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.Parameters">
            <summary>
            The parameters of this property. If this property has no parameters, returns
            an empty list. Parameters are only present on indexers, or on some properties
            imported from a COM interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.ParameterCount">
            <summary>
            Optimization: in many cases, the parameter count (fast) is sufficient and we
            don't need the actual parameter symbols (slow).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.RequiresInstanceReceiver">
            <summary>
            Returns true if this symbol requires an instance reference as the implicit receiver. This is false if the symbol is static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsIndexer">
            <summary>
            Returns whether the property is really an indexer.
            </summary>
            <remarks>
            In source, we regard a property as an indexer if it is declared with an IndexerDeclarationSyntax.
            From metadata, we regard a property if it has parameters and is a default member of the containing
            type.
            CAVEAT: To ensure that this property (and indexer Names) roundtrip, source properties are not
            indexers if they are explicit interface implementations (since they will not be marked as default
            members in metadata).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsIndexedProperty">
            <summary>
            True if this an indexed property; that is, a property with parameters
            within a [ComImport] type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsReadOnly">
            <summary>
            True if this is a read-only property; that is, a property with no set accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsWriteOnly">
            <summary>
            True if this is a write-only property; that is, a property with no get accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsRequired">
            <summary>
            Returns true if this property is required to be set in an object initializer on object creation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsDirectlyExcludedFromCodeCoverage">
            <summary>
            True if the property itself is excluded from code coverage instrumentation.
            True for source properties marked with <see cref="F:Microsoft.CodeAnalysis.AttributeDescription.ExcludeFromCodeCoverageAttribute"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.GetMethod">
            <summary>
            The 'get' accessor of the property, or null if the property is write-only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.SetMethod">
            <summary>
            The 'set' accessor of the property, or null if the property is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.OverriddenProperty">
            <summary>
            Returns the overridden property, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsExplicitInterfaceImplementation">
            <summary>
            Source: Was the member name qualified with a type name?
            Metadata: Is the member an explicit implementation?
            </summary>
            <remarks>
            Will not always agree with ExplicitInterfaceImplementations.Any()
            (e.g. if binding of the type part of the name fails).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface properties explicitly implemented by this property.
            </summary>
            <remarks>
            Properties imported from metadata can explicitly implement more than one property.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsHighestPriorityUseSiteErrorCode(System.Int32)">
            <summary>
            Returns true if the error code is highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol">
            <summary>
            Represents an assembly built by compiler.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._compilation">
            <summary>
            A Compilation the assembly is created for.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.lazyAssemblyIdentity">
            <summary>
            Assembly's identity.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._modules">
            <summary>
            A list of modules the assembly consists of. 
            The first (index=0) module is a SourceModuleSymbol, which is a primary module, the rest are net-modules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._lazySourceAttributesBag">
            <summary>
            Bag of assembly's custom attributes and decoded well-known attribute data from source.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._lazyNetModuleAttributesBag">
            <summary>
            Bag of assembly's custom attributes and decoded well-known attribute data from added netmodules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._lazyOmittedAttributeIndices">
            <summary>
            Indices of attributes that will not be emitted for one of two reasons:
            - They are duplicates of another attribute (i.e. attributes that bind to the same constructor and have identical arguments)
            - They are InternalsVisibleToAttributes with invalid assembly identities
            </summary>
            <remarks>
            These indices correspond to the merged assembly attributes from source and added net modules, i.e. attributes returned by <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetAttributes"/> method.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._unassignedFieldsMap">
            <summary>
            Map for storing effectively private or effectively internal fields declared in this assembly but never initialized nor assigned.
            Each {symbol, bool} key-value pair in this map indicates the following:
             (a) Key: Unassigned field symbol.
             (b) Value: True if the unassigned field is effectively internal, false otherwise.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._unreadFields">
            <summary>
            private fields declared in this assembly but never read
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.TypesReferencedInExternalMethods">
            <summary>
            We imitate the native compiler's policy of not warning about unused fields
            when the enclosing type is used by an extern method for a ref argument.
            Here we keep track of those types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._unusedFieldWarnings">
            <summary>
            The warnings for unused fields.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.DeclaringCompilation">
            <remarks>
            This override is essential - it's a base case of the recursive definition.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.AssemblyFlags">
            <summary>
            This represents what the user claimed in source through the AssemblyFlagsAttribute.
            It may be modified as emitted due to presence or absence of the public key.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.ReportDiagnosticsForSynthesizedAttributes(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            We're going to synthesize some well-known attributes for this assembly symbol.  However, at synthesis time, it is
            too late to report diagnostics or cancel the emit.  Instead, we check for use site errors on the types and members
            we know we'll need at synthesis time.
            </summary>
            <remarks>
            As in Dev10, we won't report anything if the attribute TYPES are missing (note: missing, not erroneous) because we won't
            synthesize anything in that case.  We'll only report diagnostics if the attribute TYPES are present and either they or 
            the attribute CONSTRUCTORS have errors.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.ReportDiagnosticsForUnsafeSynthesizedAttributes(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            If this compilation allows unsafe code (note: allows, not contains), then when we actually emit the assembly/module, 
            we're going to synthesize SecurityPermissionAttribute/UnverifiableCodeAttribute.  However, at synthesis time, it is
            too late to report diagnostics or cancel the emit.  Instead, we check for use site errors on the types and members
            we know we'll need at synthesis time.
            </summary>
            <remarks>
            As in Dev10, we won't report anything if the attribute TYPES are missing (note: missing, not erroneous) because we won't
            synthesize anything in that case.  We'll only report diagnostics if the attribute TYPES are present and either they or 
            the attribute CONSTRUCTORS have errors.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.InternalsAreVisible">
            <summary>
            True if internals are exposed at all.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            This property shouldn't be accessed during binding as it can lead to attribute binding cycle.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetUniqueSourceAssemblyAttributes">
            <summary>
            Gets unique source assembly attributes that should be emitted,
            i.e. filters out attributes with errors and duplicate attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetSourceAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetSourceAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.IsIndexOfOmittedAssemblyAttribute(System.Int32)">
            <summary>
            Returns true if the assembly attribute at the given index is a duplicate assembly attribute that must not be emitted.
            Duplicate assembly attributes are attributes that bind to the same constructor and have identical arguments.
            </summary>
            <remarks>
            This method must be invoked only after all the assembly attributes have been bound.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetSourceDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from source assembly attributes or null if there are none.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            TODO: We should replace methods GetSourceDecodedWellKnownAttributeData and GetNetModuleDecodedWellKnownAttributeData with
            a single method GetDecodedWellKnownAttributeData, which merges DecodedWellKnownAttributeData from source and netmodule attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetSourceDecodedWellKnownAttributeData(Microsoft.CodeAnalysis.CSharp.Symbols.QuickAttributes)">
            <remarks>
            This implements the same logic as <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetSourceDecodedWellKnownAttributeData"/>
            but loading a smaller set of attributes if possible, to reduce circularity.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetForwardedTypes">
            <summary>
            This only forces binding of attributes that look like they may be forwarded types attributes (syntactically).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.ContainsExtensionMethods">
            <summary>
            Returns true if and only if at least one type within the assembly contains
            extension methods. Note, this method is expensive since it potentially
            inspects all types within the assembly. The expectation is that this method is
            only called at emit time, when all types have been or will be traversed anyway.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetUnusedFieldWarnings(System.Threading.CancellationToken)">
            <summary>
            Get the warnings for unused fields.  This should only be fetched when all method bodies have been compiled.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol">
            <summary>
            Represents a type parameter in a generic type or generic method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.ReducedFrom">
            <summary>
            If this is a type parameter of a reduced extension method, gets the type parameter definition that
            this type parameter was reduced from. Otherwise, returns Nothing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.Ordinal">
            <summary>
            The ordinal position of the type parameter in the parameter list which declares
            it. The first type parameter has ordinal zero.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.ConstraintTypesNoUseSiteDiagnostics">
            <summary>
            The types that were directly specified as constraints on the type parameter.
            Duplicates and cycles are removed, although the collection may include
            redundant constraints where one constraint is a base type of another.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.HasConstructorConstraint">
            <summary>
            True if the parameterless constructor constraint was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.TypeParameterKind">
            <summary>
            The type parameter kind of this type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.DeclaringMethod">
            <summary>
            The method that declared this type parameter, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.DeclaringType">
            <summary>
            The type that declared this type parameter, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.EffectiveBaseClassNoUseSiteDiagnostics">
            <summary>
            The effective base class of the type parameter (spec 10.1.5). If the deduced
            base type is a reference type, the effective base type will be the same as
            the deduced base type. Otherwise if the deduced base type is a value type,
            the effective base type will be the most derived reference type from which
            deduced base type is derived.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.EffectiveInterfacesNoUseSiteDiagnostics">
            <summary>
            The effective interface set (spec 10.1.5).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.DeducedBaseTypeNoUseSiteDiagnostics">
            <summary>
            The most encompassed type (spec 6.4.2) from the constraints.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.AllEffectiveInterfacesNoUseSiteDiagnostics">
            <summary>
            The effective interface set and any base interfaces of those
            interfaces. This is AllInterfaces excluding interfaces that are
            only implemented by the effective base type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.EnsureAllConstraintsAreResolved">
            <summary>
            Called by <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.ConstraintTypesNoUseSiteDiagnostics"/>, <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.InterfacesNoUseSiteDiagnostics(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})"/>, <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.EffectiveBaseClass(Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)"/>, and <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.DeducedBaseType(Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)"/>.
            to allow derived classes to ensure constraints within the containing
            type or method are resolved in a consistent order, regardless of the
            order the callers query individual type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.EnsureAllConstraintsAreResolved(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol})">
            <summary>
            Helper method to force type parameter constraints to be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.ReferenceTypeConstraintIsNullable">
            <summary>
            Returns whether the reference type constraint (the 'class' constraint) should also be treated as nullable ('class?') or non-nullable (class!).
            In some cases this aspect is unknown (null value is returned). For example, when 'class' constraint is specified in a NonNullTypes(false) context.  
            This API returns false when <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.HasReferenceTypeConstraint"/> is false.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.DelegateCacheContainer">
            <summary>
            This type is synthesized to hold the cached delegates that target static method groups.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.DelegateCacheContainer.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Int32)">
            <summary>Creates a type-scope concrete delegate cache container.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.DelegateCacheContainer.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,System.Int32,System.Int32)">
            <summary>Creates a method-scope generic delegate cache container.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStateMachineProperty">
            <summary>
            State machine interface property implementation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedMethodBaseSymbol">
            <summary>
            A base method symbol used as a base class for lambda method symbol and base method wrapper symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedMethodBaseSymbol.InheritsBaseMethodAttributes">
            <summary>
            Indicates that this method inherits attributes from the base method, its parameters, return type, and type parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap">
            <summary>
            Abstract base class for mutable and immutable type maps.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteTypeDeclaration(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Substitute for a type declaration.  May use alpha renaming if the container is substituted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            SubstType, but for NamedTypeSymbols only.  This is used for concrete types, so no alpha substitution appears in the result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Perform the substitution on the given type.  Each occurrence of the type parameter is
            replaced with its corresponding type argument from the map.
            </summary>
            <param name="previous">The type to be rewritten.</param>
            <returns>The type with type parameters replaced with the type arguments.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteConstraintTypesDistinctWithoutModifiers(Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol})">
            <summary>
            Substitute types, and return the results without duplicates, preserving the original order.
            Note, all occurrences of 'dynamic' in resulting types will be replaced with 'object'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteNamedTypes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol})">
            <summary>
            Like SubstTypes, but for NamedTypeSymbols.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol">
            <summary>
            Symbol representing a using alias appearing in a compilation unit or within a namespace
            declaration. Generally speaking, these symbols do not appear in the set of symbols reachable
            from the unnamed namespace declaration.  In other words, when a using alias is used in a
            program, it acts as a transparent alias, and the symbol to which it is an alias is used in
            the symbol table.  For example, in the source code
            <pre>
            namespace NS
            {
                using o = System.Object;
                partial class C : o {}
                partial class C : object {}
                partial class C : System.Object {}
            }
            </pre>
            all three declarations for class C are equivalent and result in the same symbol table object
            for C. However, these using alias symbols do appear in the results of certain SemanticModel
            APIs. Specifically, for the base clause of the first of C's class declarations, the
            following APIs may produce a result that contains an AliasSymbol:
            <pre>
                SemanticInfo SemanticModel.GetSemanticInfo(ExpressionSyntax expression);
                SemanticInfo SemanticModel.BindExpression(CSharpSyntaxNode location, ExpressionSyntax expression);
                SemanticInfo SemanticModel.BindType(CSharpSyntaxNode location, ExpressionSyntax type);
                SemanticInfo SemanticModel.BindNamespaceOrType(CSharpSyntaxNode location, ExpressionSyntax type);
            </pre>
            Also, the following are affected if container==null (and, for the latter, when arity==null
            or arity==0):
            <pre>
                IList&lt;string&gt; SemanticModel.LookupNames(CSharpSyntaxNode location, NamespaceOrTypeSymbol container = null, LookupOptions options = LookupOptions.Default, List&lt;string> result = null);
                IList&lt;Symbol&gt; SemanticModel.LookupSymbols(CSharpSyntaxNode location, NamespaceOrTypeSymbol container = null, string name = null, int? arity = null, LookupOptions options = LookupOptions.Default, List&lt;Symbol> results = null);
            </pre>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol.Target">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol"/> for the
            namespace or type referenced by the alias.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol.ContainingSymbol">
            <summary>
            Using aliases in C# are always contained within a namespace declaration, or at the top
            level within a compilation unit, within the implicit unnamed namespace declaration.  We
            return that as the "containing" symbol, even though the alias isn't a member of the
            namespace as such.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbolFromSyntax.Target">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol"/> for the
            namespace or type referenced by the alias.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbolFromResolvedTarget.Target">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol"/> for the
            namespace or type referenced by the alias.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor">
            <summary>
            Describes anonymous type in terms of fields
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.Location">
            <summary> Anonymous type location </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.Fields">
            <summary> Anonymous type fields </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.Key">
            <summary>
            Anonymous type descriptor Key 
            
            The key is to be used to separate anonymous type templates in an anonymous type symbol cache. 
            The type descriptors with the same keys are supposed to map to 'the same' anonymous type 
            template in terms of the same generic type being used for their implementation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.Equals(Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor,Microsoft.CodeAnalysis.TypeCompareKind)">
            <summary>
            Compares two anonymous type descriptors, takes into account fields names and types, not locations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.Equals(System.Object)">
            <summary>
            Compares two anonymous type descriptors, takes into account fields names and types, not locations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.WithNewFieldsTypes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations})">
            <summary>
            Creates a new anonymous type descriptor based on 'this' one, 
            but having field types passed as an argument.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeField">
            <summary>
            Describes anonymous type field in terms of its name, type and other attributes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeField.Name">
            <summary>Anonymous type field name, not nothing and not empty</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeField.Location">
            <summary>Anonymous type field location</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeField.TypeWithAnnotations">
            <summary>Anonymous type field type with annotations</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeField.Type">
            <summary>Anonymous type field type</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol">
            <summary>
            Represents a .NET assembly, consisting of one or more modules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol._corLibrary">
            <summary>
            The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. 
            The value is provided by ReferenceManager and must not be modified. For SourceAssemblySymbol, non-missing 
            coreLibrary must match one of the referenced assemblies returned by GetReferencedAssemblySymbols() method of 
            the main module. If there is no existing assembly that can be used as a source for the primitive types, 
            the value is a Compilation.MissingCorLibrary. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.CorLibrary">
            <summary>
            The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. 
            The value is MissingAssemblySymbol if none of the referenced assemblies can be used as a source for the 
            primitive types and the owning assembly cannot be used as the source too. Otherwise, it is one of 
            the referenced assemblies returned by GetReferencedAssemblySymbols() method or the owning assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.SetCorLibrary(Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <summary>
            A helper method for ReferenceManager to set the system assembly, which provides primitive 
            types like Object, String, etc., e.g. mscorlib.dll. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Name">
            <summary>
            Simple name the assembly.
            </summary>
            <remarks>
            This is equivalent to <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Identity"/>.<see cref="P:Microsoft.CodeAnalysis.AssemblyIdentity.Name"/>, but may be 
            much faster to retrieve for source code assemblies, since it does not require binding
            the assembly-level attributes that contain the version number and other assembly
            information.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Identity">
            <summary>
            Gets the identity of this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.AssemblyVersionPattern">
            <summary>
            Assembly version pattern with wildcards represented by <see cref="F:System.UInt16.MaxValue"/>,
            or null if the version string specified in the <see cref="T:System.Reflection.AssemblyVersionAttribute"/> doesn't contain a wildcard.
            
            For example, 
              AssemblyVersion("1.2.*") is represented as 1.2.65535.65535,
              AssemblyVersion("1.2.3.*") is represented as 1.2.3.65535.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Machine">
            <summary>
            Target architecture of the machine.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Bit32Required">
            <summary>
            Indicates that this PE file makes Win32 calls. See CorPEKind.pe32BitRequired for more information (http://msdn.microsoft.com/en-us/library/ms230275.aspx).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GlobalNamespace">
            <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetAssemblyNamespace(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol)">
            <summary>
            Given a namespace symbol, returns the corresponding assembly specific namespace symbol
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Modules">
            <summary>
            Gets a read-only list of all the modules in this assembly. (There must be at least one.) The first one is the main module
            that holds the assembly manifest.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.IsMissing">
            <summary>
            Does this symbol represent a missing assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.IsInteractive">
            <summary>
            True if the assembly contains interactive code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name with generic name mangling.
            </param>
            <param name="digThroughForwardedTypes">
            Take forwarded types into account.
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.LookupTopLevelMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol},System.Boolean)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.  Detect cycles during lookup.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <param name="visitedAssemblies">
            List of assemblies lookup has already visited (since type forwarding can introduce cycles).
            </param>
            <param name="digThroughForwardedTypes">
            Take forwarded types into account.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.ResolveForwardedType(System.String)">
            <summary>
            Returns the type symbol for a forwarded type based its canonical CLR metadata name.
            The name should refer to a non-nested type. If type with this name is not forwarded,
            null is returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.TryLookupForwardedMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Look up the given metadata type, if it is forwarded.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.TryLookupForwardedMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol})">
            <summary>
            Look up the given metadata type, if it is forwarded.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly.
            </summary>
            <returns>The symbol for the pre-defined type or an error type if the type is not defined in the core library.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.RegisterDeclaredSpecialType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Register declaration of predefined CorLib type in this Assembly.
            </summary>
            <param name="corType"></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.KeepLookingForDeclaredSpecialTypes">
            <summary>
            Continue looking for declaration of predefined CorLib type in this Assembly
            while symbols for new type declarations are constructed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetNativeIntegerType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Return the native integer type corresponding to the underlying type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.RuntimeSupportsDefaultInterfaceImplementation">
            <summary>
            Figure out if the target runtime supports default interface implementation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.RuntimeSupportsStaticAbstractMembersInInterfaces">
            <summary>
            Figure out if the target runtime supports static abstract members in interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.RuntimeSupportsNumericIntPtr">
            <summary>
            Whether the target runtime supports numeric IntPtr types.
            This test hook should be removed once TargetFramework.Net70 is added.
            Tracked by https://github.com/dotnet/roslyn/issues/61235
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.RuntimeSupportsCovariantReturnsOfClasses">
            <summary>
            True if the target runtime support covariant returns of methods declared in classes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetNoPiaResolutionAssemblies">
            <summary>
            Return an array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by previous compilation referencing this assembly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetLinkedReferencedAssemblies">
            <summary>
            Return an array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.IsLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetGuidString(System.String@)">
            <summary>
            Returns true and a string from the first GuidAttribute on the assembly, 
            the string might be null or an invalid guid representation. False, 
            if there is no GuidAttribute with string argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.TypeNames">
            <summary>
            Gets the set of type identifiers from this assembly.
            </summary>
            <remarks>
            These names are the simple identifiers for the type, and do not include namespaces,
            outer type names, or type parameters.
            
            This functionality can be used for features that want to quickly know if a name could be
            a type for performance reasons.  For example, classification does not want to incur an
            expensive binding call cost if it knows that there is no type with the name that they
            are looking at.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.NamespaceNames">
            <summary>
            Gets the set of namespace names from this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.MightContainExtensionMethods">
            <summary>
            Returns true if this assembly might contain extension methods. If this property
            returns false, there are no extension methods in this assembly.
            </summary>
            <remarks>
            This property allows the search for extension methods to be narrowed quickly.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Gets the symbol for the pre-defined type from core library associated with this assembly.
            </summary>
            <returns>The symbol for the pre-defined type or an error type if the type is not defined in the core library.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.ObjectType">
            <summary>
            The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
            Error if there was no COR Library in a compilation using the assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetPrimitiveType(Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Get symbol for predefined type from Cor Library used by this assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetTypeByMetadataName(System.String)">
            <summary>
            Lookup a type within the assembly using the canonical CLR metadata name of the type.
            </summary>
            <param name="fullyQualifiedMetadataName">Type name.</param>
            <returns>Symbol for the type or null if type cannot be found or is ambiguous. </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetTypeByMetadataName(System.String,System.Boolean,System.Boolean,System.ValueTuple{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
            <summary>
            Lookup a type within the assembly using its canonical CLR metadata name.
            </summary>
            <param name="metadataName"></param>
            <param name="includeReferences">
            If search within assembly fails, lookup in assemblies referenced by the primary module.
            For source assembly, this is equivalent to all assembly references given to compilation.
            </param>
            <param name="isWellKnownType">
            Extra restrictions apply when searching for a well-known type.  In particular, the type must be public.
            </param>
            <param name="useCLSCompliantNameArityEncoding">
            While resolving the name, consider only types following CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
            I.e. arity is inferred from the name and matching type must have the same emitted name and arity.
            </param>
            <param name="warnings">
            A diagnostic bag to receive warnings if we should allow multiple definitions and pick one.
            </param>
            <param name="ignoreCorLibraryDuplicatedTypes">
            In case duplicate types are found, ignore the one from corlib. This is useful for any kind of compilation at runtime
            (EE/scripting/Powershell) using a type that is being migrated to corlib.
            </param>
            <param name="conflicts">
            In cases a type could not be found because of ambiguity, we return two of the candidates that caused the ambiguity.
            </param>
            <returns>Null if the type can't be found.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetTypeByReflectionType(System.Type,System.Boolean)">
            <summary>
            Resolves <see cref="T:System.Type"/> to a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol"/> available in this assembly
            its referenced assemblies.
            </summary>
            <param name="type">The type to resolve.</param>
            <param name="includeReferences">Use referenced assemblies for resolution.</param>
            <returns>The resolved symbol if successful or null on failure.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetDeclaredSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
            assembly is the Cor Library
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type used by this Assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetMetadata">
            <summary>
            If this symbol represents a metadata assembly returns the underlying <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata"/>.
            
            Otherwise, this returns <see langword="null"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAttributeData">
            <summary>
            Represents a PE custom attribute
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAttributeData.IsTargetAttribute(System.String,System.String)">
            <summary>
            Matches an attribute by metadata namespace, metadata type name. Does not load the type symbol for
            the attribute.
            </summary>
            <param name="namespaceName"></param>
            <param name="typeName"></param>
            <returns>True if the attribute data matches.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAttributeData.GetTargetAttributeSignatureIndex(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Matches an attribute by metadata namespace, metadata type name and metadata signature. Does not load the
            type symbol for the attribute.
            </summary>
            <param name="targetSymbol">Target symbol.</param>
            <param name="description">Attribute to match.</param>
            <returns>
            An index of the target constructor signature in
            signatures array, -1 if
            this is not the target attribute.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder">
            <summary>
            Decodes System.Runtime.CompilerServices.DynamicAttribute applied to a specified metadata symbol and
            transforms the specified metadata type, using the decoded dynamic transforms attribute argument,
            by replacing each occurrence of <see cref="T:System.Object"/> type with dynamic type.
            </summary>
            <remarks>
            This is a port of TypeManager::ImportDynamicTransformType from the native compiler.
            Comments from the C# design document for Dynamic:
            SPEC:   To represent the dynamic type in metadata, any indexer, field or return value typed as dynamic or known to be a constructed type
            SPEC:   containing dynamic will have each occurrence of dynamic erased to object and will be annotated with a [DynamicAttribute].
            SPEC:   If the relevant type is a constructed type, the attribute's constructor is passed a bool array.
            SPEC:   This array represents a preorder traversal of each "node" in the constructed type's "tree of types",
            SPEC:   with true set for each "node" that is dynamic, and false set for all other types.
            SPEC:   When dynamic occurs as part of the base type of a type, the applicable [DynamicAttribute] is applied to the type itself.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder._index">
            <remarks>
            Should be accessed through <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.HasFlag"/>, <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.PeekFlag"/>, and <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.ConsumeFlag"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.TransformType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Int32,System.Reflection.Metadata.EntityHandle,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol,Microsoft.CodeAnalysis.RefKind)">
            <summary>
            Decodes the attributes applied to the given <see paramref="targetSymbol"/> from metadata and checks if System.Runtime.CompilerServices.DynamicAttribute is applied.
            If so, it transforms the given <see paramref="metadataType"/>, using the decoded dynamic transforms attribute argument,
            by replacing each occurrence of <see cref="T:System.Object"/> type with dynamic type.
            If no System.Runtime.CompilerServices.DynamicAttribute is applied or the decoded dynamic transforms attribute argument is erroneous,
            returns the unchanged <see paramref="metadataType"/>.
            </summary>
            <remarks>This method is a port of TypeManager::ImportDynamicTransformType from the native compiler.</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder">
            <summary>
            This subclass of MetadataDecoder is specifically for finding
            method symbols corresponding to method MemberRefs.  The parent 
            implementation is unsuitable because it requires a PEMethodSymbol
            for context when decoding method type parameters and no such
            context is available because it is precisely what we are trying
            to find.  Since we know in advance that there will be no context
            and that signatures decoded with this class will only be used
            for comparison (when searching through the methods of a known
            TypeSymbol), we can return indexed type parameters instead.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder._containingType">
            <summary>
            Type context for resolving generic type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder.GetGenericMethodTypeParamSymbol(System.Int32)">
            <summary>
            We know that we'll never have a method context because that's what we're
            trying to find.  Instead, just return an indexed type parameter that will
            make comparison easier.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder.GetGenericTypeParamSymbol(System.Int32)">
            <summary>
            This override can handle non-PE types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder.FindMember(System.Reflection.Metadata.EntityHandle,System.Boolean)">
            <summary>
            Search through the members of the <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder._containingType"/> type symbol to find the method that matches a particular
            signature.
            </summary>
            <param name="memberRefOrMethodDef">A MemberRef or a MethodDef handle that can be used to obtain the name and signature of the method</param>
            <param name="methodsOnly">True to only return a method.</param>
            <returns>The matching method symbol, or null if the inputs do not correspond to a valid method.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder">
            <summary>
            Helper class to resolve metadata tokens and signatures.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder._typeContextOpt">
            <summary>
            Type context for resolving generic type arguments.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder._methodContextOpt">
            <summary>
            Method context for resolving generic method type arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.Int32,Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a type defined in referenced assembly.
            </summary>
            <param name="referencedAssemblyIndex"></param>
            <param name="emittedName"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.String,Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean@)">
            <summary>
            Lookup a type defined in a module of a multi-module assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean@)">
            <summary>
            Lookup a type defined in this module.
            This method will be called only if the type we are
            looking for hasn't been loaded yet. Otherwise, MetadataDecoder
            would have found the type in TypeDefRowIdToTypeMap based on its 
            TypeDef row id. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder.IsOrClosedOverATypeFromAssemblies(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol})">
            <summary>
            Perform a check whether the type or at least one of its generic arguments 
            is defined in the specified assemblies. The check is performed recursively. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder.SubstituteNoPiaLocalType(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.String,System.String,System.String,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <summary>
            Find canonical type for NoPia embedded type.
            </summary>
            <returns>
            Symbol for the canonical type or an ErrorTypeSymbol. Never returns null.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.NullableTypeDecoder.TransformType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,System.Reflection.Metadata.EntityHandle,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            If the type reference has an associated NullableAttribute, this method
            returns the type transformed to have IsNullable set to true or false
            (but not null) for each reference type in the type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol">
            <summary>
            Represents an assembly imported from a PE.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._assembly">
            <summary>
            An Assembly object providing metadata for the assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._documentationProvider">
            <summary>
            A DocumentationProvider that provides XML documentation comments for this assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._modules">
            <summary>
            The list of contained PEModuleSymbol objects.
            The list doesn't use type ReadOnlyCollection(Of PEModuleSymbol) so that we
            can return it from Modules property as is.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._noPiaResolutionAssemblies">
            <summary>
            An array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by a compilation referencing this assembly.
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._linkedReferencedAssemblies">
            <summary>
            An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._isLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._lazyCustomAttributes">
            <summary>
            Assembly's custom attributes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol.LookupAssembliesForForwardedMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Look up the assemblies to which the given metadata type is forwarded.
            </summary>
            <param name="emittedName"></param>
            <returns>
            The assemblies to which the given type is forwarded.
            </returns>
            <remarks>
            The returned assemblies may also forward the type.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEEventSymbol">
            <summary>
            The class to represent all events imported from a PE/module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEEventSymbol.GetAssociatedField(Roslyn.Utilities.MultiDictionary{System.String,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEFieldSymbol},System.Boolean)">
            <summary>
            Look for a field with the same name and an appropriate type (i.e. the same type, except in WinRT).
            If one is found, the caller will assume that this event was originally field-like and associate
            the two symbols.
            </summary>
            <remarks>
            Perf impact: If we find a field with the same name, we will eagerly evaluate its type.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEEventSymbol.ExplicitInterfaceImplementations">
            <summary>
            Intended behavior: this event, E, explicitly implements an interface event, IE, 
            if E.add explicitly implements IE.add and E.remove explicitly implements IE.remove.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEFieldSymbol">
            <summary>
            The class to represent all fields imported from a PE/module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEFieldSymbol.SetAssociatedEvent(Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEEventSymbol)">
            <summary>
            Mark this field as the backing field of a field-like event.
            The caller will also ensure that it is excluded from the member list of
            the containing type (as it would be in source).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEGlobalNamespaceSymbol._moduleSymbol">
            <summary>
            The module containing the namespace.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol">
            <summary>
            The class to represent all methods imported from a PE/module.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol.SignatureData">
            <summary>
            internal for testing purpose
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol.UncommonFields">
            <summary>
            Holds infrequently accessed fields. See <seealso cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields"/> for an explanation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields">
            <summary>
            A single field to hold optional auxiliary data.
            In many scenarios it is possible to avoid allocating this, thus saving total space in <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol"/>.
            Even for lazily-computed values, it may be possible to avoid allocating <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields"/> if
            the computed value is a well-known "empty" value. In this case, bits in <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol._packedFlags"/> are used
            to indicate that the lazy values have been computed and, if <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields"/> is null, then
            the "empty" value should be inferred.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol.SetAssociatedProperty(Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol,Microsoft.CodeAnalysis.MethodKind)">
            <summary>
            Associate the method with a particular property. Returns
            false if the method is already associated with a property or event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol.SetAssociatedEvent(Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEEventSymbol,Microsoft.CodeAnalysis.MethodKind)">
            <summary>
            Associate the method with a particular event. Returns
            false if the method is already associated with a property or event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol.Signature">
            <summary>
            internal for testing purpose
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol.ExplicitlyOverriddenClassMethod">
            <summary>
            If a methodimpl record indicates a unique overridden method, that method. Otherwise null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol">
            <summary>
            Represents a net-module imported from a PE. Can be a primary module of an assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._assemblySymbol">
            <summary>
            Owning AssemblySymbol. This can be a PEAssemblySymbol or a SourceAssemblySymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._module">
            <summary>
            A Module object providing metadata.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._globalNamespace">
            <summary>
            Global namespace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._lazySystemTypeSymbol">
            <summary>
            Cache the symbol for well-known type System.Type because we use it frequently
            (for attributes).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.DefaultTypeMapCapacity">
            <summary>
            The same value as ConcurrentDictionary.DEFAULT_CAPACITY
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.TypeHandleToTypeMap">
            <summary>
            This is a map from TypeDef handle to the target <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol"/>. 
            It is used by <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder"/> to speed up type reference resolution
            for metadata coming from this module. The map is lazily populated
            as we load types from the module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.TypeRefHandleToTypeMap">
            <summary>
            This is a map from TypeRef row id to the target <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol"/>. 
            It is used by <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder"/> to speed up type reference resolution
            for metadata coming from this module. The map is lazily populated
            by <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder"/> as we resolve TypeRefs from the module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._lazyCustomAttributes">
            <summary>
            Module's custom attributes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._lazyAssemblyAttributes">
            <summary>
            Module's assembly attributes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.GetCustomAttributesForToken(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.CustomAttributeHandle@,Microsoft.CodeAnalysis.AttributeDescription,System.Reflection.Metadata.CustomAttributeHandle@,Microsoft.CodeAnalysis.AttributeDescription,System.Reflection.Metadata.CustomAttributeHandle@,Microsoft.CodeAnalysis.AttributeDescription,System.Reflection.Metadata.CustomAttributeHandle@,Microsoft.CodeAnalysis.AttributeDescription,System.Reflection.Metadata.CustomAttributeHandle@,Microsoft.CodeAnalysis.AttributeDescription,System.Reflection.Metadata.CustomAttributeHandle@,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Returns attributes with up-to 6 filters applied. For each filter, the last application of the
            attribute will be tracked and returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.GetCustomAttributesForToken(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.CustomAttributeHandle@)">
            <summary>
            Get the custom attributes, but filter out any ParamArrayAttributes.
            </summary>
            <param name="token">The parameter token handle.</param>
            <param name="paramArrayAttribute">Set to a ParamArrayAttribute</param>
            CustomAttributeHandle if any are found. Nil token otherwise.
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.GetCustomAttributesFilterCompilerAttributes(System.Reflection.Metadata.EntityHandle,System.Boolean@,System.Boolean@)">
            <summary>
            Filters extension attributes from the attribute results.
            </summary>
            <param name="token"></param>
            <param name="foundExtension">True if we found an extension method, false otherwise.</param>
            <returns>The attributes on the token, minus any ExtensionAttributes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.GetAssembliesForForwardedType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Returns a tuple of the assemblies this module forwards the given type to.
            </summary>
            <param name="fullName">Type to look up.</param>
            <returns>A tuple of the forwarded to assemblies.</returns>
            <remarks>
            The returned assemblies may also forward the type.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol">
            <summary>
            The class to represent all types imported from a PE/module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol._lazyMemberNames">
            <summary>
            A set of all the names of the members in this type.
            We can get names without getting members (which is a more expensive operation)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol._lazyMembersInDeclarationOrder">
            <summary>
            We used to sort symbols on demand and relied on row ids to figure out the order between symbols of the same kind.
            However, that was fragile because, when map tables are used in metadata, row ids in the map table define the order
            and we don't have them.
            Members are grouped by kind. First we store fields, then methods, then properties, then events and finally nested types.
            Within groups, members are sorted based on declaration order.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol._lazyMembersByName">
            <summary>
            A map of members immediately contained within this type 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol._lazyNestedTypes">
            <summary>
            A map of types immediately contained within this type 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol._lazyKind">
            <summary>
            Lazily initialized by TypeKind property.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.UncommonProperties.lazyInstanceEnumFields">
            <summary>
            Need to import them for an enum from a linked assembly, when we are embedding it. These symbols are not included into lazyMembersInDeclarationOrder.  
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.GetIndexOfFirstMember(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.SymbolKind)">
            <summary>
            Returns the index of the first member of the specific kind.
            Returns the number of members if not found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.GetMembers``1(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.SymbolKind,System.Int32)">
            <summary>
            Returns all members of the specific kind, starting at the optional offset.
            Members of the same kind are assumed to be contiguous.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.PENamedTypeSymbolNonGeneric">
            <summary>
            Specialized PENamedTypeSymbol for types with no type parameters in
            metadata (no type parameters on this type and all containing types).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.PENamedTypeSymbolGeneric">
            <summary>
            Specialized PENamedTypeSymbol for types with type parameters in metadata.
            NOTE: the type may have Arity == 0 if it has same metadata arity as the metadata arity of the containing type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.PENamedTypeSymbolGeneric.MatchesContainingTypeParameters">
            <summary>
            Return true if the type parameters specified on the nested type (this),
            that represent the corresponding type parameters on the containing
            types, in fact match the actual type parameters on the containing types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol">
            <summary>
            The base class to represent a namespace imported from a PE/module. Namespaces that differ
            only by casing in name are not merged.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.lazyNamespaces">
            <summary>
            A map of namespaces immediately contained within this namespace 
            mapped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.lazyTypes">
            <summary>
            A map of types immediately contained within this namespace 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol._lazyNoPiaLocalTypes">
            <summary>
            A map of NoPia local types immediately contained in this assembly.
            Maps type name (non-qualified) to the row id. Note, for VB we should use
            full name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol._lazyFlattenedTypes">
            <summary>
            All type members in a flat array
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.ContainingPEModule">
            <summary>
            Returns PEModuleSymbol containing the namespace.
            </summary>
            <returns>PEModuleSymbol containing the namespace.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.LoadAllMembers(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}})">
            <summary>
            Initializes namespaces and types maps with information about 
            namespaces and types immediately contained within this namespace.
            </summary>
            <param name="typesByNS">
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids must be grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups must be sorted by
            their key in case-sensitive manner. Empty string must be used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            must be in several first IGroupings.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.LazyInitializeNamespaces(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}}}})">
            <summary>
            Create symbols for nested namespaces and initialize namespaces map.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.LazyInitializeTypes(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}})">
            <summary>
            Create symbols for nested types and initialize types map.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENestedNamespaceSymbol">
            <summary>
            The class to represent all, but Global, namespaces imported from a PE/module.
            Namespaces that differ only by casing in name are not merged.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENestedNamespaceSymbol._containingNamespaceSymbol">
            <summary>
            The parent namespace. There is always one, Global namespace contains all
            top level namespaces. 
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENestedNamespaceSymbol._name">
            <summary>
            The name of the namespace.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENestedNamespaceSymbol._typesByNS">
            <summary>
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids are grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups are sorted by their 
            key in case-sensitive manner. Empty string is used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            will be in several first IGroupings.
            
            This member is initialized by constructor and is cleared in EnsureAllMembersLoaded 
            as soon as symbols for children are created.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENestedNamespaceSymbol.#ctor(System.String,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}})">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Name of the namespace, must be not empty.
            </param>
            <param name="containingNamespace">
            Containing namespace.
            </param>
            <param name="typesByNS">
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids are grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups are sorted by their 
            key in case-sensitive manner. Empty string is used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            will be in several first IGroupings.
            </param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol">
            <summary>
            The class to represent all method parameters imported from a PE/module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol._lazyCallerArgumentExpressionParameterIndex">
            <summary>
            The index of a CallerArgumentExpression. The value -2 means uninitialized, -1 means
            not found. Otherwise, the index of the CallerArgumentExpression.
            </summary>        
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol._lazyHiddenAttributes">
            <summary>
            Attributes filtered out from m_lazyCustomAttributes, ParamArray, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol.Create(Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol,System.Boolean,System.Int32,System.Reflection.Metadata.ParameterHandle,Microsoft.CodeAnalysis.ParamInfo{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean@)">
            <summary>
            Construct a parameter symbol for a property loaded from metadata.
            </summary>
            <param name="moduleSymbol"></param>
            <param name="containingSymbol"></param>
            <param name="ordinal"></param>
            <param name="handle">The property parameter doesn't have a name in metadata,
            so this is the handle of a corresponding accessor parameter, if there is one,
            or of the ParamInfo passed in, otherwise.</param>
            <param name="parameterInfo" />
            <param name="isBad" />
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol.ImportConstantValue(System.Boolean)">
            <remarks>
            Internal for testing.  Non-test code should use <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol.ExplicitDefaultConstantValue"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol">
            <summary>
            The class to represent all properties imported from a PE/module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol.Name">
            <remarks>
            To facilitate lookup, all indexer symbols have the same name.
            Check the MetadataName property to find the name we imported.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol.IsIndexer">
            <remarks>
            This property can return true for bogus indexers.
            Rationale: If a type in metadata has a single, bogus indexer
            and a source method tries to invoke it, then Dev10 reports a bogus
            indexer rather than lack of an indexer.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Intended behavior: this property, P, explicitly implements an interface property, IP, 
            if any of the following is true:
            
            1) P.get explicitly implements IP.get and P.set explicitly implements IP.set
            2) P.get explicitly implements IP.get and there is no IP.set
            3) P.set explicitly implements IP.set and there is no IP.get
            
            Extra or missing accessors will not result in errors, P will simply not report that
            it explicitly implements IP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PETypeParameterSymbol">
            <summary>
            The class to represent all generic type parameters imported from a PE/module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PETypeParameterSymbol._lazyCachedConstraintsUseSiteInfo">
            <summary>
            First error calculating bounds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PETypeParameterSymbol.GetNullableAttributeValue">
            <summary>
            Returns the byte value from the (single byte) NullableAttribute or nearest
            NullableContextAttribute. Returns 0 if neither attribute is specified.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.TupleTypeDecoder">
             <summary>
             In C#, tuples can be represented using tuple syntax and be given
             names. However, the underlying representation for tuples unifies
             to a single underlying tuple type, System.ValueTuple. Since the
             names aren't part of the underlying tuple type they have to be
             recorded somewhere else.
             
             Roslyn records tuple names in an attribute: the
             TupleElementNamesAttribute. The attribute contains a single string
             array which records the names of the tuple elements in a pre-order
             depth-first traversal. If the type contains nested parameters,
             they are also recorded in a pre-order depth-first traversal.
             <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.TupleTypeDecoder.DecodeTupleTypesIfApplicable(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Reflection.Metadata.EntityHandle,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol)"/>
             can be used to extract tuple names and types from metadata and create
             a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol"/> with attached names.
             
             <example>
             For instance, a method returning a tuple
             
             <code>
                 (int x, int y) M() { ... }
             </code>
            
             will be encoded using an attribute on the return type as follows
             
             <code>
                 [return: TupleElementNamesAttribute(new[] { "x", "y" })]
                 System.ValueTuple&lt;int, int&gt; M() { ... }
             </code>
             </example>
             
             <example>
             For nested type parameters, we expand the tuple names in a pre-order
             traversal:
             
             <code>
                 class C : BaseType&lt;((int e1, int e2) e3, int e4)&lt; { ... }
             </code>
            
             becomes
             
             <code>
                 [TupleElementNamesAttribute(new[] { "e3", "e4", "e1", "e2" });
                 class C : BaseType&lt;System.ValueTuple&lt;
                     System.ValueTuple&lt;int,int&gt;, int&gt;
                 { ... }
             </code>
             </example>
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAttributeData">
            <summary>
            Represents a retargeting custom attribute
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAttributeData.GetSystemType(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Gets the retargeted System.Type type symbol.
            </summary>
            <param name="targetSymbol">Target symbol on which this attribute is applied.</param>
            <returns>Retargeted System.Type type symbol.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol">
            <summary>
            Essentially this is a wrapper around another AssemblySymbol that is responsible for retargeting
            symbols from one assembly to another. It can retarget symbols for multiple assemblies at the same time. 
            
            For example, compilation C1 references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. 
            In this case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
            signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
            RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
            reference C1.m_AssemblySymbol, but reference a special RetargetingAssemblySymbol created for 
            C1 by ReferenceManager.
            
            Here is how retargeting is implemented in general:
            - Symbols from underlying assembly are substituted with retargeting symbols.
            - Symbols from referenced assemblies that can be reused as is (i.e. doesn't have to be retargeted) are
              used as is.
            - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._underlyingAssembly">
            <summary>
            The underlying AssemblySymbol, it leaks symbols that should be retargeted.
            This cannot be an instance of RetargetingAssemblySymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._modules">
            <summary>
            The list of contained ModuleSymbol objects. First item in the list
            is RetargetingModuleSymbol that wraps corresponding SourceModuleSymbol 
            from underlyingAssembly.Modules list, the rest are PEModuleSymbols for 
            added modules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._noPiaResolutionAssemblies">
            <summary>
            An array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by a compilation referencing this assembly.
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._linkedReferencedAssemblies">
            <summary>
            An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._noPiaUnificationMap">
            <summary>
            Backing field for the map from a local NoPia type to corresponding canonical type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol.NoPiaUnificationMap">
            <summary>
            A map from a local NoPia type to corresponding canonical type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._isLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="underlyingAssembly">
            The underlying AssemblySymbol, cannot be an instance of RetargetingAssemblySymbol.
            </param>
            <param name="isLinked">
            Assembly is /l-ed by compilation that is using it as a reference.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol.UnderlyingAssembly">
            <summary>
            The underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Lookup declaration for FX type in this Assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingEventSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingFieldSymbol">
            <summary>
            Represents a field in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another FieldSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingFieldSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingFieldSymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol">
            <summary>
            Represents a method in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another MethodSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol._underlyingMethod">
            <summary>
            The underlying MethodSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol._lazyReturnTypeCustomAttributes">
            <summary>
            Retargeted return type custom attributes
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol.ExplicitlyOverriddenClassMethod">
            <summary>
            The explicitly overridden method (e.g. as would be declared in the PE method in covariant return scenarios).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol">
            <summary>
            Represents a primary module of a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol"/>. Essentially this is a wrapper around 
            another <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol"/> that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            
            Here is how retargeting is implemented in general:
            - Symbols from underlying module are substituted with retargeting symbols.
            - Symbols from referenced assemblies that can be reused as is (i.e. don't have to be retargeted) are
              used as is.
            - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol._retargetingAssembly">
            <summary>
            Owning <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol._underlyingModule">
            <summary>
            The underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol"/>, cannot be another <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol._retargetingAssemblyMap">
            <summary>
            The map that captures information about what assembly should be retargeted 
            to what assembly. Key is the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> referenced by the underlying module,
            value is the corresponding <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> referenced by this module, and corresponding
            retargeting map for symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol,Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol)">
            <summary>
            Constructor.
            </summary>
            <param name="retargetingAssembly">
            Owning assembly.
            </param>
            <param name="underlyingModule">
            The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.UnderlyingModule">
            <summary>
            The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.SetReferences(Microsoft.CodeAnalysis.ModuleReferences{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol},Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol)">
            <summary>
            A helper method for ReferenceManager to set AssemblySymbols for assemblies 
            referenced by this module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol._symbolMap">
            <summary>
            Retargeting map from underlying module to this one.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.SymbolMap">
            <summary>
            Retargeting map from underlying module to the retargeting module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.RetargetingAssembly">
            <summary>
            RetargetingAssemblySymbol owning retargetingModule.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.UnderlyingModule">
            <summary>
            The underlying ModuleSymbol for retargetingModule.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.RetargetingAssemblyMap">
            <summary>
            The map that captures information about what assembly should be retargeted 
            to what assembly. Key is the AssemblySymbol referenced by the underlying module,
            value is the corresponding AssemblySymbol referenced by the retargeting module, and 
            corresponding retargeting map for symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.IsOrClosedOverAnExplicitLocalType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Perform a check whether the type or at least one of its generic arguments 
            is an explicitly defined local type. The check is performed recursively. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamedTypeSymbol">
            <summary>
            Represents a type of a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another NamedTypeSymbol that is responsible for retargeting referenced symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamedTypeSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamespaceSymbol">
            <summary>
            Represents a namespace of a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another NamespaceSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamespaceSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamespaceSymbol._underlyingNamespace">
            <summary>
            The underlying NamespaceSymbol, cannot be another RetargetingNamespaceSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingParameterSymbol">
            <summary>
            Represents a parameter of a RetargetingMethodSymbol. Essentially this is a wrapper around 
            another ParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingParameterSymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingParameterSymbol.DeclaringCompilation">
            <summary>
            <inheritdoc/>
            </summary>
            <remarks>
            This override is done for performance reasons. Lacking the override this would redirect to 
            <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.DeclaringCompilation"/> which returns null. The override 
            short circuits the overhead in <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.DeclaringCompilation"/> and the extra virtual
            dispatch and just returns null.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodParameterSymbol._retargetingMethod">
            <summary>
            Owning RetargetingMethodSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingPropertyParameterSymbol._retargetingProperty">
            <summary>
            Owning RetargetingPropertySymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingPropertySymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingPropertySymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingTypeParameterSymbol">
            <summary>
            Represents a type parameter in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another TypeParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingTypeParameterSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingTypeParameterSymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAttributeData">
            <summary>
            Represents a Source custom attribute specification
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAttributeData.ConstructorArgumentsSourceIndices">
            <summary>
            If the <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.ConstructorArguments"/> contains any named constructor arguments or default value arguments,
            it returns an array representing each argument's source argument index. A value of -1 indicates default value argument.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAttributeData.GetTargetAttributeSignatureIndex(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            This method finds an attribute by metadata name and signature. The algorithm for signature matching is similar to the one
            in Module.GetTargetAttributeSignatureIndex. Note, the signature matching is limited to primitive types
            and System.Type.  It will not match an arbitrary signature but it is sufficient to match the signatures of the current set of
            well known attributes.
            </summary>
            <param name="targetSymbol">The symbol which is the target of the attribute</param>
            <param name="description">The attribute to match.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAttributeData.GetSystemType(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Gets the System.Type type symbol from targetSymbol's containing assembly.
            </summary>
            <param name="targetSymbol">Target symbol on which this attribute is applied.</param>
            <returns>System.Type type symbol.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.FieldWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a field.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodEarlyWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a module.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterEarlyWellKnownAttributeData">
            <summary>
            Information early-decoded from well-known custom attributes applied on a parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.PropertyEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.PropertyWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeEarlyWellKnownAttributeData">
            <summary>
            Information decoded early from well-known custom attributes applied on a type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.BaseTypeAnalysis.GetManagedKind(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            IsManagedType is simple for most named types:
                enums are not managed;
                non-enum, non-struct named types are managed;
                type parameters are managed unless an 'unmanaged' constraint is present;
                all special types have spec'd values (basically, (non-string) primitives) are not managed;
            
            Only structs are complicated, because the definition is recursive.  A struct type is managed
            if one of its instance fields is managed or a ref field.  Unfortunately, this can result in infinite recursion.
            If the closure is finite, and we don't find anything definitely managed, then we return true.
            If the closure is infinite, we disregard all but a representative of any expanding cycle.
            
            Intuitively, this will only return true if there's a specific type we can point to that is would
            be managed even if it had no fields.  e.g. struct S { S s; } is not managed, but struct S { S s; object o; }
            is because we can point to object.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.BaseTypeAnalysis.IsManagedTypeHelper(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Returns True or False if we can determine whether the type is managed
            without looking at its fields and Unknown otherwise.
            Also returns whether or not the given type is generic.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.CompletionPart">
            <summary>
            This enum describes the types of components that could give
            us diagnostics.  We shouldn't read the list of diagnostics
            until all of these types are accounted for.
            </summary>
            <remarks>
            PEParameterSymbol reserves all completion part bits and uses them to track the completion state and
            presence of well known attributes.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterDiagnosticInfo">
            <summary>
            A tuple of TypeParameterSymbol and DiagnosticInfo, created for errors
            reported from ConstraintsHelper rather than creating Diagnostics directly.
            This decouples constraints checking from syntax and Locations, and supports
            callers that may want to create Location instances lazily or not at all.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper">
            <summary>
            Helper methods for generic type parameter constraints. There are two sets of methods: one
            set for resolving constraint "bounds" (that is, determining the effective base type, interface set,
            etc.), and another set for checking for constraint violations in type and method references.
            
            Bounds are resolved by calling one of the ResolveBounds overloads. Typically bounds are
            resolved by each TypeParameterSymbol at, or before, one of the corresponding properties
            (BaseType, Interfaces, etc.) is accessed. Resolving bounds may result in errors (cycles,
            inconsistent constraints, etc.) and it is the responsibility of the caller to report any such
            errors as declaration errors or use-site errors (depending on whether the type parameter
            was from source or metadata) and to ensure bounds are resolved for source type parameters
            even if the corresponding properties are never accessed directly.
            
            Constraints are checked by calling one of the CheckConstraints or CheckAllConstraints
            overloads for any generic type or method reference from source. In some circumstances,
            references are checked at the time the generic type or generic method is bound and constructed
            by the Binder. In those case, it is sufficient to call one of the CheckConstraints overloads
            since compound types (such as A&lt;T&gt;.B&lt;U&gt; or A&lt;B&lt;T&gt;&gt;) are checked
            incrementally as each part is bound. In other cases however, constraint checking needs to be
            delayed to prevent cycles where checking constraints requires binding the syntax that is currently
            being bound (such as the constraint in class C&lt;T&gt; where T : C&lt;T&gt;). In those cases,
            the caller must lazily check constraints, and since the types may be compound types, it is
            necessary to call CheckAllConstraints.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper.ResolveBounds(Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Boolean,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Determine the effective base type, effective interface set, and set of type
            parameters (excluding cycles) from the type parameter constraints. Conflicts
            within the constraints and constraint types are returned as diagnostics.
            'inherited' should be true if the type parameters are from an overridden
            generic method. In those cases, additional constraint checks are applied.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper.CheckAllConstraints(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.ConversionsBase,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Check all generic constraints on the given type and any containing types
            (such as A&lt;T&gt; in A&lt;T&gt;.B&lt;U&gt;). This includes checking constraints
            on generic types within the type (such as B&lt;T&gt; in A&lt;B&lt;T&gt;[]&gt;).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper.CheckConstraints(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper.CheckConstraintsArgs@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeMap,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterDiagnosticInfo},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterDiagnosticInfo},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterDiagnosticInfo}@,Microsoft.CodeAnalysis.BitVector,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol})">
            <summary>
            Check type parameter constraints for the containing type or method symbol.
            </summary>
            <param name="containingSymbol">The generic type or method.</param>
            <param name="args">Arguments for constraints checking.</param>
            <param name="substitution">The map from type parameters to type arguments.</param>
            <param name="typeParameters">Containing symbol type parameters.</param>
            <param name="typeArguments">Containing symbol type arguments.</param>
            <param name="diagnosticsBuilder">Diagnostics.</param>
            <param name="nullabilityDiagnosticsBuilderOpt">Nullability warnings.</param>
            <param name="skipParameters">Parameters to skip.</param>
            <param name="useSiteDiagnosticsBuilder"/>
            <param name="ignoreTypeConstraintsDependentOnTypeParametersOpt">If an original form of a type constraint 
            depends on a type parameter from this set, do not verify this type constraint.</param>
            <returns>True if the constraints were satisfied, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper.IsEncompassedBy(Microsoft.CodeAnalysis.CSharp.ConversionsBase,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Returns true if type a is encompassed by type b (spec 6.4.3),
            and returns false otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedNestedTypeSymbol">
            <summary>
            A named type symbol that results from substituting a new owner for a type declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ConstructedNamedTypeSymbol">
            <summary>
            A generic named type symbol that has been constructed with type arguments distinct from its own type parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.DynamicTypeEraser">
            <summary>
            Substitutes all occurrences of dynamic type with Object type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorPropertySymbol">
            <summary>
            When indexer overload resolution fails, we have two options:
              1) Create a BoundBadExpression with the candidates as child nodes;
              2) Create a BoundIndexerAccess with the error flag set.
              
            Option 2 is preferable, because it retains information about the arguments
            (names, ref kind, etc), and results in better output from flow analysis.
            However, we can't create a BoundIndexerAccess with a null indexer symbol,
            so we create an ErrorPropertySymbol to fill the gap.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol">
            <summary>
            An ErrorSymbol is used when the compiler cannot determine a symbol object to return because
            of an error. For example, if a field is declared "Goo x;", and the type "Goo" cannot be
            found, an ErrorSymbol is returned when asking the field "x" what it's type is.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.ErrorInfo">
            <summary>
            The underlying error.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.ResultKind">
            <summary>
            Summary of the reason why the type is bad.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Substitute(Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap)">
            <summary>
            Called by <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)"/> to perform substitution
            on types with TypeKind ErrorType.  The general pattern is to use the type map
            to perform substitution on the wrapped type, if any, and then construct a new
            error type symbol from the result (if there was a change).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.CandidateSymbols">
            <summary>
            When constructing this ErrorTypeSymbol, there may have been symbols that seemed to
            be what the user intended, but were unsuitable. For example, a type might have been
            inaccessible, or ambiguous. This property returns the possible symbols that the user
            might have intended. It will return no symbols if no possible symbols were found.
            See the CandidateReason property to understand why the symbols were unsuitable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.CandidateReason">
            <summary>
             If CandidateSymbols returns one or more symbols, returns the reason that those
             symbols were not chosen. Otherwise, returns None.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.MemberNames">
            <summary>
            Collection of names of members declared within this type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ImmutableArray. Never returns Null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ImmutableArray. Never returns Null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.TypeKind">
            <summary>
            Gets the kind of this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.ContainingSymbol">
            <summary>
            Get the symbol that logically contains this symbol. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Locations">
            <summary>
            Gets the locations where this symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Arity">
            <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a give type parameters,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.TypeParameters">
            <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ImmutableArray.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.ConstructedFrom">
            <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ExtendedErrorTypeSymbol">
            <summary>
            An error type, used to represent the type of a type binding
            operation when binding fails.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ExtendedErrorTypeSymbol.ExtractNonErrorType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            If (we believe) we know which symbol the user intended, then we should retain that information
            in the corresponding error symbol - it can be useful for deciding how to handle the error.
            For example, we might want to know whether (we believe) the error type was supposed to be an
            interface, so that we can put it in a derived type's interface list, rather than in the base
            type slot.
            
            Sometimes we will return the original definition of the intended symbol.  For example, if we see 
            <![CDATA[IGoo<int>]]> and we have an IGoo with a different arity or accessibility 
            (e.g. <![CDATA[IGoo<int>]]> was constructed from an error symbol based on <![CDATA[IGoo<T>]]>), 
            then we'll return <![CDATA[IGoo<T>]]>, rather than trying to construct a corresponding closed
            type (which may not be difficult/possible in the case of nested types or mismatched arities).
            
            NOTE: Any non-null type symbol returned is guaranteed not to be an error type.
            </summary>
            <remarks>
            TypeSymbolExtensions.GetNonErrorGuess is a more discoverable version of this functionality.
            However, the real definition is in this class so that it can access the private field 
            nonErrorGuessType.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer">
            <summary>
            Represents a field initializer, a property initializer, or a global statement in script code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer.FieldOpt">
            <summary>
            The field being initialized (possibly a backing field of a property), or null if this is a top-level statement in script code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer.Syntax">
            <summary>
            A reference to <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax"/>,
            or top-level <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax"/> in script code,
            or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax"/> for an initialization of a generated property based on record parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerMethodSymbol.CreateFromPartsForTest(Microsoft.Cci.CallingConvention,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier},Microsoft.CodeAnalysis.RefKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Creates a function pointer method symbol from individual parts. This method should only be used when diagnostics are not needed.
            This should only be used from testing code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerMethodSymbol.CreateFromParts(Microsoft.Cci.CallingConvention,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier},Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.RefKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Creates a function pointer method symbol from individual parts. This method should only be used when diagnostics are not needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerMethodSymbol.#ctor(Microsoft.Cci.CallingConvention,Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Creates a function pointer method symbol from individual parts. This method should only be used when diagnostics are not needed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.InferredDelegateTypeData">
            <summary>
            Inferred delegate type state, recorded during testing only.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.InferredDelegateTypeData.InferredDelegateCount">
            <summary>
            Number of delegate types calculated in the compilation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionTypeSymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol"/> implementation that represents the lazily-inferred signature of a
            lambda expression or method group. This is implemented as a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol"/>
            to allow types and function signatures to be treated similarly in <see cref="T:Microsoft.CodeAnalysis.CSharp.ConversionsBase"/>,
            <see cref="T:Microsoft.CodeAnalysis.CSharp.BestTypeInferrer"/>, and <see cref="T:Microsoft.CodeAnalysis.CSharp.MethodTypeInferrer"/>. Instances of this type
            should only be used in those code paths and should not be exposed from the symbol model.
            The actual delegate signature is calculated on demand in <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionTypeSymbol.GetInternalDelegateType"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionTypeSymbol.GetInternalDelegateType">
            <summary>
            Returns the inferred signature as a delegate type
            or null if the signature could not be inferred.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol">
            <summary>
            Represents a label in method body
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsExtern">
            <summary>
            Returns false because label can't be defined externally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsSealed">
            <summary>
            Returns false because label can't be sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsAbstract">
            <summary>
            Returns false because label can't be abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsOverride">
            <summary>
            Returns false because label can't be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsVirtual">
            <summary>
            Returns false because label can't be virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsStatic">
            <summary>
            Returns false because label can't be static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable' because label can't be used outside the member body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.Locations">
            <summary>
            Gets the locations where the symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.ContainingMethod">
            <summary>
            Gets the immediately containing symbol of the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol"/>.
            It should be the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/> containing the label in its body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.ContainingSymbol">
            <summary>
            Gets the immediately containing symbol of the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol"/>.
            It should be the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/> containing the label in its body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.Kind">
            <summary>
            Returns value 'Label' of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey">
            <summary>
            A structure used to lexically order symbols. For performance, it's important that this be 
            a STRUCTURE, and be able to be returned from a symbol without doing any additional allocations (even
            if nothing is cached yet).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey.Compare(Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey,Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey)">
            <summary>
            Compare two lexical sort keys in a compilation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind">
            <summary>
            Specifies the syntactic construct that a user defined variable comes from.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.None">
            <summary>
            The local is not user defined nor it is a copy of a user defined local (e.g. with a substituted type).
            Check the value of <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.SynthesizedKind"/> for the kind of synthesized variable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.RegularVariable">
            <summary>
            User defined local variable declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.Constant">
            <summary>
            User defined local constant declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.FixedVariable">
            <summary>
            User defined local variable declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax"/> in <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.UsingVariable">
            <summary>
            User defined local variable declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax"/> in <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.CatchVariable">
            <summary>
            User defined local variable declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.ForEachIterationVariable">
            <summary>
            User defined local variable declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.PatternVariable">
            <summary>
            The variable that captures the result of a pattern matching operation like "i" in "expr is int i"
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.DeconstructionVariable">
            <summary>
            User variable declared by a declaration expression in the left-hand-side of a deconstruction assignment.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.OutVariable">
            <summary>
            User variable declared as an out argument.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.DeclarationExpressionVariable">
            <summary>
            User variable declared by a declaration expression in some unsupported context.
            This occurs as a result of error recovery in incorrect code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol">
            <summary>
            Represents a local variable in a method body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.ScopeDesignatorOpt">
            <summary>
            Syntax node that is used as the scope designator. Otherwise, null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.TypeWithAnnotations">
            <summary>
            Gets the type of this local along with its annotations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.Type">
            <summary>
            Gets the type of this local.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsPinned">
            <summary>
            WARN WARN WARN: If you access this via the semantic model, things will break (since the initializer may not have been bound).
            
            Whether or not this local is pinned (i.e. the type will be emitted with the "pinned" modifier).
            </summary>
            <remarks>
            Superficially, it seems as though this should always be the same as DeclarationKind == LocalDeclarationKind.Fixed.
            Unfortunately, when we fix a string expression, it is not the declared local (e.g. char*) but a synthesized temp (string)
            that is pinned.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsExtern">
            <summary>
            Returns false because local variable can't be defined externally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsSealed">
            <summary>
            Returns false because local variable can't be sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsAbstract">
            <summary>
            Returns false because local variable can't be abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsOverride">
            <summary>
            Returns false because local variable can't be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsVirtual">
            <summary>
            Returns false because local variable can't be virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsStatic">
            <summary>
            Returns false because local variable can't be declared as static in C#.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable' because local variable can't be used outside the member body..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.Kind">
            <summary>
            Returns value 'Local' of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsCatch">
            <summary>
            Returns true if this local variable was declared in a catch clause. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsConst">
            <summary>
            Returns true if this local variable was declared as "const" (i.e. is a constant declaration).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsUsing">
            <summary>
            Returns true if the local variable is declared in resource-acquisition of a 'using statement';
            otherwise false
            </summary>
            <example>
            <code>
                using (var localVariable = new StreamReader("C:\\Temp\\MyFile.txt")) { ... } 
            </code>
            </example>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsFixed">
            <summary>
            Returns true if the local variable is declared in fixed-pointer-initializer (in unsafe context)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsForEach">
            <summary>
            Returns true if this local variable is declared as iteration variable
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.GetDeclaratorSyntax">
            <summary>
            Returns the syntax node that declares the variable.
            </summary>
            <remarks>
            All user-defined and long-lived synthesized variables must return a reference to a node that is 
            tracked by the EnC diffing algorithm. For example, for <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.CatchVariable"/> variable
            the declarator is the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax"/> node.
            
            The location of the declarator is used to calculate <see cref="F:Microsoft.CodeAnalysis.CodeGen.LocalDebugId.SyntaxOffset"/> during emit.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsWritableVariable">
            <summary>
            Describes whether this represents a modifiable variable. Note that
            this refers to the variable, not the underlying value, so if this
            variable is a ref-local, the writability refers to ref-assignment,
            not assignment to the underlying storage.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.ConstantValue">
            <summary>
            If IsConst returns true, then returns the constant value of the field or enum member. If IsConst returns
            false, then returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsCompilerGenerated">
            <summary>
            Returns true if the local symbol was compiler generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.RefEscapeScope">
            <summary>
            Returns the scope to which a local can "escape" ref assignments or other form of aliasing
            Makes sense only for locals with formal scopes - i.e. source locals
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.ValEscapeScope">
            <summary>
            Returns the scope to which values of a local can "escape" via ordinary assignments
            Makes sense only for ref-like locals with formal scopes - i.e. source locals
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.ForbiddenZone">
            <summary>
            When a local variable's type is inferred, it may not be used in the
            expression that computes its value (and type). This property returns
            the expression where a reference to an inferred variable is forbidden.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.ForbiddenDiagnostic">
            <summary>
            The diagnostic code to be reported when an inferred variable is used
            in its forbidden zone.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer">
            <summary>
            <para>
            C# 4.0 §10.6: The name, the type parameter list and the formal parameter list of a method define
            the signature (§3.6) of the method. Specifically, the signature of a method consists of its
            name, the number of type parameters and the number, modifiers, and types of its formal
            parameters. For these purposes, any type parameter of the method that occurs in the type of
            a formal parameter is identified not by its name, but by its ordinal position in the type
            argument list of the method. The return type is not part of a method's signature, nor are
            the names of the type parameters or the formal parameters.
            </para>
            <para>
            C# 4.0 §3.6: For the purposes of signatures, the types object and dynamic are considered the
            same. 
            </para>
            <para>
            C# 4.0 §3.6: We implement the rules for ref/out by mapping both to ref. The caller (i.e.
            checking for proper overrides or partial methods, etc) should check that ref/out are
            consistent.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.ExplicitImplementationComparer">
            <summary>
            This instance is used when trying to determine if one member explicitly implements another,
            according the C# definition.
            The member signatures are compared without regard to name (including the interface part, if any)
            and the return types must match.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpImplicitImplementationComparer">
            <summary>
            This instance is used when trying to determine if one member implicitly implements another,
            according to the C# definition.
            The member names, parameters, and (return) types must match. Custom modifiers are ignored.
            </summary>
            <remarks>
            One would expect this comparer to have requireSourceMethod = true, but it doesn't because (for source types)
            we allow inexact matching of custom modifiers when computing implicit member implementations. Consider the
            following scenario: interface I has a method M with custom modifiers C1, source type ST includes I in its
            interface list but has no method M, and metadata type MT has a method M with custom modifiers C2.
            In this scenario, we want to compare I.M to MT.M without regard to custom modifiers, because if C1 != C2,
            we can just synthesize an explicit implementation of I.M in ST that calls MT.M.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpCloseImplicitImplementationComparer">
            <summary>
            This instance is used as a fallback when it is determined that one member does not implicitly implement
            another. It applies a looser check to determine whether the proposed implementation should be reported
            as "close".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.DuplicateSourceComparer">
            <summary>
            This instance is used to determine if two C# member declarations in source conflict with each other.
            Names, arities, and parameter types are considered.
            Return types, type parameter constraints, custom modifiers, and parameter ref kinds, etc are ignored.
            </summary>
            <remarks>
            This does the same comparison that MethodSignature used to do.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RecordAPISignatureComparer">
            <summary>
            This instance is used to determine if some API specific to records is explicitly declared.
            It is the same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.DuplicateSourceComparer"/> except it considers ref kinds as well.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.PartialMethodsComparer">
            <summary>
            This instance is used to determine if a partial method implementation matches the definition.
            It is the same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.DuplicateSourceComparer"/> except it considers ref kinds as well.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.PartialMethodsStrictComparer">
            <summary>
            This instance is used to determine if a partial method implementation matches the definition,
            including differences ignored by the runtime.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpOverrideComparer">
            <summary>
            This instance is used to check whether one member overrides another, according to the C# definition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpWithTupleNamesComparer">
            <summary>
            This instance checks whether two signatures match including tuples names, in both return type and parameters.
            It is used to detect tuple-name-only differences.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpWithoutTupleNamesComparer">
            <summary>
            This instance checks whether two signatures match excluding tuples names, in both return type and parameters.
            It is used to detect tuple-name-only differences.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpAccessorOverrideComparer">
            <summary>
            This instance is used to check whether one property or event overrides another, according to the C# definition.
            <para>NOTE: C# ignores accessor member names.</para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpCustomModifierOverrideComparer">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpOverrideComparer"/> except that it pays attention to custom modifiers and return type.  
            Normally, the return type isn't considered during overriding, but this comparer is actually used to find
            exact matches (i.e. before tie-breaking takes place amongst close matches).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.SloppyOverrideComparer">
            <summary>
            If this returns false, then the real override comparer (whichever one is appropriate for the scenario)
            will also return false.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RuntimeSignatureComparer">
            <summary>
            This instance is intended to reflect the definition of signature equality used by the runtime 
            (<a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf">ECMA-335</a>, Partition I, §8.6.1.6 Signature Matching).
            It considers return type, name, parameters, calling convention, and custom modifiers, but ignores
            the difference between <see cref="F:Microsoft.CodeAnalysis.RefKind.Out"/> and <see cref="F:Microsoft.CodeAnalysis.RefKind.Ref"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RuntimeExplicitImplementationSignatureComparer">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RuntimeSignatureComparer"/>, but in addition ignores name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RuntimePlusRefOutSignatureComparer">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RuntimeSignatureComparer"/>, but distinguishes between <c>ref</c> and <c>out</c>. During override resolution,
            if we find two methods that match except for <c>ref</c>/<c>out</c>, we want to prefer the one that matches, even
            if the runtime doesn't.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RuntimeImplicitImplementationComparer">
            <summary>
            This instance is the same as RuntimeSignatureComparer.
            CONSIDER: just use RuntimeSignatureComparer?
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpSignatureAndConstraintsAndReturnTypeComparer">
            <summary>
            This instance is used to search for members that have the same name, parameters, (return) type, and constraints (if any)
            according to the C# definition. Custom modifiers are ignored.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RetargetedExplicitImplementationComparer">
            <summary>
            This instance is used to search for members that have identical signatures in every regard.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CrefComparer">
            <summary>
            This instance is used for performing approximate overload resolution of documentation
            comment <c>cref</c> attributes. It ignores the name, because the candidates were all found by lookup.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.MethodGroupSignatureComparer">
            <summary>
            Compare signatures of methods from a method group.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.AreConstraintTypesSubset(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol)">
            <summary>
            Returns true if the first set of constraint types
            is a subset of the second set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol)">
             <summary>
             Do the members differ in terms of tuple names (both in their return type and parameters), but would match ignoring names?
            
             We'll look at the result of equality without tuple names (1) and with tuple names (2).
             The question is whether there is a change in tuple element names only (3).
            
             member1                       vs. member2                        | (1) | (2) |    (3)    |
             <c>(int a, int b) M()</c>     vs. <c>(int a, int b) M()</c>      | yes | yes |   match   |
             <c>(int a, int b) M()</c>     vs. <c>(int x, int y) M()</c>      | yes | no  | different |
             <c>void M((int a, int b))</c> vs. <c>void M((int x, int y))</c>  | yes | no  | different |
             <c>int M()</c>                vs. <c>string M()</c>              | no  | no  |   match   |
            
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions">
            <summary>
            SymbolExtensions for member symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetParameters(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Get the parameters of a member symbol.  Should be a method, property, or event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetParameterTypes(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Get the types of the parameters of a member symbol.  Should be a method, property, or event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetParameterRefKinds(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Get the ref kinds of the parameters of a member symbol.  Should be a method, property, or event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.CustomModifierCount(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Count the number of custom modifiers in/on the return type
            and parameters of the specified method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.CustomModifierCount(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol)">
            <summary>
            Count the number of custom modifiers in/on the type
            and parameters (for indexers) of the specified property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetMemberArity(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Return the arity of a member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.HasThisConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax@)">
            <summary>
            Returns true if the method is a constructor and has a this() constructor initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsParameterlessConstructor(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            NOTE: every struct has a public parameterless constructor either user-defined or default one
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsDefaultValueTypeConstructor(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Returns true if the method is the default constructor synthesized for struct types.
            If the containing struct type is from metadata, the default constructor is synthesized when there
            is no accessible parameterless constructor. (That synthesized constructor from metadata zero-inits
            the instance.) If the containing struct type is from source, the parameterless constructor is synthesized
            if there is no explicit parameterless constructor, and the synthesized
            parameterless constructor simply zero-inits the instance (and is not emitted).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.ShouldEmit(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Indicates whether the method should be emitted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetOwnOrInheritedAddMethod(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol)">
            <summary>
            If the event has a AddMethod, return that.  Otherwise check the overridden
            event, if any.  Repeat for each overridden event.
            </summary>
            <remarks>
            This method exists to mimic the behavior of GetOwnOrInheritedGetMethod, but it
            should only ever look at the overridden event in error scenarios.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetOwnOrInheritedRemoveMethod(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol)">
            <summary>
            If the event has a RemoveMethod, return that.  Otherwise check the overridden
            event, if any.  Repeat for each overridden event.
            </summary>
            <remarks>
            This method exists to mimic the behavior of GetOwnOrInheritedSetMethod, but it
            should only ever look at the overridden event in error scenarios.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsCompilationOutputWinMdObj(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Does the compilation this symbol belongs to output to a winmdobj?
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.ConstructIfGeneric(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations})">
            <summary>
            Returns a constructed named type symbol if 'type' is generic, otherwise just returns 'type'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsAccessibleViaInheritance(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Returns true if the members of superType are accessible from subType due to inheritance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.ContainingNamespaceOrType(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            The immediately containing namespace or named type, or null
            if the containing symbol is neither a namespace or named type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsContainingSymbolOfAllTypeParameters(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Returns true if all type parameter references within the given
            type belong to containingSymbol or its containing types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsContainingSymbolOfAllTypeParameters(Microsoft.CodeAnalysis.CSharp.Symbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Returns true if all type parameter references within the given
            types belong to containingSymbol or its containing types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsHiddenByCodeAnalysisEmbeddedAttribute(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Does the top level type containing this symbol have 'Microsoft.CodeAnalysis.Embedded' attribute?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.HasAsyncMethodBuilderAttribute(Microsoft.CodeAnalysis.CSharp.Symbol,System.Object@)">
            <summary>
            Returns true if the method has a [AsyncMethodBuilder(typeof(B))] attribute. If so it returns type B.
            Validation of builder type B is left for elsewhere. This method returns B without validation of any kind.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MergedNamespaceSymbol">
            <summary>
            A MergedNamespaceSymbol represents a namespace that merges the contents of two or more other
            namespaces. Any sub-namespaces with the same names are also merged if they have two or more
            instances.
            
            Merged namespaces are used to merge the symbols from multiple metadata modules and the
            source "module" into a single symbol tree that represents all the available symbols. The
            compiler resolves names against this merged set of symbols.
            
            Typically there will not be very many merged namespaces in a Compilation: only the root
            namespaces and namespaces that are used in multiple referenced modules. (Microsoft, System,
            System.Xml, System.Diagnostics, System.Threading, ...)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MergedNamespaceSymbol.Create(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol},System.String)">
            <summary>
            Create a possibly merged namespace symbol. If only a single namespace is passed it, it
            is just returned directly. If two or more namespaces are passed in, then a new merged
            namespace is created with the given extent and container.
            </summary>
            <param name="extent">The namespace extent to use, IF a merged namespace is created.</param>
            <param name="containingNamespace">The containing namespace to used, IF a merged
            namespace is created.</param>
            <param name="namespacesToMerge">One or more namespaces to merged. If just one, then it
            is returned. The merged namespace symbol may hold onto the array.</param>
            <param name="nameOpt">An optional name to give the resulting namespace.</param>
            <returns>A namespace symbol representing the merged namespace.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MergedNamespaceSymbol.SlowGetChildrenOfName(System.String)">
            <summary>
            Method that is called from the CachingLookup to lookup the children of a given name.
            Looks in all the constituent namespaces.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MergedNamespaceSymbol.SlowGetChildNames(System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Method that is called from the CachingLookup to get all child names. Looks in all
            constituent namespaces.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol">
            <summary>
            Represents source or metadata assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol._lazySpecialTypes">
            <summary>
            An array of cached Cor types defined in this assembly.
            Lazily filled by GetDeclaredSpecialType method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol._cachedSpecialTypes">
            <summary>
            How many Cor types have we cached so far.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol.RegisterDeclaredSpecialType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Register declaration of predefined CorLib type in this Assembly.
            </summary>
            <param name="corType"></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol.KeepLookingForDeclaredSpecialTypes">
            <summary>
            Continue looking for declaration of predefined CorLib type in this Assembly
            while symbols for new type declarations are constructed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol._lazySpecialTypeMembers">
            <summary>
            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
            assembly is the Cor Library
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol.MakeFinalIVTDetermination(Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <summary>
            Determine whether this assembly has been granted access to <paramref name="potentialGiverOfAccess"></paramref>.
            Assumes that the public key has been determined. The result will be cached.
            </summary>
            <param name="potentialGiverOfAccess"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.IsRuntimeFinalizer(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean)">
            <summary>
            The runtime considers a method to be a finalizer (i.e. a method that should be invoked
            by the garbage collector) if it (directly or indirectly) overrides System.Object.Finalize.
            </summary>
            <remarks>
            As an optimization, return true immediately for metadata methods with MethodKind
            Destructor - they are guaranteed to be finalizers.
            </remarks>
            <param name="method">Method to inspect.</param>
            <param name="skipFirstMethodKindCheck">This method is used to determine the method kind of
            a PEMethodSymbol, so we may need to avoid using MethodKind until we move on to a different
            MethodSymbol.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.ConstructIfGeneric(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations})">
            <summary>
            Returns a constructed method symbol if 'method' is generic, otherwise just returns 'method'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.CanBeHiddenByMemberKind(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.SymbolKind)">
            <summary>
            Some kinds of methods are not considered to be hideable by certain kinds of members.
            Specifically, methods, properties, and types cannot hide constructors, destructors,
            operators, conversions, or accessors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.CanBeHiddenByMethodPropertyOrType(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Some kinds of methods are never considered hidden by methods, properties, or types
            (constructors, destructors, operators, conversions, and accessors).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.IsAsyncReturningVoid(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Returns whether this method is async and returns void.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.IsAsyncEffectivelyReturningTask(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Returns whether this method is async and returns a task, task-like, or other type with a method-level builder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.IsAsyncEffectivelyReturningGenericTask(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Returns whether this method is async and returns a generic task, task-like, or other type with a method-level builder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.IsAsyncReturningIAsyncEnumerable(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Returns whether this method is async and returns an IAsyncEnumerable`1.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.IsAsyncReturningIAsyncEnumerator(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Returns whether this method is async and returns an IAsyncEnumerator`1.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingAssemblySymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingAssemblySymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> that represents
            an assembly that couldn't be found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingCorLibrarySymbol">
            <summary>
            AssemblySymbol to represent missing, for whatever reason, CorLibrary.
            The symbol is created by ReferenceManager on as needed basis and is shared by all compilations
            with missing CorLibraries.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MissingCorLibrarySymbol._lazySpecialTypes">
            <summary>
            An array of cached Cor types defined in this assembly.
            Lazily filled by GetDeclaredSpecialType method.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MissingCorLibrarySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly. Only should be
            called if it is know that this is the Cor Library (mscorlib).
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol"/> that represents
            a type symbol that was attempted to be read from metadata, but couldn't be
            found, because:
              a) The metadata file it lives in wasn't referenced
              b) The metadata file was referenced, but didn't contain the type
              c) The metadata file was referenced, contained the correct outer type, but
                 didn't contains a nested type in that outer type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.Arity">
            <summary>
            Get the arity of the missing type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.TopLevel">
            <summary>
            Represents not nested missing type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.TopLevel._lazyTypeId">
            <summary>
            Either <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.TopLevel.SpecialType"/>, <see cref="T:Microsoft.CodeAnalysis.WellKnownType"/>, or -1 if not initialized.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.TopLevel.NamespaceName">
            <summary>
            This is the FULL namespace name (e.g., "System.Collections.Generic")
            of the type that couldn't be found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.Nested">
            <summary>
            Represents nested missing type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingModuleSymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingModuleSymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol"/> that represents
            a module that couldn't be found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingNamespaceSymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingNamespaceSymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol"/> that represents
            a namespace that couldn't be found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol">
            <summary>
            Represents a module within an assembly. Every assembly contains one or more modules.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GlobalNamespace">
            <summary>
            Returns a NamespaceSymbol representing the global (root) namespace, with
            module extent, that can be used to browse all of the symbols defined in this module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.ContainingAssembly">
            <summary>
            Returns the containing assembly. Modules are always directly contained by an assembly,
            so this property always returns the same as ContainingSymbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.Kind">
            <summary>
            Returns value 'NetModule' of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.Ordinal">
            <summary>
            Module's ordinal within containing assembly's Modules array.
            0 - for a source module, etc.
            -1 - for a module that doesn't have containing assembly, or has it, but is not part of Modules array. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.Machine">
            <summary>
            Target architecture of the machine.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.Bit32Required">
            <summary>
            Indicates that this PE file makes Win32 calls. See CorPEKind.pe32BitRequired for more information (http://msdn.microsoft.com/en-us/library/ms230275.aspx).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsMissing">
            <summary>
            Does this symbol represent a missing module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable'
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsStatic">
            <summary>
            Returns false because module can't be declared as 'static'.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsVirtual">
            <summary>
            Returns false because module can't be virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsOverride">
            <summary>
            Returns false because module can't be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsAbstract">
            <summary>
            Returns false because module can't be abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsSealed">
            <summary>
            Returns false because module can't be sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsExtern">
            <summary>
            Returns false because module can't be defined externally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.ReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from ReferencedAssemblies and from ReferencedAssemblySymbols 
            correspond to each other.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GetReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
            should correspond to each other.
            
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.ReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from ReferencedAssemblies and 
            from ReferencedAssemblySymbols correspond to each other.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GetReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from GetReferencedAssemblies and 
            from GetReferencedAssemblySymbols should correspond to each other. If reference is 
            not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
            corresponding item.
            
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.SetReferences(Microsoft.CodeAnalysis.ModuleReferences{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol},Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol)">
            <summary>
            A helper method for ReferenceManager to set assembly identities for assemblies 
            referenced by this module and corresponding AssemblySymbols.
            </summary>
            <param name="moduleReferences">A description of the assemblies referenced by this module.</param>
            <param name="originatingSourceAssemblyDebugOnly">
            Source assembly that triggered creation of this module symbol.
            For debug purposes only, this assembly symbol should not be persisted within
            this module symbol because the module can be shared across multiple source 
            assemblies. This method will only be called for the first one.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.HasUnifiedReferences">
            <summary>
            True if this module has any unified references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GetUnificationUseSiteDiagnostic(Microsoft.CodeAnalysis.DiagnosticInfo@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary> 
            Returns a unification use-site error (if any) for a symbol contained in this module 
            that is referring to a specified <paramref name="dependentType"/>.
            </summary> 
            <remarks> 
            If an assembly referenced by this module isn't exactly matching any reference given to compilation 
            the Assembly Manager might decide to use another reference if it matches except for version 
            (it unifies the version with the existing reference).  
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.HasAssemblyCompilationRelaxationsAttribute">
            <summary>
            Returns true if there is any applied CompilationRelaxationsAttribute assembly attribute for this module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.HasAssemblyRuntimeCompatibilityAttribute">
            <summary>
            Returns true if there is any applied RuntimeCompatibilityAttribute assembly attribute for this module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.DefaultMarshallingCharSet">
            <summary>
            Default char set for contained types, or null if not specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GetModuleNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)">
            <summary>
            Given a namespace symbol, returns the corresponding module specific namespace symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GetModuleNamespace(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol)">
            <summary>
            Given a namespace symbol, returns the corresponding module specific namespace symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GetMetadata">
            <summary>
            If this symbol represents a metadata module returns the underlying <see cref="T:Microsoft.CodeAnalysis.ModuleMetadata"/>.
            
            Otherwise, this returns <see langword="null"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MutableTypeMap">
            <summary>
            Utility class for substituting actual type arguments for formal generic type parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent">
            <summary>
            A NamespaceExtent represents whether a namespace contains types and sub-namespaces from a
            particular module, assembly, or merged across all modules (source and metadata) in a
            particular compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.Kind">
            <summary>
            Returns what kind of extent: Module, Assembly, or Compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.Module">
            <summary>
            If the Kind is ExtendKind.Module, returns the module symbol that this namespace
            encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.Assembly">
            <summary>
            If the Kind is ExtendKind.Assembly, returns the assembly symbol that this namespace
            encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.Compilation">
            <summary>
            If the Kind is ExtendKind.Compilation, returns the compilation symbol that this
            namespace encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol)">
            <summary>
            Create a NamespaceExtent that represents a given ModuleSymbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <summary>
            Create a NamespaceExtent that represents a given AssemblySymbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.#ctor(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Create a NamespaceExtent that represents a given Compilation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol">
            <summary>
            Represents either a namespace or a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.IsNamespace">
            <summary>
            Returns true if this symbol is a namespace. If it is not a namespace, it must be a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.IsType">
            <summary>
            Returns true if this symbols is a type. Equivalent to !IsNamespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the "virtual" modifier. Does not return true for
            members declared as abstract or override.
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the "override" modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            "extern" modifier. 
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetMembersUnordered">
            <summary>
            Get all the members of this symbol. The members may not be in a particular order, and the order
            may not be stable from call-to-call.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetTypeMembersUnordered">
            <summary>
            Get all the members of this symbol that are types. The members may not be in a particular order, and the order
            may not be stable from call-to-call.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An IEnumerable containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty IEnumerable. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetSourceTypeMember(Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax)">
            <summary>
            Get a source type symbol for the given declaration syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetSourceTypeMember(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax)">
            <summary>
            Get a source type symbol for the given declaration syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetSourceTypeMember(System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Get a source type symbol of given name, arity and kind.  If a tree and syntax are provided, restrict the results
            to those that are declared within the given syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.LookupMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup an immediately nested type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedTypeName">
            Simple type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetNamespaceOrTypeByQualifiedName(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Finds types or namespaces described by a qualified name.
            </summary>
            <param name="qualifiedName">Sequence of simple plain names.</param>
            <returns>
            A set of namespace or type symbols with given qualified name (might comprise of types with multiple generic arities), 
            or an empty set if the member can't be found (the qualified name is ambiguous or the symbol doesn't exist).
            </returns>
            <remarks>
            "C.D" matches C.D, C{T}.D, C{S,T}.D{U}, etc.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NativeIntegerTypeSymbol">
            <summary>
            This wrapper is only used on platforms where System.IntPtr isn't considered
            a numeric type (as indicated by a RuntimeFeature flag).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NativeIntegerTypeSymbol.GetMembers">
            <summary>
            Certain members from the underlying types are not exposed from the native integer types:
              constructors other than the default parameterless constructor are not supported;
              operators are handled explicitly as built-in operators and conversions;
              0 should be used instead of Zero;
              sizeof() should be used instead of Size;
              + and - should be used instead of Add() and Subtract();
              ToInt32(), ToInt64(), ToPointer() should be used from underlying types only.
            The remaining members are exposed on the native integer types with appropriate
            substitution of underlying types in the signatures.
            Specifically, we expose public, non-generic instance and static methods and properties
            other than those named above.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NativeIntegerTypeSymbol.SubstituteUnderlyingType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations)">
            <summary>
            Replaces references to underlying type with references to native integer type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NativeIntegerTypeSymbol.SubstituteUnderlyingType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Replaces references to underlying type with references to native integer type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> that represents
            an assembly that is not missing, i.e. the "real" thing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol._emittedNameToTypeMap">
            <summary>
            This is a cache similar to the one used by MetaImport::GetTypeByName
            in native compiler. The difference is that native compiler pre-populates 
            the cache when it loads types. Here we are populating the cache only
            with things we looked for, so that next time we are looking for the same 
            thing, the lookup is fast. This cache also takes care of TypeForwarders. 
            Gives about 8% win on subsequent lookups in some scenarios.     
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol.IsMissing">
            <summary>
            Does this symbol represent a missing assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol.GlobalNamespace">
            <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol.LookupTopLevelMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol},System.Boolean)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.  Detect cycles during lookup.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <param name="visitedAssemblies">
            List of assemblies lookup has already visited (since type forwarding can introduce cycles).
            </param>
            <param name="digThroughForwardedTypes">
            Take forwarded types into account.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol.CachedTypeByEmittedName(System.String)">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol.EmittedNameToTypeMapCount">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol"/> that represents
            a module that is not missing, i.e. the "real" thing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol._moduleReferences">
            <summary>
            An array of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> objects corresponding to assemblies directly referenced by this module.
            </summary>
            <remarks>
            The contents are provided by ReferenceManager and may not be modified.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol.IsMissing">
            <summary>
            Does this symbol represent a missing module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol.GetReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
            should correspond to each other.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol.GetReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from GetReferencedAssemblies and 
            from GetReferencedAssemblySymbols should correspond to each other. If reference is 
            not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
            corresponding item.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol.SetReferences(Microsoft.CodeAnalysis.ModuleReferences{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol},Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol)">
            <summary>
            A helper method for ReferenceManager to set assembly identities for assemblies 
            referenced by this module and corresponding AssemblySymbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NoPiaAmbiguousCanonicalTypeSymbol">
            <summary>
            A NoPiaAmbiguousCanonicalTypeSymbol is a special kind of ErrorSymbol that represents a NoPia
            embedded type symbol that was attempted to be substituted with canonical type, but the
            canonical type was ambiguous.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NoPiaIllegalGenericInstantiationSymbol">
            <summary>
            A NoPiaIllegalGenericInstantiationSymbol is a special kind of ErrorSymbol that represents a
            generic type instantiation that cannot cross assembly boundaries according to NoPia rules.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NoPiaMissingCanonicalTypeSymbol">
            <summary>
            A NoPiaMissingCanonicalTypeSymbol is a special kind of ErrorSymbol that represents a NoPia
            embedded type symbol that was attempted to be substituted with canonical type, but the
            canonical type couldn't be found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NullableContextKind">
            <summary>
            Used by symbol implementations (source and metadata) to represent the value
            that was mapped from, or will be mapped to a [NullableContext] attribute.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.NullableContextKind.Unknown">
            <summary>
            Uninitialized state
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.NullableContextKind.None">
            <summary>
            No [NullableContext] attribute
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.NullableContextKind.Oblivious">
            <summary>
            [NullableContext(0)]
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.NullableContextKind.NotAnnotated">
            <summary>
            [NullableContext(1)]
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.NullableContextKind.Annotated">
            <summary>
            [NullableContext(2)]
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(Microsoft.CodeAnalysis.ObsoleteAttributeData@,System.Reflection.Metadata.EntityHandle,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol,System.Boolean,System.Boolean)">
            <summary>
            Initialize the ObsoleteAttributeData by fetching attributes and decoding ObsoleteAttributeData. This can be 
            done for Metadata symbol easily whereas trying to do this for source symbols could result in cycles.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ObsoleteAttributeHelpers.GetObsoleteDataFromMetadata(System.Reflection.Metadata.EntityHandle,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol,System.Boolean,System.Boolean)">
            <summary>
            Get the ObsoleteAttributeData by fetching attributes and decoding ObsoleteAttributeData. This can be 
            done for Metadata symbol easily whereas trying to do this for source symbols could result in cycles.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ObsoleteAttributeHelpers.GetObsoleteContextState(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean)">
            <summary>
            This method checks to see if the given symbol is Obsolete or if any symbol in the parent hierarchy is Obsolete.
            </summary>
            <returns>
            True if some symbol in the parent hierarchy is known to be Obsolete. Unknown if any
            symbol's Obsoleteness is Unknown. False, if we are certain that no symbol in the parent
            hierarchy is Obsolete.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BinderFlags)">
            <summary>
            Create a diagnostic for the given symbol. This could be an error or a warning based on
            the ObsoleteAttribute's arguments.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers">
            <summary>
            Encapsulates the MakeOverriddenOrHiddenMembers functionality for methods, properties (including indexers), 
            and events.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.MakeOverriddenOrHiddenMembersWorker(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Walk up the type hierarchy from ContainingType and list members that this
            member either overrides (accessible members with the same signature, if this
            member is declared "override") or hides (accessible members with the same name
            but different kinds, plus members that would be in the overrides list if
            this member were not declared "override").
            
            Members in the overridden list may be non-virtual or may have different
            accessibilities, types, accessors, etc.  They are really candidates to be
            overridden.
            
            Members in the hidden list are definitely hidden.
            
            Members in the runtime overridden list are indistinguishable from the members
            in the overridden list from the point of view of the runtime (see
            FindOtherOverriddenMethodsInContainingType for details).
            </summary>
            <remarks>
            In the presence of non-C# types, the meaning of "same signature" is rather
            complicated.  If this member isn't from source, then it refers to the runtime's
            notion of signature (i.e. including return type, custom modifiers, etc).
            If this member is from source, then the process is (conceptually) as follows.
            
            1) Walk up the type hierarchy, recording all matching members with the same
               signature, ignoring custom modifiers and return type.  Stop if a hidden
               member is encountered.
            2) Apply the following "tie-breaker" rules until you have at most one member,
               a) Prefer members in more derived types.
               b) Prefer an exact custom modifier match (i.e. none, for a source member).
               c) Prefer fewer custom modifiers (values/positions don't matter, just count).
               d) Prefer earlier in GetMembers order (within the same type).
            3) If a member remains, search its containing type for other members that
               have the same C# signature (overridden members) or runtime signature
               (runtime overridden members).
            
            In metadata, properties participate in overriding only through their accessors.
            That is, property/event accessors may implicitly or explicitly override other methods
            and a property/event can be considered to override another property/event if its accessors
            override those of the other property/event.
            This implementation (like Dev10) will not follow that approach.  Instead, it is
            based on spec section 10.7.5, which treats properties as entities in their own
            right.  If all property/event accessors have conventional names in metadata and nothing
            "unusual" is done with explicit overriding, this approach should produce the same
            results as an implementation based on accessor overriding.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.KnownOverriddenClassMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Compute a candidate overridden method when a method knows what method it is intended to
            override. This makes a particular difference when covariant returns are used, in which
            case the signature matching rules would not compute the correct overridden method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.MakePropertyAccessorOverriddenOrHiddenMembers(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol)">
            <summary>
            In the CLI, accessors are just regular methods and their overriding/hiding rules are the same as for
            regular methods.  In C#, however, accessors are intimately connected with their corresponding properties.
            Rather than walking up the type hierarchy from the containing type of this accessor, looking for members
            with the same name, MakePropertyAccessorOverriddenOrHiddenMembers delegates to the associated property.
            For an accessor to hide a member, the hidden member must be a corresponding accessor on a property hidden
            by the associated property.  For an accessor to override a member, the overridden member must be a
            corresponding accessor on a property (directly or indirectly) overridden by the associated property.
            
            Example 1:
            
            public class A { public virtual int P { get; set; } }
            public class B : A { public override int P { get { return 1; } } } //get only
            public class C : B { public override int P { set { } } } // set only
            
            C.P.set overrides A.P.set because C.P.set is the setter of C.P, which overrides B.P,
            which overrides A.P, which has A.P.set as a setter.
            
            Example 2:
            
            public class A { public virtual int P { get; set; } }
            public class B : A { public new virtual int P { get { return 1; } } } //get only
            public class C : B { public override int P { set { } } } // set only
            
            C.P.set does not override any method because C.P overrides B.P, which has no setter
            and does not override a property.
            </summary>
            <param name="accessor">This accessor.</param>
            <param name="associatedProperty">The property associated with this accessor.</param>
            <returns>Members overridden or hidden by this accessor.</returns>
            <remarks>
            This method is intended to return values consistent with the definition of C#, which
            may differ from the actual meaning at runtime.
            
            Note: we don't need a different path for interfaces - Property.OverriddenOrHiddenMembers handles that.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.MakeEventAccessorOverriddenOrHiddenMembers(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol)">
            <summary>
            In the CLI, accessors are just regular methods and their overriding/hiding rules are the same as for
            regular methods.  In C#, however, accessors are intimately connected with their corresponding events.
            Rather than walking up the type hierarchy from the containing type of this accessor, looking for members
            with the same name, MakeEventAccessorOverriddenOrHiddenMembers delegates to the associated event.
            For an accessor to hide a member, the hidden member must be a corresponding accessor on a event hidden
            by the associated event.  For an accessor to override a member, the overridden member must be a
            corresponding accessor on a event (directly or indirectly) overridden by the associated event.
            </summary>
            <param name="accessor">This accessor.</param>
            <param name="associatedEvent">The event associated with this accessor.</param>
            <returns>Members overridden or hidden by this accessor.</returns>
            <remarks>
            This method is intended to return values consistent with the definition of C#, which
            may differ from the actual meaning at runtime.
            
            Note: we don't need a different path for interfaces - Event.OverriddenOrHiddenMembers handles that.
            
            CONSIDER: It is an error for an event to have only one accessor.  Currently, we mimic the behavior for
            properties, for consistency, but an alternative approach would be to say that nothing is overridden.
            
            CONSIDER: is there a way to share code with MakePropertyAccessorOverriddenOrHiddenMembers?
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.MakeInterfaceOverriddenOrHiddenMembers(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean)">
            <summary>
            There are two key reasons why interface overriding/hiding is different from class overriding/hiding:
              1) interface members never override other members; and
              2) interfaces can extend multiple interfaces.
            The first difference doesn't require any special handling - as long as the members have IsOverride=false,
            the code for class overriding/hiding does the right thing.
            The second difference is more problematic.  For one thing, an interface member can hide a different member in
            each base interface.  We only report the first one, but we need to expose all of them in the API.  More importantly,
            multiple inheritance raises the possibility of diamond inheritance.  Spec section 13.2.5, Interface member access,
            says: "The intuitive rule for hiding in multiple-inheritance interfaces is simply this: If a member is hidden in any
            access path, it is hidden in all access paths."  For example, consider the following interfaces:
            
            interface I0 { void M(); }
            interface I1 : I0 { void M(); }
            interface I2 : I0, I1 { void M(); }
            
            I2.M does not hide I0.M, because it is already hidden by I1.M.  To make this work, we need to traverse the graph
            of ancestor interfaces in topological order and flag ones later in the enumeration that are hidden along some path.
            </summary>
            <remarks>
            See SymbolPreparer::checkIfaceHiding.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.FindOverriddenOrHiddenMembersInType(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol@,System.Boolean@,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol}@)">
            <summary>
            Look for overridden or hidden members in a specific type.
            </summary>
            <param name="member">Member that is hiding or overriding.</param>
            <param name="memberIsFromSomeCompilation">True if member is from the current compilation.</param>
            <param name="memberContainingType">The type that contains member (member.ContainingType).</param>
            <param name="knownOverriddenMember">The known overridden member (e.g. in the presence of a metadata methodimpl).</param>
            <param name="currType">The type to search.</param>
            <param name="currTypeBestMatch">
            A member with the same signature if currTypeHasExactMatch is true,
            a member with (a minimal number of) different custom modifiers if there is one,
            and null otherwise.</param>
            <param name="currTypeHasSameKindNonMatch">True if there's a member with the same name and kind that is not a match.</param>
            <param name="hiddenBuilder">Hidden members (same name, different kind) will be added to this builder.</param>
            <remarks>
            There is some similarity between this member and TypeSymbol.FindPotentialImplicitImplementationMemberDeclaredInType.
            When making changes to this member, think about whether or not they should also be applied in TypeSymbol.
            
            In incorrect or imported code, it is possible that both currTypeBestMatch and hiddenBuilder will be populated.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.FindRelatedMembers(System.Boolean,System.Boolean,Microsoft.CodeAnalysis.SymbolKind,Microsoft.CodeAnalysis.CSharp.Symbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol}@,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol}@)">
            <summary>
            If representative member is non-null and is contained in a constructed type, then find
            other members in the same type with the same signature.  If this is an override member,
            add them to the overridden and runtime overridden lists.  Otherwise, add them to the
            hidden list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.AddHiddenMemberIfApplicable(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol}@,Microsoft.CodeAnalysis.SymbolKind,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Some kinds of methods are not considered to be hideable by certain kinds of members.
            Specifically, methods, properties, and types cannot hide constructors, destructors,
            operators, conversions, or accessors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.FindOtherOverriddenMethodsInContainingType(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Having found the best member to override, we want to find members with the same signature on the
            best member's containing type.
            </summary>
            <param name="representativeMember">
            The member that we consider to be overridden (may have different custom modifiers from the overriding member).
            Assumed to already be in the overridden and runtime overridden lists.
            </param>
            <param name="overridingMemberIsFromSomeCompilation">
            If the best match was based on the custom modifier count, rather than the custom modifiers themselves 
            (because the overriding member is in the current compilation), then we should use the count when determining
            whether the override is ambiguous.
            </param>
            <param name="overriddenBuilder">
            If the declaring type is constructed, it's possible that two (or more) members have the same signature
            (including custom modifiers).  Return a list of such members so that we can report the ambiguity.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.FindOtherHiddenMembersInContainingType(Microsoft.CodeAnalysis.SymbolKind,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol}@)">
            <summary>
            Having found that we are hiding a method with exactly the same signature
            (including custom modifiers), we want to find methods with the same signature
            on the declaring type because they will also be hidden.
            (If the declaring type is constructed, it's possible that two or more
            methods have the same signature (including custom modifiers).)
            (If the representative member is an indexer, it's possible that two or more
            properties have the same signature (including custom modifiers, even in a
            non-generic type).
            </summary>
            <param name="hidingMemberKind">
            This kind of the hiding member.
            </param>
            <param name="representativeMember">
            The member that we consider to be hidden (must have exactly the same custom modifiers as the hiding member).
            Assumed to already be in hiddenBuilder.
            </param>
            <param name="hiddenBuilder">
            Will have all other members with the same signature (including custom modifiers) as 
            representativeMember added.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.RequiresExplicitOverride(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean@)">
            <summary>
            Determine if this method requires a methodimpl table entry to inform the runtime of the override relationship.
            </summary>
            <param name="warnAmbiguous">True if we should produce an ambiguity warning per https://github.com/dotnet/roslyn/issues/45453 .</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.GetFirstRuntimeOverriddenMethodIgnoringNewSlot(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean@)">
            <summary>
            Given a method, find the first method that it overrides from the perspective of the CLI.
            Key differences from C#: non-virtual methods are ignored, the RuntimeSignatureComparer
            is used (i.e. consider return types, ignore ref/out distinction).  Sets <paramref name="wasAmbiguous"/>
            to true if more than one method is overridden by CLI rules.
            </summary>
            <remarks>
            WARN: Must not check method.MethodKind - PEMethodSymbol.ComputeMethodKind uses this method.
            NOTE: Does not check whether the given method will be marked "newslot" in metadata (as
            "newslot" is used for covariant method overrides).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.IsOverriddenSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <remarks>
            Note that the access check is done using the original definitions.  This is because we want to avoid
            reductions in accessibility that result from type argument substitution (e.g. if an inaccessible type
            has been passed as a type argument).
            See DevDiv #11967 for an example.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersResult">
            <summary>
            Groups the information computed by MakeOverriddenOrHiddenMembers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersResult.GetOverriddenMember">
            <summary>
            It is not suitable to call this method on a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersResult"/> object
            associated with a member within substituted type, <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersResult.GetOverriddenMember(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol)"/>
            should be used instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.PlaceholderTypeArgumentSymbol">
            <summary>
            Used for lightweight binding of type constraints. Instead of binding type arguments,
            we'll just use these placeholders instead. That's good enough binding to compute
            <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsValueType"/> with minimal binding.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.PEPropertyOrEventHelpers">
            <summary>
            Helper methods that exist to share code between properties and events.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbolExtensions.GetOwnOrInheritedGetMethod(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol)">
            <summary>
            If the property has a GetMethod, return that.  Otherwise check the overridden
            property, if any.  Repeat for each overridden property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbolExtensions.GetOwnOrInheritedSetMethod(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol)">
            <summary>
            If the property has a SetMethod, return that.  Otherwise check the overridden
            property, if any.  Repeat for each overridden property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PublicModel.NamedTypeSymbol.Microsoft#CodeAnalysis#INamedTypeSymbol#TupleElements">
             <summary>
             Returns fields that represent tuple elements for types that are tuples.
            
             If this type is not a tuple, then returns default.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PublicModel.NamedTypeSymbol.Microsoft#CodeAnalysis#INamedTypeSymbol#TupleUnderlyingType">
            <summary>
            If this is a tuple type with element names, returns the symbol for the tuple type without names.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.RangeVariableSymbol">
            <summary>
            A RangeVariableSymbol represents an identifier introduced in a query expression as the
            identifier of a "from" clause, an "into" query continuation, a "let" clause, or a "join" clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.RangeVariableSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ReducedExtensionMethodSymbol">
            <summary>
            An extension method with the "this" parameter removed.
            Used for the public binding API only, not for compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ReducedExtensionMethodSymbol.Create(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Return the extension method in reduced form if the extension method
            is applicable, and satisfies type parameter constraints, based on the
            "this" argument type. Otherwise, returns null.
            </summary>
            <param name="compilation">Compilation used to check constraints.
            The latest language version is assumed if this is null.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ReducedExtensionMethodSymbol.InferExtensionMethodTypeArguments(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            If the extension method is applicable based on the "this" argument type, return
            the method constructed with the inferred type arguments. If the method is not an
            unconstructed generic method, type inference is skipped. If the method is not
            applicable, or if constraints when inferring type parameters from the "this" type
            are not satisfied, the return value is null.
            </summary>
            <param name="compilation">Compilation used to check constraints.  The latest language version is assumed if this is null.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyMethodSymbol">
            <summary>
            A representation of a method symbol that is intended only to be used for comparison purposes
            (esp in MethodSignatureComparer).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyParameterSymbol">
            <summary>
            Intended to be used to create ParameterSymbols for a SignatureOnlyMethodSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyPropertySymbol">
            <summary>
            A representation of a property symbol that is intended only to be used for comparison purposes
            (esp in PropertySignatureComparer).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.OrderAllDependencies(Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.FieldInfo},System.Boolean)">
            <summary>
            Generate a list containing the given field and all dependencies
            of that field that require evaluation. The list is ordered by
            dependencies, with fields with no dependencies first. Cycles are
            broken at the first field lexically in the cycle. If multiple threads
            call this method with the same field, the order of the fields
            returned should be the same, although some fields may be missing
            from the lists in some threads as other threads evaluate fields.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.Node`1.Dependencies">
            <summary>
            The set of fields on which the field depends.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.Node`1.DependedOnBy">
            <summary>
            The set of fields that depend on the field.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.CreateGraph(System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference,Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.Node{Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference}},Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference,System.Boolean)">
            <summary>
            Build a dependency graph (a map from
            field to dependencies).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.CrefTypeParameterSymbol">
            <summary>
            Type parameters in documentation comments are complicated since they sort of act as declarations,
            rather than references.  Consider the following example:
            
            <![CDATA[
            /// <summary>See <see cref="B{U}.M(U)" />.</summary>
            class B<T> { void M(T t) { } }
            ]]>
            
            We make some key observations:
              1) The type parameter name in the cref is not tied to the type parameter name in the type declaration.
              2) A relationship exists between the two occurrences of "U" in the cref: they both refer to (or define)
                   the same symbol.
            
            In Roslyn, we've decided on the following representation: within the (entire) scope of a cref, the names
            of all type parameters "declared" in the cref are in scope and bind to the corresponding type parameters.
            This representation has one major advantage: as long as the appropriate binder (i.e. the one that knows
            about the implicitly-declared type parameters) is used, TypeSyntaxes within the cref can be bound by
            calling BindType.  In addition to eliminating the necessity for custom binding code in the batch case,
            this reduces the problem of exposing such nodes in the SemanticModel to one of ensuring that the right
            enclosing binder is chosen.  That is, new code will have to be written to handle CrefSyntaxes, but the
            existing code for TypeSyntaxes should just work!
            
            In the example above, this means that, between the cref quotation marks, the name "U" binds to an
            implicitly declared type parameter, whether it is in "B{U}", "M{U}", or "M{List{U[]}}".
            
            Of course, it's not all gravy.  One thing we're giving up by using this representation is the ability to
            distinguish between "declared" type parameters with the same name.  Consider the following example:
            
            <![CDATA[
            <summary>See <see cref=""A{T, T}.M(T)""/>.</summary>
            class A<T, U>
            {
                void M(T t) { }
                void M(U u) { }
            }
            ]]>
            </summary>
            
            The native compiler interprets this in the same way as it would interpret A{T1, T2}.M(T2) and unambiguously
            (i.e. without a warning) binds to A{T, U}.M(U).  Since Roslyn does not distinguish between the T's, Roslyn
            reports an ambiguity warning and picks the first method.  Furthermore, renaming one 'T' will rename all of
            them.
            
            This class represents such an implicitly declared type parameter.  The declaring syntax is expected to be
            an IdentifierNameSyntax in the type argument list of a QualifiedNameSyntax.
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CustomModifierUtils.CopyMethodCustomModifiers(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol}@,System.Boolean)">
            <remarks>
            Out params are updated by assignment.  If you require thread-safety, pass temps and then
            CompareExchange them back into shared memory.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CustomModifierUtils.CopyTypeCustomModifiers(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <param name="sourceType">Type that already has custom modifiers.</param>
            <param name="destinationType">Same as <paramref name="sourceType"/>, but without custom modifiers.
            May differ in object/dynamic, tuple element names, or other differences ignored by the runtime.</param>
            <param name="containingAssembly">The assembly containing the signature referring to the destination type.</param>
            <returns><paramref name="destinationType"/> with custom modifiers copied from <paramref name="sourceType"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ExplicitInterfaceHelpers.FindExplicitImplementationCollisions(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Given a member, look for other members contained in the same type with signatures that will
            not be distinguishable by the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbolWithAttributesAndModifiers.AttributeDeclarationSyntaxList">
            <summary>
            Gets the syntax list of custom attributes applied on the symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbolWithAttributesAndModifiers.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbolWithAttributesAndModifiers.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbolWithAttributesAndModifiers.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes.
            Returns an empty bag if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbolWithAttributesAndModifiers.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbolWithAttributesAndModifiers.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbolWithAttributesAndModifiers.VerifyConstantValueMatches(Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation}@)">
            <summary>
            Verify the constant value matches the default value from any earlier attribute
            (DateTimeConstantAttribute or DecimalConstantAttribute).
            If not, report ERR_FieldHasMultipleDistinctConstantValues.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.GlobalExpressionVariable">
            <summary>
            Represents expression and deconstruction variables declared in a global statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.GlobalExpressionVariable._typeSyntaxOpt">
            <summary>
            The type syntax, if any, from source. Optional for patterns that can omit an explicit type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.GlobalExpressionVariable.SetType(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations)">
            <summary>
            Can add some diagnostics into <paramref name="diagnostics"/>. 
            Returns the type that it actually locks onto (it's possible that it had already locked onto ErrorType).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.GlobalExpressionVariable.SetTypeWithAnnotations(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Can add some diagnostics into <paramref name="diagnostics"/>.
            Returns the type that it actually locks onto (it's possible that it had already locked onto ErrorType).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol">
            <summary>
            Implemented by symbols that can be targeted by an attribute declaration (i.e. source symbols).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AttributesOwner">
            <summary>
            Returns the owner of attributes that apply to this symbol.
            </summary>
            <remarks>
            Attributes for this symbol might be retrieved from attribute list of another (owning) symbol.
            In that case this property returns that owning symbol, otherwise it returns "this".
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AllowedAttributeLocations">
            <summary>
            Returns a bit set of attribute locations applicable to this symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation">
            <summary>
            Attribute location corresponding to this symbol.
            </summary>
            <remarks>
            Location of an attribute if an explicit location is not specified via attribute target specification syntax.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ImplicitNamedTypeSymbol">
            <summary>
            Represents implicit, script and submission classes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ImplicitNamedTypeSymbol.BaseTypeNoUseSiteDiagnostics">
            <summary>
            Returns null for a submission class.
            This ensures that a submission class does not inherit methods such as ToString or GetHashCode.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.IndexedTypeParameterSymbol">
            <summary>
            Indexed type parameters are used in place of type parameters for method signatures.  There is
            a unique mapping from index to a single IndexedTypeParameterSymbol.  
            
            They don't have a containing symbol or locations.
            
            They do not have constraints, variance, or attributes. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.IndexedTypeParameterSymbol.TakeSymbols(System.Int32)">
            <summary>
            Create a vector of n dummy type parameters.  Always reuses the same type parameter symbol
            for the same position.
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LambdaSymbol.ReturnTypeIsBeingInferred">
            <summary>
            This symbol is used as the return type of a LambdaSymbol when we are interpreting
            lambda's body in order to infer its return type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LambdaSymbol.InferenceFailureReturnType">
            <summary>
            This symbol is used as the return type of a LambdaSymbol when we failed to infer its return type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LambdaSymbol.DiagnosticLocation">
            <summary>
            Locations[0] on lambda symbols covers the entire syntax, which is inconvenient but remains for compatibility.
            For better diagnostics quality, use the DiagnosticLocation instead, which points to the "delegate" or the "=>".
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalFunctionSymbol.ScopeBinder">
            <summary>
            Binder that owns the scope for the local function symbol, namely the scope where the
            local function is declared.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.QuickAttributeChecker">
            <summary>
            The QuickAttributeChecker applies a simple fast heuristic for determining probable
            attributes of certain kinds without binding attribute types, just by looking at the final syntax of an
            attribute usage.
            </summary>
            <remarks>
            It works by maintaining a dictionary of all possible simple names that might map to the given
            attribute.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.QuickAttributeHelpers.GetQuickAttributes(System.String,System.Boolean)">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.QuickAttributes"/> that corresponds to the particular type 
            <paramref name="name"/> passed in.  If <paramref name="inAttribute"/> is <see langword="true"/>
            then the name will be checked both as-is as well as with the 'Attribute' suffix.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceClonedParameterSymbol">
            <summary>
            Represents a source parameter cloned from another <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol"/>, when they must share attribute data and default constant value.
            For example, parameters on a property symbol are cloned to generate parameters on accessors.
            Similarly parameters on delegate invoke method are cloned to delegate begin/end invoke methods.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolBase">
            <summary>
            A source parameter, potentially with a default value, attributes, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolBase.BoundAttributesSource">
            <summary>
            Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source parameter symbols.
            </summary>
            <remarks>
            Used for parameters of partial implementation. We bind the attributes only on the definition
            part and copy them over to the implementation.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolBase.GetAttributeDeclarations">
            <summary>
            Gets the syntax list of custom attributes that declares attributes for this parameter symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolBase.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolBase.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolBase.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolBase.VerifyParamDefaultValueMatchesAttributeIfAny(Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Verify the default value matches the default value from any earlier attribute
            (DefaultParameterValueAttribute, DateTimeConstantAttribute or DecimalConstantAttribute).
            If not, report ERR_ParamDefaultValueDiffersFromAttribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolBase.IsOnPartialImplementation(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>
            Is the attribute syntax appearing on a parameter of a partial method implementation part?
            Since attributes are merged between the parts of a partial, we need to look at the syntax where the
            attribute appeared in the source to see if it corresponds to a partial method implementation part.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolBase.HasDefaultArgumentSyntax">
            <summary>
            True if the parameter has default argument syntax.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolBase.HasOptionalAttribute">
            <summary>
            True if the parameter is marked by <see cref="T:System.Runtime.InteropServices.OptionalAttribute"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventAccessorSymbol">
            <summary>
            This class represents an event accessor declared in source 
            (i.e. not one synthesized for a field-like event).
            </summary>
            <remarks>
            The accessors are associated with <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol">
            <summary>
            This class represents an event declared in source with explicit accessors
            (i.e. not a field-like event).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEnumConstantSymbol">
            <summary>
            Represents a constant field of an enum.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventAccessorSymbol">
            <summary>
            Base class for event accessors - synthesized and user defined.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventFieldSymbol">
            <summary>
            A delegate field associated with a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol"/>.
            </summary>
            <remarks>
            SourceFieldSymbol takes care of the initializer (plus "var" in the interactive case).
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol">
            <summary>
            This class represents an event declared in source.  It may be either
            field-like (see <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol"/>) or property-like (see
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol"/>).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.AttributeDeclarationSyntaxList">
            <summary>
            Gets the syntax list of custom attributes applied on the event symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol">
            <summary>
            This class represents an event declared in source without explicit accessors.
            It implicitly has thread safe accessors and an associated field (of the same
            name), unless it does not have an initializer and is either extern or inside
            an interface, in which case it only has accessors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol.AssociatedField">
            <summary>
            Backing field for field-like event. Will be null if the event
            has no initializer and is either extern or inside an interface.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference.GetConstantValueDependencies(System.Boolean)">
            <summary>
            Return the constant value dependencies. Compute the dependencies
            if necessary by evaluating the constant value but only persist the
            constant value if there were no dependencies. (If there are dependencies,
            the constant value will be re-evaluated after evaluating dependencies.)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLabelSymbol._switchCaseLabelConstant">
            <summary>
            Switch case labels have a constant expression associated with them.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLabelSymbol.SwitchCaseLabelConstant">
            <summary>
            If the label is a switch case label, returns the associated constant value with
            case expression, otherwise returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol">
            <summary>
            Represents a local variable in a method body.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol._containingSymbol">
            <summary>
            Might not be a method symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol._refEscapeScope">
            <summary>
            Scope to which the local can "escape" via aliasing/ref assignment.
            Not readonly because we can only know escape values after binding the initializer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol._valEscapeScope">
            <summary>
            Scope to which the local's values can "escape" via ordinary assignments.
            Not readonly because we can only know escape values after binding the initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.ScopeBinder">
            <summary>
            Binder that owns the scope for the local, the one that returns it in its <see cref="P:Microsoft.CodeAnalysis.CSharp.Binder.Locals"/> array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.TypeSyntaxBinder">
            <summary>
            Binder that should be used to bind type syntax for the local.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.MakeDeconstructionLocal(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Make a local variable symbol for an element of a deconstruction,
            which can be inferred (if necessary) by binding the enclosing statement.
            </summary>
            <param name="containingSymbol"></param>
            <param name="scopeBinder">
            Binder that owns the scope for the local, the one that returns it in its <see cref="P:Microsoft.CodeAnalysis.CSharp.Binder.Locals"/> array.
            </param>
            <param name="nodeBinder">
            Enclosing binder for the location where the local is declared.
            It should be used to bind something at that location.
            </param>
            <param name="closestTypeSyntax"></param>
            <param name="identifierToken"></param>
            <param name="kind"></param>
            <param name="deconstruction"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.MakeLocalSymbolWithEnclosingContext(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Make a local variable symbol whose type can be inferred (if necessary) by binding and enclosing construct.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.MakeLocal(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Binder,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Make a local variable symbol which can be inferred (if necessary) by binding its initializing expression.
            </summary>
            <param name="containingSymbol"></param>
            <param name="scopeBinder">
            Binder that owns the scope for the local, the one that returns it in its <see cref="P:Microsoft.CodeAnalysis.CSharp.Binder.Locals"/> array.
            </param>
            <param name="allowRefKind"></param>
            <param name="allowScoped"></param>
            <param name="typeSyntax"></param>
            <param name="identifierToken"></param>
            <param name="declarationKind"></param>
            <param name="initializer"></param>
            <param name="initializerBinderOpt">
            Binder that should be used to bind initializer, if different from the <paramref name="scopeBinder"/>.
            </param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.Name">
            <summary>
            Gets the name of the local variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.Locations">
            <summary>
            Gets the locations where the local symbol was originally defined in source.
            There should not be local symbols from metadata, and there should be only one local variable declared.
            TODO: check if there are multiple same name local variables - error symbol or local symbol?
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.LocalWithInitializer">
            <summary>
            Symbol for a local whose type can be inferred by binding its initializer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.LocalWithInitializer._constantTuple">
            <summary>
            Store the constant value and the corresponding diagnostics together
            to avoid having the former set by one thread and the latter set by
            another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.LocalWithInitializer.MakeConstantTuple(Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Determine the constant value of this local and the corresponding diagnostics.
            Set both to constantTuple in a single operation for thread safety.
            </summary>
            <param name="inProgress">Null for the initial call, non-null if we are in the process of evaluating a constant.</param>
            <param name="boundInitValue">If we already have the bound node for the initial value, pass it in to avoid recomputing it.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.ForEachLocalSymbol">
            <summary>
            Symbol for a foreach iteration variable that can be inferred by binding the
            collection element type of the foreach.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.ForEachLocalSymbol.ForEachLoopBinder">
            <summary>
            We initialize the base's ScopeBinder with a ForEachLoopBinder, so it is safe
            to cast it to that type here.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.ForEachLocalSymbol.ForbiddenZone">
            <summary>
            There is no forbidden zone for a foreach loop, because the iteration
            variable is not in scope in the collection expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.DeconstructionLocalSymbol">
            <summary>
            Symbol for a deconstruction local that might require type inference.
            For instance, local <c>x</c> in <c>var (x, y) = ...</c> or <c>(var x, int y) = ...</c>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol">
            <summary>
            Represents a named type symbol whose members are declared in source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.EffectiveAccessibility">
            <summary>
            Compute the "effective accessibility" of the current class for the purpose of warnings about unused fields.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializers">
            <summary>
            Encapsulates information about the non-type members of a (i.e. this) type.
              1) For non-initializers, symbols are created and stored in a list.
              2) For fields and properties/indexers, the symbols are stored in (1) and their initializers are
                 stored with other initialized fields and properties from the same syntax tree with
                 the same static-ness.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.TryCalculateSyntaxOffsetOfPositionInInitializer(System.Int32,Microsoft.CodeAnalysis.SyntaxTree,System.Boolean,System.Int32,System.Int32@)">
            <summary>
            Calculates a syntax offset of a syntax position that is contained in a property or field initializer (if it is in fact contained in one).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.HasPossibleWellKnownCloneMethod">
            <remarks>
            For source symbols, there can only be a valid clone method if this is a record, which is a
            simple syntax check. This will need to change when we generalize cloning, but it's a good
            heuristic for now.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetEarlyAttributeDecodingMembers">
             <summary>
             During early attribute decoding, we consider a safe subset of all members that will not
             cause cyclic dependencies.  Get all such members for this symbol.
            
             In particular, this method will return nested types and fields (other than auto-property
             backing fields).
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetEarlyAttributeDecodingMembers(System.String)">
             <summary>
             During early attribute decoding, we consider a safe subset of all members that will not
             cause cyclic dependencies.  Get all such members for this symbol that have a particular name.
            
             In particular, this method will return nested types and fields (other than auto-property
             backing fields).
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.AssertMemberExposure(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean)">
            <summary>
            The purpose of this function is to assert that the <paramref name="member"/> symbol
            is actually among the symbols cached by this type symbol in a way that ensures
            that any consumer of standard APIs to get to type's members is going to get the same 
            symbol (same instance) for the member rather than an equivalent, but different instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.FixPartialMember(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol)">
            <summary>
            Fix up a partial method by combining its defining and implementing declarations, updating the array of symbols (by name),
            and returning the combined symbol.
            </summary>
            <param name="symbols">The symbols array containing both the latent and implementing declaration</param>
            <param name="part1">One of the two declarations</param>
            <param name="part2">The other declaration</param>
            <returns>An updated symbols array containing only one method symbol representing the two parts</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckForMemberConflictWithPropertyAccessor(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Report an error if a member (other than a method) exists with the same name
            as the property accessor, or if a method exists with the same name and signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckForMemberConflictWithEventAccessor(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Report an error if a member (other than a method) exists with the same name
            as the event accessor, or if a method exists with the same name and signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetAccessorOrPropertyLocation(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,System.Boolean)">
            <summary>
            Return the location of the accessor, or if no accessor, the location of the property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetAccessorOrEventLocation(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,System.Boolean)">
            <summary>
            Return the location of the accessor, or if no accessor, the location of the event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ParametersMatchPropertyAccessor(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol})">
            <summary>
            Return true if the method parameters match the parameters of the
            property accessor, including the value parameter for the setter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ParametersMatchEventAccessor(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol})">
            <summary>
            Return true if the method parameters match the parameters of the
            event accessor, including the value parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.IsNullableEnabledForConstructorsAndInitializers(System.Boolean)">
            <summary>
            Returns true if the overall nullable context is enabled for constructors and initializers.
            </summary>
            <param name="useStatic">Consider static constructor and fields rather than instance constructors and fields.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetSynthesizedExplicitImplementations(System.Threading.CancellationToken)">
            <summary>
            In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a
            base type from another assembly) it is necessary for the compiler to generate explicit implementations for
            some interface methods.  They don't go in the symbol table, but if we are emitting, then we should
            generate code for them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ReportAccessorOfInterfacePropertyOrEvent(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            It's not interesting to report diagnostics on implementation of interface accessors
            if the corresponding events or properties are not implemented (i.e. we want to suppress
            cascading diagnostics).
            Caveat: Indexed property accessors are always interesting.
            Caveat: It's also uninteresting if a WinRT event is implemented by a non-WinRT event,
            or vice versa.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.IsValidOverrideReturnType(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Return true if <paramref name="overridingReturnType"/> is valid for the return type of an override method when the overridden method's return type is <paramref name="overriddenReturnType"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckValidNullableMethodOverride``1(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.ReportMismatchInReturnType{``0},Microsoft.CodeAnalysis.CSharp.Symbols.ReportMismatchInParameterType{``0},``0,System.Boolean)">
            <returns>
            <see langword="true"/> if a diagnostic was added. Otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.RequiresValidScopedOverrideForRefSafety(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Returns true if the method signature must match, with respect to scoped for ref safety,
            in overrides, interface implementations, or delegate conversions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ReportInvalidScopedOverrideAsError(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Returns true if a scoped mismatch should be reported as an error rather than a warning.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckValidScopedOverride``1(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.ReportMismatchInParameterType{``0},``0,System.Boolean,System.Boolean)">
            <summary>
            Returns true if a diagnostic was added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.AddHidingAbstractDiagnostic(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean@)">
            <summary>
            If necessary, report a diagnostic for a hidden abstract member.
            </summary>
            <returns>True if a diagnostic was reported.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckInterfaceUnification(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            It is invalid for a type to directly (vs through a base class) implement two interfaces that
            unify (i.e. are the same for some substitution of type parameters).
            </summary>
            <remarks>
            CONSIDER: check this while building up InterfacesAndTheirBaseInterfaces (only in the SourceNamedTypeSymbol case).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.SynthesizeInterfaceMemberImplementation(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.SymbolAndDiagnostics,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Though there is a method that C# considers to be an implementation of the interface method, that
            method may not be considered an implementation by the CLR.  In particular, implicit implementation
            methods that are non-virtual or that have different (usually fewer) custom modifiers than the
            interface method, will not be considered CLR overrides.  To address this problem, we either make
            them virtual (in metadata, not in C#), or we introduce an explicit interface implementation that
            delegates to the implicit implementation.
            </summary>
            <param name="implementingMemberAndDiagnostics">Returned from FindImplementationForInterfaceMemberWithDiagnostics.</param>
            <param name="interfaceMember">The interface method or property that is being implemented.</param>
            <returns>
            A synthesized forwarding method for the implementation, or information about MethodImpl entry that should be emitted,
            or default if neither needed.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.IsPossibleImplementationUnderRuntimeRules(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
             <summary>
             The CLR will only look for an implementation of an interface method in a type that
               1) declares that it implements that interface; or
               2) is a base class of a type that declares that it implements the interface but not
                    a subtype of a class that declares that it implements the interface.
            
             For example,
            
               interface I
               class A
               class B : A, I
               class C : B
               class D : C, I
            
             Suppose the runtime is looking for D's implementation of a member of I.  It will look in
             D because of (1), will not look in C, will look in B because of (1), and will look in A
             because of (2).
            
             The key point is that it does not look in C, which C# *does*.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.IsOverrideOfPossibleImplementationUnderRuntimeRules(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
             <summary>
             If C# picks a different implementation than the CLR (see IsPossibleImplementationUnderClrRules), then we might
             still be okay, but dynamic dispatch might result in C#'s choice getting called anyway.
             </summary>
             <remarks>
             This is based on SymbolPreparer::IsCLRMethodImplSame in the native compiler.
            
             ACASEY: What the native compiler actually does is compute the C# answer, compute the CLR answer,
             and then confirm that they override the same method.  What I've done here is check for the situations
             where the answers could disagree.  I believe the results will be equivalent.  If in doubt, a more conservative
             check would be implementingMethod.ContainingType.InterfacesAndTheirBaseInterfaces.Contains(@interface).
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.MethodChecks(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <remarks>
            Implementers should assume that a lock has been taken on MethodChecksLockObject.
            In particular, it should not (generally) be necessary to use CompareExchange to
            protect assignments to fields.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.MethodChecksLockObject">
            <summary>
            We can usually lock on the syntax reference of this method, but it turns
            out that some synthesized methods (e.g. field-like event accessors) also
            need to do method checks.  This property allows such methods to supply
            their own lock objects, so that we don't have to add a new field to every
            SourceMethodSymbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.Locations">
            <summary>
            Overridden by <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol"/>, 
            which might return locations of partial methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.CheckModifiersForBody(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Checks to see if a body is legal given the current modifiers.
            If it is not, a diagnostic is added with the current type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.IsExpressionBodied">
            <summary>
            Returns true if the method body is an expression, as expressed
            by the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax"/> syntax. False
            otherwise.
            </summary>
            <remarks>
            If the method has both block body and an expression body
            present, this is not treated as expression-bodied.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol">
            <summary>
            Base class to represent all source method-like symbols. This includes
            things like ordinary methods and constructors, and functions
            like lambdas and local functions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.GetTypeParameterConstraintTypes">
            <summary>
            If there are no constraints, returns an empty immutable array. Otherwise, returns an immutable
            array of types, indexed by the constrained type parameter in <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TypeParameters"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.GetTypeParameterConstraintKinds">
            <summary>
            If there are no constraints, returns an empty immutable array. Otherwise, returns an immutable
            array of kinds, indexed by the constrained type parameter in <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TypeParameters"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes">
            <summary>
            A source method that can have attributes, including a member method, accessor, or local function.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.GetInMethodSyntaxNode">
            <summary>
            Gets the syntax node used for the in-method binder.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.BoundAttributesSource">
            <summary>
            Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source method symbols.
            </summary>
            <remarks>
            Used for example for event accessors. The "remove" method delegates attribute binding to the "add" method.
            The bound attribute data are then applied to both accessors.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.GetAttributeDeclarations">
            <summary>
            Gets the syntax list of custom attributes that declares attributes for this method symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.GetReturnTypeAttributeDeclarations">
            <summary>
            Gets the syntax list of custom attributes that declares attributes for return type of this method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.GetDecodedReturnTypeWellKnownAttributeData">
            <summary>
            Returns information retrieved from custom attributes on return type in source, or null if the symbol is not source symbol or there are none.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.GetReturnTypeAttributesBag">
            <summary>
            Returns a bag of custom attributes applied on the method return value and data decoded from well-known attributes. Returns null if there are no attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.NoteAttributesComplete(System.Boolean)">
            <summary>
            Called when this thread loaded the method's attributes. For method symbols with completion state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.GetReturnTypeAttributes">
            <summary>
            Gets the attributes applied on the return value of this method symbol.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbolWithAttributes.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol">
            <summary>
            Represents the primary module of an assembly being built by compiler.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol._assemblySymbol">
            <summary>
            Owning assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol._sources">
            <summary>
            The declarations corresponding to the source files of this module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol._name">
            <summary>
            The name (contains extension)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.DeclaringCompilation">
            <remarks>
            This override is essential - it's a base case of the recursive definition.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol._lazyTypeParameterConstraintTypes">
            <summary>
            A collection of type parameter constraint types, populated when
            constraint types for the first type parameter are requested.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol._lazyTypeParameterConstraintKinds">
            <summary>
            A collection of type parameter constraint kinds, populated when
            constraint kinds for the first type parameter are requested.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.GetTypeParameterConstraintTypes(System.Int32)">
            <summary>
            Returns the constraint types for the given type parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.GetTypeParameterConstraintKind(System.Int32)">
            <summary>
            Returns the constraint kind for the given type parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.MergeConstraintTypesForPartialDeclarations(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintClause},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintClause}},Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Note, only nullability aspects are merged if possible, other mismatches are treated as failures.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.MergeConstraintKindsForPartialDeclarations(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintClause},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintClause}})">
            <summary>
            Note, only nullability aspects are merged if possible, other mismatches are treated as failures.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.GetAttributeDeclarations(System.Nullable{Microsoft.CodeAnalysis.CSharp.Symbols.QuickAttributes})">
            <summary>
            Gets all the attribute lists for this named type.  If <paramref name="quickAttributes"/> is provided
            the attribute lists will only be returned if there is reasonable belief that 
            the type has one of the attributes specified by <paramref name="quickAttributes"/> on it.
            This can avoid going back to syntax if we know the type definitely doesn't have an attribute
            on it that could be the one specified by <paramref name="quickAttributes"/>. Pass <see langword="null"/>
            to get all attribute declarations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.AddSynthesizedAttributes(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData}@)">
            <remarks>
            These won't be returned by GetAttributes on source methods, but they
            will be returned by GetAttributes on metadata symbols.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.BaseTypeNoUseSiteDiagnostics">
            <summary>
            Gets the BaseType of this type. If the base type could not be determined, then 
            an instance of ErrorType is returned. If this kind of type does not have a base type
            (for example, interfaces), null is returned. Also the special class System.Object
            always has a BaseType of null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.InterfacesNoUseSiteDiagnostics(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Gets the set of interfaces that this type directly implements. This set does not include
            interfaces that are base interfaces of directly implemented interfaces.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.IsRestrictedBaseType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Returns true if the type cannot be used as an explicit base class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.EnumValueField">
            <summary>
            For enum types, returns the synthesized instance field used
            for generating metadata. Returns null for non-enum types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.AliasesAndUsings._state">
            <summary>
            Completion state that tracks whether validation was done/not done/currently in process. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.MergedGlobalAliasesAndUsings._state">
            <summary>
            Completion state that tracks whether validation was done/not done/currently in process. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.RegisterDeclaredCorTypes">
            <summary>
            Register COR types declared in this namespace, if any, in the COR types cache.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol._lazyTypeParameterConstraintTypes">
            <summary>
            A collection of type parameter constraint types, populated when
            constraint types for the first type parameter is requested.
            Initialized in two steps. Hold a copy if accessing during initialization.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol._lazyTypeParameterConstraintKinds">
            <summary>
            A collection of type parameter constraint kinds, populated when
            constraint kinds for the first type parameter is requested.
            Initialized in two steps. Hold a copy if accessing during initialization.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol._otherPartOfPartial">
            <summary>
            If this symbol represents a partial method definition or implementation part, its other part (if any).
            This should be set, if at all, before this symbol appears among the members of its owner.  
            The implementation part is not listed among the "members" of the enclosing type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.OtherPartOfPartial">
            <summary>
            If this is a partial implementation part returns the definition part and vice versa.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.IsPartialDefinition">
            <summary>
            Returns true if this symbol represents a partial method definition (the part that specifies a signature but no body).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.IsPartialImplementation">
            <summary>
            Returns true if this symbol represents a partial method implementation (the part that specifies both signature and body).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.IsPartialWithoutImplementation">
            <summary>
            True if this is a partial method that doesn't have an implementation part.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.SourcePartialDefinition">
            <summary>
            Returns the implementation part of a partial method definition, 
            or null if this is not a partial method or it is the definition part.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.SourcePartialImplementation">
            <summary>
            Returns the definition part of a partial method implementation, 
            or null if this is not a partial method or it is the implementation part.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol.PartialMethodChecks(Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Report differences between the defining and implementing
            parts of a partial method. Diagnostics are reported on the
            implementing part, matching Dev10 behavior.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbolBase">
            <summary>
            Unlike <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOrdinaryMethodSymbol"/>, this type doesn't depend
            on any specific kind of syntax node associated with it. Any syntax node is good enough
            for it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol">
            <summary>
            Base class for parameters can be referred to from source code.
            </summary>
            <remarks>
            These parameters can potentially be targeted by an attribute specified in source code. 
            As an optimization we distinguish simple parameters (no attributes, no modifiers, etc.) and complex parameters.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol.HasOptionalAttribute">
            <summary>
            True if the parameter is marked by <see cref="T:System.Runtime.InteropServices.OptionalAttribute"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol.HasDefaultArgumentSyntax">
            <summary>
            True if the parameter has default argument syntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol.AddDeclarationDiagnostics(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            The declaration diagnostics for a parameter depend on the containing symbol.
            For instance, if the containing symbol is a method the declaration diagnostics
            go on the compilation, but if it is a local function it is part of the local
            function's declaration diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol.DeclaredScope">
            <summary>
            The declared scope. From source, this is from the <c>scope</c> keyword only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbolBase">
            <summary>
            Base class for all parameters that are emitted.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol.LocalAccessibility">
            <summary>
            Return Accessibility declared locally on the accessor, or
            NotApplicable if no accessibility was declared explicitly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol.LocalDeclaredReadOnly">
            <summary>
            Indicates whether this accessor itself has a 'readonly' modifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol.IsDeclaredReadOnly">
            <summary>
            Indicates whether this accessor is readonly due to reasons scoped to itself and its containing property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol.GetAccessorName(System.String,System.Boolean,System.Boolean)">
            <summary>
            If we are outputting a .winmdobj then the setter name is put_, not set_.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol.GetSyntax">
            <returns>
            The declaring syntax for the accessor, or property if there is no accessor-specific
            syntax.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.Flags">
            <summary>
            Condensed flags storing useful information about the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase"/>
            so that we do not have to go back to source to compute this data.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.Name">
            <remarks>
            To facilitate lookup, all indexer symbols have the same name.
            Check the MetadataName property to find the name that will be
            emitted (based on IndexerNameAttribute, or the default "Item").
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.IsIndexer">
            <remarks>
            Even though it is declared with an IndexerDeclarationSyntax, an explicit
            interface implementation is not an indexer because it will not cause the
            containing type to be emitted with a DefaultMemberAttribute (and even if
            there is another indexer, the name of the explicit implementation won't
            match).  This is important for round-tripping.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.CreateGetAccessorSymbol(System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            The method is called at the end of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase"/> constructor.
            The implementation may depend only on information available from the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase"/> type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.CreateSetAccessorSymbol(System.Boolean,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            The method is called at the end of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase"/> constructor.
            The implementation may depend only on information available from the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase"/> type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.BackingField">
            <summary>
            Backing field for automatically implemented property, or
            for a property with an initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.IsAccessibilityMoreRestrictive(Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Accessibility)">
            <summary>
            Return true if the accessor accessibility is more restrictive
            than the property accessibility, otherwise false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.SynthesizedSealedAccessorOpt">
            <summary>
            If this property is sealed, then we have to emit both accessors - regardless of whether
            they are present in the source - so that they can be marked final. (i.e. sealed).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.MakeSynthesizedSealedAccessor">
            <remarks>
            Only non-null for sealed properties without both accessors.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.GetAttributesBag">
            <summary>
            Returns a bag of custom attributes applied on the property and data decoded from well-known attributes. Returns null if there are no attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbolBase.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceSimpleParameterSymbol">
            <summary>
            A source parameter that has no default value, no attributes,
            and is not params.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbolBase">
            <summary>
            Base class for type and method type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbolBase.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbolBase.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbolBase.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbolBase.CheckConstraintTypeConstraints(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Check constraints of generic types referenced in constraint types. For instance,
            with "interface I&lt;T&gt; where T : I&lt;T&gt; {}", check T satisfies constraints
            on I&lt;T&gt;. Those constraints are not checked when binding ConstraintTypes
            since ConstraintTypes has not been set on I&lt;T&gt; at that point.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenMethodTypeParameterMapBase">
            <summary>
            A map shared by all type parameters for an overriding method or a method
            that explicitly implements an interface. The map caches the overridden method
            and a type map from overridden type parameters to overriding type parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOverridingMethodTypeParameterSymbol">
            <summary>
            A type parameter for a method that either overrides a base
            type method or explicitly implements an interface method.
            </summary>
            <remarks>
            Exists to copy constraints from the corresponding type parameter of an overridden method.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOverridingMethodTypeParameterSymbol.OverriddenTypeParameter">
            <summary>
            The type parameter to use for determining constraints. If there is a base
            method that the owner method is overriding, the corresponding type
            parameter on that method is used. Otherwise, the result is null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData">
            <summary>
            Class to represent a synthesized attribute
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBuilder">
            <summary>
            A context for binding type parameter symbols of named types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType">
            <summary>
            Type parameter has no type constraints, including `struct`, `class`, `unmanaged` and is declared in a context 
            where nullable annotations are disabled.
            Cannot be combined with <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintKind.ReferenceType"/>, <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintKind.ValueType"/> or <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintKind.Unmanaged"/>.
            Note, presence of this flag suppresses generation of Nullable attribute on the corresponding type parameter.
            This imitates the shape of metadata produced by pre-nullable compilers. Metadata import is adjusted accordingly
            to distinguish between the two situations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintKind.PartialMismatch">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintKind"/> mismatch is detected during merging process for partial type declarations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintKind.AllReferenceTypeKinds">
            <summary>
            All bits involved into describing various aspects of 'class' constraint. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintKind.AllValueTypeKinds">
            <summary>
            Any of these bits is equivalent to presence of 'struct' constraint. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintKind.AllNonNullableKinds">
            <summary>
            All bits except those that are involved into describing various nullability aspects.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintClause">
            <summary>
            A simple representation of a type parameter constraint clause
            as a set of constraint bits and a set of constraint types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedNamedTypeSymbol">
            <summary>
            Either a SubstitutedNestedTypeSymbol or a ConstructedNamedTypeSymbol, which share in common that they
            have type parameters substituted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolCompletionState._completeParts">
            <summary>
            This field keeps track of the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.CompletionPart"/>s for which we already retrieved
            diagnostics. We shouldn't return from ForceComplete (i.e. indicate that diagnostics are
            available) until this is equal to <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.CompletionPart.All"/>, except that when completing
            with a given position, we might not complete <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.CompletionPart"/>.Member*.
            
            Since completeParts is used as a flag indicating completion of other assignments 
            it must be volatile to ensure the read is not reordered/optimized to happen 
            before the writes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolCompletionState.DefaultForceComplete(Microsoft.CodeAnalysis.CSharp.Symbol,System.Threading.CancellationToken)">
            <summary>
            Used to force (source) symbols to a given state of completion when the only potential remaining 
            part is attributes. This does force the invariant on the caller that the implementation of 
            of <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetAttributes"/> will set the part <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.CompletionPart.Attributes"/> on
            the thread that actually completes the loading of attributes. Failure to do so will potentially
            result in a deadlock.
            </summary>
            <param name="symbol">The owning source symbol.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolCompletionState.NextIncompletePart">
            <summary>
            Produce the next (i.e. lowest) CompletionPart (bit) that is not set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolCompletionState.HasAtMostOneBitSet(System.Int32)">
            <remarks>
            Since this formula is rather opaque, a demonstration of its correctness is
            provided in Roslyn.Compilers.CSharp.UnitTests.CompletionTests.TestHasAtMostOneBitSet.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolEqualityComparer.IgnoringDynamicTupleNamesAndNullability">
            <summary>
            A comparer that treats dynamic and object as "the same" types, and also ignores tuple element names differences.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedNamespaceSymbol">
            <summary>
            Synthesized namespace that contains synthesized types or subnamespaces.
            All its members are stored in a table on <see cref="T:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNameParser.TryParseLocalFunctionName(System.String,System.String@)">
            <summary>
            Parses generated local function name out of a generated method name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNameParser.TryParseFileTypeName(System.String,System.String@,System.Byte[]@,System.String@)">
            <remarks>
            This method will work with either unmangled or mangled type names as input, but it does not remove any arity suffix if present.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNames.MakeSynthesizedDelegateName(Microsoft.CodeAnalysis.CSharp.Symbols.RefKindVector,System.Boolean,System.Int32)">
            <summary>
            Produces name of the synthesized delegate symbol that encodes the parameter byref-ness and return type of the delegate.
            The arity is appended via `N suffix in MetadataName calculation since the delegate is generic.
            </summary>
            <remarks>
            Logic here should match <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNames.TryParseSynthesizedDelegateName(System.String,Microsoft.CodeAnalysis.CSharp.Symbols.RefKindVector@,System.Boolean@,System.Int32@,System.Int32@)" />.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNames.TryParseSynthesizedDelegateName(System.String,Microsoft.CodeAnalysis.CSharp.Symbols.RefKindVector@,System.Boolean@,System.Int32@,System.Int32@)">
            <summary>
            Parses the name of a synthesized delegate out into the things it represents.
            </summary>
            <remarks>
            Logic here should match <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNames.MakeSynthesizedDelegateName(Microsoft.CodeAnalysis.CSharp.Symbols.RefKindVector,System.Boolean,System.Int32)" />.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedLocalWithValEscape">
            <summary>
            A synthesized local variable with a val escape scope.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordBaseEquals">
            <summary>
            If the record type is derived from a base record type Base, the record type includes
            a synthesized override of the strongly-typed Equals(Base other). The synthesized
            override is sealed. It is an error if the override is declared explicitly.
            The synthesized override returns Equals((object?)other).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordClone">
            <summary>
            If a virtual "clone" method is present in the base record, the synthesized "clone" method overrides it
            and the return type of the method is the current containing type if the "covariant returns" feature is
            supported and the override return type otherwise. An error is produced if the base record clone method
            is sealed. If a virtual "clone" method is not present in the base record, the return type of the clone
            method is the containing type and the method is virtual, unless the record is sealed or abstract.
            If the containing record is abstract, the synthesized clone method is also abstract.
            If the "clone" method is not abstract, it returns the result of a call to a copy constructor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordEqualityOperator">
             <summary>
             The record type includes synthesized '==' and '!=' operators equivalent to operators declared as follows:
            
             For record class:
             public static bool operator==(R? left, R? right)
                  => (object) left == right || ((object)left != null &amp;&amp; left.Equals(right));
             public static bool operator !=(R? left, R? right)
                  => !(left == right);
            
             For record struct:
             public static bool operator==(R left, R right)
                  => left.Equals(right);
             public static bool operator !=(R left, R right)
                  => !(left == right);
            
            The 'Equals' method called by the '==' operator is the 'Equals(R? other)' (<see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordEquals"/>).
            The '!=' operator delegates to the '==' operator. It is an error if the operators are declared explicitly.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordEqualityOperatorBase">
             <summary>
             The record type includes synthesized '==' and '!=' operators equivalent to operators declared as follows:
            
             For record class:
             public static bool operator==(R? left, R? right)
                  => (object) left == right || ((object)left != null &amp;&amp; left.Equals(right));
             public static bool operator !=(R? left, R? right)
                  => !(left == right);
            
             For record struct:
             public static bool operator==(R left, R right)
                  => left.Equals(right);
             public static bool operator !=(R left, R right)
                  => !(left == right);
            
            The 'Equals' method called by the '==' operator is the 'Equals(R? other)' (<see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordEquals"/>).
            The '!=' operator delegates to the '==' operator. It is an error if the operators are declared explicitly.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordEquals">
            <summary>
            Unless explicitly declared,  a record includes a synthesized strongly-typed overload
            of `Equals(R? other)` where `R` is the record type.
            The method is `public`, and the method is `virtual` unless the record type is `sealed`.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordGetHashCode">
            <summary>
            The record type includes a synthesized override of object.GetHashCode().
            The method can be declared explicitly. It is an error if the explicit
            declaration is sealed unless the record type is sealed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordInequalityOperator">
             <summary>
             The record type includes synthesized '==' and '!=' operators equivalent to operators declared as follows:
            
             For record class:
             public static bool operator==(R? left, R? right)
                  => (object) left == right || ((object)left != null &amp;&amp; left.Equals(right));
             public static bool operator !=(R? left, R? right)
                  => !(left == right);
            
             For record struct:
             public static bool operator==(R left, R right)
                  => left.Equals(right);
             public static bool operator !=(R left, R right)
                  => !(left == right);
            
            The 'Equals' method called by the '==' operator is the 'Equals(R? other)' (<see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordEquals"/>).
            The '!=' operator delegates to the '==' operator. It is an error if the operators are declared explicitly.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordObjectMethod">
            <summary>
            Common base for ordinary methods overriding methods from object synthesized by compiler for records.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordObjectMethod.VerifyOverridesMethodFromObject(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Returns true if reported an error
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordObjEquals">
            <summary>
            The record type includes a synthesized override of object.Equals(object? obj).
            It is an error if the override is declared explicitly. The synthesized override
            returns Equals(other as R) where R is the record type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordOrdinaryMethod">
            <summary>
            Common base for ordinary methods synthesized by compiler for records.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordPrintMembers">
            <summary>
            The `bool PrintMembers(StringBuilder)` method is responsible for printing members declared
            in the containing type that are "printable" (public fields and properties),
            and delegating to the base to print inherited printable members. Base members get printed first.
            It returns true if the record contains some printable members.
            The method is used to implement `ToString()`.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordToString">
             <summary>
             The record includes a synthesized override of object.ToString().
             For `record R(int I) { public int J; }` it prints `R { I = ..., J = ... }`.
            
             The method can be declared explicitly. It is an error if the explicit
             declaration does not match the expected signature or accessibility, or
             if the explicit declaration doesn't allow overriding it in a derived type and
             the record type is not sealed.
             It is an error if either synthesized or explicitly declared method doesn't
             override `object.ToString()` (for example, due to shadowing in intermediate base types, etc.).
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAccessorValueParameterSymbol">
            <summary>
            Represents the compiler generated value parameter for property/event accessor.
            This parameter has no source location/syntax, but may have attributes.
            Attributes with 'param' target specifier on the accessor must be applied to the this parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedBackingFieldSymbol">
            <summary>
            Represents a compiler generated backing field for an automatically implemented property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedContainer">
            <summary>
            A container synthesized for a lambda, iterator method, or async method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEmbeddedAttributeSymbolBase">
            <summary>
            Represents a compiler generated and embedded attribute type.
            This type has the following properties:
            1) It is non-generic, sealed, internal, non-static class.
            2) It derives from System.Attribute
            3) It has Microsoft.CodeAnalysis.EmbeddedAttribute
            4) It has System.Runtime.CompilerServices.CompilerGeneratedAttribute
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEmbeddedAttributeSymbol">
            <summary>
            Represents a compiler generated and embedded attribute type with a single default constructor
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEntryPointSymbol">
            <summary>
            Represents an interactive code entry point that is inserted into the compilation if there is not an existing one. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEntryPointSymbol.AsyncForwardEntryPoint">
            <summary> A synthesized entrypoint that forwards all calls to an async Main Method </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEntryPointSymbol.AsyncForwardEntryPoint._userMainReturnTypeSyntax">
            <summary> The syntax for the user-defined asynchronous main method. </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEntryPointSymbol.AsyncForwardEntryPoint.UserMain">
            <summary> The user-defined asynchronous main method. </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEnumValueFieldSymbol">
            <summary>
            Represents __value field of an enum.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEventAccessorSymbol">
            <summary>
            Event accessor that has been synthesized for a field-like event declared in source,
            or for an event re-abstraction in an interface.
            </summary>
            <remarks>
            Associated with <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol"/> and <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedFieldSymbol">
            <summary>
            Represents a compiler generated field.
            </summary>
            <summary>
            Represents a compiler generated field of given type and name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedFieldSymbolBase">
            <summary>
            Represents a compiler generated field or captured variable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedGlobalMethodSymbol">
            <summary>
            Represents a compiler generated synthesized method symbol
            that must be emitted in the compiler generated
            PrivateImplementationDetails class
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedGlobalMethodSymbol.ContainingSymbol">
            <summary>
            Synthesized methods that must be emitted in the compiler generated
            PrivateImplementationDetails class have null containing type symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedInstanceMethodSymbol">
            <summary>
            A base class for synthesized methods that want a this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedInstanceMethodSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedLocal">
            <summary>
            A synthesized local variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedLocal.ValEscapeScope">
            <summary>
            Compiler should always be synthesizing locals with correct escape semantics.
            Checking escape scopes is not valid here.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedLocal.RefEscapeScope">
            <summary>
            Compiler should always be synthesizing locals with correct escape semantics.
            Checking escape scopes is not valid here.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedParameterlessThrowMethod">
            <summary>
            Throws an exception of a given type using a parameterless constructor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedParameterSymbolBase">
            <summary>
            Represents a simple compiler generated parameter of a given type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedParameterSymbol.DeriveParameters(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            For each parameter of a source method, construct a corresponding synthesized parameter
            for a destination method.
            </summary>
            <param name="sourceMethod">Has parameters.</param>
            <param name="destinationMethod">Needs parameters.</param>
            <returns>Synthesized parameters to add to destination method.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSimpleProgramEntryPointSymbol._declaration">
            <summary>
            The corresponding <see cref="T:Microsoft.CodeAnalysis.CSharp.SingleTypeDeclaration"/>. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSubstitutedTypeParameterSymbol">
            <summary>
            A type parameter for a synthesized class or method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedThrowIfNullMethod">
            <summary>
            Throws a System.ArgumentNullException if 'argument' is null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedThrowMethod">
            <summary>
            Throws a System.ArgumentNullException with the given 'paramName'.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedThrowSwitchExpressionExceptionMethod">
            <summary>
            Throws a 'System.Runtime.CompilerServices.SwitchExpressionException' with the given 'unmatchedValue'.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSubstitutedLocalSymbol.ValEscapeScope">
            <summary>
            Compiler should always be synthesizing locals with correct escape semantics.
            Checking escape scopes is not valid here.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSubstitutedLocalSymbol.RefEscapeScope">
            <summary>
            Compiler should always be synthesizing locals with correct escape semantics.
            Checking escape scopes is not valid here.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSubstitutedLocalSymbol.Scope">
            <summary>
            Compiler should always be synthesizing locals with correct escape semantics.
            Checking escape scopes is not valid here.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TupleErrorFieldSymbol">
            <summary>
            Represents a field of a tuple type (such as (int, byte).Item1)
            that doesn't have a corresponding backing field within the tuple underlying type.
            Created in response to an error condition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TupleErrorFieldSymbol._tupleElementIndex">
            <summary>
            If this field represents a tuple element with index X
             2X      if this field represents Default-named element
             2X + 1  if this field represents Friendly-named element
            Otherwise, (-1 - [index in members array]);
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TupleErrorFieldSymbol.TupleElementIndex">
            <summary>
            If this is a field representing a tuple element,
            returns the index of the element (zero-based).
            Otherwise returns -1
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TupleElementFieldSymbol">
             <summary>
             A plain TupleElementFieldSymbol (as opposed to a TupleVirtualElementFieldSymbol) represents
             an element field of a tuple type (such as (int, byte).Item1) that is backed by a real field
             with the same name within the tuple underlying type.
            
             Note that original tuple fields (like 'System.ValueTuple`2.Item1') do not get wrapped.
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TupleElementFieldSymbol._tupleElementIndex">
            <summary>
            If this field represents a tuple element with index X
             2X      if this field represents Default-named element
             2X + 1  if this field represents Friendly-named element
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TupleElementFieldSymbol.TupleElementIndex">
            <summary>
            If this is a field representing a tuple element,
            returns the index of the element (zero-based).
            Otherwise returns -1
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TupleVirtualElementFieldSymbol">
             <summary>
             Represents an element field of a tuple type that is not backed by a real field
             with the same name within the tuple type.
            
             Examples
                 // alias to Item1 with a different name
                 (int a, byte b).a
            
                 // not backed directly by the type
                 (int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8).i8
            
                 // Item8, which is also not backed directly by the type
                 (int, int, int, int, int, int, int, int).Item8
            
             NOTE: For any virtual element, there is a nonvirtual way to access the same underlying field.
                   In scenarios where we need to enumerate actual fields of a struct,
                   virtual fields should be ignored.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeMap">
            <summary>
            Utility class for substituting actual type arguments for formal generic type parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds">
            <summary>
            The effective "bounds" of a type parameter: the constraint types, effective
            interface set, and effective base type, determined from the declared
            constraints, with any cycles removed. The fields are exposed by the
            TypeParameterSymbol as ConstraintTypes, Interfaces, and BaseType.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol},Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Creates a "late" bound instance with all fields set.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds.ConstraintTypes">
            <summary>
            The type parameters, classes, and interfaces explicitly declared as
            constraint types on the containing type parameter, with cycles removed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds.Interfaces">
            <summary>
            The set of interfaces explicitly declared on the containing type
            parameter and any type parameters on which the containing
            type parameter depends, with duplicates removed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds.EffectiveBaseClass">
            <summary>
            As defined in 10.1.5 of the specification.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds.DeducedBaseType">
            <summary>
            The "exact" effective base type. 
            In the definition of effective base type we abstract some concrete types to their base classes:
             * For each constraint of T that is a struct-type, R contains System.ValueType.
             * For each constraint of T that is an enumeration type, R contains System.Enum.
             * For each constraint of T that is a delegate type, R contains System.Delegate.
             * For each constraint of T that is an array type, R contains System.Array.
             * For each constraint of T that is a class-type C, R contains type C' which is constructed 
               from C by replacing all occurrences of dynamic with object.
            The reason is that the CLR doesn't support operations on generic parameters that would be needed 
            to work with these types. For example, ldelem instruction requires the receiver to be a specific array, 
            not a type parameter constrained to be an array.
            
            When computing the deduced type we don't perform this abstraction. We keep the original constraint T.
            Deduced base type is used to check that consistency rules are satisfied.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol">
            <summary>
            A TypeSymbol is a base class for all the symbols that represent a type
            in C#.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.InterfaceInfo.interfacesAndTheirBaseInterfaces">
            <summary>
            <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.InterfaceInfo.explicitInterfaceImplementationMap">
            <summary>
            key = interface method/property/event compared using <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.ExplicitInterfaceImplementationTargetMemberEqualityComparer"/>,
            value = explicitly implementing methods/properties/events declared on this type (normally a single value, multiple in case of
            an error).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.BaseTypeNoUseSiteDiagnostics">
            <summary>
            Gets the BaseType of this type. If the base type could not be determined, then 
            an instance of ErrorType is returned. If this kind of type does not have a base type
            (for example, interfaces), null is returned. Also the special class System.Object
            always has a BaseType of null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.InterfacesNoUseSiteDiagnostics(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Gets the set of interfaces that this type directly implements. This set does not include
            interfaces that are base interfaces of directly implemented interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.AllInterfacesNoUseSiteDiagnostics">
            <summary>
            The list of all interfaces of which this type is a declared subtype, excluding this type
            itself. This includes all declared base interfaces, all declared base interfaces of base
            types, and all declared base interfaces of those results (recursively).  Each result
            appears exactly once in the list. This list is topologically sorted by the inheritance
            relationship: if interface type A extends interface type B, then A precedes B in the
            list. This is not quite the same as "all interfaces of which this type is a proper
            subtype" because it does not take into account variance: AllInterfaces for
            IEnumerable&lt;string&gt; will not include IEnumerable&lt;object&gt;
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.EffectiveTypeNoUseSiteDiagnostics">
            <summary>
            If this is a type parameter returns its effective base class, otherwise returns this type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsDerivedFrom(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.TypeCompareKind,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Returns true if this type derives from a given type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsEqualToOrDerivedFrom(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.TypeCompareKind,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Returns true if this type is equal or derives from a given type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.Equals(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.TypeCompareKind)">
            <summary>
            Determines if this type symbol represent the same type as another, according to the language
            semantics.
            </summary>
            <param name="t2">The other type.</param>
            <param name="compareKind">
            What kind of comparison to use? 
            You can ignore custom modifiers, ignore the distinction between object and dynamic, or ignore tuple element names differences.
            </param>
            <returns>True if the types are equivalent.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.GetHashCode">
            <summary>
            We ignore custom modifiers, and the distinction between dynamic and object, when computing a type's hash code.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.MakeAllInterfaces">
            Produce all implemented interfaces in topologically sorted order. We use
            TypeSymbol.Interfaces as the source of edge data, which has had cycles and infinitely
            long dependency cycles removed. Consequently, it is possible (and we do) use the
            simplest version of Tarjan's topological sorting algorithm.
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics">
            <summary>
            Gets the set of interfaces that this type directly implements, plus the base interfaces
            of all such types. Keys are compared using <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolEqualityComparer.CLRSignature"/>,
            values are distinct interfaces corresponding to the key, according to <see cref="F:Microsoft.CodeAnalysis.TypeCompareKind.ConsiderEverything"/> rules.
            </summary>
            <remarks>
            CONSIDER: it probably isn't truly necessary to cache this.  If space gets tight, consider
            alternative approaches (recompute every time, cache on the side, only store on some types,
            etc).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.FindImplementationForInterfaceMember(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Returns the corresponding symbol in this type or a base type that implements 
            interfaceMember (either implicitly or explicitly), or null if no such symbol exists
            (which might be either because this type doesn't implement the container of
            interfaceMember, or this type doesn't supply a member that successfully implements
            interfaceMember).
            </summary>
            <param name="interfaceMember">
            Must be a non-null interface property, method, or event.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.TypeKind">
            <summary>
            Gets the kind of this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.SpecialType">
            <summary>
            Gets corresponding special TypeId of this type.
            </summary>
            <remarks>
            Not preserved in types constructed from this one.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.PrimitiveTypeCode">
            <summary>
            Gets corresponding primitive type code for this type declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsHighestPriorityUseSiteErrorCode(System.Int32)">
            <summary>
            Returns true if the error code is highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsAnonymousType">
            <summary>
            Is this a symbol for an anonymous type (including delegate).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsTupleType">
            <summary>
            Is this a symbol for a Tuple.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsNativeIntegerWrapperType">
            <summary>
            True if the type represents a native integer. In C#, the types represented
            by language keywords 'nint' and 'nuint' on platforms where they are not unified
            with 'System.IntPtr' and 'System.UIntPtr'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsTupleTypeOfCardinality(System.Int32)">
            <summary>
            Verify if the given type is a tuple of a given cardinality, or can be used to back a tuple type 
            with the given cardinality. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.TupleElementTypesWithAnnotations">
            <summary>
            If this symbol represents a tuple type, get the types of the tuple's elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.TupleElementNames">
            <summary>
            If this symbol represents a tuple type, get the names of the tuple's elements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.TupleElements">
            <summary>
            If this symbol represents a tuple type, get the fields for the tuple's elements.
            Otherwise, returns default.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsManagedType(Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Is this type a managed type (false for everything but enum, pointer, and
            some struct types).
            </summary>
            <remarks>
            See Type::computeManagedType.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.GetManagedKind(Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@)">
            <summary>
            Indicates whether a type is managed or not (i.e. you can take a pointer to it).
            Contains additional cases to help implement FeatureNotAvailable diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.MergeEquivalentTypes(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.VarianceKind)">
            <summary>
            Merges features of the type with another type where there is an identity conversion between them.
            The features to be merged are
            object vs dynamic (dynamic wins), tuple names (dropped in case of conflict), and nullable
            annotations (e.g. in type arguments).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsRefLikeType">
            <summary>
            Returns true if the type may contain embedded references
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsReadOnly">
            <summary>
            Returns true if the type is a readonly struct
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.FindImplementationForInterfaceMemberInNonInterfaceWithDiagnostics(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean)">
            <summary>
            Locate implementation of the <paramref name="interfaceMember"/> in context of the current type.
            The method is using cache to optimize subsequent calls for the same <paramref name="interfaceMember"/>.
            </summary>
            <param name="interfaceMember">Member for which an implementation should be found.</param>
            <param name="ignoreImplementationInInterfacesIfResultIsNotReady">
            The process of looking up an implementation for an accessor can involve figuring out how corresponding event/property is implemented,
            <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.CheckForImplementationOfCorrespondingPropertyOrEvent(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbol@)"/>. And the process of looking up an implementation for a property can
            involve figuring out how corresponding accessors are implemented, <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.FindMostSpecificImplementationInInterfaces(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)"/>. This can 
            lead to cycles, which could be avoided if we ignore the presence of implementations in interfaces for the purpose of
            <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.CheckForImplementationOfCorrespondingPropertyOrEvent(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbol@)"/>. Fortunately, logic in it allows us to ignore the presence of
            implementations in interfaces and we use that.
            When the value of this parameter is true and the result that takes presence of implementations in interfaces into account is not
            available from the cache, the lookup will be performed ignoring the presence of implementations in interfaces. Otherwise, result from
            the cache is returned.
            When the value of the parameter is false, the result from the cache is returned, or calculated, taking presence of implementations
            in interfaces into account and then cached.
            This means that:
             - A symbol from an interface can still be returned even when <paramref name="ignoreImplementationInInterfacesIfResultIsNotReady"/> is true.
               A subsequent call with <paramref name="ignoreImplementationInInterfacesIfResultIsNotReady"/> false will return the same value. 
             - If symbol from a non-interface is returned when <paramref name="ignoreImplementationInInterfacesIfResultIsNotReady"/> is true. A subsequent
               call with <paramref name="ignoreImplementationInInterfacesIfResultIsNotReady"/> false will return the same value.
             - If no symbol is returned for <paramref name="ignoreImplementationInInterfacesIfResultIsNotReady"/> true. A subsequent call with
               <paramref name="ignoreImplementationInInterfacesIfResultIsNotReady"/> might return a symbol, but that symbol guaranteed to be from an interface.
             - If the first request is done with <paramref name="ignoreImplementationInInterfacesIfResultIsNotReady"/> false. A subsequent call
               is guaranteed to return the same result regardless of <paramref name="ignoreImplementationInInterfacesIfResultIsNotReady"/> value.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.ComputeImplementationForInterfaceMember(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean,System.Boolean@)">
            <summary>
            Performs interface mapping (spec 13.4.4).
            </summary>
            <remarks>
            CONSIDER: we could probably do less work in the metadata and retargeting cases - we won't use the diagnostics.
            </remarks>
            <param name="interfaceMember">A non-null implementable member on an interface type.</param>
            <param name="implementingType">The type implementing the interface property (usually "this").</param>
            <param name="diagnostics">Bag to which to add diagnostics.</param>
            <param name="ignoreImplementationInInterfaces">Do not consider implementation in an interface as a valid candidate for the purpose of this computation.</param>
            <param name="implementationInInterfacesMightChangeResult">
            Returns true when <paramref name="ignoreImplementationInInterfaces"/> is true, the method fails to locate an implementation and an implementation in
            an interface, if any (its presence is not checked), could potentially be a candidate. Returns false otherwise.
            When true is returned, a different call with <paramref name="ignoreImplementationInInterfaces"/> false might return a symbol. That symbol, if any,
            is guaranteed to be from an interface.
            This parameter is used to optimize caching in <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.FindImplementationForInterfaceMemberInNonInterfaceWithDiagnostics(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean)"/>.
            </param>
            <returns>The implementing property or null, if there isn't one.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.FindMostSpecificImplementationInBases(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Microsoft.CodeAnalysis.CSharp.Symbol@,Microsoft.CodeAnalysis.CSharp.Symbol@)">
            <summary>
            One implementation M1 is considered more specific than another implementation M2 
            if M1 is declared on interface T1, M2 is declared on interface T2, and 
            T1 contains T2 among its direct or indirect interfaces.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsExplicitlyImplementedViaAccessors(System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CompoundUseSiteInfo{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol}@,Microsoft.CodeAnalysis.CSharp.Symbol@)">
            <summary>
            Since dev11 didn't expose a symbol API, it had the luxury of being able to accept a base class's claim that 
            it implements an interface.  Roslyn, on the other hand, needs to be able to point to an implementing symbol
            for each interface member.
            
            DevDiv #718115 was triggered by some unusual metadata in a Microsoft reference assembly (Silverlight System.Windows.dll).
            The issue was that a type explicitly implemented the accessors of an interface event, but did not tie them together with
            an event declaration.  To make matters worse, it declared its own protected event with the same name as the interface
            event (presumably to back the explicit implementation).  As a result, when Roslyn was asked to find the implementing member
            for the interface event, it found the protected event and reported an appropriate diagnostic.  What it should have done
            (and does do now) is recognize that no event associated with the accessors explicitly implementing the interface accessors
            and returned null.
            
            We resolved this issue by introducing a new step into the interface mapping algorithm: after failing to find an explicit
            implementation in a type, but before searching for an implicit implementation in that type, check for an explicit implementation
            of an associated accessor.  If there is such an implementation, then immediately return the associated property or event,
            even if it is null.  That is, never attempt to find an implicit implementation for an interface property or event with an
            explicitly implemented accessor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.CheckForImplementationOfCorrespondingPropertyOrEvent(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbol@)">
            <summary>
            If we were looking for an accessor, then look for an accessor on the implementation of the
            corresponding interface property/event.  If it is valid as an implementation (ignoring the name),
            then prefer it to our current result if:
              1) our current result is null; or
              2) our current result is on the same type.
              
            If there is no corresponding accessor on the implementation of the corresponding interface
            property/event and we found an accessor, then the accessor we found is invalid, so clear it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.ReportImplicitImplementationMatchDiagnostics(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            These diagnostics are for members that do implicitly implement an interface member, but do so
            in an undesirable way.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.ReportImplicitImplementationMismatchDiagnostics(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            These diagnostics are for members that almost, but not actually, implicitly implement an interface member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.GetInterfaceLocation(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Determine a better location for diagnostic squiggles.  Squiggle the interface rather than the class.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.FindPotentialImplicitImplementationMemberDeclaredInType(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol@,Microsoft.CodeAnalysis.CSharp.Symbol@)">
            <summary>
            Search the declared members of a type for one that could be an implementation
            of a given interface member (depending on interface declarations).
            </summary>
            <param name="interfaceMember">The interface member being implemented.</param>
            <param name="implementingTypeIsFromSomeCompilation">True if the implementing type is from some compilation (i.e. not from metadata).</param>
            <param name="currType">The type on which we are looking for a declared implementation of the interface member.</param>
            <param name="implicitImpl">A member on currType that could implement the interface, or null.</param>
            <param name="closeMismatch">A member on currType that could have been an attempt to implement the interface, or null.</param>
            <remarks>
            There is some similarity between this member and OverriddenOrHiddenMembersHelpers.FindOverriddenOrHiddenMembersInType.
            When making changes to this member, think about whether or not they should also be applied in MemberSymbol.
            One key difference is that custom modifiers are considered when looking up overridden members, but
            not when looking up implicit implementations.  We're preserving this behavior from Dev10.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsInterfaceMemberImplementation(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean)">
             <summary>
             To implement an interface member, a candidate member must be public, non-static, and have
             the same signature.  "Have the same signature" has a looser definition if the type implementing
             the interface is from source.
             </summary>
             <remarks>
             PROPERTIES:
             NOTE: we're not checking whether this property has at least the accessors
             declared in the interface.  Dev10 considers it a match either way and,
             reports failure to implement accessors separately.
            
             If the implementing type (i.e. the type with the interface in its interface
             list) is in source, then we can ignore custom modifiers in/on the property
             type because they will be copied into the bridge property that explicitly
             implements the interface property (or they would be, if we created such
             a bridge property).  Bridge *methods* (not properties) are inserted in 
             SourceMemberContainerTypeSymbol.SynthesizeInterfaceMemberImplementation.
            
             CONSIDER: The spec for interface mapping (13.4.4) could be interpreted to mean that this
             property is not an implementation unless it has an accessor for each accessor of the
             interface property.  For now, we prefer to represent that case as having an implemented
             property and an unimplemented accessor because it makes finding accessor implementations
             much easier.  If we decide that we want the API to report the property as unimplemented,
             then it might be appropriate to keep current result internally and just check the accessors
             before returning the value from the public API (similar to the way MethodSymbol.OverriddenMethod
             filters MethodSymbol.OverriddenOrHiddenMembers.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.GetBodyOfSynthesizedInterfaceMethodImpl(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            If implementation of an interface method <paramref name="interfaceMethod"/> will be accompanied with 
            a MethodImpl entry in metadata, information about which isn't already exposed through
            <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ExplicitInterfaceImplementations"/> API, this method returns the "Body" part
            of the MethodImpl entry, i.e. the method that implements the <paramref name="interfaceMethod"/>.
            Some of the MethodImpl entries could require synthetic forwarding methods. In such cases,
            the result is the method that the language considers to implement the <paramref name="interfaceMethod"/>,
            rather than the forwarding method. In other words, it is the method that the forwarding method forwards to.
            </summary>
            <param name="interfaceMethod">The interface method that is going to be implemented by using synthesized MethodImpl entry.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.SynthesizedInterfaceMethodImpls">
            <summary>
            Returns information about interface method implementations that will be accompanied with 
            MethodImpl entries in metadata, information about which isn't already exposed through
            <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ExplicitInterfaceImplementations"/> API. The "Body" is the method that
            implements the interface method "Implemented". 
            Some of the MethodImpl entries could require synthetic forwarding methods. In such cases,
            the "Body" is the method that the language considers to implement the interface method,
            the "Implemented", rather than the forwarding method. In other words, it is the method that 
            the forwarding method forwards to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.AbstractMembers">
            <summary>
            The set of abstract members in declared in this type or declared in a base type and not overridden.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.SymbolAndDiagnostics">
            <summary>
            Represents the method by which this type implements a given interface type
            and/or the corresponding diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsTypeParameterDisallowingAnnotationInCSharp8(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Assuming that nullable annotations are enabled:
            T => true
            T where T : struct => false
            T where T : class => false
            T where T : class? => true
            T where T : IComparable => true
            T where T : IComparable? => true
            T where T : notnull => true
            </summary>
            <remarks>
            In C#9, annotations are allowed regardless of constraints.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsPossiblyNullableReferenceTypeTypeParameter(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Assuming that nullable annotations are enabled:
            T => true
            T where T : struct => false
            T where T : class => false
            T where T : class? => true
            T where T : IComparable => false
            T where T : IComparable? => true
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsNullableType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
             <summary>
             Is this System.Nullable`1 type, or its substitution.
            
             To check whether a type is System.Nullable`1 or is a type parameter constrained to System.Nullable`1
             use <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsNullableTypeOrTypeParameter(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)" /> instead.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsValidAttributeParameterType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Determines if the given type is a valid attribute parameter type.
            </summary>
            <param name="type">Type to validated</param>
            <param name="compilation">compilation</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetAttributeParameterTypedConstantKind(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Gets the typed constant kind for the given attribute parameter type.
            </summary>
            <param name="type">Type to validated</param>
            <param name="compilation">compilation</param>
            <returns>TypedConstantKind for the attribute parameter type.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsExpressionTree(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Returns true if the type is constructed from a generic type named "System.Linq.Expressions.Expression"
            with one type parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsNonGenericExpressionType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Returns true if the type is a non-generic type named "System.Linq.Expressions.Expression"
            or "System.Linq.Expressions.LambdaExpression".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsGenericOrNonGenericExpressionType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@)">
            <summary>
            Returns true if the type is constructed from a generic type named "System.Linq.Expressions.Expression"
            with one type parameter, or if the type is a non-generic type named "System.Linq.Expressions.Expression"
            or "System.Linq.Expressions.LambdaExpression".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsPossibleArrayGenericInterface(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            return true if the type is constructed from a generic interface that 
            might be implemented by an array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetDefaultValue(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return the default value constant for the given type,
            or null if the default value is not a constant.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.VisitType``1(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Func{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,``0,System.Boolean,System.Boolean},``0,System.Boolean,System.Boolean)">
            <summary>
            Visit the given type and, in the case of compound types, visit all "sub type"
            (such as A in A[], or { A&lt;T&gt;, T, U } in A&lt;T&gt;.B&lt;U&gt;) invoking 'predicate'
            with the type and 'arg' at each sub type. If the predicate returns true for any type,
            traversal stops and that type is returned from this method. Otherwise if traversal
            completes without the predicate returning true for any type, this method returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.VisitType``1(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Func{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,``0,System.Boolean,System.Boolean},System.Func{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,``0,System.Boolean,System.Boolean},``0,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Visit the given type and, in the case of compound types, visit all "sub type".
            One of the predicates will be invoked at each type. If the type is a
            TypeWithAnnotations, <paramref name="typeWithAnnotationsPredicate"/>
            will be invoked; otherwise <paramref name="typePredicate"/> will be invoked.
            If the corresponding predicate returns true for any type,
            traversal stops and that type is returned from this method. Otherwise if traversal
            completes without the predicate returning true for any type, this method returns null.
            </summary>
            <param name="useDefaultType">If true, use <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.DefaultType"/>
            instead of <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.Type"/> to avoid early resolution of nullable types</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.ContainsTypeParameter(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol)">
            <summary>
            (null TypeParameterSymbol "parameter"): Checks if the given type is a type parameter 
            or its referent type is a type parameter (array/pointer) or contains a type parameter (aggregate type)
            (non-null TypeParameterSymbol "parameter"): above + also checks if the type parameter
            is the same as "parameter"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.ContainsDynamic(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return true if the type contains any dynamic type reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.ContainsTuple(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return true if the type contains any tuples.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.ContainsTupleNames(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return true if the type contains any tuples with element names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.ContainsFunctionPointer(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return true if the type contains any function pointer types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetNonErrorGuess(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Guess the non-error type that the given type was intended to represent.
            If the type itself is not an error type, then it will be returned.
            Otherwise, the underlying type (if any) of the error type will be
            returned.
            </summary>
            <remarks>
            Any non-null type symbol returned is guaranteed not to be an error type.
            
            It is possible to pass in a constructed type and received back an 
            unconstructed type.  This can occur when the type passed in was
            constructed from an error type - the underlying definition will be
            available, but there won't be a good way to "re-substitute" back up
            to the level of the specified type.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetNonErrorTypeKindGuess(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Guess the non-error type kind that the given type was intended to represent,
            if possible. If not, return TypeKind.Error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsValidV6SwitchGoverningType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Returns true if the type was a valid switch expression type in C# 6. We use this test to determine
            whether or not we should attempt a user-defined conversion from the type to a C# 6 switch governing
            type, which we support for compatibility with C# 6 and earlier.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsRestrictedType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Returns true if the type is one of the restricted types, namely: <see cref="T:System.TypedReference"/>, 
            <see cref="T:System.ArgIterator"/>, or <see cref="T:System.RuntimeArgumentHandle"/>.
            or a ref-like type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.MarkCheckedIfNecessary(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol}@)">
            <summary>
            Add this instance to the set of checked types. Returns true
            if this was added, false if the type was already in the set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsPrimitiveRecursiveStruct(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            These special types are structs that contain fields of the same type
            (e.g. <see cref="T:System.Int32"/> contains an instance field of type <see cref="T:System.Int32"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.ComputeHashCode(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Compute a hash code for the constructed type. The return value will be
            non-zero so callers can used zero to represent an uninitialized value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.AsDynamicIfNoPia(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            If we are in a COM PIA with embedInteropTypes enabled we should turn properties and methods 
            that have the type and return type of object, respectively, into type dynamic. If the requisite conditions 
            are fulfilled, this method returns a dynamic type. If not, it returns the original type.
            </summary>
            <param name="type">A property type or method return type to be checked for dynamification.</param>
            <param name="containingType">Containing type.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsVerifierReference(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Type variables are never considered reference types by the verifier.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsVerifierValue(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Type variables are never considered value types by the verifier.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetAllTypeParameters(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Return all of the type parameters in this type and enclosing types,
            from outer-most to inner-most type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetAllTypeParameters(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol})">
            <summary>
            Return all of the type parameters in this type and enclosing types,
            from outer-most to inner-most type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.FindEnclosingTypeParameter(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.String)">
            <summary>
            Return the nearest type parameter with the given name in
            this type or any enclosing type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.FindEnclosingTypeParameter(Microsoft.CodeAnalysis.CSharp.Symbol,System.String)">
            <summary>
            Return the nearest type parameter with the given name in
            this symbol or any enclosing symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.HasNameQualifier(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.String)">
            <summary>
            Return true if the fully qualified name of the type's containing symbol
            matches the given name. This method avoids string concatenations
            in the common case where the type is a top-level type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsCustomTaskType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Object@)">
            <summary>
            Returns true if the type is generic or non-generic custom task-like type due to the
            [AsyncMethodBuilder(typeof(B))] attribute. It returns the "B".
            </summary>
            <remarks>
            For the Task types themselves, this method might return true or false depending on mscorlib.
            The definition of "custom task-like type" is one that has an [AsyncMethodBuilder(typeof(B))] attribute,
            no more, no less. Validation of builder type B is left for elsewhere. This method returns B
            without validation of any kind.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.NormalizeTaskTypes(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Replace Task-like types with Task types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.NormalizeTaskTypesInType(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol@)">
            <summary>
            Replace Task-like types with Task types. Returns true if there were changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.CustomModifierCount(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Count the custom modifiers within the specified TypeSymbol.
            Potentially non-zero for arrays, pointers, and generic instantiations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.HasCustomModifiers(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Check for custom modifiers within the specified TypeSymbol.
            Potentially true for arrays, pointers, and generic instantiations.
            </summary>
            <remarks>
            A much less efficient implementation would be CustomModifierCount() == 0.
            CONSIDER: Could share a backing method with CustomModifierCount.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.CanUnifyWith(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return true if this type can unify with the specified type
            (i.e. is the same for some substitution of type parameters).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetNextBaseTypeNoUseSiteDiagnostics(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.PooledObjects.PooledHashSet{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol}@)">
            <summary>
            Used when iterating through base types in contexts in which the caller needs to avoid cycles and can't use BaseType
            (perhaps because BaseType is in the process of being computed)
            </summary>
            <param name="type"></param>
            <param name="basesBeingResolved"></param>
            <param name="compilation"></param>
            <param name="visited"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations">
            <summary>
            A struct that combines a single type with annotations
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.DefaultType">
            <summary>
            The underlying type, unless overridden by _extensions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations._extensions">
            <summary>
            Additional data or behavior. Such cases should be
            uncommon to minimize allocations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.IsDefault">
            <summary>
            True if the fields are unset. Appropriate when detecting if a lazily-initialized variable has been initialized.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.HasType">
            <summary>
            True if the type is not null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.TryForceResolve(System.Boolean)">
            <summary>
            If this is a lazy nullable type pending resolution, forces this to be resolved.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.MergeEquivalentTypes(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.VarianceKind)">
            <summary>
            Merges top-level and nested nullability, dynamic/object, and tuple names from an otherwise equivalent type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.IsNullableType">
            <summary>
            Is this System.Nullable`1 type, or its substitution.
            
            To check whether a type is System.Nullable`1 or is a type parameter constrained to System.Nullable`1
            use <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsNullableTypeOrTypeParameter(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)" /> instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.Type"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.AsTypeSymbolOnly">
            <summary>
            Extract type under assumption that there should be no custom modifiers or annotations.
            The method asserts otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.Is(Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol)">
            <summary>
            Is this the given type parameter?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.NeedsNullableAttribute">
            <summary>
            Used by callers before calling CSharpCompilation.EnsureNullableAttributeExists().
            </summary>
            <remarks>
            This method ignores any [NullableContext]. For example, if there is a [NullableContext(1)]
            at the containing type, and this type reference is oblivious, NeedsNullableAttribute()
            will return false even though a [Nullable(0)] will be emitted for this type reference.
            In practice, this shouldn't be an issue though since EnsuresNullableAttributeExists()
            will have returned true for at least some of other type references that required
            [Nullable(1)] and were subsequently aggregated to the [NullableContext(1)].
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.IsNonGenericValueType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            If the type is a non-generic value type or Nullable&lt;&gt;, and
            is not a type parameter, the nullability is not included in the byte[].
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.op_Equality(System.Nullable{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Nullable{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations})">
            <summary>
            Used by the generated <see cref="M:Microsoft.CodeAnalysis.CSharp.BoundTypeExpression.Update(Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol,Microsoft.CodeAnalysis.CSharp.BoundTypeExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.op_Inequality(System.Nullable{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},System.Nullable{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations})">
            <summary>
            Used by the generated <see cref="M:Microsoft.CodeAnalysis.CSharp.BoundTypeExpression.Update(Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol,Microsoft.CodeAnalysis.CSharp.BoundTypeExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.ToTypeWithState">
            <summary>
            Compute the flow state resulting from reading from an lvalue.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.Extensions">
            <summary>
            Additional data or behavior beyond the core TypeWithAnnotations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations.LazyNullableTypeParameter">
            <summary>
            Nullable type parameter. The underlying TypeSymbol is resolved
            lazily to avoid cycles when binding declarations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState">
            <summary>
            A type and its corresponding flow state resulting from evaluating an rvalue expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.UpdatedContainingSymbolAndNullableAnnotationLocal.CreateForTest(Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.UpdatedContainingSymbolAndNullableAnnotationLocal"/> for testing purposes,
            which does not verify that the containing symbol matches the original containing symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety">
            <summary>
            This class groups together all of the functionality needed to check for error CS1961, ERR_UnexpectedVariance.
            Its functionality is accessible through the NamedTypeSymbol extension method CheckInterfaceVarianceSafety and
            the MethodSymbol extension method CheckMethodVarianceSafety (for checking delegate Invoke).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckInterfaceVarianceSafety(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckNestedTypeVarianceSafety(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Check for illegal nesting into a variant interface.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckDelegateVarianceSafety(Microsoft.CodeAnalysis.CSharp.Symbols.SourceDelegateMethodSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of a delegate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckMethodVarianceSafety(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckPropertyVarianceSafety(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckEventVarianceSafety(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckParametersVarianceSafety(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface method/property parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckTypeParametersVarianceSafety(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol},Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface method type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.IsVarianceUnsafe``1(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.LocationProvider{``0},``0,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Returns true if the type is output-unsafe or input-unsafe, as defined in the C# spec.
            Roughly, a type is output-unsafe if it could not be the return type of a method and
            input-unsafe if it could not be a parameter type of a method.
            </summary>
            <remarks>
            This method is intended to match spec section 13.1.3.1 as closely as possible 
            (except that the output-unsafe and input-unsafe checks are merged).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.IsVarianceUnsafe``1(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.LocationProvider{``0},``0,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            3) T is an interface, class, struct, enum, or delegate type <![CDATA[S<A_1, ..., A_k>]]> constructed
            from a generic type <![CDATA[S<X_1, ..., X_k>]]> where for at least one A_i one
            of the following holds:
                a) X_i is covariant or invariant and A_i is output-unsafe [input-unsafe]
                b) X_i is contravariant or invariant and A_i is input-unsafe [output-unsafe] (note: spec has "input-safe", but it's a typo)
            </summary>
            <remarks>
            Slight rewrite to make it more idiomatic for C#:
                a) X_i is covariant and A_i is input-unsafe
                b) X_i is contravariant and A_i is output-unsafe
                c) X_i is invariant and A_i is input-unsafe or output-unsafe
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.AddVarianceError``1(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.LocationProvider{``0},``0,Microsoft.CodeAnalysis.CSharp.MessageID)">
            <summary>
            Add an ERR_UnexpectedVariance diagnostic to the diagnostic bag.
            </summary>
            <param name="diagnostics">Diagnostic bag.</param>
            <param name="unsafeTypeParameter">Type parameter that is not variance safe.</param>
            <param name="context">Context in which type is not variance safe (e.g. method).</param>
            <param name="locationProvider">Callback to provide location.</param>
            <param name="locationArg">Callback argument.</param>
            <param name="expectedVariance">Desired variance of type.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedEventSymbol">
            <summary>
            Represents an event that is based on another event.
            When inheriting from this class, one shouldn't assume that 
            the default behavior it has is appropriate for every case.
            That behavior should be carefully reviewed and derived type
            should override behavior as appropriate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedEventSymbol._underlyingEvent">
            <summary>
            The underlying EventSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedFieldSymbol">
            <summary>
            Represents a field that is based on another field.
            When inheriting from this class, one shouldn't assume that 
            the default behavior it has is appropriate for every case.
            That behavior should be carefully reviewed and derived type
            should override behavior as appropriate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedFieldSymbol._underlyingField">
            <summary>
            The underlying FieldSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedMethodSymbol">
            <summary>
            Represents a method that is based on another method.
            When inheriting from this class, one shouldn't assume that 
            the default behavior it has is appropriate for every case.
            That behavior should be carefully reviewed and derived type
            should override behavior as appropriate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedNamedTypeSymbol">
            <summary>
            Represents a named type that is based on another named type.
            When inheriting from this class, one shouldn't assume that 
            the default behavior it has is appropriate for every case.
            That behavior should be carefully reviewed and derived type
            should override behavior as appropriate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedNamedTypeSymbol._underlyingType">
            <summary>
            The underlying NamedTypeSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedParameterSymbol">
            <summary>
            Represents a parameter that is based on another parameter.
            When inheriting from this class, one shouldn't assume that 
            the default behavior it has is appropriate for every case.
            That behavior should be carefully reviewed and derived type
            should override behavior as appropriate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedPropertySymbol">
            <summary>
            Represents a property that is based on another property.
            When inheriting from this class, one shouldn't assume that 
            the default behavior it has is appropriate for every case.
            That behavior should be carefully reviewed and derived type
            should override behavior as appropriate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedPropertySymbol._underlyingProperty">
            <summary>
            The underlying PropertySymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedTypeParameterSymbol">
            <summary>
            Represents a type parameter that is based on another type parameter.
            When inheriting from this class, one shouldn't assume that 
            the default behavior it has is appropriate for every case.
            That behavior should be carefully reviewed and derived type
            should override behavior as appropriate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.WrappedTypeParameterSymbol._underlyingTypeParameter">
            <summary>
            The underlying TypeParameterSymbol, cannot be another RetargetingTypeParameterSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker">
            <summary>
            Traverses the symbol table checking for CLS compliance.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker._compilerTasks">
            <seealso cref="F:Microsoft.CodeAnalysis.CSharp.MethodCompiler._compilerTasks"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.ConcurrentAnalysis">
            <summary>
            Gets a value indicating whether <see cref="T:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker"/> is allowed to analyze in parallel.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.CheckCompliance(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Threading.CancellationToken,Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Traverses the symbol table checking for CLS compliance.
            </summary>
            <param name="compilation">Compilation that owns the symbol table.</param>
            <param name="diagnostics">Will be supplemented with documentation comment diagnostics.</param>
            <param name="cancellationToken">To stop traversing the symbol table early.</param>
            <param name="filterTree">Only report diagnostics from this syntax tree, if non-null.</param>
            <param name="filterSpanWithinTree">If <paramref name="filterTree"/> and <paramref name="filterSpanWithinTree"/> is non-null, report diagnostics within this span in the <paramref name="filterTree"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.VisitTypeOrMember(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.Compliance)">
            <returns>False if no further checks are required (because they would be cascading).</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.CheckForAttributeWithArrayArgumentInternal(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData})">
            <remarks>
            BREAK: Dev11 reports WRN_CLS_ArrayArgumentToAttribute on all symbols, whereas roslyn reports it only
            on accessible symbols.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.CheckForDeclarationWithoutAssemblyDeclaration(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.Compliance)">
            <returns>True if the symbol is okay (i.e. no warnings).</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.CheckSymbolDistinctness(Microsoft.CodeAnalysis.CSharp.Symbol,System.String,Roslyn.Utilities.MultiDictionary{System.String,Microsoft.CodeAnalysis.CSharp.Symbol}.ValueSet)">
            <remarks>
            NOTE: Dev11 behavior - First, it ignores arity,
            which seems like a good way to disambiguate symbols (in particular,
            CLS Rule 43 says that the name includes backtick-arity).  Second, it
            does not consider two members with identical names (i.e. not differing
            in case) to collide.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.IsInaccessibleBecauseOfConstruction(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <remarks>
            This check (the only one that uses the "context" parameter is based on CLS Rule 46,
            as implemented by LangCompiler::IsCLSAccessible.  The idea is that C&lt;int&gt; and C&lt;char&gt;
            are separate types in CLS, so they can't touch each other's protected members.
            TODO: This should really have a separate error code - it's logically separate and requires explanation.
            </remarks>
            <param name="type">Check the accessibility of this type (probably a parameter or return type).</param>
            <param name="context">Context for the accessibility check (e.g. containing type of method with <paramref name="type"/> as a parameter type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.GetDeclaredCompliance(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.Location@)">
            <remarks>
            As in dev11, we ignore the fact that CLSCompliantAttribute is inherited (i.e. from the base type)
            (see CSemanticChecker::CheckSymForCLS).  This should only affect types where the syntactic parent
            and the inheritance parent disagree.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.TryGetCollisionErrorCode(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.ErrorCode@)">
            <remarks>
            Based on CompilationPass::CLSReduceSignature.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler">
            <summary>
            Traverses the symbol table processing XML documentation comments and optionally writing them to
            a provided stream.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.WriteDocumentationCommentXml(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.String,System.IO.Stream,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Threading.CancellationToken,Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Traverses the symbol table processing XML documentation comments and optionally writing them to
            a provided stream.
            </summary>
            <param name="compilation">Compilation that owns the symbol table.</param>
            <param name="assemblyName">Assembly name override, if specified. Otherwise the <see cref="P:Microsoft.CodeAnalysis.ISymbol.Name"/> of the source assembly is used.</param>
            <param name="xmlDocStream">Stream to which XML will be written, if specified.</param>
            <param name="diagnostics">Will be supplemented with documentation comment diagnostics.</param>
            <param name="cancellationToken">To stop traversing the symbol table early.</param>
            <param name="filterTree">Only report diagnostics from this syntax tree, if non-null.</param>
            <param name="filterSpanWithinTree">If <paramref name="filterTree"/> and filterSpanWithinTree is non-null, report diagnostics within this span in the <paramref name="filterTree"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetDocumentationCommentXml(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets the XML that would be written to the documentation comment file for this assembly.
            </summary>
            <param name="symbol">The symbol for which to retrieve documentation comments.</param>
            <param name="processIncludes">True to treat includes as semantically meaningful (pull in contents from other files and bind crefs, etc).</param>
            <param name="cancellationToken">To stop traversing the symbol table early.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.VisitNamespace(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol)">
            <summary>
            Write header, descend into members, and write footer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.VisitNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Write own documentation comments and then descend into members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Compile documentation comments on the symbol and write them to the stream if one is provided.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.TryProcessDocumentationCommentTriviaNodes(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax},System.Boolean,System.String@,System.Boolean@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode}@)">
            <summary>
            Loop over the DocumentationCommentTriviaSyntaxes.  Gather
              1) concatenated XML, as a string;
              2) whether or not the XML is valid;
              3) set of type parameters covered by &lt;typeparam&gt; elements;
              4) set of parameters covered by &lt;param&gt; elements;
              5) list of &lt;include&gt; elements, as SyntaxNodes.
            </summary>
            <returns>True, if at least one documentation comment was processed; false, otherwise.</returns>
            <remarks>This was factored out for clarity, not because it's reusable.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetParameters(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            Similar to SymbolExtensions.GetParameters, but returns empty for unsupported symbols
            and handles delegates.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetTypeParameters(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            Similar to SymbolExtensions.GetMemberTypeParameters, but returns empty for unsupported symbols.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.RequiresDocumentationComment(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            A symbol requires a documentation comment if it was explicitly declared and
            will be visible outside the current assembly (ignoring InternalsVisibleTo).
            Exception: accessors do not require doc comments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.TryGetDocumentationCommentNodes(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.DocumentationMode@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax}@)">
            <summary>
            Get all of the DocumentationCommentTriviaSyntax associated with any declaring syntax of the
            given symbol (except for partial methods, which only consider the part with the body).
            </summary>
            <returns>True if the nodes are all valid XML.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.FormatComment(System.String)">
            <summary>
            Given the full text of a documentation comment, strip off the comment punctuation (///, /**, etc)
            and add appropriate indentations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetIndexOfFirstNonWhitespaceChar(System.String)">
            <summary>
            Given a string, find the index of the first non-whitespace char.
            </summary>
            <param name="str">The string to search</param>
            <returns>The index of the first non-whitespace char in the string</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetIndexOfFirstNonWhitespaceChar(System.String,System.Int32,System.Int32)">
            <summary>
            Find the first non-whitespace character in a given substring.
            </summary>
            <param name="str">The string to search</param>
            <param name="start">The start index</param>
            <param name="end">The last index (non-inclusive)</param>
            <returns>The index of the first non-whitespace char after index start in the string up to, but not including the end index</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.TrimmedStringStartsWith(System.String,System.String)">
            <summary>
            Determine if the given string starts with the given prefix if whitespace
            is first trimmed from the beginning.
            </summary>
            <param name="str">The string to search</param>
            <param name="prefix">The prefix</param>
            <returns>true if str.TrimStart().StartsWith(prefix)</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.IndexOfNewLine(System.String,System.Int32,System.Int32@)">
            <summary>
            Given a string which may contain newline sequences, get the index of the first newline
            sequence beginning at the given starting index.
            </summary>
            <param name="str">The string to split.</param>
            <param name="start">The starting index within the string.</param>
            <param name="newLineLength">The length of the newline sequence discovered. 0 if the end of the string was reached, otherwise either 1 or 2 chars</param>
            <returns>The index of the start of the first newline sequence following the start index</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.WriteFormattedSingleLineComment(System.String)">
            <summary>
            Given the full text of a single-line style documentation comment, for each line, strip off
            the comment punctuation (///) and add appropriate indentations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.WriteFormattedMultiLineComment(System.String[],System.Int32)">
            <summary>
            Given the full text of a multi-line style documentation comment, broken into lines, strip off
            the comment punctuation (/**, */, etc) and add appropriate indentations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.TrimEndOfMultiLineComment(System.String)">
            <summary>
            Remove "*/" and any following text, if it is present.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.FindMultiLineCommentPattern(System.String)">
            <summary>
            Return the longest prefix matching [whitespace]*[*][whitespace]*.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.LongestCommonPrefix(System.String,System.String)">
            <summary>
            Return the longest common prefix of two strings
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetDocumentationCommentId(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Bind a CrefSyntax and unwrap the result if it's an alias.
            </summary>
            <remarks>
            Does not respect DocumentationMode, so use a temporary bag if diagnostics are not desired.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.ToBadCrefString(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax)">
            <summary>
            Given a cref syntax that cannot be resolved, get the string that will be written to
            the documentation file in place of a documentation comment ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.BindName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Symbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol}@,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Bind an XmlNameAttributeSyntax and update the sets of documented parameters and type parameters.
            </summary>
            <remarks>
            Does not respect DocumentationMode, so do not call unless diagnostics are desired.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetDescription(System.Xml.XmlException)">
            <remarks>
            WORKAROUND:
            We're taking a dependency on the location and structure of a framework assembly resource.  This is not a robust solution.
            
            Possible alternatives:
            1) Polish our XML parser until it matches MSXML.  We don't want to reinvent the wheel.
            2) Build a map that lets us go from XML string positions back to source positions.  
            This is what the native compiler did, and it was a lot of work.  We'd also still need to modify the message.
            3) Do not report a diagnostic.  This is very unhelpful.
            4) Report a vague diagnostic (i.e. there's a problem somewhere in this doc comment).  This is relatively unhelpful.
            5) Always report the message in English, so that we can pull it apart without needing to consume resource files.
            This engenders a lot of ill will.
            6) Report the exception message without modification and (optionally) include the text with respect to which the
            position is specified.  This would not look sufficiently polished.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.DocumentationCommentWalker">
            <summary>
            Walks a DocumentationCommentTriviaSyntax, binding the semantically meaningful parts 
            to produce diagnostics and to replace source crefs with documentation comment IDs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.DocumentationCommentWalker.GetSubstitutedText(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedRecordPropertySymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode},System.Text.StringBuilder)">
            <summary>
            Writes the matching 'param' tags on a primary constructor as 'summary' tags for a synthesized record property.
            </summary>
            <remarks>
            Still has all of the comment punctuation (///, /**, etc). associated with the 'param' tag.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.DocumentationCommentWalker.GetSubstitutedText(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol}@)">
            <summary>
            Given a DocumentationCommentTriviaSyntax, return the full text, but with
            documentation comment IDs substituted into crefs.
            </summary>
            <remarks>
            Still has all of the comment punctuation (///, /**, etc).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.IncludeElementExpander.RewriteMany(System.Xml.Linq.XNode[],System.String,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <remarks>
            Rewrites nodes in <paramref name="nodes"/>, which is a snapshot of nodes from the original document.
            We're mutating the tree as we rewrite, so it's important to grab a snapshot of the
            nodes that we're going to reparent before we enumerate them.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.IncludeElementExpander.RewriteIncludeElement(System.Xml.Linq.XElement,System.String,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.String@)">
            <remarks>
            This method boils down to Rewrite(XDocument.Load(fileAttrValue).XPathSelectElements(pathAttrValue)).  
            Everything else is error handling.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.IncludeElementExpander.RecordSyntaxDiagnostics(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.Location)">
            <remarks>
            Respects the DocumentationMode at the source location.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.IncludeElementExpander.RecordBindingDiagnostics(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.Location)">
            <remarks>
            Respects the DocumentationMode at the source location.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer">
            <summary>
            Contains methods related to synthesizing bound nodes in initial binding
            form that needs lowering, primarily method bodies for compiler-generated methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.MakeSubmissionInitialization(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundStatement},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Generates a submission initialization part of a Script type constructor that represents an interactive submission.
            </summary>
            <remarks>
            The constructor takes a parameter of type Microsoft.CodeAnalysis.Scripting.Session - the session reference.
            It adds the object being constructed into the session by calling Microsoft.CSharp.RuntimeHelpers.SessionHelpers.SetSubmission,
            and retrieves strongly typed references on all previous submission script classes whose members are referenced by this submission.
            The references are stored to fields of the submission (<paramref name="synthesizedFields"/>).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.ConstructAutoPropertyAccessorBody(Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol)">
            <summary>
            Construct a body for an auto-property accessor (updating or returning the backing field).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.ConstructFieldLikeEventAccessorBody(Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Generate an accessor for a field-like event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.ConstructFieldLikeEventAccessorBody_WinRT(Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
             <summary>
             Generate a thread-safe accessor for a WinRT field-like event.
            
             Add:
               return EventRegistrationTokenTable&lt;Event&gt;.GetOrCreateEventRegistrationTokenTable(ref _tokenTable).AddEventHandler(value);
            
             Remove:
               EventRegistrationTokenTable&lt;Event&gt;.GetOrCreateEventRegistrationTokenTable(ref _tokenTable).RemoveEventHandler(value);
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.ConstructFieldLikeEventAccessorBody_Regular(Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
             <summary>
             Generate a thread-safe accessor for a regular field-like event.
            
             DelegateType tmp0 = _event; //backing field
             DelegateType tmp1;
             DelegateType tmp2;
             do {
                 tmp1 = tmp0;
                 tmp2 = (DelegateType)Delegate.Combine(tmp1, value); //Remove for -=
                 tmp0 = Interlocked.CompareExchange&lt;DelegateType&gt;(ref _event, tmp2, tmp1);
             } while ((object)tmp0 != (object)tmp1);
            
             Note, if System.Threading.Interlocked.CompareExchange&lt;T&gt; is not available,
             we emit the following code and mark the method Synchronized (unless it is a struct).
            
             _event = (DelegateType)Delegate.Combine(_event, value); //Remove for -=
            
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.GetBaseTypeFinalizeMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Look for a base type method named "Finalize" that is protected (or protected internal), has no parameters,
            and returns void.  It doesn't need to be virtual or a destructor.
            </summary>
            <remarks>
            You may assume that this would share code and logic with PEMethodSymbol.OverridesRuntimeFinalizer,
            but FUNCBRECCS::bindDestructor has its own loop that performs these checks (differently).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedExplicitImplementations(Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol,Microsoft.CodeAnalysis.CSharp.TypeCompilationState)">
            <summary>
            In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a
            base type from another assembly) it is necessary for the compiler to generate explicit implementations for
            some interface methods.  They don't go in the symbol table, but if we are emitting, then we should
            generate code for them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.CSharp.BoundStatement,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeGen.StateMachineStateDebugInfo},Microsoft.CodeAnalysis.CSharp.StateMachineTypeSymbol,Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider,Microsoft.CodeAnalysis.CSharp.ImportChain,System.Boolean,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeGen.SourceSpan},Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEntryPointSymbol.AsyncForwardEntryPoint)">
            <summary>
            entryPointOpt is only considered for synthesized methods (to recognize the synthesized MoveNext method for async Main)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedMetadataCompiler">
            <summary>
            When compiling in metadata-only mode, <see cref="T:Microsoft.CodeAnalysis.CSharp.MethodCompiler"/> is not run. This is problematic because
            <see cref="T:Microsoft.CodeAnalysis.CSharp.MethodCompiler"/> adds synthesized explicit implementations to the list of synthesized definitions.
            In lieu of running <see cref="T:Microsoft.CodeAnalysis.CSharp.MethodCompiler"/>, this class performs a quick
            traversal of the symbol table and performs processing of synthesized symbols if necessary
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SynthesizedMetadataCompiler.ProcessSynthesizedMembers(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder,System.Threading.CancellationToken)">
            <summary>
            Traverse the symbol table and call Module.AddSynthesizedDefinition for each
            synthesized explicit implementation stub that has been generated (e.g. when the real
            implementation doesn't have the appropriate custom modifiers).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TypeCompilationState">
            <summary>
            Represents the state of compilation of one particular type.
            This includes, for example, a collection of synthesized methods created during lowering. 
            </summary>
            <remarks>
            WARNING: Note that the collection class is not thread-safe and will 
            need to be revised if emit phase is changed to support multithreading when
            translating a particular type.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.MethodWithBody">
            <summary> Synthesized method info </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.TypeCompilationState._synthesizedMethods">
            <summary> Flat array of created methods, non-empty if not-null </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.TypeCompilationState._wrappers">
            <summary> 
            Map of wrapper methods created for base access of base type virtual methods from 
            other classes (like those created for lambdas...); actually each method symbol will 
            only need one wrapper to call it non-virtually.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.TypeCompilationState._typeOpt">
            <summary>
            Type symbol being compiled, or null if we compile a synthesized type that doesn't have a symbol (e.g. PrivateImplementationDetails).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.ModuleBuilderOpt">
            <summary>
            The builder for generating code, or null if not in emit phase.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.CurrentImportChain">
            <summary>
            Any generated methods that don't suppress debug info will use this
            list of debug imports.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.TypeCompilationState._constructorInitializers">
            <summary>
            A graph of method->method references for this(...) constructor initializers.
            Used to detect and report initializer cycles.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.Type">
            <summary>
            The type for which this compilation state is being used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.DynamicOperationContextType">
            <summary>
            The type passed to the runtime binder as context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.AddSynthesizedMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary> 
            Add a 'regular' synthesized method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.AddMethodWrapper(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary> 
            Add a 'wrapper' synthesized method and map it to the original one so it can be reused. 
            </summary>
            <remarks>
            Wrapper methods are created for base access of base type virtual methods from 
            other classes (like those created for lambdas...).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.NextWrapperMethodIndex">
            <summary> The index of the next wrapped method to be used </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.GetMethodWrapper(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary> 
            Get a 'wrapper' method for the original one. 
            </summary>
            <remarks>
            Wrapper methods are created for base access of base type virtual methods from 
            other classes (like those created for lambdas...).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.Free">
            <summary> Free resources allocated for this method collection </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.ReportCtorInitializerCycles(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Report an error if adding the edge (method1, method2) to the ctor-initializer
            graph would add a new cycle to that graph.
            </summary>
            <param name="method1">a calling ctor</param>
            <param name="method2">the chained-to ctor</param>
            <param name="syntax">where to report a cyclic error if needed</param>
            <param name="diagnostics">a diagnostic bag for receiving the diagnostic</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions">
            <summary>
            Represents various options that affect compilation, such as 
            whether to emit an executable or a library, whether to optimize
            generated code, and so on.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions.AllowUnsafe">
            <summary>
            Allow unsafe regions (i.e. unsafe modifiers on members and unsafe blocks).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions.Usings">
            <summary>
            Global namespace usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions.TopLevelBinderFlags">
            <summary>
            Flags applied to the top-level binder created for each syntax tree in the compilation 
            as well as for the binder of global imports.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions.NullableContextOptions">
            <summary>
            Global Nullable context options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsCSharpKind(System.Int32)">
            <summary>
            Determines if the given raw kind value belongs to the C# <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> enumeration.
            </summary>
            <param name="rawKind">The raw value to test.</param>
            <returns><see langword="true"/> when the raw value belongs to the C# syntax kind; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> for <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/> from <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind"/> property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> for <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/> from <see cref="P:Microsoft.CodeAnalysis.SyntaxTrivia.RawKind"/> property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> for <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> from <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.RawKind"/> property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> for <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> from <see cref="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.RawKind"/> property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])">
            <summary>
            Insert one or more tokens in the list at the specified index.
            </summary>
            <returns>A new list with the tokens inserted.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new token with the specified old trivia replaced with computed new trivia.
            </summary>
            <param name="token"></param>
            <param name="trivia">The trivia to be replaced; descendants of the root token.</param>
            <param name="computeReplacementTrivia">A function that computes a replacement trivia for
            the argument trivia. The first argument is the original trivia. The second argument is
            the same trivia rewritten with replaced structure.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in
            the token's leading or trailing trivia.
            </summary>
            <param name="token"></param>
            <param name="oldTrivia">The trivia to be replaced.</param>
            <param name="newTrivia">The new trivia to use in the new tree in place of the old
            trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AsSeparatedList``1(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Returns this list as a <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1"/>.
            </summary>
            <typeparam name="TOther">The type of the list elements in the separated list.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})">
            <summary>
            Gets the first directive of the tree rooted by this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})">
            <summary>
            Gets the last directive of the tree rooted by this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information for an ordering clause in an orderby query clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a select or group clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
             <summary>
             Returns what symbol(s), if any, the given expression syntax bound to in the program.
            
             An AliasSymbol will never be returned by this method. What the alias refers to will be
             returned instead. To get information about aliases, call GetAliasInfo.
            
             If binding the type name C in the expression "new C(...)" the actual constructor bound to
             will be returned (or all constructor if overload resolution failed). This occurs as long as C
             unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple
             types, or C binds to a static class, then type(s) are returned.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax
            within <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax.Initializer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given attribute syntax bound to in the program.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a documentation comment cref.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the CrefSyntax expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>
            Bind the attribute in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about an attribute
            that did not actually appear in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)">
             <summary>
             Bind the constructor initializer in the context of the specified location and get semantic information
             such as type, symbols and diagnostics. This method is used to get semantic information about a constructor
             initializer that did not actually appear in the source code.
            
             NOTE: This will only work in locations where there is already a constructor initializer.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax)">
             <summary>
             Bind the constructor initializer in the context of the specified location and get semantic information
             about symbols. This method is used to get semantic information about a constructor
             initializer that did not actually appear in the source code.
            
             NOTE: This will only work in locations where there is already a constructor initializer.
             <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax"/>.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a constructor initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about an expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about an attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the expression in the context of the specified location and gets type information.
            This method is used to get type information about an expression that did not actually
            appear in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.Operations.IConversionOperation)">
            <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> information from this <see cref="T:Microsoft.CodeAnalysis.Operations.IConversionOperation"/>. This
            <see cref="T:Microsoft.CodeAnalysis.Operations.IConversionOperation"/> must have been created from CSharp code.
            </summary>
            <param name="conversionExpression">The conversion expression to get original info from.</param>
            <returns>The underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/>.</returns>
            <exception cref="T:System.InvalidCastException">If the <see cref="T:Microsoft.CodeAnalysis.Operations.IConversionOperation"/> was not created from CSharp code.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetInConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)">
            <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> information from this <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation"/>. This
            conversion is applied before the operator is applied to the result of this conversion and <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Value"/>.
            </summary>
            <remarks>
            This compound assignment must have been created from C# code.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetOutConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)">
            <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> information from this <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation"/>. This
            conversion is applied after the operator is applied, before the result is assigned to <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Target"/>.
            </summary>
            <remarks>
            This compound assignment must have been created from C# code.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a query clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)">
            <summary>
            If <paramref name="nameSyntax"/> resolves to an alias name, return the AliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze control-flow within a part of a method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze control-flow within a part of a method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)">
            <summary>
            Analyze data-flow within a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax)">
            <summary>
            Analyze data-flow within a <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax.ArgumentList"/> initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Analyze data-flow within an <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze data-flow within a part of a method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze data-flow within a part of a method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position"/> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position"/> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Get a SemanticModel object that is associated with a type syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a type syntax that did not appear in source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a cref syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a cref syntax that did not appear in source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a statement that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a statement that did not appear in source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a field initializer or default parameter value that did not appear in source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an expression body that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression body that did not appear in source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
             <summary>
             Get a SemanticModel object that is associated with a constructor initializer that did not appear in
             this source code. This can be used to get detailed semantic information about sub-parts
             of a constructor initializer that did not appear in source code.
            
             NOTE: This will only work in locations where there is already a constructor initializer.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
             <summary>
             Get a SemanticModel object that is associated with a constructor initializer that did not appear in
             this source code. This can be used to get detailed semantic information about sub-parts
             of a constructor initializer that did not appear in source code.
            
             NOTE: This will only work in locations where there is already a constructor initializer.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an attribute that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an attribute that did not appear in source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a member declaration syntax, get the corresponding symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a compilation unit syntax, get the corresponding Simple Program entry point symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of tuple expression, get the tuple type symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of a tuple argument, get the tuple element symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property or member accessor, get the corresponding symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a tuple element syntax, get the corresponding symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a using declaration get the corresponding symbol for the using alias that was introduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a parameter declaration syntax node, get the corresponding symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a foreach statement, get the symbol for the iteration variable
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a catch declaration, get the symbol for the exception variable
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the query range variable declared in a join into clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the query range variable declared in a query continuation clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions.Emit(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Threading.CancellationToken)">
            <summary>
            Emit the IL for the compilation into the specified stream.
            </summary>
            <param name="compilation">Compilation.</param>
            <param name="outputPath">Path of the file to which the PE image will be written.</param>
            <param name="pdbPath">Path of the file to which the compilation's debug info will be written.
            Also embedded in the output file.  Null to forego PDB generation.
            </param>
            <param name="xmlDocumentationPath">Path of the file to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
            <param name="win32ResourcesPath">Path of the file from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none.</param>
            <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
            <param name="cancellationToken">To cancel the emit process.</param>
            <exception cref="T:System.ArgumentNullException">Compilation or path is null.</exception>
            <exception cref="T:System.ArgumentException">Path is empty or invalid.</exception>
            <exception cref="T:System.IO.IOException">An error occurred while reading or writing a file.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions">
            <summary>
            This class stores several source parsing related options and offers access to their values.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.Default">
            <summary>
            The default parse options.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.LanguageVersion">
            <summary>
            Gets the effective language version, which the compiler uses to select the
            language rules to apply to the program.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.SpecifiedLanguageVersion">
            <summary>
            Gets the specified language version, which is the value that was specified in
            the call to the constructor, or modified using the <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.WithLanguageVersion(Microsoft.CodeAnalysis.CSharp.LanguageVersion)"/> method,
            or provided on the command line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.PreprocessorSymbolNames">
            <summary>
            Gets the names of defined preprocessor symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.WithFeatures(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Enable some experimental language features for testing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Declaration">
            <summary>
            A Declaration summarizes the declaration structure of a source file. Each entity declaration
            in the program that is a container (specifically namespaces, classes, interfaces, structs,
            and delegate declarations) is represented by a node in this tree.  At the top level, the
            compilation unit is treated as a declaration of the unnamed namespace.
            
            Special treatment is required for namespace declarations, because a single namespace
            declaration can declare more than one namespace.  For example, in the declaration
            
                namespace A.B.C {}
                
            we see that namespaces A and B and C are declared.  This declaration is represented as three
            declarations. All three of these ContainerDeclaration objects contain a reference to the
            syntax tree for the declaration.
            
            A "single" declaration represents a specific namespace or type declaration at a point in
            source code. A "root" declaration is a special single declaration which summarizes the
            contents of an entire file's types and namespaces.  Each source file is represented as a tree
            of single declarations.
            
            A "merged" declaration merges together one or more declarations for the same symbol.  For
            example, the root namespace has multiple single declarations (one in each source file) but
            there is a single merged declaration for them all.  Similarly partial classes may have
            multiple declarations, grouped together under the umbrella of a merged declaration.  In the
            common trivial case, a merged declaration for a single declaration contains only that single
            declaration.  The whole program, consisting of the set of all declarations in all of the
            source files, is represented by a tree of merged declarations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DeclarationTable">
            <summary>
            A declaration table is a device which keeps track of type and namespace declarations from
            parse trees. It is optimized for the case where there is one set of declarations that stays
            constant, and a specific root namespace declaration corresponding to the currently edited
            file which is being added and removed repeatedly. It maintains a cache of information for
            "merging" the root declarations into one big summary declaration; this cache is efficiently
            re-used provided that the pattern of adds and removes is as we expect.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DeclarationTreeBuilder._nonGlobalAliasedQuickAttributes">
            <summary>
            Any special attributes we may be referencing through a using alias in the file.
            For example <c>using X = System.Runtime.CompilerServices.TypeForwardedToAttribute</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DeclarationTreeBuilder.CreateScriptRootDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax)">
            <summary>
            Creates a root declaration that contains a Script class declaration (possibly in a namespace) and namespace declarations.
            Top-level declarations in script code are nested in Script class.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MergedTypeDeclaration.GetAttributeDeclarations(System.Nullable{Microsoft.CodeAnalysis.CSharp.Symbols.QuickAttributes})">
            <summary>
            Returns the original syntax nodes for this type declaration across all its parts.  If
            <paramref name="quickAttributes"/> is provided, attributes will not be returned if it
            is certain there are none that could match the request.  This prevents going back to 
            source unnecessarily.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.RootSingleNamespaceDeclaration.GlobalAliasedQuickAttributes">
            <summary>
            Any special attributes we may be referencing directly through a global using alias in the file.
            <c>global using X = System.Runtime.CompilerServices.TypeForwardedToAttribute</c>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SingleNamespaceOrTypeDeclaration.Diagnostics">
            <summary>
            Any diagnostics reported while converting the Namespace/Type syntax into the Declaration
            instance.  Generally, we determine and store some diagnostics here because we don't want 
            to have to go back to Syntax when we have our NamespaceSymbol or NamedTypeSymbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SingleTypeDeclaration.QuickAttributes">
            <summary>
            Any special attributes we may be referencing directly as an attribute on this type or
            through a using alias in the file. For example
            <c>using X = System.Runtime.CompilerServices.TypeForwardedToAttribute</c> or
            <c>[TypeForwardedToAttribute]</c>.  Can be used to avoid having to go back to source
            to retrieve attributes when there is no chance they would bind to attribute of interest.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SingleTypeDeclaration.TypeDeclarationFlags.HasAwaitExpressions">
            <summary>
            Simple program uses await expressions. Set only in conjunction with <see cref="F:Microsoft.CodeAnalysis.CSharp.SingleTypeDeclaration.TypeDeclarationFlags.IsSimpleProgram"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SingleTypeDeclaration.TypeDeclarationFlags.IsIterator">
            <summary>
            Set only in conjunction with <see cref="F:Microsoft.CodeAnalysis.CSharp.SingleTypeDeclaration.TypeDeclarationFlags.IsSimpleProgram"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SingleTypeDeclaration.TypeDeclarationFlags.HasReturnWithExpression">
            <summary>
            Set only in conjunction with <see cref="F:Microsoft.CodeAnalysis.CSharp.SingleTypeDeclaration.TypeDeclarationFlags.IsSimpleProgram"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DocumentationCommentIDVisitor.PartVisitor">
            <summary>
            A visitor that generates the part of the documentation comment after the initial type
            and colon.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.CSharpDefinitionMap">
            <summary>
            Matches symbols from an assembly in one compilation to
            the corresponding assembly in another. Assumes that only
            one assembly has changed between the two compilations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.CSharpDefinitionMap.CreateLocalSlotMap(Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.LocalInfo{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol}})">
            <summary>
            Match local declarations to names to generate a map from
            declaration to local slot. The names are indexed by slot and the
            assumption is that declarations are in the same order as slots.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Emit.CSharpSymbolMatcher.MatchSymbols._otherSynthesizedMembers">
            <summary>
            Members that are not listed directly on their containing type or namespace symbol as they were synthesized in a lowering phase,
            after the symbol has been created.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Emit.CSharpSymbolMatcher.MatchSymbols._otherMembers">
            <summary>
            A cache of members per type, populated when the first member for a given
            type is needed. Within each type, members are indexed by name. The reason
            for caching, and indexing by name, is to avoid searching sequentially
            through all members of a given kind each time a member is matched.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.EmitHelpers.MapToCompilation(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Emit.PEDeltaAssemblyBuilder)">
            <summary>
            Return a version of the baseline with all definitions mapped to this compilation.
            Definitions from the initial generation, from metadata, are not mapped since
            the initial generation is always included as metadata. That is, the symbols from
            types, methods, ... in the TypesAdded, MethodsAdded, ... collections are replaced
            by the corresponding symbols from the current compilation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.GenericMethodInstanceReference">
            <summary>
            Represents a reference to a generic method instantiation, closed over type parameters,
            e.g. MyNamespace.Class.Method{T}()
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.GenericNamespaceTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation that is not nested.
            e.g. MyNamespace.A{int}
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.GenericNestedTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation that is nested in a non-generic type.
            e.g. A.B{int}
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.GenericTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation.
            Subclasses represent nested and namespace types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Emit.PEAssemblyBuilderBase._additionalTypes">
            <summary>
            Additional types injected by the Expression Evaluator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Emit.PEAssemblyBuilderBase._lazyFilesWithoutManifestResources">
            <summary>This is a cache of a subset of <seealso cref="F:Microsoft.CodeAnalysis.CSharp.Emit.PEAssemblyBuilderBase._lazyFiles"/>. We don't include manifest resources in ref assemblies</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Emit.PEAssemblyBuilderBase._metadataName">
            <summary>
            The behavior of the C# command-line compiler is as follows:
              1) If the /out switch is specified, then the explicit assembly name is used.
              2) Otherwise,
                 a) if the assembly is executable, then the assembly name is derived from
                    the name of the file containing the entrypoint;
                 b) otherwise, the assembly name is derived from the name of the first input
                    file.
            
            Since we don't know which method is the entrypoint until well after the
            SourceAssemblySymbol is created, in case 2a, its name will not reflect the
            name of the file containing the entrypoint.  We leave it to our caller to
            provide that name explicitly.
            </summary>
            <remarks>
            In cases 1 and 2b, we expect (metadataName == sourceAssembly.MetadataName).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder._fixedImplementationTypes">
            <summary>
            The compiler-generated implementation type for each fixed-size buffer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.GetNeedsGeneratedAttributes">
            <summary>
            Returns a value indicating which embedded attributes should be generated during emit phase.
            The value is set during binding the symbols that need those attributes, and is frozen on first trial to get it.
            Freezing is needed to make sure that nothing tries to modify the value after the value is read.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.GetDocumentsForMethodsAndNestedTypes(Microsoft.CodeAnalysis.PooledObjects.PooledHashSet{Microsoft.Cci.DebugSourceDocument},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.Cci.ITypeDefinition},Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Gets a list of documents from the method definitions in the types in <paramref name="typesToProcess"/> or any
            nested types of those types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.IgnoreAccessibility">
            <summary>
            Ignore accessibility when resolving well-known type
            members, in particular for generic type arguments
            (e.g.: binding to internal types in the EE).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.GetDynamicOperationContextType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Override the dynamic operation context type for all dynamic calls in the module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.CalculateExportedTypes">
            <summary>
            Builds an array of public type symbols defined in netmodules included in the compilation
            and type forwarders defined in this compilation or any included netmodule (in this order).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.GetForwardedTypes(Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.Cci.ExportedType})">
            <summary>
            Returns a set of top-level forwarded types
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.SetFixedImplementationType(Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberFieldSymbol)">
            <summary>
            Set the underlying implementation type for a given fixed-size buffer field.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.SynthesizeNullableAttributeIfNecessary(Microsoft.CodeAnalysis.CSharp.Symbol,System.Nullable{System.Byte},Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations)">
            <summary>
            Given a type <paramref name="type"/>, which is either a nullable reference type OR 
            is a constructed type with a nullable reference type present in its type argument tree,
            returns a synthesized NullableAttribute with encoded nullable transforms array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.EnsureThrowIfNullFunctionExists(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Creates the ThrowIfNull and Throw helpers if needed.
            </summary>
            <remarks>
            The ThrowIfNull and Throw helpers are modeled off of the helpers on ArgumentNullException.
            https://github.com/dotnet/runtime/blob/22663769611ba89cd92d14cfcb76e287f8af2335/src/libraries/System.Private.CoreLib/src/System/ArgumentNullException.cs#L56-L69
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.EnsureThrowSwitchExpressionExceptionExists(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Creates the ThrowSwitchExpressionException helper if needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.EnsureThrowSwitchExpressionExceptionParameterlessExists(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Creates the ThrowSwitchExpressionExceptionParameterless helper if needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.EnsureThrowInvalidOperationExceptionExists(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Creates the ThrowInvalidOperationException helper if needed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.SpecializedFieldReference">
            <summary>
            Represents a reference to a field of a generic type instantiation.
            e.g.
            A{int}.Field
            A{int}.B{string}.C.Field
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.SpecializedGenericMethodInstanceReference">
            <summary>
            Represents a generic method of a generic type instantiation, closed over type parameters.
            e.g. 
            A{T}.M{S}()
            A.B{T}.C.M{S}()
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.SpecializedGenericNestedTypeInstanceReference">
            <summary>
            Represents a reference to an instantiation of a generic type nested in an instantiation of another generic type.
            e.g. 
            A{int}.B{string}
            A.B{int}.C.D{string}
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.SpecializedMethodReference">
            <summary>
            Represents a method of a generic type instantiation.
            e.g. 
            A{int}.M()
            A.B{int}.C.M()
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.SpecializedNestedTypeReference">
            <summary>
            Represents a reference to a type nested in an instantiation of a generic type.
            e.g. 
            A{int}.B
            A.B{int}.C.D
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.TypeMemberReference.ToString">
            <remarks>
            Used only for testing.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedTypesManager)">
            <summary>
            Returns true if the type can be embedded. If the type is defined in a linked (/l-ed)
            assembly, but doesn't meet embeddable type requirements, this function returns false
            and reports appropriate diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MostCommonNullableValueBuilder.GetCommonValue(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Byte})">
            <summary>
            Returns the common value if all bytes are the same value.
            Otherwise returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSDiagnostic">
            <summary>
            A diagnostic, along with the location where it occurred.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticBagExtensions.Add(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.ErrorCode,Microsoft.CodeAnalysis.Location)">
            <summary>
            Add a diagnostic to the bag.
            </summary>
            <param name="diagnostics"></param>
            <param name="code"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticBagExtensions.Add(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.ErrorCode,Microsoft.CodeAnalysis.Location,System.Object[])">
            <summary>
            Add a diagnostic to the bag.
            </summary>
            <param name="diagnostics"></param>
            <param name="code"></param>
            <param name="location"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticBagExtensions.Add(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo})">
            <summary>
            Adds diagnostics from useSiteDiagnostics into diagnostics and returns True if there were any errors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticBagExtensions.Add(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo})">
            <summary>
            Adds diagnostics from useSiteDiagnostics into diagnostics and returns True if there were any errors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ErrorFacts.GetMessage(Microsoft.CodeAnalysis.CSharp.MessageID,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ErrorFacts.GetMessage(Microsoft.CodeAnalysis.CSharp.ErrorCode,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ErrorFacts.GetMessage(Microsoft.CodeAnalysis.CSharp.XmlParseErrorCode,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ErrorFacts.IsBuildOnlyDiagnostic(Microsoft.CodeAnalysis.CSharp.ErrorCode)">
            <summary>
            Returns true if this is a build-only diagnostic that is never reported from
            <see cref="M:Microsoft.CodeAnalysis.SemanticModel.GetDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)"/> API.
            Diagnostics generated during compilation phases such as lowering, emit, etc.
            are example of build-only diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ErrorFacts.PreventsSuccessfulDelegateConversion(Microsoft.CodeAnalysis.CSharp.ErrorCode)">
            <summary>
            When converting an anonymous function to a delegate type, there are some diagnostics
            that will occur regardless of the delegate type - particularly those that do not
            depend on the substituted types (e.g. name uniqueness).  Even though we need to
            produce a diagnostic in such cases, we do not need to abandon overload resolution -
            we can choose the overload that is best without regard to such diagnostics.
            </summary>
            <returns>True if seeing the ErrorCode should prevent a delegate conversion
            from completing successfully.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ErrorFacts.PreventsSuccessfulDelegateConversion(Microsoft.CodeAnalysis.DiagnosticBag)">
            <remarks>
            WARNING: will resolve lazy diagnostics - do not call this before the member lists are completed
            or you could trigger infinite recursion.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LazyMissingNonNullTypesContextDiagnosticInfo">
            <summary>
            A lazily calculated diagnostic for use of nullable annotations outside of a '#nullable' annotations context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.SyntaxToken,System.Nullable{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations},Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            A `?` annotation on a type that isn't a value type causes:
            - an error before C# 8.0
            - a warning outside of a NonNullTypes context
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2">
            <summary>
            An abstract flow pass that takes some shortcuts in analyzing finally blocks, in order to enable
            the analysis to take place without tracking exceptions or repeating the analysis of a finally block
            for each exit from a try statement.  The shortcut results in a slightly less precise
            (but still conservative) analysis, but that less precise analysis is all that is required for
            the language specification.  The most significant shortcut is that we do not track the state
            where exceptions can arise.  That does not affect the soundness for most analyses, but for those
            analyses whose soundness would be affected (e.g. "data flows out"), we track "unassignments" to keep
            the analysis sound.
            </summary>
            <remarks>
            Formally, this is a fairly conventional lattice flow analysis (<see
            href="https://en.wikipedia.org/wiki/Data-flow_analysis"/>) that moves upward through the <see cref="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.Join(`0@,`0@)"/> operation.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.compilation">
            <summary>
            The compilation in which the analysis is taking place.  This is needed to determine which
            conditional methods will be compiled and which will be omitted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2._symbol">
            <summary>
            The method whose body is being analyzed, or the field whose initializer is being analyzed.
            May be a top-level member or a lambda or local function. It is used for
            references to method parameters. Thus, '_symbol' should not be used directly, but
            'MethodParameters', 'MethodThisParameter' and 'AnalyzeOutParameters(...)' should be used
            instead. _symbol is null during speculative binding.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.CurrentSymbol">
            <summary>
            Reflects the enclosing member, lambda or local function at the current location (in the bound tree).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.methodMainNode">
            <summary>
            The bound node of the method or initializer being analyzed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2._labels">
            <summary>
            The flow analysis state at each label, computed by calling <see cref="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.Join(`0@,`0@)"/> on the state from branches to that label with the state
            when we fall into the label.  Entries are created when the label is encountered. One
            case deserves special attention: when the destination of the branch is a label earlier
            in the code, it is possible (though rarely occurs in practice) that we are changing the
            state at a label that we've already analyzed. In that case we run another pass of the
            analysis to allow those changes to propagate. This repeats until no further changes to
            the state of these labels occurs.  This can result in quadratic performance in unlikely
            but possible code such as this: "int x; if (cond) goto l1; x = 3; l5: print x; l4: goto
            l5; l3: goto l4; l2: goto l3; l1: goto l2;"
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.stateChangedAfterUse">
            <summary>
            Set to true after an analysis scan if the analysis was incomplete due to state changing
            after it was used by another analysis component.  In this case the caller scans again (until
            this is false). Since the analysis proceeds by monotonically changing the state computed
            at each label, this must terminate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2._labelsSeen">
            <summary>
            All of the labels seen so far in this forward scan of the body
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.PendingBranches">
            <summary>
            Pending escapes generated in the current scope (or more deeply nested scopes). When jump
            statements (goto, break, continue, return) are processed, they are placed in the
            pendingBranches buffer to be processed later by the code handling the destination
            statement. As a special case, the processing of try-finally statements might modify the
            contents of the pendingBranches buffer to take into account the behavior of
            "intervening" finally clauses.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.State">
            <summary>
            The definite assignment and/or reachability state at the point currently being analyzed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2._nonMonotonicTransfer">
            <summary>
            Indicates that the transfer function for a particular node (the function mapping the
            state before the node to the state after the node) is not monotonic, in the sense that
            it can change the state in either direction in the lattice. If the transfer function is
            monotonic, the transfer function can only change the state toward the <see
            cref="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.UnreachableState"/>. Reachability and definite assignment are monotonic, and
            permit a more efficient analysis. Region analysis and nullable analysis are not
            monotonic. This is just an optimization; we could treat all of them as nonmonotonic
            without much loss of performance. In fact, this only affects the analysis of (relatively
            rare) try statements, and is only a slight optimization.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.Diagnostics">
            <summary>
            Where all diagnostics are deposited.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2._loopHeadState">
            <summary>
            A cache of the state at the backward branch point of each loop.  This is not needed
            during normal flow analysis, but is needed for DataFlowsOut region analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.EnterRegion">
            <summary>
            Subclasses may override EnterRegion to perform any actions at the entry to the region.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.LeaveRegion">
            <summary>
            Subclasses may override LeaveRegion to perform any action at the end of the region.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.PendingBranch">
            <summary>
            A pending branch.  These are created for a return, break, continue, goto statement,
            yield return, yield break, await expression, and await foreach/using. The idea is that
            we don't know if the branch will eventually reach its destination because of an
            intervening finally block that cannot complete normally.  So we store them up and handle
            them as we complete processing each construct.  At the end of a block, if there are any
            pending branches to a label in that block we process the branch.  Otherwise we relay it
            up to the enclosing construct as a pending branch of the enclosing construct.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.Scan(System.Boolean@)">
            <summary>
            Perform a single pass of flow analysis.  Note that after this pass,
            this.backwardBranchChanged indicates if a further pass is required.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.MethodParameters">
            <summary>
            If a method is currently being analyzed returns its parameters, returns an empty array
            otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.MethodThisParameter">
            <summary>
            If a method is currently being analyzed returns its 'this' parameter, returns null
            otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.ShouldAnalyzeOutParameters(Microsoft.CodeAnalysis.Location@)">
            <summary>
            Specifies whether or not method's out parameters should be analyzed.
            </summary>
            <param name="location">location to be used</param>
            <returns>true if the out parameters of the method should be analyzed</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.LabelState(Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol)">
            <summary>
            Return the flow analysis state associated with a label.
            </summary>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.RemoveReturns">
            <summary>
            Return to the caller the set of pending return statements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.SetUnreachable">
            <summary>
            Set the current state to one that indicates that it is unreachable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.VisitCondition(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Visit a boolean condition expression.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.VisitRvalue(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Visit a general expression, where we will only need to determine if variables are
            assigned (or not). That is, we will not be needing AssignedWhenTrue and
            AssignedWhenFalse.
            </summary>
            <param name="isKnownToBeAnLvalue">True when visiting an rvalue that will actually be used as an lvalue,
            for example a ref parameter when simulating a read of it, or an argument corresponding to an in parameter</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.VisitStatement(Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Visit a statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.LoopHead(Microsoft.CodeAnalysis.CSharp.BoundLoopStatement)">
            <summary>
            Called at the point in a loop where the backwards branch would go to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.LoopTail(Microsoft.CodeAnalysis.CSharp.BoundLoopStatement)">
            <summary>
            Called at the point in a loop where the backward branch is placed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.ResolveBreaks(`0,Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol)">
            <summary>
            Used to resolve break statements in each statement form that has a break statement
            (loops, switch).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.ResolveContinues(Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol)">
            <summary>
            Used to resolve continue statements in each statement form that supports it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.NoteBranch(Microsoft.CodeAnalysis.CSharp.AbstractFlowPass{`0,`1}.PendingBranch,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Subclasses override this if they want to take special actions on processing a goto
            statement, when both the jump and the label have been located.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.ResolveBranches(Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            To handle a label, we resolve all branches to that label.  Returns true if the state of
            the label changes as a result.
            </summary>
            <param name="label">Target label</param>
            <param name="target">Statement containing the target label</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.SavePending">
            <summary>
            Since branches cannot branch into constructs, only out, we save the pending branches
            when visiting more nested constructs.  When tracking exceptions, we store the current
            state as the exception state for the following code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.RestorePending(Microsoft.CodeAnalysis.CSharp.AbstractFlowPass{`0,`1}.SavedPending)">
            <summary>
            We use this when closing a block that may contain labels or branches
            - branches to new labels are resolved
            - new labels are removed (no longer can be reached)
            - unresolved pending branches are carried forward
            </summary>
            <param name="oldPending">The old pending branches, which are to be merged with the current ones</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Since each language construct must be handled according to the rules of the language specification,
            the default visitor reports that the construct for the node is not implemented in the compiler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.TypeIsImmutable(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Certain (struct) types are known by the compiler to be immutable.  In these cases calling a method on
            the type is known (by flow analysis) not to write the receiver.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.VisitArguments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Do not call for a local function.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.VisitArgumentsAfterCall(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Writes ref and out parameters
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.JoinTryBlockState(`0@,`0@)">
            <summary>
            Join state from other try block, potentially in a nested method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.TryVisitConditionalAccess(Microsoft.CodeAnalysis.CSharp.BoundExpression,`0@)">
            <summary>
            Visits a node only if it is a conditional access.
            Returns 'true' if and only if the node was visited.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.CanPropagateStateWhenNotNull(Microsoft.CodeAnalysis.CSharp.Conversion)">
            <summary>
            "State when not null" can only propagate out of a conditional access if
            it is not subject to a user-defined conversion whose parameter is not of a non-nullable value type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.VisitPossibleConditionalAccess(Microsoft.CodeAnalysis.CSharp.BoundExpression,`0@)">
            <summary>
            Unconditionally visits an expression.
            If the expression has "state when not null" after visiting,
            the method returns 'true' and writes the state to <paramref name="stateWhenNotNull" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.VisitAssignmentOfNullCoalescingAssignment(Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingAssignmentOperator,Microsoft.CodeAnalysis.CSharp.BoundPropertyAccess)">
            <summary>
            This visitor represents just the assignment part of the null coalescing assignment
            operator.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.AdjustStateForNullCoalescingAssignmentNonNullCase(Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingAssignmentOperator)">
            <summary>
            This visitor represents just the non-assignment part of the null coalescing assignment
            operator (when the left operand is non-null).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.TopState">
            <summary>
            This is the "top" state of the data flow lattice. Generally, it is considered the state
            which is reachable, but no information is yet available. This is the state used at the
            start of method bodies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.UnreachableState">
            <summary>
            This is the absolute "bottom" state of the data flow lattice. C# does not specify a
            difference between unreachable states, so there can only be one. This is the state used
            for unreachable code, like statements after a "return" or "throw" statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.ReachableBottomState">
             <summary>
             This should be a reachable state that won't affect another reachable state in a
             <see cref="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.Join(`0@,`0@)"/>.
            
             Nontrivial implementation is required for DataFlowsOutWalker or any flow analysis pass
             that "tracks unassignments" like the nullable walker. The result should be a state, for
             each variable, that is the strongest result possible (i.e. definitely assigned for the
             data flow passes, or not null for the nullable analysis).
             operation.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.Join(`0@,`0@)">
             <summary>
             The "Join" operation is used when two separate control flow paths converge at a single
             statement. This operation is used to combine the if/else paths of a conditional, or two
             "goto" statements to the same label, for example.
             
             According to convention, Join moves "up" the lattice, so the following equations must hold:
             1. Join(Unreachable(), X) = X
             2. Join(Top, X) = Top
            
             </summary>
             <returns>
             True if <paramref name="self"/> was changed. False otherwise.
             </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.Meet(`0@,`0@)">
             <summary>
             The Meet operation is the inverse of <see cref="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.Join(`0@,`0@)"/>. 
             It's used when combining state additively, like when the state from a return statement
             inside a 'try' clause is combined with the end state of a 'finally' clause.
            
             This moves "down" our flow lattice, by convention. The following equations must hold:
             1. Meet(Unreachable, X) = Unreachable
             2. Meet(ReachableBottom, X - Unreachable) = ReachableBottom
             3. Meet(Top, X) = X
            
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.ILocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.ILocalState.Reachable">
            <summary>
            Is the code reachable?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.PendingBranchesCollection.ToImmutable">
            <summary>
            Returns the unordered collection of branches.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.PendingBranchesCollection.AsEnumerable">
            <summary>
            Returns the unordered collection of branches.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.AbstractLocalFunctionState.StateFromBottom">
            <summary>
            This is the state from the local function which makes the
            current state less specific. For example, in nullable analysis
            this would be captured variables that may be nullable after
            calling the local function. When a local function is called,
            this state is <see cref="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.Join(`0@,`0@)"/>
            with the current state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.AbstractLocalFunctionState.StateFromTop">
            <summary>
            This is the part of the local function transfer function which
            transfers knowledge additively. For example, in definite
            assignment this would be captured state which is assigned by
            the local function.  When a local function is called, this
            state is <see cref="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.Meet(`0@,`0@)"/>
            with the current state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.LocalFunctionStart(`1)">
            <summary>
            Executed at the start of visiting a local function body. The <paramref name="state"/>
            parameter holds the current state information for the local function being visited. To
            save state information across the analysis, return an instance of <typeparamref name="TLocalFunctionState"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.LocalFunctionEnd(`1,`1,`0@)">
            <summary>
            Executed after visiting a local function body. The <paramref name="savedState"/> is the
            return value from <see cref="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.LocalFunctionStart(`1)"/>. The <paramref name="currentState"/>
            is state information for the local function that was just visited. <paramref name="stateAtReturn"/> is
            the state after visiting the method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2.IsTraditionalSwitch(Microsoft.CodeAnalysis.CSharp.BoundSwitchStatement)">
            <summary>
            Is the switch statement one that could be interpreted as a C# 6 or earlier switch statement?
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.RegionPlace">
            <summary>
            The possible places that we are processing when there is a region.
            </summary>
            <remarks>
            This should be nested inside <see cref="T:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2"/> but is not due to https://github.com/dotnet/roslyn/issues/36992 .
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractRegionDataFlowPass.Scan(System.Boolean@)">
            <summary>
            To scan the whole body, we start outside (before) the region.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AlwaysAssignedWalker">
            <summary>
            A region analysis walker that computes the set of variables that are always assigned a value
            in the region. A variable is "always assigned" in a region if an analysis of the region that
            starts with the variable unassigned ends with the variable assigned.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis">
            <summary>
            This class implements the region control flow analysis operations. Region control flow
            analysis provides information about statements which enter and leave a region. The analysis
            is done lazily. When created, it performs no analysis, but simply caches the arguments.
            Then, the first time one of the analysis results is used it computes that one result and
            caches it. Each result is computed using a custom algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis.EntryPoints">
            <summary>
            A collection of statements outside the region that jump into the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis.ExitPoints">
            <summary>
            A collection of statements inside the region that jump to locations outside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis.EndPointIsReachable">
            <summary>
            Returns true if and only if the endpoint of the last statement in the region is reachable or the region contains no
            statements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis.ReturnStatements">
            <summary>
            A collection of return (or yield break) statements found within the region that return from the enclosing method or lambda.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis.Succeeded">
            <summary>
            Returns true if and only if analysis was successful.  Analysis can fail if the region does not properly span a single expression,
            a single statement, or a contiguous series of statements within the enclosing block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ControlFlowPass.LocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Analyze(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundBlock,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Perform control flow analysis, reporting all necessary diagnostics.  Returns true if the end of
            the body might be reachable...
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Analyze(System.Boolean@,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Analyze the body, reporting all necessary diagnostics.  Returns true if the end of the
            body might be reachable.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis">
            <summary>
            This class implements the region data flow analysis operations.  Region data flow analysis
            provides information how data flows into and out of a region.  The analysis is done lazily.
            When created, it performs no analysis, but simply caches the arguments. Then, the first time
            one of the analysis results is used it computes that one result and caches it. Each result
            is computed using a custom algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.VariablesDeclared">
            <summary>
            A collection of the local variables that are declared within the region. Note that the region must be
            bounded by a method's body or a field's initializer, so method parameter symbols are never included
            in the result, but lambda parameters might appear in the result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.DataFlowsIn">
            <summary>
            A collection of the local variables for which a value assigned outside the region may be used inside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.DefinitelyAssignedOnEntry">
            <summary>
            The set of local variables which are definitely assigned a value when a region is
            entered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.DefinitelyAssignedOnExit">
            <summary>
            The set of local variables which are definitely assigned a value when a region is
            exited.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.DataFlowsOut">
            <summary>
            A collection of the local variables for which a value assigned inside the region may be used outside the region.
            Note that every reachable assignment to a ref or out variable will be included in the results.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.AlwaysAssigned">
            <summary>
            A collection of the local variables for which a value is always assigned inside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.ReadInside">
            <summary>
            A collection of the local variables that are read inside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.WrittenInside">
            <summary>
            A collection of local variables that are written inside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.ReadOutside">
            <summary>
            A collection of the local variables that are read outside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.WrittenOutside">
            <summary>
            A collection of local variables that are written outside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.Captured">
            <summary>
            A collection of the non-constant local variables and parameters that have been referenced in anonymous functions
            and therefore must be moved to a field of a frame class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.UnsafeAddressTaken">
            <summary>
            A collection of the non-constant local variables and parameters that have had their address (or the address of one
            of their fields) taken using the '&amp;' operator.
            </summary>
            <remarks>
            If there are any of these in the region, then a method should not be extracted.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.Succeeded">
            <summary>
            Returns true if and only if analysis was successful.  Analysis can fail if the region does not properly span a single expression,
            a single statement, or a contiguous series of statements within the enclosing block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DataFlowsInWalker">
            <summary>
            A region analysis walker that computes the set of variables whose values flow into (are used
            in) the region. A variable assigned outside is used inside if an analysis that leaves the
            variable unassigned on entry to the region would cause the generation of "unassigned" errors
            within the region.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DataFlowsOutWalker">
            <summary>
            A region analysis walker that computes the set of variables for
            which their assigned values flow out of the region.
            A variable assigned inside is used outside if an analysis that
            treats assignments in the region as unassigning the variable would
            cause "unassigned" errors outside the region.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass">
            <summary>
            Implement C# definite assignment.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._variableSlot">
            <summary>
            A mapping from local variables to the index of their slot in a flow analysis local state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.variableBySlot">
             <summary>
             A mapping from the local variable slot to the symbol for the local variable itself.  This
             is used in the implementation of region analysis (support for extract method) to compute
             the set of variables "always assigned" in a region of code.
            
             The first slot, slot 0, is reserved for indicating reachability, so the first tracked variable will
             be given slot 1. When referring to VariableIdentifier.ContainingSlot, slot 0 indicates
             that the variable in VariableIdentifier.Symbol is a root, i.e. not nested within another
             tracked variable. Slots less than 0 are illegal.
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.initiallyAssignedVariables">
            <summary>
            Some variables that should be considered initially assigned.  Used for region analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._usedVariables">
            <summary>
            Variables that were used anywhere, in the sense required to suppress warnings about
            unused variables.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._readParameters">
            <summary>
            Parameters of record primary constructors that were read anywhere.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._usedLocalFunctions">
            <summary>
            Variables that were used anywhere, in the sense required to suppress warnings about
            unused variables.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._writtenVariables">
            <summary>
            Variables that were initialized or written anywhere.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._implicitlyInitializedFieldsOpt">
            <summary>
            Struct fields that are implicitly initialized, due to being used before being written, or not being written at an exit point.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._unsafeAddressTakenVariables">
            <summary>
            Map from variables that had their addresses taken, to the location of the first corresponding
            address-of expression.
            </summary>
            <remarks>
            Doesn't include fixed statement address-of operands.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._capturedVariables">
            <summary>
            Variables that were captured by anonymous functions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._sourceAssembly">
            <summary>
            The current source assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._unassignedVariableAddressOfSyntaxes">
            <summary>
            A set of address-of expressions for which the operand is not definitely assigned.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._alreadyReported">
            <summary>
            Tracks variables for which we have already reported a definite assignment error.  This
            allows us to report at most one such error per variable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._requireOutParamsAssigned">
            <summary>
            true if we should check to ensure that out parameters are assigned on every exit point.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._trackClassFields">
            <summary>
            Track fields of classes in addition to structs.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._trackStaticMembers">
            <summary>
            Track static fields, properties, events, in addition to instance members.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.topLevelMethod">
            <summary>
            The topmost method of this analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass._shouldCheckConverted">
            <summary>
            Check that every rvalue has been converted in the definite assignment pass only (not later passes deriving from it).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.#ctor(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundNode,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax},System.Boolean)">
            <summary>
            Constructor to be used for region analysis, for which a struct type should never be considered empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.Analyze(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol}@,System.Boolean)">
            <summary>
            Perform data flow analysis, reporting all necessary diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.Analyze(System.Boolean@,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Analyze the body, reporting all necessary diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.CheckCaptured(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol)">
            <summary>
            Check if the variable is captured and, if so, add it to this._capturedVariables.
            </summary>
            <param name="variable">The variable to be checked</param>
            <param name="rangeVariableUnderlyingParameter">If variable.Kind is RangeVariable, its underlying lambda parameter. Else null.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.NoteCaptured(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Add the variable to the captured set. For range variables we only add it if inside the region.
            </summary>
            <param name="variable"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.WriteConsideredUse(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            This reflects the Dev10 compiler's rules for when a variable initialization is considered a "use"
            for the purpose of suppressing the warning about unused variables.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.CheckAssigned(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Check that the given variable is definitely assigned.  If not, produce an error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.ReportUnassigned(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean)">
            <summary>
            Report a given variable as not definitely assigned.  Once a variable has been so
            reported, we suppress further reports of that variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.AssignImpl(Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Mark a variable as assigned (or unassigned).
            </summary>
            <param name="node">Node being assigned to.</param>
            <param name="value">The value being assigned.</param>
            <param name="written">True if target location is considered written to.</param>
            <param name="isRef">Ref assignment or value assignment.</param>
            <param name="read">True if target location is considered read from.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.FieldsAllSet(System.Int32,Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.LocalState)">
            <summary>
            Does the struct variable at the given slot have all of its instance fields assigned?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.BoundUsingStatement)">
            <remarks>
            Variables declared in a using statement are always considered used, so this is just an assert.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.LocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.CheckIfAssignedDuringLocalFunctionReplay(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Check that the given variable is definitely assigned when replaying local function
            reads. If not, produce an error.
            </summary>
            <remarks>
            Specifying the slot manually may be necessary if the symbol is a field,
            in which case <see cref="M:Microsoft.CodeAnalysis.CSharp.LocalDataFlowPass`2.VariableSlot(Microsoft.CodeAnalysis.CSharp.Symbol,System.Int32)"/>
            will not know which containing slot to look for.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.LocalFunctionEnd(Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.LocalFunctionState,Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.LocalFunctionState,Microsoft.CodeAnalysis.CSharp.DefiniteAssignmentPass.LocalState@)">
            <summary>
            State changes are handled by the base class. We override to find captured variables that
            have been read before they were assigned and determine if the set has changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalDataFlowPass`2">
            <summary>
            Does a data flow analysis for state attached to local variables and fields of struct locals.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LocalDataFlowPass`2.VariableIdentifier.ContainingSlot">
            <summary>
            Indicates whether this variable is nested inside another tracked variable.
            For instance, if a field `x` of a struct is a tracked variable, the symbol is not sufficient
            to uniquely determine which field is being tracked. The containing slot(s) would
            identify which tracked variable the field `x` is part of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.LocalDataFlowPass`2.ILocalDataFlowState.NormalizeToBottom">
            <summary>
            True if new variables introduced in <see cref="T:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`2" /> should be set
            to the bottom state. False if they should be set to the top state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LocalDataFlowPass`2._emptyStructTypeCache">
            <summary>
            A cache for remember which structs are empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalDataFlowPass`2.VariableSlot(Microsoft.CodeAnalysis.CSharp.Symbol,System.Int32)">
            <summary>
            Locals are given slots when their declarations are encountered.  We only need give slots
            to local variables, out parameters, and the "this" variable of a struct constructs.
            Other variables are not given slots, and are therefore not tracked by the analysis.  This
            returns -1 for a variable that is not tracked, for fields of structs that have the same
            assigned status as the container, and for structs that (recursively) contain no data members.
            We do not need to track references to
            variables that occur before the variable is declared, as those are reported in an
            earlier phase as "use before declaration". That allows us to avoid giving slots to local
            variables before processing their declarations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalDataFlowPass`2.GetOrCreateSlot(Microsoft.CodeAnalysis.CSharp.Symbol,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Force a variable to have a slot.  Returns -1 if the variable has an empty struct type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalDataFlowPass`2.Normalize(`0@)">
            <summary>
            Sets the starting state for any newly declared variables in the LocalDataFlowPass.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalDataFlowPass`2.DescendThroughTupleRestFields(Microsoft.CodeAnalysis.CSharp.Symbol@,System.Int32,System.Boolean)">
            <summary>
            Descends through Rest fields of a tuple if "symbol" is an extended field
            As a result the "symbol" will be adjusted to be the field of the innermost tuple
            and a corresponding containingSlot is returned.
            Return value -1 indicates a failure which could happen for the following reasons
            a) Rest field does not exist, which could happen in rare error scenarios involving broken ValueTuple types
            b) Rest is not tracked already and forceSlotsToExist is false (otherwise we create slots on demand)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalDataFlowPass`2.MakeSlot(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Return the slot for a variable, or -1 if it is not tracked (because, for example, it is an empty struct).
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DefinitelyAssignedWalker">
            <summary>
            A region analysis walker that computes the set of variables that are definitely assigned
            when a region is entered or exited.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache">
            <summary>
            A small cache for remembering empty struct types for flow analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache._dev12CompilerCompatibility">
            <summary>
            When set, we ignore private reference fields of structs loaded from metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.#ctor(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.Boolean)">
            <summary>
            Create a cache for computing whether or not a struct type is "empty".
            </summary>
            <param name="dev12CompilerCompatibility">Enable compatibility with the native compiler, which
             ignores inaccessible fields of reference type for structs loaded from metadata.</param>
            <param name="compilation">if <see cref="F:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache._dev12CompilerCompatibility"/> is true, set to the compilation from
            which to check accessibility.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.NeverEmptyStructTypeCache">
            <summary>
            Specialized EmptyStructTypeCache that reports all structs as not empty
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.IsEmptyStructType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Determine if the given type is an empty struct type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.IsEmptyStructType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol})">
            <summary>
            Determine if the given type is an empty struct type,. "typesWithMembersOfThisType" contains
            a list of types that have members (directly or indirectly) of this type.
            to remove circularity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.CheckStructInstanceFields(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol},Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Get all instance fields of a struct. They are not necessarily returned in order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.GetStructInstanceFields(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
             <summary>
             Get all instance fields of a struct. They are not necessarily returned in order.
             </summary>
            
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.IsIgnorableType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            When deciding what struct fields to drop on the floor, the native compiler looks
            through arrays, and does not ignore value types or type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.IsAccessibleInAssembly(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol)">
            <summary>
            Is it possible that the given symbol can be accessed somewhere in the given assembly?
            For the purposes of this test, we assume that code in the given assembly might derive from
            any type. So protected members are considered potentially accessible.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EntryPointsWalker">
            <summary>
            A region analysis walker that records jumps into the region.  Works by overriding NoteBranch, which is
            invoked by a superclass when the two endpoints of a jump have been identified.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExitPointsWalker">
            <summary>
            A region analysis walker that records jumps out of the region.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.FlowAnalysisPass.Rewrite(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BoundBlock,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean,System.Boolean)">
            <summary>
            The flow analysis pass.  This pass reports required diagnostics for unreachable
            statements and uninitialized variables (through the call to FlowAnalysisWalker.Analyze),
            and inserts a final return statement if the end of a void-returning method is reachable.
            </summary>
            <param name="method">the method to be analyzed</param>
            <param name="block">the method's body</param>
            <param name="compilationState">The state of compilation of the enclosing type</param>
            <param name="diagnostics">the receiver of the reported diagnostics</param>
            <param name="hasTrailingExpression">indicates whether this Script had a trailing expression</param>
            <param name="originalBodyNested">the original method body is the last statement in the block</param>
            <returns>the rewritten block for the method (with a return statement possibly inserted)</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker">
            <summary>
            Nullability flow analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.NullableAnalysisData">
            <summary>
            Nullable analysis data for methods, parameter default values, and attributes
            stored on the Compilation during testing only.
            The key is a symbol for methods or parameters, and syntax for attributes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.VariableState">
            <summary>
            Used to copy variable slots and types from the NullableWalker for the containing method
            or lambda to the NullableWalker created for a nested lambda or local function.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.Data">
            <summary>
            Data recorded for a particular analysis run.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.Data.TrackedEntries">
            <summary>
            Number of entries tracked during analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.Data.RequiredAnalysis">
            <summary>
            True if analysis was required; false if analysis was optional and results dropped.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitResult">
            <summary>
            Represents the result of visiting an expression.
            Contains a result type which tells us whether the expression may be null,
            and an l-value type which tells us whether we can assign null to the expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitArgumentResult">
            <summary>
            Represents the result of visiting an argument expression.
            In addition to storing the <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitArgumentResult.VisitResult"/>, also stores the <see cref="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.LocalState"/>
            for reanalyzing a lambda.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._binder">
            <summary>
            Binder for symbol being analyzed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._conversions">
            <summary>
            Conversions with nullability and unknown matching any.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._useConstructorExitWarnings">
            <summary>
            'true' if non-nullable member warnings should be issued at return points.
            One situation where this is 'false' is when we are analyzing field initializers and there is a constructor symbol in the type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._useDelegateInvokeParameterTypes">
            <summary>
            If true, the parameter types and nullability from _delegateInvokeMethod is used for
            initial parameter state. If false, the signature of CurrentSymbol is used instead.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._useDelegateInvokeReturnType">
            <summary>
            If true, the return type and nullability from _delegateInvokeMethod is used.
            If false, the signature of CurrentSymbol is used instead.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._delegateInvokeMethod">
            <summary>
            Method signature used for return or parameter types. Distinct from CurrentSymbol signature
            when CurrentSymbol is a lambda and type is inferred from MethodTypeInferrer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._returnTypesOpt">
            <summary>
            Return statements and the result types from analyzing the returned expressions. Used when inferring lambda return type in MethodTypeInferrer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._invalidType">
            <summary>
            Invalid type, used only to catch Visit methods that do not set
            _result.Type. See VisitExpressionWithoutStackGuard.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._analyzedNullabilityMapOpt">
            <summary>
            Contains the map of expressions to inferred nullabilities and types used by the optional rewriter phase of the
            compiler.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._snapshotBuilderOpt">
            <summary>
            Manages creating snapshots of the walker as appropriate. Null if we're not taking snapshots of
            this walker.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._methodGroupReceiverMapOpt">
            <summary>
            State of method group receivers, used later when analyzing the conversion to a delegate.
            (Could be replaced by _analyzedNullabilityMapOpt if that map is always available.)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._nestedFunctionVariables">
            <summary>
            Variables instances for each lambda or local function defined within the analyzed region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.NullableWalker.TargetTypedAnalysisCompletion">
            <summary>
            Map from a target-typed expression (such as a target-typed conditional, switch or new) to the delegate
            that completes analysis once the target type is known.
            The delegate is invoked by <see cref="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitConversion(Microsoft.CodeAnalysis.CSharp.BoundConversion,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.NullableWalker.AssignmentKind,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.Optional{Microsoft.CodeAnalysis.CSharp.NullableWalker.LocalState},System.Boolean,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitResult})"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._isSpeculative">
            <summary>
            True if we're analyzing speculative code. This turns off some initialization steps
            that would otherwise be taken.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._hasInitialState">
            <summary>
            True if this walker was created using an initial state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._visitResult">
            <summary>
            The result and l-value type of the last visited expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._currentConditionalReceiverVisitResult">
             <summary>
             The visit result of the receiver for the current conditional access.
            
             For example: A conditional invocation uses a placeholder as a receiver. By storing the
             visit result from the actual receiver ahead of time, we can give this placeholder a correct result.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.NullableWalker.ResultType">
            <summary>
            The result type represents the state of the last visited expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.UseRvalueOnly(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Force the inference of the LValueResultType from ResultType.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.UseLvalueOnly(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Force the inference of the ResultType from LValueResultType.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.SetAnalyzedNullability(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitResult,System.Nullable{System.Boolean})">
            <summary>
            Sets the analyzed nullability of the expression to be the given result.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._placeholderLocalsOpt">
            <summary>
            Placeholder locals, e.g. for objects being constructed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._disableDiagnostics">
            <summary>
            For methods with annotations, we'll need to visit the arguments twice.
            Once for diagnostics and once for result state (but disabling diagnostics).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._expressionIsRead">
            <summary>
            Whether we are going to read the currently visited expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker._lastConditionalAccessSlot">
            <summary>
            Used to allow <see cref="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.MakeSlot(Microsoft.CodeAnalysis.CSharp.BoundExpression)"/> to substitute the correct slot for a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundConditionalReceiver"/> when
            it's encountered.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.GetBaseOrThisInitializer">
            <summary>
            We have multiple ways of entering the nullable walker: we could be just analyzing the initializers, with a BoundStatementList body and _baseOrThisInitializer
            having been provided, or we could be analyzing the body of a constructor, with a BoundConstructorBody body and _baseOrThisInitializer being null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.AnalyzeIfNeeded(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean,Microsoft.CodeAnalysis.CSharp.NullableWalker.VariableState,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.NullableWalker.VariableState@)">
            <summary>
            Analyzes a method body if settings indicate we should.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.GetAfterInitializersState(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Gets the "after initializers state" which should be used at the beginning of nullable analysis
            of certain constructors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.AnalyzeWithoutRewrite(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
            <summary>
            Analyzes a set of bound nodes, recording updated nullability information. This method is only
            used when nullable is explicitly enabled for all methods but disabled otherwise to verify that
            correct semantic information is being recorded for all bound nodes. The results are thrown away.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.AnalyzeAndRewrite(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.NullableWalker.VariableState,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean,Microsoft.CodeAnalysis.CSharp.NullableWalker.SnapshotManager@,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol}@)">
            <summary>
            Analyzes a set of bound nodes, recording updated nullability information, and returns an
            updated BoundNode with the information populated.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.NeedsAnalysis(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the nullable analysis is needed for the region represented by <paramref name="syntaxNode"/>.
            The syntax node is used to determine the overall nullable context for the region.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.AnalyzeIfNeeded(Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>Analyzes a node in a "one-off" context, such as for attributes or parameter default values.</summary>
            <remarks><paramref name="syntax"/> is the syntax span used to determine the overall nullable context.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitRvalueEpilogue(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            The contents of this method, particularly <see cref="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.UseRvalueOnly(Microsoft.CodeAnalysis.CSharp.BoundExpression)"/>, are problematic when
            inlined. The methods themselves are small but they end up allocating significantly larger
            frames due to the use of biggish value types within them. The <see cref="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitRvalue(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean)"/> method
            is used on a hot path for fluent calls and this size change is enough that it causes us
            to exceed our thresholds in EndToEndTests.OverflowOnFluentCall.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.ShouldReportNullableAssignment(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.NullableFlowState)">
             <summary>
             Should we warn for assigning this state into this type?
            
             This should often be checked together with <seealso cref="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.IsDisallowedNullAssignment(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState,Microsoft.CodeAnalysis.CSharp.Symbols.FlowAnalysisAnnotations)"/>
             It catches putting a `null` into a `[DisallowNull]int?` for example, which cannot simply be represented as a non-nullable target type.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.ReportNullableAssignmentIfNecessary(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState,System.Boolean,Microsoft.CodeAnalysis.CSharp.NullableWalker.AssignmentKind,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.Location)">
            <summary>
            Reports top-level nullability problem in assignment.
            Any conversion of the value should have been applied.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.TrackNullableStateForAssignment(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState,System.Int32)">
            <summary>
            Update tracked value on assignment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.SetStateAndTrackForFinally(Microsoft.CodeAnalysis.CSharp.NullableWalker.LocalState@,System.Int32,Microsoft.CodeAnalysis.CSharp.NullableFlowState)">
            <summary>
            Whenever assigning a variable, and that variable is not declared at the point the state is being set,
            and the new state is not <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableFlowState.NotNull"/>, this method should be called to perform the
            state setting and to ensure the mutation is visible outside the finally block when the mutation occurs in a
            finally block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitObjectCreationInitializer(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundObjectInitializerExpressionBase,System.Boolean)">
            <summary>
            If <paramref name="delayCompletionForType"/>, <paramref name="containingSlot"/> is known only within returned delegate.
            </summary>
            <returns>A delegate to complete the initializer analysis.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitObjectElementInitializer(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundAssignmentOperator,System.Boolean)">
            <summary>
            If <paramref name="delayCompletionForType"/>, <paramref name="containingSlot"/> is known only within returned delegate.
            </summary>
            <returns>A delegate to complete the element initializer analysis.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.IsEmptyStructType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Returns true if the type is a struct with no fields or properties.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.BestTypeForLambdaReturns(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.ValueTuple{Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,System.Boolean}},Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.Conversions,System.Boolean@)">
            <summary>
            Applies analysis similar to <see cref="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitArrayCreation(Microsoft.CodeAnalysis.CSharp.BoundArrayCreation)"/>.
            The expressions returned from a lambda are not converted though, so we'll have to classify fresh conversions.
            Note: even if some conversions fail, we'll proceed to infer top-level nullability. That is reasonable in common cases.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.GetSlotsToMarkAsNotNullable(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Int32})">
            <summary>
            If we learn that the operand is non-null, we can infer that certain
            sub-expressions were also non-null.
            Get all nested conditional slots for those sub-expressions. For example in a?.b?.c we'll set a, b, and c.
            Only returns slots for tracked expressions.
            </summary>
            <remarks>https://github.com/dotnet/roslyn/issues/53397 This method should potentially be removed.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.TryVisitConditionalAccess(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.NullableWalker.PossiblyConditionalState@)">
            <summary>
            Visits a node only if it is a conditional access.
            Returns 'true' if and only if the node was visited.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitPossibleConditionalAccess(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.NullableWalker.PossiblyConditionalState@)">
            <summary>
            Unconditionally visits an expression and returns the "state when not null" for the expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.CreatePlaceholderIfNecessary(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations)">
            <summary>
            Placeholders are bound expressions with type and state.
            But for typeless expressions (such as `null` or `(null, null)` we hold onto the original bound expression,
            as it will be useful for conversions from expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.ApplyLValueAnnotations(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.FlowAnalysisAnnotations)">
            <summary>
            Fix a TypeWithAnnotations based on Allow/DisallowNull annotations prior to a conversion or assignment.
            Note this does not work for nullable value types, so an additional check with <see cref="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.CheckDisallowedNullAssignment(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState,Microsoft.CodeAnalysis.CSharp.Symbols.FlowAnalysisAnnotations,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BoundExpression)"/> may be required.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.ApplyUnconditionalAnnotations(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState,Microsoft.CodeAnalysis.CSharp.Symbols.FlowAnalysisAnnotations)">
            <summary>
            Update the null-state based on MaybeNull/NotNull
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitArguments(Microsoft.CodeAnalysis.CSharp.BoundNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.Collections.Immutable.ImmutableArray{System.Int32},Microsoft.CodeAnalysis.BitVector,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            If you pass in a method symbol, its type arguments will be re-inferred and the re-inferred method will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitArgumentConversionAndInboundAssignmentsAndPreConditions(Microsoft.CodeAnalysis.CSharp.BoundConversion,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.FlowAnalysisAnnotations,Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitArgumentResult,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitResult},System.Boolean)">
            <summary>
            Verifies that an argument's nullability is compatible with its parameter's on the way in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.CheckDisallowedNullAssignment(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState,Microsoft.CodeAnalysis.CSharp.Symbols.FlowAnalysisAnnotations,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>Returns <see langword="true"/> if this is an assignment forbidden by DisallowNullAttribute, otherwise <see langword="false"/>.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitArgumentOutboundAssignmentsAndPostConditions(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.FlowAnalysisAnnotations,Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitArgumentResult,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},Microsoft.CodeAnalysis.CSharp.NullableWalker.CompareExchangeInfo)">
            <summary>
            Verifies that outbound assignments (from parameter to argument) are safe and
            tracks those assignments (or learns from post-condition attributes)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.LearnFromPostConditions(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.FlowAnalysisAnnotations)">
            <summary>
            Learn from postconditions on a by-value or 'in' argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.MethodInferenceExtensions.GetNullableAnnotation(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Return top-level nullability for the expression. This method should be called on a limited
            set of expressions only. It should not be called on expressions tracked by flow analysis
            other than <see cref="F:Microsoft.CodeAnalysis.CSharp.BoundKind.ExpressionWithNullability"/> which is an expression
            specifically created in NullableWalker to represent the flow analysis state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.RemoveConversion(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Returns the expression without the top-most conversion plus the conversion.
            If the expression is not a conversion, returns the original expression plus
            the Identity conversion. If `includeExplicitConversions` is true, implicit and
            explicit conversions are considered. If `includeExplicitConversions` is false
            only implicit conversions are considered and if the expression is an explicit
            conversion, the expression is returned as is, with the Identity conversion.
            (Currently, the only visit method that passes `includeExplicitConversions: true`
            is VisitConversion. All other callers are handling implicit conversions only.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.UseExpressionForConversion(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Returns true if the expression should be used as the source when calculating
            a conversion from this expression, rather than using the type (with nullability)
            calculated by visiting this expression. Typically, that means expressions that
            do not have an explicit type but there are several other cases as well.
            (See expressions handled in ClassifyImplicitBuiltInConversionFromExpression.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.GetAdjustedResult(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState,System.Int32)">
            <summary>
            Adjust declared type based on inferred nullability at the point of reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.AsMemberOfType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Gets the corresponding member for a symbol from initial binding to match an updated receiver type in NullableWalker.
            For instance, this will map from List&lt;string~&gt;.Add(string~) to List&lt;string?&gt;.Add(string?) in the following example:
            <example>
            string s = null;
            var list = new[] { s }.ToList();
            list.Add(null);
            </example>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitOptionalImplicitConversion(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.NullableWalker.AssignmentKind)">
            <summary>
            Visit an expression. If an explicit target type is provided, the expression is converted
            to that type. This method should be called whenever an expression may contain
            an implicit conversion, even if that conversion was omitted from the bound tree,
            so the conversion can be re-classified with nullability.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.TrackNullableStateOfTupleElements(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState},System.Collections.Immutable.ImmutableArray{System.Int32},System.Boolean)">
            <summary>
            Set the nullability of tuple elements for tuples at the point of construction.
            If <paramref name="useRestField"/> is true, the tuple was constructed with an explicit
            'new ValueTuple' call, in which case the 8-th element, if any, represents the 'Rest' field.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.GetConversionIfApplicable(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Gets the conversion node for passing to VisitConversion, if one should be passed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitConversion(Microsoft.CodeAnalysis.CSharp.BoundConversion,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.NullableWalker.AssignmentKind,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.Optional{Microsoft.CodeAnalysis.CSharp.NullableWalker.LocalState},System.Boolean,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitResult})">
            <summary>
            Apply the conversion to the type of the operand and return the resulting type.
            If the operand does not have an explicit type, the operand expression is used.
            </summary>
            <param name="checkConversion">
            If <see langword="true"/>, the incoming conversion is assumed to be from binding
            and will be re-calculated, this time considering nullability.
            Note that the conversion calculation considers nested nullability only.
            The caller is responsible for checking the top-level nullability of
            the type returned by this method.
            </param>
            <param name="trackMembers">
            If <see langword="true"/>, the nullability of any members of the operand
            will be copied to the converted result when possible.
            </param>
            <param name="useLegacyWarnings">
            If <see langword="true"/>, indicates that the "non-safety" diagnostic <see cref="F:Microsoft.CodeAnalysis.CSharp.ErrorCode.WRN_ConvertingNullableToNonNullable"/>
            should be given for an invalid conversion.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.GetLiftedReturnType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.NullableFlowState)">
            <summary>
            Return the return type for a lifted operator, given the nullability state of its operands.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.AdjustSetValue(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState@)">
            <summary>
            When the allowed output of a property/indexer is not-null but the allowed input is maybe-null, we store a not-null value instead.
            This way, assignment of a legal input value results in a legal output value.
            This adjustment doesn't apply to oblivious properties/indexers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.GetDeconstructionRightParts(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Nullable{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithState})">
            <summary>
            Return the sub-expressions for the righthand side of a deconstruction
            assignment. cf. LocalRewriter.GetRightParts.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.ReportNullabilityMismatchInArgument(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Report warning passing argument where nested nullability does not match
            parameter (e.g.: calling `void F(object[] o)` with `F(new[] { maybeNull })`).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.LocalState">
            <summary>
            A bit array containing the nullability of variables associated with a method scope. If the method is a
            nested function (a lambda or a local function), there is a reference to the corresponding instance for
            the containing method scope. The instances in the chain are associated with a corresponding
            <see cref="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.Variables"/> chain, and the <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.LocalState.Id"/> field in this type matches <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.Variables.Id"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.LocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.LocalFunctionState.StartingState">
            <summary>
            Defines the starting state used in the local function body to
            produce diagnostics and determine types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.PlaceholderLocal">
            <summary>
            A symbol to be used as a placeholder for an instance being constructed by
            <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundObjectCreationExpression"/>, or the input expression of a pattern-matching operation.
            It is used to track the state of an expression, such as members being initialized.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.SnapshotManager._walkerSharedStates">
            <summary>
            The int key corresponds to <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.Snapshot.SharedStateIndex"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.SnapshotManager._incrementalSnapshots">
            <summary>
            The snapshot array should be sorted in ascending order by the position tuple element in order for the binary search algorithm to
            function correctly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.SnapshotManager.Builder._updatedSymbolMap">
            <summary>
            Contains the map of expression and original symbol to reinferred symbols, used by the optional
            rewriter phase of the compiler.
            </summary>
            <remarks>
            Lambda symbols are mapped to the NameTypeSymbol of the delegate type they were reinferred to,
            and are stored with a null node. The LambdaSymbol itself is position-independent, and does not
            need any more information to serve as a key.
            All other symbol types are stored mapped to exactly the same type as was provided.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.SnapshotManager.Builder._walkerStates">
            <summary>
            Shared walker states are the parts of the walker state that are not unique at a single position,
            but are instead used by all snapshots. Each shared state corresponds to one invocation of Analyze,
            so entering a lambda or local function will create a new state here. The indexes in this array
            correspond to <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.Snapshot.SharedStateIndex"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.SnapshotManager.Builder._incrementalSnapshots">
            <summary>
            Snapshots are kept in a dictionary of position -> snapshot at that position. These are stored in descending order.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.SnapshotManager.Builder._symbolToSlot">
            <summary>
            Every walker is walking a specific symbol, and can potentially walk each symbol multiple times
            to get to a stable state. Each of these symbols gets a single shared state slot, which this
            dictionary keeps track of. These slots correspond to indexes into <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.SnapshotManager.Builder._walkerStates"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.SharedWalkerState">
            <summary>
            Contains the shared state used to restore the walker at a specific point
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.Snapshot">
            <summary>
            Contains a snapshot of the state of the NullableWalker at any given point of execution, used for restoring the walker to
            a specific point for speculatively analyzing a piece of code that does not appear in the original tree.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.VariablesSnapshot">
            <summary>
            An immutable copy of <see cref="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.Variables"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.VariablesSnapshot.Id">
            <summary>
            Unique identifier in the chain of nested VariablesSnapshot instances. The value starts at 0
            for the outermost method and increases at each nested function.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.VariablesSnapshot.Container">
            <summary>
            VariablesSnapshot instance for containing method, or null if this is the outermost method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.VariablesSnapshot.Symbol">
            <summary>
            Symbol that contains this set of variables. This is typically a method but may be a field
            when analyzing a field initializer. The symbol may be null at the outermost scope when
            analyzing an attribute argument value or a parameter default value.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.VariablesSnapshot.VariableSlot">
            <summary>
            Mapping from variable to slot.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.VariablesSnapshot.VariableTypes">
            <summary>
            Mapping from local or parameter to inferred type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableWalker.Variables">
            <summary>
            A collection of variables associated with a method scope. For a particular method, the variables
            may contain parameters and locals and any fields from other variables in the collection. If the method
            is a nested function (a lambda or a local function), there is a reference to the variables collection at
            the containing method scope. The outermost scope may also contain variables for static fields.
            Each variable (parameter, local, or field of other variable) must be associated with the variables collection
            for that method where the parameter or local are declared, even if the variable is used in a nested scope.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.Variables.Id">
            <summary>
            Unique identifier in the chain of nested Variables instances. The value starts at 0
            for the outermost method and increases at each nested function.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.Variables.Container">
            <summary>
            Variables instance for containing method, or null if this is the outermost method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.Variables.Symbol">
            <summary>
            Symbol that contains this set of variables. This is typically a method but may be a field
            when analyzing a field initializer. The symbol may be null at the outermost scope when
            analyzing an attribute argument value or a parameter default value.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.Variables._variableSlot">
            <summary>
            A mapping from local variables to the index of their slot in a flow analysis local state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.Variables._variableTypes">
            <summary>
            The inferred type at the point of declaration of var locals and parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableWalker.Variables._variableBySlot">
             <summary>
             A mapping from the local variable slot to the symbol for the local variable itself.
            
             The first slot, slot 0, is reserved for indicating reachability, so the first tracked variable will
             be given slot 1. When referring to VariableIdentifier.ContainingSlot, slot 0 indicates
             that the variable in VariableIdentifier.Symbol is a root, i.e. not nested within another
             tracked variable. Slots less than 0 are illegal.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.LearnFromAnyNullPatterns(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundPattern)">
            <summary>
            Learn something about the input from a test of a given expression against a given pattern.  The given
            state is updated to note that any slots that are tested against `null` may be null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableWalker.LearnFromAnyNullPatterns(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundPattern)">
            <summary>
            Learn from any constant null patterns appearing in the pattern.
            </summary>
            <param name="inputType">Type type of the input expression (before nullable analysis).
            Used to determine which types can contain null.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ReadWriteWalker">
            <summary>
            A region analysis walker that records reads and writes of all variables, both inside and outside the region.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ReadWriteWalker.NoteRead(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol)">
            <summary>
            Note that a variable is read.
            </summary>
            <param name="variable">The variable</param>
            <param name="rangeVariableUnderlyingParameter">If variable.Kind is RangeVariable, its underlying lambda parameter. Else null.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ReadWriteWalker.NoteReceiverReadOrWritten(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            When we read a field from a struct, the receiver isn't seen as being read until we get to the
            end of the field access expression, because we only read the relevant piece of the struct.
            But we want the receiver to be considered to be read in the region in that case.
            For example, if an rvalue expression is x.y.z and the region is x.y, we want x to be included
            in the ReadInside set.  That is implemented here.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ReadWriteWalker.GetRangeVariableUnderlyingParameter(Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Compute the underlying lambda parameter symbol for a range variable, if any.
            </summary>
            <param name="underlying">The bound node for the expansion of the range variable</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext">
            <summary>
            Represents region analysis context attributes such as compilation, region, etc...
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.Compilation">
            <summary> Compilation to use </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.Member">
            <summary> Containing symbol if available, null otherwise </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.BoundNode">
            <summary> Bound node, not null </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.FirstInRegion">
            <summary> Region to be used </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.LastInRegion">
            <summary> Region to be used </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.Failed">
            <summary> True if the input was bad, such as no first and last nodes </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.#ctor(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Construct context
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.RegionReachableWalker">
            <summary>
            A region analysis walker that computes whether or not the region completes normally.  It does this by determining
            if the point at which the region ends is reachable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UnassignedAddressTakenVariablesWalker">
            <summary>
            An analysis that computes all cases where the address is taken of a variable that has not yet been assigned
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UnassignedVariablesWalker">
            <summary>
            An analysis that computes the set of variables that may be used
            before being assigned anywhere within a method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.VariablesDeclaredWalker">
            <summary>
            A region analysis walker that records declared variables.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.VariablesDeclaredWalker.NoteDeclaredPatternVariables(Microsoft.CodeAnalysis.CSharp.BoundPattern)">
            <summary>
            Record declared variables in the pattern.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LanguageVersion">
            <summary>
            Specifies the language version.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp1">
            <summary>
            C# language version 1
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp2">
            <summary>
            C# language version 2
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp3">
            <summary>
            C# language version 3
            <para>
            Features: LINQ.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp4">
            <summary>
            C# language version 4
            <para>
            Features: dynamic.
            </para>        
            </summary>        
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp5">
            <summary>
            C# language version 5
            <para>
            Features: async, caller info attributes.
            </para>        
            </summary> 
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp6">
            <summary>
            C# language version 6
            <para>Features:</para>
            <list type="bullet">
            <item><description>Using of a static class</description></item>
            <item><description>Exception filters</description></item>
            <item><description>Await in catch/finally blocks</description></item>
            <item><description>Auto-property initializers</description></item>
            <item><description>Expression-bodied methods and properties</description></item>
            <item><description>Null-propagating operator ?.</description></item>
            <item><description>String interpolation</description></item>
            <item><description>nameof operator</description></item>
            <item><description>Dictionary initializer</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp7">
            <summary>
            C# language version 7.0
            <para>Features:</para>
            <list type="bullet">
            <item><description>Out variables</description></item>
            <item><description>Pattern-matching</description></item>
            <item><description>Tuples</description></item>
            <item><description>Deconstruction</description></item>
            <item><description>Discards</description></item>
            <item><description>Local functions</description></item>
            <item><description>Digit separators</description></item>
            <item><description>Ref returns and locals</description></item>
            <item><description>Generalized async return types</description></item>
            <item><description>More expression-bodied members</description></item>
            <item><description>Throw expressions</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp7_1">
            <summary>
            C# language version 7.1
            <para>Features:</para>
            <list type="bullet">
            <item><description>Async Main</description></item>
            <item><description>Default literal</description></item>
            <item><description>Inferred tuple element names</description></item>
            <item><description>Pattern-matching with generics</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp7_2">
            <summary>
            C# language version 7.2
            <para>Features:</para>
            <list type="bullet">
            <item><description>Ref readonly</description></item>
            <item><description>Ref and readonly structs</description></item>
            <item><description>Ref extensions</description></item>
            <item><description>Conditional ref operator</description></item>
            <item><description>Private protected</description></item>
            <item><description>Digit separators after base specifier</description></item>
            <item><description>Non-trailing named arguments</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp7_3">
            <summary>
            C# language version 7.3
            <para>Features:</para>
            <list type="bullet">
            <item><description>Indexing fixed fields does not require pinning</description></item>
            <item><description>ref local variables may be reassigned</description></item>
            <item><description>stackalloc arrays support initializers</description></item>
            <item><description>More types support the fixed statement</description></item>
            <item><description>Enhanced generic constraints</description></item>
            <item><description>Tuples support == and !=</description></item>
            <item><description>Attach attributes to the backing fields for auto-implemented properties</description></item>
            <item><description>Method overload resolution improvements when arguments differ by 'in'</description></item>
            <item><description>Extend expression variables in initializers</description></item>
            <item><description>Improved overload candidates</description></item>
            <item><description>New compiler options (-publicsign and -pathmap)</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp8">
            <summary>
            C# language version 8.0
            <para>Features:</para>
            <list type="bullet">
            <item><description>Readonly members</description></item>
            <item><description>Default interface methods</description></item>
            <item><description>Pattern matching enhancements (switch expressions, property patterns, tuple patterns, and positional patterns)</description></item>
            <item><description>Using declarations</description></item>
            <item><description>Static local functions</description></item>
            <item><description>Disposable ref structs</description></item>
            <item><description>Nullable reference types</description></item>
            <item><description>Asynchronous streams</description></item>
            <item><description>Asynchronous disposable</description></item>
            <item><description>Indices and ranges</description></item>
            <item><description>Null-coalescing assignment</description></item>
            <item><description>Unmanaged constructed types</description></item>
            <item><description>Stackalloc in nested expressions</description></item>
            <item><description>Enhancement of interpolated verbatim strings</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp9">
            <summary>
            C# language version 9.0
            <para>Features:</para>
            <list type="bullet">
            <item><description>Records</description></item>
            <item><description>Init only setters</description></item>
            <item><description>Top-level statements</description></item>
            <item><description>Pattern matching enhancements</description></item>
            <item><description>Native sized integers</description></item>
            <item><description>Function pointers</description></item>
            <item><description>Suppress emitting localsinit flag</description></item>
            <item><description>Target-typed new expressions</description></item>
            <item><description>Static anonymous functions</description></item>
            <item><description>Target-typed conditional expressions</description></item>
            <item><description>Covariant return types</description></item>
            <item><description>Extension GetEnumerator support for foreach loops</description></item>
            <item><description>Lambda discard parameters</description></item>
            <item><description>Attributes on local functions</description></item>
            <item><description>Module initializers</description></item>
            <item><description>New features for partial methods</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp10">
            <summary>
            C# language version 10.0
            <para>Features:</para>
            <list type="bullet">
            <item><description>Record structs</description></item>
            <item><description>Global using directives</description></item>
            <item><description>Lambda improvements</description></item>
            <item><description>Improved definite assignment</description></item>
            <item><description>Constant interpolated strings</description></item>
            <item><description>Mix declarations and variables in deconstruction</description></item>
            <item><description>Extended property patterns</description></item>
            <item><description>Sealed record ToString</description></item>
            <item><description>Source Generator v2 APIs</description></item>
            <item><description>Method-level AsyncMethodBuilder</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp11">
            <summary>
            C# language version 11.0
            <br/>
            Features:
            <list type="bullet">
            <item><description>Raw string literals</description></item>
            <item><description>Static abstract members in interfaces</description></item>
            <item><description>Generic attributes</description></item>
            <item><description>Newlines in interpolations</description></item>
            <item><description>List-patterns</description></item>
            <item><description>Required members</description></item>
            <item><description>Span&lt;char> constant pattern</description></item>
            <item><description>Struct auto-default</description></item>
            <item><description>Nameof(parameter)</description></item>
            <item><description>Checked user-defined operators</description></item>
            <item><description>UTF-8 string literals</description></item>
            <item><description>Unsigned right-shift operator</description></item>
            <item><description>Relaxed shift operator</description></item>
            <item><description>Ref fields</description></item>
            <item><description>File-local types</description></item>
            </list> 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.LatestMajor">
            <summary>
            The latest major supported version.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.Preview">
            <summary>
            Preview of the next language version.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.Latest">
            <summary>
            The latest supported version of the language.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.Default">
            <summary>
            The default language version, which is the latest supported version.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.CSharpNext">
            <summary>
            Usages of TestOptions.RegularNext and LanguageVersionFacts.CSharpNext
            will be replaced with TestOptions.RegularN and LanguageVersion.CSharpN when language version N is introduced.
            <para>
            Corresponds to Microsoft.CodeAnalysis.CSharp.Shared.Extensions.LanguageVersionExtensions.CSharpNext.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.ToDisplayString(Microsoft.CodeAnalysis.CSharp.LanguageVersion)">
            <summary>
            Displays the version number in the format expected on the command-line (/langver flag).
            For instance, "6", "7.0", "7.1", "latest".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.TryParse(System.String,Microsoft.CodeAnalysis.CSharp.LanguageVersion@)">
            <summary>
            Try parse a <see cref="T:Microsoft.CodeAnalysis.CSharp.LanguageVersion"/> from a string input, returning default if input was null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.MapSpecifiedToEffectiveVersion(Microsoft.CodeAnalysis.CSharp.LanguageVersion)">
            <summary>
            Map a language version (such as Default, Latest, or CSharpN) to a specific version (CSharpM).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.DisallowInferredTupleElementNames(Microsoft.CodeAnalysis.CSharp.LanguageVersion)">
            <summary>Inference of tuple element names was added in C# 7.1</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter">
            <summary>
            The purpose of this rewriter is to replace await-containing catch and finally handlers
            with surrogate replacements that keep actual handler code in regular code blocks.
            That allows these constructs to be further lowered at the async lowering pass.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
             <summary>
             Lower a block of code by performing local rewritings. 
             The goal is to not have exception handlers that contain awaits in them.
             
             1) Await containing finally blocks:
                 The general strategy is to rewrite await containing handlers into synthetic handlers.
                 Synthetic handlers are not handlers in IL sense so it is ok to have awaits in them.
                 Since synthetic handlers are just blocks, we have to deal with pending exception/branch/return manually
                 (this is the hard part of the rewrite).
            
                 try{
                    code;
                 }finally{
                    handler;
                 }
            
             Into ===>
            
                 Exception ex = null;
                 int pendingBranch = 0;
            
                 try{
                     code;  // any gotos/returns are rewritten to code that pends the necessary info and goes to finallyLabel
                     goto finallyLabel;
                 }catch (ex){  // essentially pend the currently active exception
                 };
            
                 finallyLabel:
                 {
                    handler;
                    if (ex != null) throw ex;     // unpend the exception
                    unpend branches/return
                 }
             
             2) Await containing catches:
                 try{
                     code;
                 }catch (Exception ex){
                     handler;
                     throw;
                 }
             
             
             Into ===>
            
                 Object pendingException;
                 int pendingCatch = 0;
            
                 try{
                     code; 
                 }catch (Exception temp){  // essentially pend the currently active exception
                     pendingException = temp;
                     pendingCatch = 1;
                 };
            
                 switch(pendingCatch):
                 {
                    case 1:
                     {
                         Exception ex = (Exception)pendingException;
                         handler;
                         throw pendingException
                     }
                 }
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.RewriteFinalizedRegion(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            Rewrites Try/Catch part of the Try/Catch/Finally
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.AwaitInFinallyAnalysis">
            <summary>
            Analyzes method body for try blocks with awaits in finally blocks 
            Also collects labels that such blocks contain.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.AwaitInFinallyAnalysis.FinallyContainsAwaits(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            Returns true if a finally of the given try contains awaits
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.AwaitInFinallyAnalysis.CatchContainsAwait(Microsoft.CodeAnalysis.CSharp.BoundCatchBlock)">
            <summary>
            Returns true if a catch contains awaits
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.AwaitInFinallyAnalysis.ContainsAwaitInHandlers">
            <summary>
            Returns true if body contains await in a finally block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.AwaitInFinallyAnalysis.Labels(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            Labels reachable from within this frame without invoking its finally. 
            null if there are no such labels.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncIteratorInfo">
            <summary>
            Additional information for rewriting an async-iterator.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncIteratorMethodToStateMachineRewriter">
            <summary>
            Produces a MoveNext() method for an async-iterator method.
            Compared to an async method, this handles rewriting `yield return` (with states decreasing from -3) and
            `yield break`, and adds special handling for `try` to allow disposal.
            `await` is handled like in async methods (with states 0 and up).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncIteratorMethodToStateMachineRewriter._currentDisposalLabel">
             <summary>
             Where should we jump to to continue the execution of disposal path.
            
             Initially, this is the method's return value label (<see cref="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._exprReturnLabel"/>).
             Inside a `try` or `catch` with a `finally`, we'll use the label directly preceding the `finally`.
             Inside a `try` or `catch` with an extracted `finally`, we will use the label preceding the extracted `finally`.
             Inside a `finally`, we'll have no/null label (disposal continues without a jump).
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncIteratorMethodToStateMachineRewriter._exprReturnLabelTrue">
            <summary>
            We use _exprReturnLabel for normal end of method (ie. no more values) and `yield break;`.
            We use _exprReturnLabelTrue for `yield return;`.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncIteratorMethodToStateMachineRewriter._iteratorStateAllocator">
            <summary>
            States for `yield return` are decreasing from <see cref="F:Microsoft.CodeAnalysis.StateMachineState.InitialAsyncIteratorState"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncIteratorMethodToStateMachineRewriter.VisitBody(Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Lower the body, adding an entry state (-3) at the start,
            so that we can differentiate an async-iterator that was never moved forward with MoveNextAsync()
            from one that is running (-1).
            Then we can guard against some bad usages of DisposeAsync.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncIteratorMethodToStateMachineRewriter.VisitTryStatement(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
             <summary>
             An async-iterator state machine has a flag indicating "dispose mode".
             We enter dispose mode by calling DisposeAsync() when the state machine is paused on a `yield return`.
             DisposeAsync() will resume execution of the state machine from that state (using existing dispatch mechanism
             to restore execution from a given state, without executing other code to get there).
            
             From there, we don't want normal code flow:
             - from `yield return` within a try, we'll jump to its `finally` if it has one (or method exit)
             - after finishing a `finally` within a `finally`, we'll continue
             - after finishing a `finally` within a `try`, jump to the its `finally` if it has one (or method exit)
            
             Some `finally` clauses may have already been rewritten and extracted to a plain block (<see cref="T:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter"/>).
             In those cases, we saved the finally-entry label in <see cref="P:Microsoft.CodeAnalysis.CSharp.BoundTryStatement.FinallyLabelOpt"/>.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncIteratorMethodToStateMachineRewriter.VisitExtractedFinallyBlock(Microsoft.CodeAnalysis.CSharp.BoundExtractedFinallyBlock)">
            <summary>
            Some `finally` clauses may have already been rewritten and extracted to a plain block (<see cref="T:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter"/>).
            The extracted block will have been wrapped as a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundExtractedFinallyBlock"/> so that we can process it as a `finally` block here.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection">
            <summary>
            Async methods have both a return type (void, Task, or Task&lt;T&gt;) and a 'result' type, which is the
            operand type of any return expressions in the async method. The result type is void in the case of
            Task-returning and void-returning async methods, and T in the case of Task&lt;T&gt;-returning async
            methods.
            
            System.Runtime.CompilerServices provides a collection of async method builders that are used in the
            generated code of async methods to create and manipulate the async method's task. There are three
            distinct async method builder types, one of each async return type: AsyncVoidMethodBuilder,
            AsyncTaskMethodBuilder, and AsyncTaskMethodBuilder&lt;T&gt;. 
            
            AsyncMethodBuilderMemberCollection provides a common mechanism for accessing the well-known members of
            each async method builder type. This avoids having to inspect the return style of the current async method
            to pick the right async method builder member during async rewriting.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.BuilderType">
            <summary>
            The builder's constructed type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.ResultType">
            <summary>
            The result type of the constructed task: T for Task&lt;T&gt;, void otherwise.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.CreateBuilder">
            <summary>
            Create an instance of the method builder.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.SetException">
            <summary>
            Binds an exception to the method builder.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.SetResult">
            <summary>
            Marks the method builder as successfully completed, and sets the result if method is Task&lt;T&gt;-returning.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.AwaitOnCompleted">
            <summary>
            Schedules the state machine to proceed to the next action when the specified awaiter completes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.AwaitUnsafeOnCompleted">
            <summary>
            Schedules the state machine to proceed to the next action when the specified awaiter completes. This method can be called from partially trusted code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.Start">
            <summary>
            Begins running the builder with the associated state machine.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.SetStateMachine">
            <summary>
            Associates the builder with the specified state machine.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.Task">
            <summary>
            Get the constructed task for a Task-returning or Task&lt;T&gt;-returning async method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.CheckGenericMethodConstraints">
            <summary>
            True if generic method constraints should be checked at the call-site.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter">
            <summary>
            Produces a MoveNext() method for an async method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._method">
            <summary>
            The method being rewritten.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._asyncMethodBuilderField">
            <summary>
            The field of the generated async class used to store the async method builder: an instance of
            <see cref="T:System.Runtime.CompilerServices.AsyncVoidMethodBuilder"/>, <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder"/>, or <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1"/> depending on the
            return type of the async method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._asyncMethodBuilderMemberCollection">
            <summary>
            A collection of well-known members for the current async method builder.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._exprReturnLabel">
            <summary>
            The exprReturnLabel is used to label the return handling code at the end of the async state-machine
            method. Return expressions are rewritten as unconditional branches to exprReturnLabel.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._exitLabel">
            <summary>
            The label containing a return from the method when the async method has not completed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._exprRetValue">
            <summary>
            The field of the generated async class used in generic task returning async methods to store the value
            of rewritten return expressions. The return-handling code then uses <c>SetResult</c> on the async method builder
            to make the result available to the caller.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter.GenerateMoveNext(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Generate the body for <c>MoveNext()</c>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncRewriter.AsyncIteratorRewriter">
            <summary>
            This rewriter rewrites an async-iterator method. See async-streams.md for design overview.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncRewriter.AsyncIteratorRewriter.GenerateIAsyncEnumeratorImplementation_MoveNextAsync">
            <summary>
            Generates the `ValueTask&lt;bool> MoveNextAsync()` method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncRewriter.AsyncIteratorRewriter.GetPartsForStartingMachine(Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement@,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol@,Microsoft.CodeAnalysis.CSharp.BoundStatement@,Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement@,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@)">
            <summary>
            Prepares most of the parts for MoveNextAsync() and DisposeAsync() methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncRewriter.AsyncIteratorRewriter.GenerateIAsyncDisposable_DisposeAsync">
            <summary>
            Generates the `ValueTask IAsyncDisposable.DisposeAsync()` method.
            The DisposeAsync method should not be called from states -1 (running) or 0-and-up (awaits).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncRewriter.AsyncIteratorRewriter.GenerateIAsyncEnumeratorImplementation_Current">
            <summary>
            Generates the Current property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncRewriter.AsyncIteratorRewriter.GenerateIAsyncEnumerableImplementation_GetAsyncEnumerator">
            <summary>
            Generates the GetAsyncEnumerator method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.StateMachineStateDebugInfo},Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.AsyncStateMachine@)">
            <summary>
            Rewrite an async method into a state machine type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncRewriter.VerifyPresenceOfRequiredAPIs">
            <returns>
            Returns true if all types and members we need are present and good
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncRewriter.AwaitDetector">
            <summary>
            Note: do not use a static/singleton instance of this type, as it holds state.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncStateMachine">
            <summary>
            The class that represents a translated async or async-iterator method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion">
             <summary>
             The rewriter for removing lambda expressions from method bodies and introducing closure classes
             as containers for captured variables along the lines of the example in section 6.5.3 of the
             C# language specification. A closure is the lowered form of a nested function, consisting of a
             synthesized method and a set of environments containing the captured variables.
             
             The entry point is the public method <see cref="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo},Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol})"/>.  It operates as follows:
             
             First, an analysis of the whole method body is performed that determines which variables are
             captured, what their scopes are, and what the nesting relationship is between scopes that
             have captured variables.  The result of this analysis is left in <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion._analysis"/>.
             
             Then we make a frame, or compiler-generated class, represented by an instance of
             <see cref="T:Microsoft.CodeAnalysis.CSharp.SynthesizedClosureEnvironment"/> for each scope with captured variables. The generated frames are kept
             in <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion._frames"/>.  Each frame is given a single field for each captured
             variable in the corresponding scope.  These are maintained in <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.proxies"/>.
             
             Next, we walk and rewrite the input bound tree, keeping track of the following:
             (1) The current set of active frame pointers, in <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion._framePointers"/>
             (2) The current method being processed (this changes within a lambda's body), in <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion._currentMethod"/>
             (3) The "this" symbol for the current method in <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion._currentFrameThis"/>, and
             (4) The symbol that is used to access the innermost frame pointer (it could be a local variable or "this" parameter)
            
             Lastly, we visit the top-level method and each of the lowered methods
             to rewrite references (e.g., calls and delegate conversions) to local
             functions. We visit references to local functions separately from
             lambdas because we may see the reference before we lower the target
             local function. Lambdas, on the other hand, are always convertible as
             they are being lowered.
             
             There are a few key transformations done in the rewriting.
             (1) Lambda expressions are turned into delegate creation expressions, and the body of the lambda is
                 moved into a new, compiler-generated method of a selected frame class.
             (2) On entry to a scope with captured variables, we create a frame object and store it in a local variable.
             (3) References to captured variables are transformed into references to fields of a frame class.
             
             In addition, the rewriting deposits into <see cref="P:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.SynthesizedMethods"/>
             a (<see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/>, <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundStatement"/>) pair for each generated method.
             
             <see cref="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo},Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol})"/> produces its output in two forms.  First, it returns a new bound statement
             for the caller to use for the body of the original method.  Second, it returns a collection of
             (<see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/>, <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundStatement"/>) pairs for additional methods that the lambda rewriter produced.
             These additional methods contain the bodies of the lambdas moved into ordinary methods of their
             respective frame classes, and the caller is responsible for processing them just as it does with
             the returned bound node.  For example, the caller will typically perform iterator method and
             asynchronous method transformations, and emit IL instructions into an assembly.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis">
            <summary>
            Perform a first analysis pass in preparation for removing all lambdas from a method body.  The entry point is Analyze.
            The results of analysis are placed in the fields seenLambda, blockParent, variableBlock, captured, and captures.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.MethodsConvertedToDelegates">
            <summary>
            If a local function is in the set, at some point in the code it is converted to a delegate and should then not be optimized to a struct closure.
            Also contains all lambdas (as they are converted to delegates implicitly).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.CanTakeRefParameters(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            True if the method signature can be rewritten to contain ref/out parameters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTree">
            <summary>
            The root of the scope tree for this method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ComputeLambdaScopesAndFrameCaptures">
             <summary>
             Must be called only after <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.NestedFunction.CapturedEnvironments"/>
             has been calculated.
            
             Finds the most optimal capture environment to place a closure in. 
             This roughly corresponds to the 'highest' Scope in the tree where all
             the captured variables for this closure are in scope. This minimizes
             the number of indirections we may have to traverse to access captured
             variables.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.InlineThisOnlyEnvironments">
            <summary>
            We may have ended up with a closure environment containing only
            'this'. This is basically equivalent to the containing type itself,
            so we can inline the 'this' parameter into environments that
            reference this one or lower closures directly onto the containing
            type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.CalculateFunctionsCapturingScopeVariables">
            <summary>
            Calculates all functions which directly or indirectly capture a scope's variables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.MergeEnvironments">
            <summary>
            Must be called only after <see cref="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.MakeAndAssignEnvironments"/> and <see cref="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ComputeLambdaScopesAndFrameCaptures"/>.
            
            In order to reduce allocations, merge environments into a parent environment when it is safe to do so.
            This must be done whilst preserving semantics.
            
            We also have to make sure not to extend the life of any variable.
            This means that we can only merge an environment into its parent if exactly the same closures directly or indirectly reference both environments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.GetVariableDeclarationScope(Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Walk up the scope tree looking for a variable declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.GetScopeParent(Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope,Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Find the parent <see cref="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope"/> of the <see cref="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope"/> corresponding to
            the given <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundNode"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.GetScopeWithMatchingBoundNode(Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope,Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Finds a <see cref="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope" /> with a matching <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundNode"/>
            as the one given.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.GetVisibleNestedFunction(Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Walk up the scope tree looking for a nested function.
            </summary>
            <returns>
            A tuple of the found <see cref="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.NestedFunction"/> and the <see cref="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope"/> it was found in.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.GetNestedFunctionInTree(Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Finds a <see cref="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.NestedFunction"/> with a matching original symbol somewhere in the given scope or nested scopes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope">
            <summary>
            This is the core node for a Scope tree, which stores all semantically meaningful
            information about declared variables, closures, and environments in each scope.
            It can be thought of as the essence of the bound tree -- stripping away many of
            the unnecessary details stored in the bound tree and just leaving the pieces that
            are important for closure conversion. The root scope is the method scope for the
            method being analyzed and has a null <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.Parent" />.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.NestedFunctions">
            <summary>
            A list of all nested functions (all lambdas and local functions) declared in this scope.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.DeclaredVariables">
            <summary>
            A list of all locals or parameters that were declared in this scope and captured
            in this scope or nested scopes. "Declared" refers to the start of the variable
            lifetime (which, at this point in lowering, should be equivalent to lexical scope).
            </summary>
            <remarks>
            It's important that this is a set and that enumeration order is deterministic. We loop
            over this list to generate proxies and if we loop out of order this will cause
            non-deterministic compilation, and if we generate duplicate proxies we'll generate
            wasteful code in the best case and incorrect code in the worst.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.BoundNode">
            <summary>
            The bound node representing this scope. This roughly corresponds to the bound
            node for the block declaring locals for this scope, although parameters of
            methods/functions are introduced into their Body's scope and do not get their
            own scope.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.ContainingFunctionOpt">
            <summary>
            The nested function that this scope is nested inside. Null if this scope is not nested
            inside a nested function.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.DeclaredEnvironment">
            <summary>
            Environment created in this scope to hold <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.DeclaredVariables"/>.
            At the moment, all variables declared in the same scope
            always get assigned to the same environment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.CanMergeWithParent">
            <summary>
            Is it safe to move any of the variables declared in this scope to the parent scope, 
            or would doing so change the meaning of the program?
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.NestedFunction">
            <summary>
            The NestedFunction type represents a lambda or local function and stores
            information related to that function. After initially building the
            <see cref="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope"/> tree the only information available is
            <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.NestedFunction.OriginalMethodSymbol"/> and <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.NestedFunction.CapturedVariables"/>.
            Subsequent passes are responsible for translating captured
            variables into captured environments and for calculating
            the rewritten signature of the method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.NestedFunction.OriginalMethodSymbol">
            <summary>
            The method symbol for the original lambda or local function.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.NestedFunction.BlockSyntax">
            <summary>
            Syntax for the block of the nested function.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.NestedFunction.CapturesThis">
            <summary>
            True if this function directly or transitively captures 'this' (captures
            a local function which directly or indirectly captures 'this').
            Calculated in <see cref="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.MakeAndAssignEnvironments"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ClosureEnvironment.CapturesParent">
            <summary>
            True if this environment captures a reference to a class environment
            declared in a higher scope. Assigned by
            <see cref="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ComputeLambdaScopesAndFrameCaptures"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.VisitNestedFunctions(Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope,System.Action{Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope,Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.NestedFunction})">
            <summary>
            Visit all nested functions in all nested scopes and run the <paramref name="action"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.CheckNestedFunctions(Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope,System.Func{Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope,Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.NestedFunction,System.Boolean})">
            <summary>
            Visit all the functions and return true when the <paramref name="func"/> returns
            true. Otherwise, returns false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.VisitScopeTree(Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope,System.Action{Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope})">
            <summary>
            Visit the tree with the given root and run the <paramref name="action"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder">
            <summary>
            Builds a tree of <see cref="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope"/> nodes corresponding to a given method.
            <see cref="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder.Build(Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol},Microsoft.CodeAnalysis.DiagnosticBag)"/>
            visits the bound tree and translates information from the bound tree about
            variable scope, declared variables, and variable captures into the resulting
            <see cref="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope"/> tree.
            
            At the same time it sets <see cref="P:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.CanMergeWithParent"/>
            for each Scope. This is done by looking for <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundGotoStatement"/>s 
            and <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundConditionalGoto"/>s that jump from a point 
            after the beginning of a <see cref="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope"/>, to a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundLabelStatement"/>
            before the start of the scope, but after the start of <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.Parent"/>.
            
            All loops have been converted to gotos and labels by this stage,
            so we do not have to visit them to do so. Similarly all <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundLabeledStatement"/>s
            have been converted to <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundLabelStatement"/>s, so we do not have to 
            visit them.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._currentScope">
            <summary>
            Do not set this directly, except when setting the root scope. 
            Instead use <see cref="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder.PopScope(Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope)"/> or <see cref="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder.CreateAndPushScope(Microsoft.CodeAnalysis.CSharp.BoundNode)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._currentFunction">
            <summary>
            Null if we're not inside a nested function, otherwise the nearest nested function.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._localToScope">
            <summary>
            A mapping from all captured vars to the scope they were declared in. This
            is used when recording captured variables as we must know what the lifetime
            of a captured variable is to determine the lifetime of its capture environment.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._methodsConvertedToDelegates">
            <summary>
            If a local function is in the set, at some point in the code it is converted
            to a delegate and should then not be optimized to a struct closure.
            Also contains all lambdas (as they are converted to delegates implicitly).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._scopesAfterLabel">
            <summary>
            For every label visited so far, this dictionary maps to a list of all scopes either visited so far, or currently being visited,
            that are both after the label, and are on the same level of the scope tree as the label.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._labelsInScope">
            <summary>
            Contains a list of the labels visited so far for each scope. 
            The outer ArrayBuilder is a stack representing the chain of scopes from the root scope to the current scope,
            and for each item on the stack, the ArrayBuilder is the list of the labels visited so far for the scope.
            
            Used by <see cref="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder.CreateAndPushScope(Microsoft.CodeAnalysis.CSharp.BoundNode)"/> to determine which labels a new child scope appears after.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder.CheckCanMergeWithParent(Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol)">
            <summary>
            This is where we calculate <see cref="P:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.CanMergeWithParent"/>.
            <see cref="P:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.CanMergeWithParent"/> is always true unless we jump from after 
            the beginning of a scope, to a point in between the beginning of the parent scope, and the beginning of the scope
            </summary>
            <param name="jumpTarget"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder.AddDiagnosticIfRestrictedType(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Add a diagnostic if the type of a captured variable is a restricted type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder.PushOrReuseScope``1(Microsoft.CodeAnalysis.CSharp.BoundNode,System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Create a new nested scope under the current scope, and replace <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._currentScope"/> with the new scope,
            or reuse the current scope if there's no change in the bound node for the nested scope.
            Records the given locals as declared in the aforementioned scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder.CreateAndPushScope(Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Creates a new nested scope which is a child of <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._currentScope"/>,
            and replaces <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._currentScope"/> with the new scope
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder.PopScope(Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope)">
            <summary>
            Requires that scope is either the same as <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._currentScope"/>,
            or is the <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.Scope.Parent"/> of <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._currentScope"/>.
            Returns immediately in the first case,
            Replaces <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTreeBuilder._currentScope"/> with scope in the second.
            </summary>
            <param name="scope"></param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion._synthesizedMethods">
            <summary>
            Temporary bag for methods synthesized by the rewriting. Added to
            <see cref="P:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.SynthesizedMethods"/> at the end of rewriting.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion._allCapturedVariables">
            <summary>
            TODO(https://github.com/dotnet/roslyn/projects/26): Delete this.
            This should only be used by <see cref="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.NeedsProxy(Microsoft.CodeAnalysis.CSharp.Symbol)"/> which
            hasn't had logic to move the proxy analysis into <see cref="T:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis"/>,
            where the <see cref="F:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ScopeTree"/> could be walked to build
            the proxy list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo},Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol})">
            <summary>
            Rewrite the given node to eliminate lambda expressions.  Also returned are the method symbols and their
            bound bodies for the extracted lambda bodies. These would typically be emitted by the caller such as
            MethodBodyCompiler.  See this class' documentation
            for a more thorough explanation of the algorithm and its use by clients.
            </summary>
            <param name="loweredBody">The bound node to be rewritten</param>
            <param name="thisType">The type of the top-most frame</param>
            <param name="thisParameter">The "this" parameter in the top-most frame, or null if static method</param>
            <param name="method">The containing method of the node to be rewritten</param>
            <param name="methodOrdinal">Index of the method symbol in its containing type member list.</param>
            <param name="substitutedSourceMethod">If this is non-null, then <paramref name="method"/> will be treated as this for uses of parent symbols. For use in EE.</param>
            <param name="lambdaDebugInfoBuilder">Information on lambdas defined in <paramref name="method"/> needed for debugging.</param>
            <param name="closureDebugInfoBuilder">Information on closures defined in <paramref name="method"/> needed for debugging.</param>
            <param name="slotAllocatorOpt">Slot allocator.</param>
            <param name="compilationState">The caller's buffer into which we produce additional methods to be emitted by the caller</param>
            <param name="diagnostics">Diagnostic bag for diagnostics</param>
            <param name="assignLocals">The set of original locals that should be assigned to proxies if lifted</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.SynthesizeClosureEnvironments(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo})">
            <summary>
            Adds <see cref="T:Microsoft.CodeAnalysis.CSharp.SynthesizedClosureEnvironment"/> synthesized types to the compilation state
            and creates hoisted fields for all locals captured by the environments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.SynthesizeClosureMethods">
            <summary>
            Synthesize closure methods for all nested functions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.GetStaticFrame(Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Get the static container for closures or create one if one doesn't already exist.
            </summary>
            <param name="syntax">
            associate the frame with the first lambda that caused it to exist. 
            we need to associate this with some syntax.
            unfortunately either containing method or containing class could be synthetic
            therefore could have no syntax.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.FrameOfType(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Produce a bound expression representing a pointer to a frame of a particular frame type.
            </summary>
            <param name="syntax">The syntax to attach to the bound nodes produced</param>
            <param name="frameType">The type of frame to be returned</param>
            <returns>A bound node that computes the pointer to the required frame</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.FramePointer(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Produce a bound expression representing a pointer to a frame of a particular frame class.
            Note that for generic frames, the frameClass parameter is the generic definition, but
            the resulting expression will be constructed with the current type parameters.
            </summary>
            <param name="syntax">The syntax to attach to the bound nodes produced</param>
            <param name="frameClass">The class type of frame to be returned</param>
            <returns>A bound node that computes the pointer to the required frame</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.IntroduceFrame(Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.ClosureConversion.Analysis.ClosureEnvironment,System.Func{Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},Microsoft.CodeAnalysis.CSharp.BoundNode})">
            <summary>
            Introduce a frame around the translation of the given node.
            </summary>
            <param name="node">The node whose translation should be translated to contain a frame</param>
            <param name="env">The environment for the translated node</param>
            <param name="F">A function that computes the translation of the node.  It receives lists of added statements and added symbols</param>
            <returns>The translated statement, as returned from F</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.RemapLocalFunction(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BoundExpression@,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind}@)">
            <summary>
            Rewrites a reference to an unlowered local function to the newly
            lowered local function.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClosureConversion.SubstituteTypeArguments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations})">
            <summary>
            Substitutes references from old type arguments to new type arguments
            in the lowered methods.
            </summary>
            <example>
            Consider the following method:
                void M() {
                    void L&lt;T&gt;(T t) => Console.Write(t);
                    L("A");
                }
                
            In this example, L&lt;T&gt; is a local function that will be
            lowered into its own method and the type parameter T will be
            alpha renamed to something else (let's call it T'). In this case,
            all references to the original type parameter T in L must be
            rewritten to the renamed parameter, T'.
            </example>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureKind.Static">
            <summary>
            The closure doesn't declare any variables, and is never converted to a delegate.
            Lambdas are emitted directly to the containing class as a static method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureKind.Singleton">
            <summary>
            The closure doesn't declare any variables, and is converted to a delegate at least once.
            Display class is a singleton and may be shared with other top-level methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureKind.ThisOnly">
            <summary>
            The closure only contains a reference to the containing class instance ("this").
            We don't emit a display class, lambdas are emitted directly to the containing class as its instance methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureKind.General">
            <summary>
            General closure.
            Display class may only contain lambdas defined in the same top-level method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitExactType(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Visit the expression, but do so in a way that ensures that its type is precise.  That means that any
            sometimes-unnecessary conversions (such as an implicit reference conversion) are retained.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LambdaCapturedVariable">
            <summary>
            A field of a frame class that represents a variable that has been captured in a lambda.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedClosureEnvironment">
            <summary>
            The synthesized type added to a compilation to hold captured variables for closures.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SynthesizedClosureEnvironment.OriginalContainingMethodOpt">
            <summary>
            The closest method/lambda that this frame is originally from. Null if nongeneric static closure.
            Useful because this frame's type parameters are constructed from this method and all methods containing this method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SynthesizedClosureEnvironment.GetFieldsToEmit">
            <summary>
            All fields should have already been added as synthesized members on the
            <see cref="T:Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder" />, so we don't want to duplicate them here.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedClosureMethod">
            <summary>
            A method that results from the translation of a single lambda expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass">
            <summary>
            This pass detects and reports diagnostics that do not affect lambda convertibility.
            This part of the partial class focuses on features that cannot be used in expression trees.
            CAVEAT: Errors may be produced for ObsoleteAttribute, but such errors don't affect lambda convertibility.
            </summary>
            <summary>
            This pass detects and reports diagnostics that do not affect lambda convertibility.
            This part of the partial class focuses on expression and operator warnings.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass.CheckOutDeclaration(Microsoft.CodeAnalysis.CSharp.BoundLocal)">
            <summary>
            Called when a local represents an out variable declaration. Its syntax is of type DeclarationExpressionSyntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass.CheckFieldAddress(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            This is for when we are taking the address of a field.
            Distinguish from <see cref="M:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass.CheckFieldAsReceiver(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass.CheckFieldAsReceiver(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess)">
            <remarks>
            This is for when we are dotting into a field.
            Distinguish from <see cref="M:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass.CheckFieldAddress(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess,Microsoft.CodeAnalysis.CSharp.Symbol)"/>.
            
            NOTE: dev11 also calls this on string initializers in fixed statements,
            but never accomplishes anything since string is a reference type.  This
            is probably a bug, but fixing it would be a breaking change.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass.IsNonAgileFieldAccess(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <remarks>
            Based on OutputContext::IsNonAgileField.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InitializerRewriter.GetTrailingScriptExpression(Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Returns the expression if the statement is actually an expression (ExpressionStatementSyntax with no trailing semicolon).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CompoundInstrumenter">
            <summary>
            Utility class, provides a convenient way of combining various <see cref="T:Microsoft.CodeAnalysis.CSharp.Instrumenter"/>s in a chain,
            allowing each of them to apply specific instrumentations in particular order.
            
            Default implementation of all APIs delegates to the "previous" <see cref="T:Microsoft.CodeAnalysis.CSharp.Instrumenter"/> passed as a parameter
            to the constructor of this class. Usually, derived types are going to let the base (this class) to do its work first
            and then operate on the result they get back.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DebugInfoInjector">
            <summary>
            This type is responsible for adding debugging sequence points for the executable code.
            It can be combined with other <see cref="T:Microsoft.CodeAnalysis.CSharp.Instrumenter"/>s. Usually, this class should be 
            the root of the chain in order to ensure sound debugging experience for the instrumented code.
            In other words, sequence points are typically applied after all other changes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DebugInfoInjector.Singleton">
            <summary>
            A singleton object that performs only one type of instrumentation - addition of debugging sequence points. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DebugInfoInjector.InstrumentForEachStatementCollectionVarDeclaration(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Add sequence point |here|:
            
            foreach (Type var in |expr|) { }
            </summary>
            <remarks>
            Hit once, before looping begins.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DebugInfoInjector.InstrumentForEachStatement(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Add sequence point |here|:
            
            |foreach| (Type var in expr) { }
            </summary>
            <remarks>
            Hit once, before looping begins.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DebugInfoInjector.InstrumentForEachStatementIterationVarDeclaration(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Add sequence point |here|:
            
            foreach (|Type var| in expr) { }
            </summary>
            <remarks>
            Hit every iteration.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DynamicAnalysisInjector">
            <summary>
            This type provides means for instrumenting compiled methods for dynamic analysis.
            It can be combined with other <see cref="T:Microsoft.CodeAnalysis.CSharp.Instrumenter"/>s.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Instrumenter">
            <summary>
            A base class for components that instrument various portions of executable code.
            It provides a set of APIs that are called by <see cref="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter"/> to instrument
            specific portions of the code. These APIs have at least two parameters:
                - original bound node produced by the <see cref="T:Microsoft.CodeAnalysis.CSharp.Binder"/> for the relevant portion of the code;
                - rewritten bound node created by the <see cref="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter"/> for the original node.
            The APIs are expected to return new state of the rewritten node, after they apply appropriate
            modifications, if any.
            
            The base class provides default implementation for all APIs, which simply returns the rewritten node. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Instrumenter.NoOp">
            <summary>
            The singleton NoOp instrumenter, can be used to terminate the chain of <see cref="T:Microsoft.CodeAnalysis.CSharp.CompoundInstrumenter"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Instrumenter.CreateBlockPrologue(Microsoft.CodeAnalysis.CSharp.BoundBlock,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol@)">
            <summary>
            Return a node that is associated with open brace of the block. Ok to return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Instrumenter.CreateBlockEpilogue(Microsoft.CodeAnalysis.CSharp.BoundBlock)">
            <summary>
            Return a node that is associated with close brace of the block. Ok to return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Instrumenter.InstrumentSwitchWhenClauseConditionalGotoBody(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Instrument a switch case when clause, which is translated to a conditional branch to the body of the case block.
            </summary>
            <param name="original">the bound expression of the when clause</param>
            <param name="ifConditionGotoBody">the lowered conditional branch into the case block</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Instrumenter.InstrumentSwitchExpressionArmExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory)">
            <summary>
            Instrument the expression of a switch arm of a switch expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IteratorConstructor">
            <summary>
            The constructor of the class that is the translation of an iterator method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IteratorFinallyMethodSymbol">
            <summary>
            A synthesized Finally method containing finalization code for a resumable try statement.
            Finalization code for such try may run when:
            1) control flow goes out of try scope by dropping through
            2) control flow goes out of try scope by conditionally or unconditionally branching outside of one ore more try/finally frames.
            3) enumerator is disposed by the owner.
            4) enumerator is being disposed after an exception.
            
            It is easier to manage partial or complete finalization when every finally is factored out as a separate method. 
            
            NOTE: Finally is a private void nonvirtual instance method with no parameters. 
                  It is a valid JIT inlining target as long as JIT may consider inlining profitable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter._current">
            <summary>
            The field of the generated iterator class that underlies the Current property.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter._yieldsInTryAnalysis">
            <summary>
            Tells us if a particular try contains yield returns
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter._tryNestingLevel">
            <summary>
            When this is more that 0, returns are emitted as "methodValue = value; goto exitLabel;"
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter._currentFinallyFrame">
            <summary>
            The current iterator finally frame in the tree of finally frames.
            By default there is a root finally frame.
            Root frame does not have a handler, but may contain nested frames.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter._nextFinalizeState">
            <summary>
            Finally state of the next Finally frame if such created.
            Finally state is a negative decreasing number starting with -3. (-2 is used for something else).
            Root frame has finally state -1.
            
            The Finally state is the state that we are in when "between states".
            Regular states are positive and are the only states that can be resumed to.
            The purpose of distinct finally states is to have enough information about 
            which finally handlers must run when we need to finalize iterator after a fault. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.EmitFinallyFrame(Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.IteratorFinallyFrame,Microsoft.CodeAnalysis.CSharp.BoundLocal)">
            <summary>
            Produces a Try/Finally if frame has a handler (otherwise a regular block).
            Handler goes into the Finally.
            If there are nested frames, they are emitted into the try block.
            This way the handler for the current frame is guaranteed to run even if 
            nested handlers throw exceptions.
            
            {
                switch(state)
                {
                    case state1:
                    case state2:
                    case state3:
                    case state4:
                        try
                        {
                            switch(state)
                            {
                                case state3:
                                case state4:
                                    try
                                    {
                                        ... more nested state dispatches if any ....
                                    }
                                    finally
                                    {
                                        // handler for a try where state3 and state4 can be observed
                                        handler_3_4()
                                    }
                                    break;
                             }
                        }
                        finally
                        {
                            // handler for a try where state1 and state2 can be observed
                            handler_1_2()
                        }
                        break;
                        
                    case state5:
                        ... another dispatch of nested states to their finally blocks ...
                        break;
                }
            }
            
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.YieldsInTryAnalysis">
            <summary>
            Analyzes method body for yields in try blocks and labels that they contain.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.YieldsInTryAnalysis.ContainsYields(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            Returns true if given try or any of its nested try blocks contain yields
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.YieldsInTryAnalysis.ContainsYieldsInTrys">
            <summary>
            Returns true if body contains yield returns within try blocks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.YieldsInTryAnalysis.Labels(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            Labels reachable from within this frame without invoking its finally. 
            null if there are none such labels.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LabelCollector">
            <summary>
            Analyzes method body for labels.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.StateMachineStateDebugInfo},Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.IteratorStateMachine@)">
            <summary>
            Rewrite an iterator method into a state machine class.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorRewriter.VerifyPresenceOfRequiredAPIs">
            <returns>
            Returns true if all types and members we need are present and good
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorRewriter.EnsureSpecialPropertyGetter(Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Check that the property and its getter exist and collect any use-site errors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorRewriter.GenerateEnumerableImplementation(Microsoft.CodeAnalysis.CSharp.BoundExpression@)">
            <summary>
            Add IEnumerator&lt;elementType> IEnumerable&lt;elementType>.GetEnumerator()
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IteratorStateMachine">
            <summary>
            The class that represents a translated iterator method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DelegateCacheRewriter">
            <summary>
            This type helps rewrite the delegate creations that target static method groups to use a cached instance of delegate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields,System.Boolean,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeGen.SourceSpan}@,Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>
            Lower a block of code by performing local rewritings.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Return the translated node, or null if no code is necessary in the translation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.PlaceholderReplacement(Microsoft.CodeAnalysis.CSharp.BoundValuePlaceholderBase)">
            <summary>
            Returns substitution currently used by the rewriter for a placeholder node.
            Each occurrence of the placeholder node is replaced with the node returned.
            Throws if there is no substitution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.AddPlaceholderReplacement(Microsoft.CodeAnalysis.CSharp.BoundValuePlaceholderBase,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Sets substitution used by the rewriter for a placeholder node.
            Each occurrence of the placeholder node is replaced with the node returned.
            Throws if there is already a substitution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RemovePlaceholderReplacement(Microsoft.CodeAnalysis.CSharp.BoundValuePlaceholderBase)">
            <summary>
            Removes substitution currently used by the rewriter for a placeholder node.
            Asserts if there isn't already a substitution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.UnsafeGetSpecialTypeMethod(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            This function provides a false sense of security, it is likely going to surprise you when the requested member is missing.
            Recommendation: Do not use, use <see cref="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryGetSpecialTypeMethod(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@)"/> instead!
            If used, a unit-test with a missing member is absolutely a must have.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.UnsafeGetSpecialTypeMethod(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            This function provides a false sense of security, it is likely going to surprise you when the requested member is missing.
            Recommendation: Do not use, use <see cref="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryGetSpecialTypeMethod(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@)"/> instead!
            If used, a unit-test with a missing member is absolutely a must have.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.ShouldOptimizeOutInitializer(Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Returns true if the initializer is a field initializer which should be optimized out
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter">
            <summary>
            A common base class for lowering a decision dag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.BuilderForSection(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Get the builder for code in the given section of the switch.
            For an is-pattern expression, this is a singleton.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter._loweredDecisionDag">
            <summary>
            The lowered decision dag. This includes all of the code to decide which pattern
            is matched, but not the code to assign to pattern variables and evaluate when clauses.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter._dagNodeLabels">
            <summary>
            The label in the code for the beginning of code for each node of the dag.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.WhenClauseMightAssignPatternVariableWalker">
            <summary>
            A utility class that is used to scan a when clause to determine if it might assign a pattern variable
            declared in that case, directly or indirectly. Used to determine if we can skip the allocation of
            pattern-matching temporary variables and use user-declared pattern variables instead, because we can
            conclude that they are not mutated by a when clause while the pattern-matching automaton is running.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.GenerateTypeTestAndCast(Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode},System.Int32)">
            <summary>
            If we have a type test followed by a cast to that type, and the types are reference types,
            then we can replace the pair of them by a conversion using `as` and a null check.
            </summary>
            <returns>true if we generated code for the test</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.GenerateSwitchDispatch(Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode})">
            <summary>
            Generate a switch dispatch for a contiguous sequence of dag nodes if applicable.
            Returns true if it was applicable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.PushEqualityTestsIntoTree(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode,System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol}},Microsoft.CodeAnalysis.CSharp.IValueSetFactory)">
            <summary>
            Push the set of equality tests down to the level of the leaves in the value dispatch tree.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.CasesComparer">
            <summary>
            A comparer for sorting cases containing values of type float, double, or decimal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.EnsureStringHashFunction(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.StringPatternInput)">
            <summary>
            Checks whether we are generating a hash table based string switch and
            we need to generate a new helper method for computing string hash value.
            Creates the method if needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.LowerDecisionDagNode(Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode)">
            <summary>
            Translate the decision dag for node, given that it will be followed by the translation for nextNode.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode">
            <summary>
            A node in a tree representing the form of a generated decision tree for classifying an input value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.SwitchDispatch">
            <summary>
            A node representing the dispatch by value (equality). This corresponds to a classical C switch
            statement, except that it also handles values of type float, double, decimal, and string.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.LeafDispatchNode">
            <summary>
            A node representing a final destination that requires no further dispatch.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.RelationalDispatch">
            <summary>
            A node representing a dispatch based on a relational test of the input value by some constant.
            Nodes of this kind are required to be height-balanced when constructed, so that when the full
            decision tree is produced it generates a balanced tree of comparisons.  The shape of the tree
            keeps tests for lower values on the left and tests for higher values on the right:
            For <see cref="F:Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind.LessThan"/> and <see cref="F:Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind.LessThanOrEqual"/>,
            the <see cref="P:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.RelationalDispatch.WhenTrue"/> branch is <see cref="P:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.RelationalDispatch.Left"/> and the <see cref="P:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.RelationalDispatch.WhenFalse"/> branch
            is <see cref="P:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.RelationalDispatch.Right"/>; for <see cref="F:Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind.GreaterThan"/> and
            <see cref="F:Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind.GreaterThanOrEqual"/> it is reversed.
            See <see cref="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.RelationalDispatch.IsReversed(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind)"/> for where that is computed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.RelationalDispatch.Left">
            <summary>The side of the test handling lower values. The true side for &lt; and &lt;=, the false side for > and >=.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.RelationalDispatch.Right">
            <summary>The side of the test handling higher values. The false side for &lt; and &lt;=, the true side for > and >=.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.RelationalDispatch.IsReversed(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind)">
            <summary>
            Is the operator among those for which <see cref="P:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.RelationalDispatch.WhenTrue"/> is <see cref="P:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DecisionDagRewriter.ValueDispatchNode.RelationalDispatch.Right"/>?
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternLocalRewriter">
            <summary>
            A common base class for lowering constructs that use pattern-matching.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternLocalRewriter.GenerateInstrumentation">
            <summary>
            True if we should produce instrumentation and sequence points, which we do for a switch statement and a switch expression.
            This affects 
            - whether or not we invoke the instrumentation APIs
            - production of sequence points
            - synthesized local variable kind
              The temp variables must be long lived in a switch statement since their lifetime spans across sequence points.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternLocalRewriter.DagTempAllocator.TrySetTemp(Microsoft.CodeAnalysis.CSharp.BoundDagTemp,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Try setting a user-declared variable (given by its accessing expression) to be
            used for a pattern-matching temporary variable. Returns true when not already
            assigned. The return value of this method is typically ignored by the caller as
            once we have made an assignment we can keep it (we keep the first assignment we
            find), but we return a success bool to emphasize that the assignment is not unconditional.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternLocalRewriter.LowerEvaluation(Microsoft.CodeAnalysis.CSharp.BoundDagEvaluation)">
            <summary>
            Return the side-effect expression corresponding to an evaluation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternLocalRewriter.LowerTest(Microsoft.CodeAnalysis.CSharp.BoundDagTest)">
            <summary>
            Return the boolean expression to be evaluated for the given test. Returns `null` if the test is trivially true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternLocalRewriter.TryLowerTypeTestAndCast(Microsoft.CodeAnalysis.CSharp.BoundDagTest,Microsoft.CodeAnalysis.CSharp.BoundDagEvaluation,Microsoft.CodeAnalysis.CSharp.BoundExpression@,Microsoft.CodeAnalysis.CSharp.BoundExpression@)">
            <summary>
            Lower a test followed by an evaluation into a side-effect followed by a test. This permits us to optimize
            a type test followed by a cast into an `as` expression followed by a null check. Returns true if the optimization
            applies and the results are placed into <paramref name="sideEffect"/> and <paramref name="test"/>. The caller
            should place the side-effect before the test in the generated code.
            </summary>
            <param name="evaluation"></param>
            <param name="test"></param>
            <param name="sideEffect"></param>
            <param name="testExpression"></param>
            <returns>true if the optimization is applied</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternLocalRewriter.ShareTempsAndEvaluateInput(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundDecisionDag,System.Action{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.BoundExpression@)">
            <summary>
            Produce assignment of the input expression. This method is also responsible for assigning
            variables for some pattern-matching temps that can be shared with user variables.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternLocalRewriter.RewriteTupleInput(Microsoft.CodeAnalysis.CSharp.BoundDecisionDag,Microsoft.CodeAnalysis.CSharp.BoundObjectCreationExpression,System.Action{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Boolean,Microsoft.CodeAnalysis.CSharp.BoundExpression@)">
            <summary>
            We have a decision dag whose input is a tuple literal, and the decision dag does not need the tuple itself.
            We rewrite the decision dag into one which doesn't touch the tuple, but instead works directly with the
            values that have been stored in temps. This permits the caller to avoid creation of the tuple object
            itself. We also emit assignments of the tuple values into their corresponding temps.
            </summary>
            <param name="savedInputExpression">An expression that produces the value of the original input if needed
            by the caller.</param>
            <returns>A new decision dag that does not reference the input directly</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeAssignmentOperator(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Generates a lowered form of the assignment operator for the given left and right sub-expressions.
            Left and right sub-expressions must be in lowered form.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeStaticAssignmentOperator(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Generates a lowered form of the assignment operator for the given left and right sub-expressions.
            Left and right sub-expressions must be in lowered form.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteAwaitExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Lower an await expression that has already had its components rewritten.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter.BaseSwitchLocalRewriter">
            <summary>
            A common base class for lowering the pattern switch statement and the pattern switch expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LocalRewriter.BaseSwitchLocalRewriter._switchArms">
            <summary>
            Map from when clause's syntax to the lowered code for the matched pattern. The code for a section
            includes the code to assign to the pattern variables and evaluate the when clause. Since a
            when clause can yield a false value, it can jump back to a label in the lowered decision dag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.BaseSwitchLocalRewriter.LowerDecisionDag(Microsoft.CodeAnalysis.CSharp.BoundDecisionDag)">
            <summary>
            Lower the given nodes into _loweredDecisionDag. Should only be called once per instance of this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.UnsafeGetNullableMethod(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            This function provides a false sense of security, it is likely going to surprise you when the requested member is missing.
            Recommendation: Do not use, use <see cref="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryGetNullableMethod(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@)"/> instead! 
            If used, a unit-test with a missing member is absolutely a must have.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.UnsafeGetNullableMethod(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            This function provides a false sense of security, it is likely going to surprise you when the requested member is missing.
            Recommendation: Do not use, use <see cref="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryGetNullableMethod(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@)"/> instead! 
            If used, a unit-test with a missing member is absolutely a must have.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteBuiltInShiftOperation(Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Int32)">
            <summary>
            Spec section 7.9: if the left operand is int or uint, mask the right operand with 0x1F;
            if the left operand is long or ulong, mask the right operand with 0x3F.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeSizeOfMultiplication(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol,System.Boolean)">
            <summary>
            This rather confusing method tries to reproduce the functionality of ExpressionBinder::bindPtrAddMul and
            ExpressionBinder::bindPtrMul.  The basic idea is that we have a numeric expression, x, and a pointer type, 
            T*, and we want to multiply x by sizeof(T).  Unfortunately, we need to stick in some conversions to make
            everything work.
            
              1) If x is an int, then convert it to an IntPtr (i.e. a native int).  Dev10 offers no explanation (ExpressionBinder::bindPtrMul).
              2) Do overload resolution based on the (possibly converted) type of X and int (the type of sizeof(T)).
              3) If the result type of the chosen multiplication operator is signed, convert the product to IntPtr;
                 otherwise, convert the product to UIntPtr.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitStatementSubList(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundStatement},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundStatement},System.Int32)">
            <summary>
            Visit a partial list of statements that possibly contain using declarations
            </summary>
            <param name="builder">The array builder to append statements to</param>
            <param name="statements">The list of statements to visit</param>
            <param name="startIndex">The index of the <paramref name="statements"/> to begin visiting at</param>
            <returns>An <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> of <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundStatement"/></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitPossibleUsingDeclaration(Microsoft.CodeAnalysis.CSharp.BoundStatement,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundStatement},System.Int32,System.Boolean@)">
            <summary>
            Visits a node that is possibly a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundUsingLocalDeclarations"/>
            </summary>
            <param name="node">The node to visit</param>
            <param name="statements">All statements in the block containing this node</param>
            <param name="statementIndex">The current statement being visited in <paramref name="statements"/></param>
            <param name="replacedLocalDeclarations">Set to true if this visited a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundUsingLocalDeclarations"/> node</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundStatement"/></returns>
            <remarks>
            The node being visited is not necessarily equal to statements[startIndex]. 
            When traversing down a set of labels, we set node to the label.body and recurse, but statements[startIndex] still refers to the original parent label 
            as we haven't actually moved down the original statement list
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitArguments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.Symbol,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.CSharp.BoundExpression@,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol}@)">
            <summary>
            Visits all arguments of a method, doing any necessary rewriting for interpolated string handler conversions that
            might be present in the arguments and creating temps for any discard parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeArguments(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind}@,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol}@,System.Boolean)">
            <summary>
            Rewrites arguments of an invocation according to the receiving method or indexer.
            It is assumed that each argument has already been lowered, but we may need
            additional rewriting for the arguments, such as generating a params array, re-ordering
            arguments based on <paramref name="argsToParamsOpt"/> map, inserting arguments for optional parameters, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.GetEffectiveArgumentRefKinds(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol})">
            <summary>
            Patch refKinds for arguments that match 'In' or 'Ref' parameters to have effective RefKind.
            For the purpose of further analysis we will mark the arguments as -
            - In        if was originally passed as None
            - StrictIn  if was originally passed as In
            - Ref       if the argument is an interpolated string literal subject to an interpolated string handler conversion. No other types
                        are patched here.
            Here and in the layers after the lowering we only care about None/notNone differences for the arguments
            Except for async stack spilling which needs to know whether arguments were originally passed as "In" and must obey "no copying" rule.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.IsBeginningOfParamArray(System.Int32,System.Int32,System.Boolean,System.Int32,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Collections.Immutable.ImmutableArray{System.Int32},System.Int32@)">
            <summary>
            Returns true if the given argument is the beginning of a list of param array arguments (could be empty), otherwise returns false.
            When returns true, numberOfParamArrayArguments is set to the number of param array arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeLiteral(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.LocalRewriter)">
            <summary>
            To create literal expression for IOperation, set localRewriter to null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MergeArgumentsAndSideEffects(Microsoft.CodeAnalysis.CSharp.BoundExpression[],Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundAssignmentOperator})">
            <summary>
            Process tempStores and add them as side-effects to arguments where needed. The return
            value tells how many temps are actually needed. For unnecessary temps the corresponding
            temp store will be cleared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TransformCompoundAssignmentFieldOrEventAccessReceiver(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundExpression@,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol})">
            <summary>
            Returns true if the <paramref name="receiver"/> was lowered and transformed.
            The <paramref name="receiver"/> is not changed if this function returns false. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TransformCompoundAssignmentLHS(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},System.Boolean)">
            <summary>
            In the expanded form of a compound assignment (or increment/decrement), the LHS appears multiple times.
            If we aren't careful, this can result in repeated side-effects.  This creates (ordered) temps for all of the
            subexpressions that could result in side-effects and returns a side-effect-free expression that can be used
            in place of the LHS in the expanded form.
            </summary>
            <param name="originalLHS">The LHS sub-expression of the compound assignment (or increment/decrement).</param>
            <param name="stores">Populated with a list of assignment expressions that initialize the temporary locals.</param>
            <param name="temps">Populated with a list of temporary local symbols.</param>
            <param name="isDynamicAssignment">True if the compound assignment is a dynamic operation.</param>
            <returns>
            A side-effect-free expression representing the LHS.
            The returned node needs to be lowered but its children are already lowered.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.CanChangeValueBetweenReads(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean,System.Boolean)">
             <summary>
             Variables local to current frame do not need temps when re-read multiple times
             as long as there is no code that may write to locals in between accesses and they
             are not captured.
             
             Example:
                    l += goo(ref l);
             
             even though l is a local, we must access it via a temp since "goo(ref l)" may change it
             on between accesses.
            
             Note: In <c>this.x++</c>, <c>this</c> cannot change between reads. But in <c>(this, ...) == (..., this.Mutate())</c> it can.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitConditionalOperator(Microsoft.CodeAnalysis.CSharp.BoundConditionalOperator)">
            <summary>
            If the condition has a constant value, then just use the selected branch.
            e.g. "true ? x : y" becomes "x".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeConversionNode(Microsoft.CodeAnalysis.CSharp.BoundConversion,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Conversion,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Helper method to generate a lowered conversion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeConversionNode(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Helper method to generate a lowered conversion from the given <paramref name="rewrittenOperand"/> to the given <paramref name="rewrittenType"/>.
            </summary>
            <remarks>
            If we're converting a default parameter value to the parameter type, then the conversion can actually fail
            (e.g. if the default value was specified by an attribute and was, therefore, not checked by the compiler).
            Set acceptFailingConversion if you want to see default(rewrittenType) in such cases.
            The error will be suppressed only for conversions from <see cref="T:System.Decimal"/> or <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.NullableAlwaysHasValue(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            If the nullable expression always has a value, returns the value, otherwise null.
            This is normally performed on a lowered expression, however for the purpose of
            tuples and tuple equality operators, we do this on a partially lowered expression in
            which conversions appearing at the top of the expression have not been lowered.
            If this method is updated to recognize more complex patterns, callers should be reviewed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryMakeConversion(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Reports diagnostics and returns Conversion.NoConversion in case of missing runtime helpers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryMakeConversion(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Reports diagnostics and returns Conversion.NoConversion in case of missing runtime helpers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryMakeUserDefinedConversion(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Reports diagnostics and returns Conversion.NoConversion in case of missing runtime helpers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteDeconstruction(Microsoft.CodeAnalysis.CSharp.BoundTupleExpression,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean)">
             <summary>
             The left represents a tree of L-values. The structure of right can be missing parts of the tree on the left.
             The conversion holds nested conversions and deconstruction information, which matches the tree from the left,
             and it provides the information to fill in the missing parts of the tree from the right and convert it to
             the tree from the left.
            
             A bound sequence is returned which has different phases of side-effects:
             - the initialization phase includes side-effects from the left, followed by evaluations of the right
             - the deconstruction phase includes all the invocations of Deconstruct methods and tuple element accesses below a Deconstruct call
             - the conversion phase
             - the assignment phase
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.ApplyDeconstructionConversion(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Binder.DeconstructionVariable},Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},Microsoft.CodeAnalysis.CSharp.LocalRewriter.DeconstructionSideEffects,System.Boolean,System.Boolean)">
             <summary>
             This method recurses through leftTargets, right and conversion at the same time.
             As it does, it collects side-effects into the proper buckets (init, deconstructions, conversions, assignments).
            
             The side-effects from the right initially go into the init bucket. But once we started drilling into a Deconstruct
             invocation, subsequent side-effects from the right go into the deconstructions bucket (otherwise they would
             be evaluated out of order).
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.EvaluateSideEffectingArgumentToTemp(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol})">
            <summary>
            Evaluate side effects into a temp, if any.  Return the expression to give the value later.
            </summary>
            <param name="arg">The argument to evaluate early.</param>
            <param name="effects">A store of the argument into a temp, if necessary, is added here.</param>
            <param name="temps">Any generated temps are added here.</param>
            <returns>An expression evaluating the argument later (e.g. reading the temp), including a possible deferred user-defined conversion.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.GetAssignmentTargetsAndSideEffects(Microsoft.CodeAnalysis.CSharp.BoundTupleExpression,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            Adds the side effects to effects and returns temporaries to access them.
            The caller is responsible for releasing the nested ArrayBuilders.
            The variables should be unlowered.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteWindowsRuntimeEventAssignmentOperator(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,Microsoft.CodeAnalysis.CSharp.LocalRewriter.EventAssignmentKind,System.Boolean,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            If we have a WinRT type event, we need to encapsulate the adder call
            (which returns an EventRegistrationToken) with a call to 
            WindowsRuntimeMarshal.AddEventHandler or RemoveEventHandler, but these
            require us to create a new Func representing the adder and another
            Action representing the Remover.
            
            The rewritten call looks something like:
            
            WindowsRuntimeMarshal.AddEventHandler&lt;EventHandler&gt;
                (new Func&lt;EventHandler, EventRegistrationToken&gt;(@object.add), 
                 new Action&lt;EventRegistrationToken&gt;(@object.remove), handler);
            
            Where @object is a compiler-generated local temp if needed.
            </summary>
            <remarks>
            TODO: use or delete isDynamic.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeTupleFieldAccess(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
             <summary>
             Converts access to a tuple instance into access into the underlying ValueTuple(s).
            
             For instance, tuple.Item8
             produces fieldAccess(field=Item1, receiver=fieldAccess(field=Rest, receiver=ValueTuple for tuple))
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.IsInTryBlock(Microsoft.CodeAnalysis.CSharp.BoundFixedStatement)">
            <summary>
            Basically, what we need to know is, if an exception occurred within the fixed statement, would
            additional code in the current method be executed before its stack frame was popped?
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LocalRewriter._lazyUnmatchedLabelCache">
            <summary>
            If two (or more) fixed statements are nested, then we want to avoid having the outer
            fixed statement re-traverse the lowered bound tree of the inner one.  We accomplish
            this by having each fixed statement cache a set of unmatched gotos that can be
            reused by any containing fixed statements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.HasGotoOut(Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Look for gotos without corresponding labels in the lowered body of a fixed statement.
            </summary>
            <remarks>
            Assumes continue, break, etc have already been rewritten to gotos.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.InitializeFixedStatementRegularLocal(Microsoft.CodeAnalysis.CSharp.BoundLocalDeclaration,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol,Microsoft.CodeAnalysis.CSharp.BoundFixedLocalCollectionInitializer,Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol@)">
            <summary>
            <![CDATA[
            fixed(int* ptr = &v){ ... }    == becomes ===>
            
            pinned ref int pinnedTemp = ref v;    // pinning managed ref
            int* ptr = (int*)&pinnedTemp;         // unsafe cast to unmanaged ptr
              . . . 
            ]]>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.InitializeFixedStatementGetPinnable(Microsoft.CodeAnalysis.CSharp.BoundLocalDeclaration,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol,Microsoft.CodeAnalysis.CSharp.BoundFixedLocalCollectionInitializer,Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol@)">
            <summary>
            <![CDATA[
            fixed(int* ptr = &v){ ... }    == becomes ===>
            
            pinned ref int pinnedTemp = ref v;    // pinning managed ref
            int* ptr = (int*)&pinnedTemp;         // unsafe cast to unmanaged ptr
              . . . 
            ]]>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.InitializeFixedStatementStringLocal(Microsoft.CodeAnalysis.CSharp.BoundLocalDeclaration,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol,Microsoft.CodeAnalysis.CSharp.BoundFixedLocalCollectionInitializer,Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol@)">
            <summary>
            fixed(char* ptr = stringVar){ ... }    == becomes ===>
            
            pinned string pinnedTemp = stringVar;    // pinning managed ref
            char* ptr = (char*)pinnedTemp;           // unsafe cast to unmanaged ptr
            if (pinnedTemp != null) ptr += OffsetToStringData();
              . . . 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.InitializeFixedStatementArrayLocal(Microsoft.CodeAnalysis.CSharp.BoundLocalDeclaration,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol,Microsoft.CodeAnalysis.CSharp.BoundFixedLocalCollectionInitializer,Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol@)">
            <summary>
            <![CDATA[
            fixed(int* ptr = arr){ ... }    == becomes ===>
            
            pinned int[] pinnedTemp = arr;         // pinning managed ref
            int* ptr = pinnedTemp != null && pinnedTemp.Length != 0 ?
                           (int*)&pinnedTemp[0] :   // unsafe cast to unmanaged ptr
                           0;
              . . . 
              ]]>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement)">
            <summary>
            This is the entry point for foreach-loop lowering.  It delegates to
              RewriteEnumeratorForEachStatement
              RewriteSingleDimensionalArrayForEachStatement
              RewriteMultiDimensionalArrayForEachStatement
              CanRewriteForEachAsFor
            </summary>
            <remarks>
            We are diverging from the C# 4 spec (and Dev10) to follow the C# 5 spec.
            The iteration variable will be declared *inside* each loop iteration,
            rather than outside the loop.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteEnumeratorForEachStatement(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement)">
             <summary>
             Lower a foreach loop that will enumerate a collection using an enumerator.
            
             <![CDATA[
             E e = ((C)(x)).GetEnumerator()  OR  ((C)(x)).GetAsyncEnumerator()
             try {
                 while (e.MoveNext())  OR  while (await e.MoveNextAsync())
                 {
                     V v = (V)(T)e.Current;  -OR-  (D1 d1, ...) = (V)(T)e.Current;
                     // body
                 }
             }
             finally {
                 // clean up e
             }
             ]]>
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.WrapWithTryFinallyDispose(Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax,Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundLocal,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            There are three possible cases where we need disposal:
            - pattern-based disposal (we have a Dispose/DisposeAsync method)
            - interface-based disposal (the enumerator type converts to IDisposable/IAsyncDisposable)
            - we need to do a runtime check for IDisposable
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.WrapWithAwait(Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundAwaitableInfo)">
            <summary>
            Produce:
            await /* disposeCall */;
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.ConvertReceiverForInvocation(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
             <summary>
             Optionally apply a conversion to the receiver.
            
             If the receiver is of struct type and the method is an interface method, then skip the conversion.
             When we call the interface method directly - the code generator will detect it and generate a
             constrained virtual call.
             </summary>
             <param name="syntax">A syntax node to attach to the synthesized bound node.</param>
             <param name="receiver">Receiver of method call.</param>
             <param name="method">Method to invoke.</param>
             <param name="receiverConversion">Conversion to be applied to the receiver if not calling an interface method on a struct.</param>
             <param name="convertedReceiverType">Type of the receiver after applying the conversion.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteForEachStatementAsFor(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Lower a foreach loop that will enumerate a collection via indexing.
            
            <![CDATA[
            
            Indexable a = x;
            for (int p = 0; p < a.Length; p = p + 1) {
                V v = (V)a[p];   /* OR */   (D1 d1, ...) = (V)a[p];
                // body
            }
            
            ]]>
            </summary>
            <remarks>
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.LocalOrDeconstructionDeclaration(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},Microsoft.CodeAnalysis.CSharp.BoundExpression)">
             <summary>
             Takes the expression for the current value of the iteration variable and either
             (1) assigns it into a local, or
             (2) deconstructs it into multiple locals (if there is a deconstruct step).
            
             Produces <c>V v = /* expression */</c> or <c>(D1 d1, ...) = /* expression */</c>.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteSingleDimensionalArrayForEachStatement(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate a single-dimensional array.
            
            A[] a = x;
            for (int p = 0; p &lt; a.Length; p = p + 1) {
                V v = (V)a[p];   /* OR */   (D1 d1, ...) = (V)a[p];
                // body
            }
            </summary>
            <remarks>
            We will follow Dev10 in diverging from the C# 4 spec by ignoring Array's 
            implementation of IEnumerable and just indexing into its elements.
            
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteMultiDimensionalArrayForEachStatement(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate a multi-dimensional array.
            
            A[...] a = x;
            int q_0 = a.GetUpperBound(0), q_1 = a.GetUpperBound(1), ...;
            for (int p_0 = a.GetLowerBound(0); p_0 &lt;= q_0; p_0 = p_0 + 1)
                for (int p_1 = a.GetLowerBound(1); p_1 &lt;= q_1; p_1 = p_1 + 1)
                    ...
                        {
                            V v = (V)a[p_0, p_1, ...];   /* OR */   (D1 d1, ...) = (V)a[p_0, p_1, ...];
                            /* body */
                        }
            </summary>
            <remarks>
            We will follow Dev10 in diverging from the C# 4 spec by ignoring Array's 
            implementation of IEnumerable and just indexing into its elements.
            
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to nested for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.GetUnconvertedCollectionExpression(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement,Microsoft.CodeAnalysis.CSharp.Conversion@)">
            <summary>
            So that the binding info can return an appropriate SemanticInfo.Converted type for the collection
            expression of a foreach node, it is wrapped in a BoundConversion to the collection type in the
            initial bound tree.  However, we may be able to optimize away (or entirely disregard) the conversion
            so we pull out the bound node for the underlying expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakePatternIndexOffsetExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternIndexOffsetLoweringStrategy)">
            <summary>
            Used to produce an expression translating <paramref name="loweredExpr"/> to an integer offset
            according to the <paramref name="strategy"/>.
            The implementation should be in sync with <see cref="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DetermineMakePatternIndexOffsetExpressionStrategy(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternIndexOffsetLoweringStrategy@)"/>.
            </summary>
            <param name="loweredExpr">The lowered input for the translation</param>
            <param name="lengthAccess">
            An expression accessing the length of the indexing target. This should
            be a non-side-effecting operation.
            </param>
            <param name="strategy">The translation strategy</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DetermineMakePatternIndexOffsetExpressionStrategy(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternIndexOffsetLoweringStrategy@)">
            <summary>
            Determine the lowering strategy for translating a System.Index value to an integer offset value
            and prepare the lowered input for the translation process handled by <see cref="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakePatternIndexOffsetExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternIndexOffsetLoweringStrategy)"/>.
            The implementation should be in sync with <see cref="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakePatternIndexOffsetExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternIndexOffsetLoweringStrategy)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalRewriter.IsPatternExpressionGeneralLocalRewriter">
            <summary>
            A local rewriter for lowering an is-pattern expression.  This handles the general case by lowering
            the decision dag, and returning a "true" or "false" value as the result at the end.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LocalRewriter.IsPatternExpressionLinearLocalRewriter._sideEffectBuilder">
            <summary>
            Accumulates side-effects that come before the next conjunct.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LocalRewriter.IsPatternExpressionLinearLocalRewriter._conjunctBuilder">
            <summary>
            Accumulates conjuncts (conditions that must all be true) for the translation. When a conjunct is added,
            elements of the _sideEffectBuilder, if any, should be added as part of a sequence expression for
            the conjunct being added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.IsPatternExpressionLinearLocalRewriter.LowerOneTest(Microsoft.CodeAnalysis.CSharp.BoundDagTest,System.Boolean)">
            <summary>
            Translate the single test into _sideEffectBuilder and _conjunctBuilder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.IsPatternExpressionLinearLocalRewriter.ProduceLinearTestSequence(Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode,Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol)">
            <summary>
            Translate an is-pattern expression into a sequence of tests separated by the control-flow-and operator.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitLockStatement(Microsoft.CodeAnalysis.CSharp.BoundLockStatement)">
            <summary>
            Lowers a lock statement to a try-finally block that calls Monitor.Enter and Monitor.Exit
            before and after the body, respectively.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LocalRewriter.SwitchStatementLocalRewriter._sectionLabels">
            <summary>
            A map from section syntax to the first label in that section.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.SwitchStatementLocalRewriter.GetDagNodeLabel(Microsoft.CodeAnalysis.CSharp.BoundDecisionDagNode)">
            <summary>
            We revise the returned label for a leaf so that all leaves in the same switch section are given the same label.
            This enables the switch emitter to produce better code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteStringConcatenation(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
             <summary>
             The strategy of this rewrite is to do rewrite "locally".
             We analyze arguments of the concat in a shallow fashion assuming that 
             lowering and optimizations (including this one) is already done for the arguments.
             Based on the arguments we select the most appropriate pattern for the current node.
             
             NOTE: it is not guaranteed that the node that we chose will be the most optimal since we have only 
                   local information - i.e. we look at the arguments, but we do not know about siblings.
                   When we move to the parent, the node may be rewritten by this or some another optimization.
                   
             Example:
                 result = ( "abc" + "def" + null ?? expr1 + "moo" + "baz" ) + expr2
             
             Will rewrite into:
                 result = Concat("abcdef", expr2)
                 
             However there will be transient nodes like  Concat(expr1 + "moo")  that will not be present in the
             resulting tree.
            
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.FlattenConcatArg(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            digs into known concat operators and unwraps their arguments
            otherwise returns the expression as-is
            
            Generally we only need to recognize same node patterns that we create as a result of concatenation rewrite.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryExtractStringConcatArgs(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression}@)">
            <summary>
            Determines whether an expression is a known string concat operator (with or without a subsequent ?? ""), and extracts
            its args if so.
            </summary>
            <returns>True if this is a call to a known string concat operator, false otherwise</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryFoldTwoConcatOperands(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            folds two concat operands into one expression if possible
            otherwise returns null
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryFoldTwoConcatConsts(Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            folds two concat constants into one if possible
            otherwise returns null.
            It is generally always possible to concat constants, unless resulting string would be too large.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteStringConcatenationOneExpr(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Strangely enough there is such a thing as unary concatenation and it must be rewritten.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteStringConcatInExpressionLambda(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Most of the above optimizations are not applicable in expression trees as the operator
            must stay a binary operator. We cannot do much beyond constant folding which is done in binder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.ConvertConcatExprToString(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Returns an expression which converts the given expression into a string (or null).
            If necessary, this invokes .ToString() on the expression, to avoid boxing value types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeImplicitConversionForInterpolatedString(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Helper method to generate a lowered conversion from the given <paramref name="rewrittenOperand"/> to the given <paramref name="rewrittenType"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteToInterpolatedStringHandlerPattern(Microsoft.CodeAnalysis.CSharp.InterpolatedStringHandlerData,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Rewrites the given interpolated string to the set of handler creation and Append calls, returning an array builder of the append calls and the result
            local temp.
            </summary>
            <remarks>Caller is responsible for freeing the ArrayBuilder</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.HasSideEffects(Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Is there any code to execute in the given statement that could have side-effects,
            such as throwing an exception? This implementation is conservative, in the sense
            that it may return true when the statement actually may have no side effects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitTupleBinaryOperator(Microsoft.CodeAnalysis.CSharp.BoundTupleBinaryOperator)">
             <summary>
             Rewrite <c>GetTuple() == (1, 2)</c> to <c>tuple.Item1 == 1 &amp;&amp; tuple.Item2 == 2</c>.
             Also supports the != operator, nullable and nested tuples.
            
             Note that all the side-effects for visible expressions are evaluated first and from left to right. The initialization phase
             contains side-effects for:
             - single elements in tuple literals, like <c>a</c> in <c>(a, ...) == (...)</c> for example
             - nested expressions that aren't tuple literals, like <c>GetTuple()</c> in <c>(..., GetTuple()) == (..., (..., ...))</c>
             On the other hand, <c>Item1</c> and <c>Item2</c> of <c>GetTuple()</c> are not saved as part of the initialization phase of <c>GetTuple() == (..., ...)</c>
            
             Element-wise conversions occur late, together with the element-wise comparisons. They might not be evaluated.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.ReplaceTerminalElementsWithTemps(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.TupleBinaryOperatorInfo,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol})">
            <summary>
            Walk down tuple literals and replace all the side-effecting elements that need saving with temps.
            Expressions that are not tuple literals need saving, as are tuple literals that are involved in
            a simple comparison rather than a tuple comparison.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.DeferSideEffectingArgumentToTempForTupleEquality(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},System.Boolean)">
            <summary>
            Evaluate side effects into a temp, if necessary.  If there is an implicit user-defined
            conversion operation near the top of the arg, preserve that in the returned expression to be evaluated later.
            Conversions at the head of the result are unlowered, though the nested arguments within it are lowered.
            That resulting expression must be passed through <see cref="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.LowerConversions(Microsoft.CodeAnalysis.CSharp.BoundExpression)"/> to
            complete the lowering.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeNullableParts(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Boolean,Microsoft.CodeAnalysis.CSharp.BoundExpression@,Microsoft.CodeAnalysis.CSharp.BoundExpression@,System.Boolean@)">
            <summary>
            Produce a <c>.HasValue</c> and a <c>.GetValueOrDefault()</c> for nullable expressions that are neither always null or
            never null, and functionally equivalent parts for other cases.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeValueOrDefaultTemp(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            Returns a temp which is initialized with lowered-expression.HasValue
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteNonNullableNestedTupleOperators(Microsoft.CodeAnalysis.CSharp.TupleBinaryOperatorInfo.Multiple,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind)">
            <summary>
            Produces a chain of equality (or inequality) checks combined logically with AND (or OR)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.GetTuplePart(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Int32)">
            <summary>
            For tuple literals, we just return the element.
            For expressions with tuple type, we access <c>Item{i+1}</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteTupleSingleOperator(Microsoft.CodeAnalysis.CSharp.TupleBinaryOperatorInfo.Single,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind)">
             <summary>
             Produce an element-wise comparison and logic to ensure the result is a bool type.
            
             If an element-wise comparison doesn't return bool, then:
             - if it is dynamic, we'll do <c>!(comparisonResult.false)</c> or <c>comparisonResult.true</c>
             - if it implicitly converts to bool, we'll just do the conversion
             - otherwise, we'll do <c>!(comparisonResult.false)</c> or <c>comparisonResult.true</c> (as we'd do for <c>if</c> or <c>while</c>)
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.LowerConversions(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Lower any conversions appearing near the top of the bound expression, assuming non-conversions
            appearing below them have already been lowered.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteTupleCreationExpression(Microsoft.CodeAnalysis.CSharp.BoundTupleExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
             <summary>
             Converts the expression for creating a tuple instance into an expression creating a ValueTuple (if short) or nested ValueTuples (if longer).
            
             For instance, for a long tuple we'll generate:
             creationExpression(ctor=largestCtor, args=firstArgs+(nested creationExpression for remainder, with smaller ctor and next few args))
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitUnaryOperator(Microsoft.CodeAnalysis.CSharp.BoundUnaryOperator)">
            <summary>
            This rewriter lowers pre-/post- increment/decrement operations (initially represented as
            unary operators). We use BoundSequenceExpressions because we need to capture the RHS of the
            assignment in a temp variable.
            </summary>
            <remarks>
            This rewriter assumes that it will be run before decimal rewriting (so that it does not have
            to lower decimal constants and operations) and call rewriting (so that it does not have to
            lower property accesses).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitIncrementOperator(Microsoft.CodeAnalysis.CSharp.BoundIncrementOperator)">
            <summary>
            The rewrites are as follows: suppose the operand x is a variable of type X. The
            chosen increment/decrement operator is modelled as a static method on a type T,
            which takes a value of type T and returns the result of incrementing or decrementing
            that value.
            
            x++
                X temp = x
                x = (X)(T.Increment((T)temp))
                return temp
            x--
                X temp = x
                x = (X)(T.Decrement((T)temp))
                return temp
            ++x
                X temp = (X)(T.Increment((T)x))
                x = temp
                return temp
            --x
                X temp = (X)(T.Decrement((T)x))
                x = temp
                return temp
            
            Note: 
            Dev11 implements dynamic prefix operators incorrectly.
            
              result = ++x.P  is emitted as  result = SetMember{"P"}(t, UnaryOperation{Inc}(GetMember{"P"}(x)))
            
            The difference is that Dev11 relies on SetMember returning the same value as it was given as an argument.
            Failing to do so changes the semantics of ++/-- operator which is undesirable. We emit the same pattern for
            both dynamic and static operators.
               
            For example, we might have a class X with user-defined implicit conversions
            to and from short, but no user-defined increment or decrement operators. We
            would bind x++ as "X temp = x; x = (X)(short)((int)(short)temp + 1); return temp;"
            </summary>
            <param name="node">The unary operator expression representing the increment/decrement.</param>
            <returns>A bound sequence that uses a temp to achieve the correct side effects and return value.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeRValue(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Transform an expression from a form suitable as an lvalue to a form suitable as an rvalue.
            </summary>
            <param name="transformedExpression">The children of this node must already be lowered.</param>
            <returns>Fully lowered node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.BoundUsingStatement)">
             <summary>
             Rewrite a using statement into a try finally statement.  Four forms are possible:
               1) using (expr) stmt
               2) await using (expr) stmt
               3) using (C c = expr) stmt
               4) await using (C c = expr) stmt
            
             The first two are handled by RewriteExpressionUsingStatement and the latter two are handled by
             RewriteDeclarationUsingStatement (called in a loop, once for each local declared).
            
             For the async variants, `IAsyncDisposable` is used instead of `IDisposable` and we produce
             `... await expr.DisposeAsync() ...` instead of `... expr.Dispose() ...`.
             </summary>
             <remarks>
             It would be more in line with our usual pattern to rewrite using to try-finally
             in the ControlFlowRewriter, but if we don't do it here the BoundMultipleLocalDeclarations
             will be rewritten into a form that makes them harder to separate.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeLocalUsingDeclarationStatement(Microsoft.CodeAnalysis.CSharp.BoundUsingLocalDeclarations,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundStatement})">
            <summary>
            Lower "[await] using var x = (expression)" to a try-finally block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeExpressionUsingStatement(Microsoft.CodeAnalysis.CSharp.BoundUsingStatement,Microsoft.CodeAnalysis.CSharp.BoundBlock)">
            <summary>
            Lower "using [await] (expression) statement" to a try-finally block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteDeclarationUsingStatement(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundLocalDeclaration,Microsoft.CodeAnalysis.CSharp.BoundBlock,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.BoundAwaitableInfo,Microsoft.CodeAnalysis.CSharp.MethodArgumentInfo)">
            <summary>
            Lower "using [await] (ResourceType resource = expression) statement" to a try-finally block.
            </summary>
            <remarks>
            Assumes that the local symbol will be declared (i.e. in the LocalsOpt array) of an enclosing block.
            Assumes that using statements with multiple locals have already been split up into multiple using statements.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteUsingStatementTryFinally(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundBlock,Microsoft.CodeAnalysis.CSharp.BoundLocal,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.BoundAwaitableInfo,Microsoft.CodeAnalysis.CSharp.MethodArgumentInfo)">
            <param name="resourceTypeSyntax">
            The node that declares the type of the resource (might be shared by multiple resource declarations, e.g. <code>using T x = expr, y = expr;</code>)
            </param>
            <param name="resourceSyntax">
            The node that declares the resource storage, e.g. <code>x = expr</code> in <code>using T x = expr, y = expr;</code>. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.GenerateDisposeCall(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.MethodArgumentInfo,Microsoft.CodeAnalysis.CSharp.BoundAwaitableInfo,Microsoft.CodeAnalysis.SyntaxToken)">
            <param name="resourceTypeSyntax">
            The node that declares the type of the resource (might be shared by multiple resource declarations, e.g. <code>using T x = expr, y = expr;</code>)
            </param>
            <param name="resourceSyntax">
            The node that declares the resource storage, e.g. <code>x = expr</code> in <code>using T x = expr, y = expr;</code>. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeCallWithNoExplicitArgument(Microsoft.CodeAnalysis.CSharp.MethodArgumentInfo,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Synthesize a call `expression.Method()`, but with some extra smarts to handle extension methods, and to fill-in optional and params parameters. This call expects that the
            receiver parameter has already been visited.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LoweredDynamicOperation">
            <summary>
            The dynamic operation factories below return this struct so that the caller
            have the option of separating the call-site initialization from its invocation.
            
            Most callers just call <see cref="M:Microsoft.CodeAnalysis.CSharp.LoweredDynamicOperation.ToExpression"/> to get the combo but some (object and array initializers) 
            hoist all call-site initialization code and emit multiple invocations of the same site.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LoweredDynamicOperationFactory.CSharpBinderFlags">
            <summary>
            Corresponds to Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LoweredDynamicOperationFactory.CSharpArgumentInfoFlags">
            <summary>
            Corresponds to Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LoweredDynamicOperationFactory.MakeTempsForDiscardArguments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression}@)">
            <summary>
            If there are any discards in the arguments, create locals for each, updates the arguments and
            returns the symbols that were created.
            Returns default if no discards found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SpillSequenceSpiller.PromoteAndAddLocals(Microsoft.CodeAnalysis.CSharp.SpillSequenceSpiller.BoundSpillSequenceBuilder,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol})">
            <summary>
            If an expression node that declares synthesized short-lived locals (currently only sequence) contains
            a spill sequence (from an await or switch expression), these locals become long-lived since their
            values may be read by code that follows. We promote these variables to long-lived of kind
            <see cref="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.Spill"/>. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CapturedSymbolReplacement.Replacement(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            Rewrite the replacement expression for the hoisted local so all synthesized field are accessed as members
            of the appropriate frame.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IteratorAndAsyncCaptureWalker">
            <summary>
            A walker that computes the set of local variables of an iterator/async
            method that must be hoisted to the state machine.
            </summary>
            <remarks>
            Data flow analysis is used to calculate the locals. At yield/await we mark all variables as "unassigned".
            When a read from an unassigned variables is reported we add the variable to the captured set.
            "this" parameter is captured if a reference to "this", "base" or an instance field is encountered.
            Variables used in finally also need to be captured if there is a yield in the corresponding try block.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.stateField">
            <summary>
            The "state" of the state machine that is the translation of the iterator method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.cachedState">
            <summary>
            Cached "state" of the state machine within the MoveNext method.  We work with a copy of
            the state to avoid shared mutable state between threads.  (Two threads can be executing
            in a Task's MoveNext method because an awaited task may complete after the awaiter has
            tested whether the subtask is complete but before the awaiter has returned)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.cachedThis">
            <summary>
            Cached "this" local, used to store the captured "this", which is safe to cache locally since "this" 
            is semantically immutable.
            It would be hard for such caching to happen at JIT level (since JIT does not know that it never changes).
            NOTE: this field is null when we are not caching "this" which happens when
                  - not optimizing
                  - method is not capturing "this" at all
                  - containing type is a struct 
                  (we could cache "this" as a ref local for struct containers, 
                  but such caching would not save as much indirection and could actually 
                  be done at JIT level, possibly more efficiently)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._resumableStateAllocator">
            <summary>
            Allocates resumable states, i.e. states that resume execution of the state machine after await expression or yield return.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._dispatches">
            <summary>
            For each distinct label, the set of states that need to be dispatched to that label.
            Note that there is a dispatch occurring at every try-finally statement, so this
            variable takes on a new set of values inside each try block.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._lazyAvailableReusableHoistedFields">
            <summary>
            A pool of fields used to hoist locals. They appear in this set when not in scope,
            so that members of this set may be allocated to locals when the locals come into scope.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._nextHoistedFieldId">
            <summary>
            Fields allocated for temporary variables are given unique names distinguished by a number at the end.
            This counter ensures they are unique within a given translated method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._emptyStructTypeCache">
            <summary>
            Used to enumerate the instance fields of a struct.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._hoistedVariables">
            <summary>
            The set of local variables and parameters that were hoisted and need a proxy.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._stateDebugInfoBuilder">
            <summary>
            EnC support: the rewriter stores debug info for each await/yield in this builder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.GenerateReturn(System.Boolean)">
            <summary>
            Generate return statements from the state machine method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.Dispatch(System.Boolean)">
            <summary>
            Generates code that switches over states and jumps to the target labels listed in <see cref="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._dispatches"/>.
            </summary>
            <param name="isOutermost">
            If this is the outermost state dispatch switching over all states of the state machine - i.e. not state dispatch generated for a try-block.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.PossibleIteratorScope(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},System.Func{Microsoft.CodeAnalysis.CSharp.BoundStatement})">
            <summary>
            Translate a statement that declares a given set of locals.  Also allocates and frees hoisted temps as
            required for the translation.
            </summary>
            <param name="locals">The set of locals declared in the original version of this statement</param>
            <param name="wrapped">A delegate to return the translation of the body of this statement</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.MakeStateMachineScope(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.StateMachineFieldSymbol},Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <remarks>
            Must remain in sync with <see cref="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.TryUnwrapBoundStateMachineScope(Microsoft.CodeAnalysis.CSharp.BoundStatement@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.StateMachineFieldSymbol}@)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.TryUnwrapBoundStateMachineScope(Microsoft.CodeAnalysis.CSharp.BoundStatement@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.StateMachineFieldSymbol}@)">
            <remarks>
            Must remain in sync with <see cref="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.MakeStateMachineScope(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.StateMachineFieldSymbol},Microsoft.CodeAnalysis.CSharp.BoundStatement)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.MightContainReferences(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Might the given type be, or contain, managed references?  This is used to determine which
            fields allocated to temporaries should be cleared when the underlying variable goes out of scope, so
            that they do not cause unnecessary object retention.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.VisitTryStatement(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            The try statement is the most complex part of the state machine transformation.
            Since the CLR will not allow a 'goto' into the scope of a try statement, we must
            generate the dispatch to the state's label stepwise.  That is done by translating
            the try statements from the inside to the outside.  Within a try statement, we
            start with an empty dispatch table (representing the mapping from state numbers
            to labels).  During translation of the try statement's body, the dispatch table
            will be filled in with the data necessary to dispatch once we're inside the try
            block.  We generate that at the head of the translated try statement.  Then, we
            copy all of the states from that table into the table for the enclosing construct,
            but associate them with a label just before the translated try block.  That way
            the enclosing construct will generate the code necessary to get control into the
            try block for all of those states.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.GenerateSetBothStates(Microsoft.CodeAnalysis.StateMachineState)">
            <summary>
            Set the state field and the cached state
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ResumableStateMachineStateAllocator">
            <summary>
            Allocates resumable states, i.e. states that resume execution of the state machine after await expression or yield return.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ResumableStateMachineStateAllocator._nextState">
            <summary>
            The number of the next generated resumable state (i.e. state that resumes execution of the state machine after await expression or yield return).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ResumableStateMachineStateAllocator._matchedStateCount">
            <summary>
            EnC support: number of states in this state machine that match states of the previous generation state machine.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ResumableStateMachineStateAllocator.HasMissingStates">
            <summary>
            True if any of the states generated for any previous state machine has not been allocated in this version.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.StateMachineFieldSymbol">
            <summary>
            Represents a synthesized state machine field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.PreserveInitialParameterValuesAndThreadId">
            <summary>
            True if the initial values of locals in the rewritten method and the initial thread ID need to be preserved. (e.g. enumerable iterator methods and async-enumerable iterator methods)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.GenerateControlFields">
            <summary>
            Add fields to the state machine class that control the state machine.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.InitializeStateMachine(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundStatement},Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol)">
            <summary>
            Initialize the state machine class.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.GenerateStateMachineCreation(Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Collections.Generic.IReadOnlyDictionary{Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.CapturedSymbolReplacement})">
            <summary>
            Generate implementation-specific state machine initialization for the kickoff method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.GenerateMethodImplementations">
            <summary>
            Generate implementation-specific state machine member method implementations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.MakeCurrentThreadId">
            <summary>
            Produce Environment.CurrentManagedThreadId if available, otherwise CurrentThread.ManagedThreadId
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.GenerateIteratorGetEnumerator(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BoundExpression@,Microsoft.CodeAnalysis.StateMachineState)">
            <summary>
            Generate the GetEnumerator() method for iterators and GetAsyncEnumerator() for async-iterators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.GenerateResetInstance(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundStatement},Microsoft.CodeAnalysis.StateMachineState)">
            <summary>
            Generate logic to reset the current instance (rather than creating a new instance)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.CanGetThreadId">
            <summary>
            Returns true if either Thread.ManagedThreadId or Environment.CurrentManagedThreadId are available
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedStateMachineMethod">
            <summary>
            State machine interface method implementation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedStateMachineMoveNextMethod">
            <summary>
            Represents a state machine MoveNext method.
            Handles special behavior around inheriting some attributes from the original async/iterator method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedStateMachineDebuggerHiddenMethod">
            <summary>
            Represents a state machine method other than a MoveNext method.
            All such methods are considered debugger hidden. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields">
            <summary>
            Tracks synthesized fields that are needed in a submission being compiled.
            </summary>
            <remarks>
            For every other submission referenced by this submission we add a field, so that we can access members of the target submission.
            A field is also needed for the host object, if provided.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory">
            <summary>
            A helper class for synthesizing quantities of code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.MissingPredefinedMember">
            <summary>
            Thrown by the bound node factory when there is a failure to synthesize code.
            An appropriate diagnostic is included that should be reported.  Currently
            the only diagnostic handled through this mechanism is a missing special/well-known
            member.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory._binder">
            <summary>
            A binder suitable for performing overload resolution to synthesize a call to a helper method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.SyntheticBinderImpl">
            <summary>
            A binder used only for performing overload resolution of runtime helper methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <summary>
            Create a bound node factory. Note that the use of the factory to get special or well-known members
            that do not exist will result in an exception of type <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.MissingPredefinedMember"/> being thrown.
            </summary>
            <param name="topLevelMethod">The top-level method that will contain the code</param>
            <param name="node">The syntax node to which generated code should be attributed</param>
            <param name="compilationState">The state of compilation of the enclosing type</param>
            <param name="diagnostics">A bag where any diagnostics should be output</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.BindingDiagnosticBag)">
            <param name="topLevelMethodOpt">The top-level method that will contain the code</param>
            <param name="currentClassOpt">The enclosing class</param>
            <param name="node">The syntax node to which generated code should be attributed</param>
            <param name="compilationState">The state of compilation of the enclosing type</param>
            <param name="diagnostics">A bag where any diagnostics should be output</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.WellKnownMember(Microsoft.CodeAnalysis.WellKnownMember,System.Boolean)">
            <summary>
            Get the symbol for a well-known member. The use of this method to get a well-known member
            that does not exist will result in an exception of type <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.MissingPredefinedMember"/> being thrown
            containing an appropriate diagnostic for the caller to report.
            </summary>
            <param name="wm">The desired well-known member</param>
            <param name="isOptional">If true, the method may return null for a missing member without an exception</param>
            <returns>A symbol for the well-known member, or null if it is missing and <paramref name="isOptional"/> == true</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.SpecialMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Get the symbol for a special member. The use of this method to get a special member
            that does not exist will result in an exception of type MissingPredefinedMember being thrown
            containing an appropriate diagnostic for the caller to report.
            </summary>
            <param name="sm">The desired special member</param>
            <returns>A symbol for the special member.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.SyntheticSwitchSection">
            <summary>
            An internal helper class for building a switch statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.Switch(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.SyntheticSwitchSection})">
            <summary>
            Produce an int switch.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.CheckSwitchSections(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.SyntheticSwitchSection})">
            <summary>
            Check for (and assert that there are no) duplicate case labels in the switch.
            </summary>
            <param name="sections"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.ModuleVersionId">
            <summary>
            Synthesizes an expression that evaluates to the current module's MVID.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.SourceDocumentIndex(Microsoft.Cci.DebugSourceDocument)">
            <summary>
            Synthesizes an expression that evaluates to the index of a source document in the table of debug source documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.ArrayOrEmpty(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            Helper that will use Array.Empty if available and elements have 0 length
            NOTE: it is valid only if we know that the API that is being called will not
                  retain or use the array argument for any purpose (like locking or key in a hash table)
                  Typical example of valid use is Linq.Expressions factories - they do not make any
                  assumptions about array arguments and do not keep them or rely on their identity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.StoreToTemp(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundAssignmentOperator@,Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.SynthesizedLocalKind,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Takes an expression and returns the bound local expression "temp"
            and the bound assignment expression "temp = expr".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UnmatchedGotoFinder">
            <summary>
            Compiles a list of all labels that are targeted by gotos within a
            node, but are not declared within the node.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender._newPosition">
            <summary>
            newPosition represents the position we are in the final SourceText.  As we consume and reuse
            nodes from the old tree we will update our position in the new text accordingly.
            Likewise, when we must lex tokens out of the new tree we will update as well.
            
            NOTE(cyrusn): We do not need an oldPosition because it is redundant given the
            oldTreeCursor.  The oldPosition is implicitly defined by the position of the cursor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.ExtendToAffectedRange(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.Text.TextChangeRange)">
            <summary>
            Affected range of a change is the range within which nodes can be affected by a change
            and cannot be reused. Because of lookahead effective range of a change is larger than
            the change itself.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.Cursor">
            <summary>
            THe cursor represents a location in the tree that we can move around to indicate where
            we are in the original tree as we're incrementally parsing.  When it is at a node or
            token, it can either move forward to that entity's next sibling.  It can also move down
            to a node's first child or first token.
            
            Once the cursor hits the end of file, it's done.  Note: the cursor will skip any other
            zero length nodes in the tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DirectiveParser.ParseErrorOrWarningDirective(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,System.Boolean)">
            <summary>
            An error/warning directive tells the compiler to indicate a syntactic error/warning
            at the current location.
            
            Format: #error Error message string
            Resulting message: from the first non-whitespace character after the directive
            keyword until the end of the directive (aka EOD) at the line break or EOF.
            Resulting span: [first non-whitespace char, EOD)
            
            Examples (pipes indicate span):
            #error |goo|
            #error  |goo|
            #error |goo |
            #error |goo baz|
            #error |//goo|
            #error |/*goo*/|
            #error |/*goo|
            </summary>
            <param name="hash">The '#' token.</param>
            <param name="keyword">The 'error' or 'warning' token.</param>
            <param name="isActive">True if the error/warning should be recorded.</param>
            <returns>An ErrorDirective or WarningDirective node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.IsNonAsciiQuotationMark(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken)">
            <summary>
            These aren't acceptable in place of ASCII quotation marks in XML, 
            but we want to consume them (and produce an appropriate error) if
            they occur in a place where a quotation mark is legal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefAttributeValue">
             <summary>
             ACASEY: This grammar is derived from the behavior and sources of the native compiler.
             Tokens start with underscores (I've cheated for _PredefinedTypeToken, which is not actually a
             SyntaxKind), "*" indicates "0 or more", "?" indicates "0 or 1", and parentheses are for grouping.
             
             Cref	 			= CrefType _DotToken CrefMember
             					| CrefType
             					| CrefMember
                                 | CrefFirstType _OpenParenToken CrefParameterList? _CloseParenToken
             CrefName			= _IdentifierToken (_LessThanToken _IdentifierToken (_CommaToken _IdentifierToken)* _GreaterThanToken)?
             CrefFirstType 		= ((_IdentifierToken _ColonColonToken)? CrefName) 
                                 | _PredefinedTypeToken
             CrefType 			= CrefFirstType (_DotToken CrefName)*
             CrefMember 			= CrefName (_OpenParenToken CrefParameterList? _CloseParenToken)?
             					| _ThisKeyword (_OpenBracketToken CrefParameterList _CloseBracketToken)?
             					| _OperatorKeyword _OperatorToken (_OpenParenToken CrefParameterList? _CloseParenToken)?
             					| (_ImplicitKeyword | _ExplicitKeyword) _OperatorKeyword CrefParameterType (_OpenParenToken CrefParameterList? _CloseParenToken)?
             CrefParameterList	= CrefParameter (_CommaToken CrefParameter)*
             CrefParameter		= (_RefKeyword | _OutKeyword)? CrefParameterType
             CrefParameterType	= CrefParameterType2 _QuestionToken? _AsteriskToken* (_OpenBracketToken _CommaToken* _CloseBracketToken)*
             CrefParameterType2 	= (((_IdentifierToken _ColonColonToken)? CrefParameterType3) | _PredefinedTypeToken) (_DotToken CrefParameterType3)*
             CrefParameterType3 	= _IdentifierToken (_LessThanToken CrefParameterType (_CommaToken CrefParameterType)* _GreaterThanToken)?
            
             NOTE: type parameters, not type arguments
             NOTE: the first production of Cref is preferred to the other two
             NOTE: pointer, array, and nullable types only work in parameters
             NOTE: CrefParameterType2 and CrefParameterType3 correspond to CrefType and CrefName, respectively.
             Since the only difference is that they accept non-identifier type arguments, this is accomplished
             using parameters on the parsing methods (rather than whole new methods).
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseMemberCref">
            <summary>
            Parse the custom cref syntax for a named member (method, property, etc),
            an indexer, an overloadable operator, or a user-defined conversion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseNameMemberCref">
            <summary>
            Parse a named member (method, property, etc), with optional type
            parameters and regular parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseIndexerMemberCref">
            <summary>
            Parse an indexer member, with optional parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseOperatorMemberCref">
            <summary>
            Parse an overloadable operator, with optional parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseConversionOperatorMemberCref">
            <summary>
            Parse a user-defined conversion, with optional parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefParameterList">
            <summary>
            Parse a parenthesized parameter list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseBracketedCrefParameterList">
            <summary>
            Parse a bracketed parameter list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseBaseCrefParameterList(System.Boolean)">
            <summary>
            Parse the parameter list (if any) of a cref member (name, indexer, operator, or conversion).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.IsPossibleCrefParameter">
            <summary>
            True if the current token could be the beginning of a cref parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefParameter">
            <summary>
            Parse an element of a cref parameter list.
            </summary>
            <remarks>
            "ref" and "out" work, but "params", "this", and "__arglist" don't.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefName(System.Boolean)">
            <summary>
            Parse an identifier, optionally followed by an angle-bracketed list of type parameters.
            </summary>
            <param name="typeArgumentsMustBeIdentifiers">True to give an error when a non-identifier
            type argument is seen, false to accept.  No change in the shape of the tree.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefType(System.Boolean,System.Boolean)">
            <summary>
            Parse a type.  May include an alias, a predefined type, and/or a qualified name.
            </summary>
            <remarks>
            Pointer, nullable, or array types are only allowed if <paramref name="typeArgumentsMustBeIdentifiers"/> is false.
            Leaves a dot and a name unconsumed if the name is not followed by another dot
            and checkForMember is true.
            </remarks>
            <param name="typeArgumentsMustBeIdentifiers">True to give an error when a non-identifier
            type argument is seen, false to accept.  No change in the shape of the tree.</param>
            <param name="checkForMember">True means that the last name should not be consumed
            if it is followed by a parameter list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefTypeHelper(System.Boolean,System.Boolean)">
            <summary>
            Parse a type.  May include an alias, a predefined type, and/or a qualified name.
            </summary>
            <remarks>
            No pointer, nullable, or array types.
            Leaves a dot and a name unconsumed if the name is not followed by another dot
            and checkForMember is true.
            </remarks>
            <param name="typeArgumentsMustBeIdentifiers">True to give an error when a non-identifier
            type argument is seen, false to accept.  No change in the shape of the tree.</param>
            <param name="checkForMember">True means that the last name should not be consumed
            if it is followed by a parameter list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefTypeSuffix(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)">
            <summary>
            Once the name part of a type (including type parameter/argument lists) is parsed,
            we need to consume ?, *, and rank specifiers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.IsEndOfCrefAttribute">
            <summary>
            Ends at appropriate quotation mark, EOF, or EndOfDocumentationComment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.InCref">
            <summary>
            Convenience method for checking the mode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.IsEndOfNameAttribute">
            <summary>
            Ends at appropriate quotation mark, EOF, or EndOfDocumentationComment.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentXmlTokens">
            <summary>
            Set of well-known SyntaxTokens commonly found within XML doc comments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentXmlTokens.LookupToken(System.String,Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder)">
            <summary>
            Look up a well known SyntaxToken for a given XML element tag or attribute.
            This is a performance optimization to avoid creating duplicate tokens for the same content.
            </summary>
            <param name="text">The text of the tag or attribute.</param>
            <param name="leading">The leading trivia of the token.</param>
            <returns>The SyntaxToken representing the well-known tag or attribute or null if it's not well-known.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanExternAliasDirective">
            <summary>
            Returns true if the lookahead tokens compose extern alias directive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.CheckForVersionSpecificModifiers(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder,Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.MessageID)">
            <summary>
            checks for modifiers whose feature is not available
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatementCore(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Changes in this function around member parsing should be mirrored in <see cref="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationCore(Microsoft.CodeAnalysis.CSharp.SyntaxKind)"/>.
            Try keeping structure of both functions similar to simplify this task. The split was made to 
            reduce the stack usage during recursive parsing.
            </summary>
            <returns>Returns null if we can't parse anything (even partially).</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationCore(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Changes in this function should be mirrored in <see cref="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberDeclarationOrStatementCore(Microsoft.CodeAnalysis.CSharp.SyntaxKind)"/>.
            Try keeping structure of both functions similar to simplify this task. The split was made to 
            reduce the stack usage during recursive parsing.
            </summary>
            <returns>Returns null if we can't parse anything (even partially).</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlockAndExpressionBodiesWithSemicolon(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax@,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax@,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken@,System.Boolean,Microsoft.CodeAnalysis.CSharp.MessageID)">
            <summary>
            Parses any block or expression bodies that are present. Also parses
            the trailing semicolon if one is present.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.SkipBadListTokensWithExpectedKindHelper(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser,System.Boolean},System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser,System.Boolean},Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.GreenNode@)">
            <remarks>
            WARNING: it is possible that "list" is really the underlying builder of a SeparateSyntaxListBuilder,
            so it is important that we not add anything to the list.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseParameterNullCheck(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken@,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken@)">
            <summary>
            Parses the <c>!!</c> as skipped tokens following a parameter name token.  If the parameter name
            is followed by <c>!!=</c> or <c>! !=</c>, then the final equals will be returned through <paramref
            name="equalsToken"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.MergeAdjacent(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Merges two successive tokens into a single token with the given <paramref name="kind"/>.  If the two tokens
            have no trivia between them, then the final token will be trivially generated, properly passing on the right
            leading/trailing trivia.  However, if there is trivia between the tokens, then appropriate errors will be
            reported that the tokens cannot merge successfully.
            </summary>
            <remarks>
            IsFabricatedToken should be updated for tokens whose SyntaxKind is <paramref name="kind"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsTrueIdentifier">
            <summary>
            True if current identifier token is not really some contextual keyword
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsTrueIdentifier(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken)">
            <summary>
            True if the given token is not really some contextual keyword.
            This method is for use in executable code, as it treats <c>partial</c> as an identifier.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsOperatorStart(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax@,System.Boolean)">
            <summary>
            This is an adjusted version of <see cref="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMemberName(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax@,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken@,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax@,System.Boolean)"/>.
            When it returns true, it stops at operator keyword (<see cref="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsOperatorKeyword"/>).
            When it returns false, it does not advance in the token stream.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.NotType">
            <summary>
            Definitely not a type name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.MustBeType">
            <summary>
            Definitely a type name: either a predefined type (int, string, etc.) or an array
            type (ending with a [] brackets), or a pointer type (ending with *s), or a function
            pointer type (ending with > in valid cases, or a *, ), or calling convention
            identifier, in invalid cases).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.GenericTypeOrMethod">
            <summary>
            Might be a generic (qualified) type name or a method name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.GenericTypeOrExpression">
            <summary>
            Might be a generic (qualified) type name or an expression or a method name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.NonGenericTypeOrExpression">
            <summary>
            Might be a non-generic (qualified) type name or an expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.AliasQualifiedName">
            <summary>
            A type name with alias prefix (Alias::Name).  Note that Alias::Name.X would not fall under this.  This
            only is returned for exactly Alias::Name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.NullableType">
            <summary>
            Nullable type (ending with ?).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.PointerOrMultiplication">
            <summary>
            Might be a pointer type or a multiplication.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.TupleType">
            <summary>
            Might be a tuple type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTupleType(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken@)">
            <summary>
            Returns TupleType when a possible tuple type is found.
            Note that this is not MustBeType, so that the caller can consider deconstruction syntaxes.
            The caller is expected to have consumed the opening paren.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementCore(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax},System.Boolean)">
            <param name="isGlobal">If we're being called while parsing a C# top-level statements (Script or Simple Program).
            At the top level in Script, we allow most statements *except* for local-decls/local-funcs.
            Those will instead be parsed out as script-fields/methods.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsPossibleTypedIdentifierStart(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,System.Boolean)">
            <returns>
            true if the current token can be the first token of a typed identifier (a type name followed by an identifier),
            false if it definitely can't be,
            null if we need to scan further to find out.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMethodOrAccessorBodyBlock(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax},System.Boolean)">
            <summary>
            Used to parse the block-body for a method or accessor.  For blocks that appear *inside*
            method bodies, call <see cref="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax})"/>.
            </summary>
            <param name="isAccessorBody">If is true, then we produce a special diagnostic if the
            open brace is missing.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlock(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax})">
            <summary>
            Used to parse normal blocks that appear inside method bodies.  For the top level block
            of a method/accessor use <see cref="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseMethodOrAccessorBodyBlock(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax},System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsVarType">
            <summary>
            Is the following set of tokens, interpreted as a type, the type <c>var</c>?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseLocalDeclarationStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax})">
            <summary>
            Parses any kind of local declaration statement: local variable or local function.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSimpleDesignation">
            <summary>
            Parse a single variable designation (e.g. <c>x</c>) or a wildcard designation (e.g. <c>_</c>)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseVariableDeclaration">
            <summary>
            Parse a local variable declaration.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.CanStartExpression">
            <summary>
            Is the current token one that could start an expression?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsPossibleExpression">
            <summary>
            Is the current token one that could be in an expression?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseSubExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.Precedence)">
            <summary>
            Parse a subexpression of the enclosing operator of the given precedence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsPossibleDeconstructionLeft(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.Precedence)">
            <summary>
            Returns true if...
            1. The precedence is less than or equal to Assignment, and
            2. The current token is the identifier var or a predefined type, and
            3. it is followed by (, and
            4. that ( begins a valid parenthesized designation, and
            5. the token following that designation is =
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsPossibleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.Precedence)">
            <summary>
            Tokens that match the following are considered a possible lambda expression:
            <code>attribute-list* ('async' | 'static')* type? ('(' | identifier) ...</code>
            For better error recovery 'static =>' is also considered a possible lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.TryParseLambdaExpression">
            <summary>
            Parse expected lambda expression but assume `x ? () => y :` is a conditional
            expression rather than a lambda expression with an explicit return type and
            return null in that case only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.MakeInterpolatedStringTextToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringKind,System.String)">
            <summary>
            Interpret the given raw text from source as an InterpolatedStringTextToken.
            </summary>
            <param name="text">The text for the full string literal, including the quotes and contents</param>
            <param name="kind">The kind of the interpolated string we were processing</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseTypeOrPatternForIsOperator">
            <summary>
            Parses the type, or pattern, right-hand operand of an is expression.
            Priority is the TypeSyntax. It may return a TypeSyntax which turns out in binding to
            be a constant pattern such as enum 'Days.Sunday'. We handle such cases in the binder of the is operator.
            Note that the syntax `_` will be parsed as a type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.LooksLikeTypeOfPattern">
            <summary>
            Given tk, the type of the current token, does this look like the type of a pattern?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.CanTokenFollowTypeInPattern(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.Precedence)">
            <summary>
            Is the current token something that could follow a type in a pattern?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsPossibleSubpatternElement">
            <summary>
            Check the next token to see if it is valid as the first token of a subpattern element.
            Used to assist in error recovery for subpattern lists (e.g. determining which tokens to skip)
            to ensure we make forward progress during recovery.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolationFollowedByColon">
            <summary>
            The lexer is for the contents of an interpolation that is followed by a colon that signals the start of the format string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanIdentifier_CrefSlowPath(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.TokenInfo@)">
            <summary>
            This method is essentially the same as ScanIdentifier_SlowPath,
            except that it can handle XML entities.  Since ScanIdentifier
            is hot code and since this method does extra work, it seem
            worthwhile to separate it from the common case.
            </summary>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanEndOfLine">
            <summary>
            Scans a new-line sequence (either a single new-line character or a CR-LF combo).
            </summary>
            <returns>A trivia node with the new-line text</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanWhitespace">
            <summary>
            Scans all of the whitespace (not new-lines) into a trivia node until it runs out.
            </summary>
            <returns>A trivia node with the whitespace text</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlToken">
            <summary>
            Lexer entry point for LexMode.XmlDocComment
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlElementTagToken">
            <summary>
            Lexer entry point for LexMode.XmlElementTag
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.IsXmlNameStartChar(System.Char)">
            <summary>
            Determines whether this Unicode character can start a XMLName.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.IsXmlNameChar(System.Char)">
            <summary>
            Determines if this Unicode character can be part of an XML Name.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlAttributeTextToken">
            <summary>
            Lexer entry point for LexMode.XmlAttributeText
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlCharacter">
            <summary>
            Lexer entry point for LexerMode.XmlCharacter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanXmlCharacter(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.TokenInfo@)">
            <summary>
            Scan a single XML character (or entity).  Assumes that leading trivia has already
            been consumed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlCrefOrNameToken">
            <summary>
            Lexer entry point for LexerMode.XmlCrefQuote, LexerMode.XmlCrefDoubleQuote, 
            LexerMode.XmlNameQuote, and LexerMode.XmlNameDoubleQuote.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanXmlCrefToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.TokenInfo@)">
            <summary>
            Scan a single cref attribute token.  Assumes that leading trivia has already
            been consumed.
            </summary>
            <remarks>
            Within this method, characters that are not XML meta-characters can be seamlessly
            replaced with the corresponding XML entities.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.AdvanceIfMatches(System.Char)">
            <summary>
            Given a character, advance the input if either the character or the
            corresponding XML entity appears next in the text window.
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InXmlCrefOrNameAttributeValue">
            <summary>
            Convenience property for determining whether we are currently lexing the
            value of a cref or name attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InXmlNameAttributeValue">
            <summary>
            Convenience property for determining whether we are currently lexing the
            value of a name attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.AddCrefError(Microsoft.CodeAnalysis.CSharp.ErrorCode,System.Object[])">
            <summary>
            Diagnostics that occur within cref attributes need to be
            wrapped with ErrorCode.WRN_ErrorOverride.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.AddCrefError(Microsoft.CodeAnalysis.DiagnosticInfo)">
            <summary>
            Diagnostics that occur within cref attributes need to be
            wrapped with ErrorCode.WRN_ErrorOverride.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlCDataSectionTextToken">
            <summary>
            Lexer entry point for LexMode.XmlCDataSectionText
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlCommentTextToken">
            <summary>
            Lexer entry point for LexMode.XmlCommentText
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlProcessingInstructionTextToken">
            <summary>
            Lexer entry point for LexMode.XmlProcessingInstructionText
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlDocCommentLeadingTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder@)">
            <summary>
            Collects XML doc comment exterior trivia, and therefore is a no op unless we are in the Start or Exterior of an XML doc comment.
            </summary>
            <param name="trivia">List in which to collect the trivia</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlWhitespaceAndNewLineTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder@)">
            <summary>
            Collects whitespace and new line trivia for XML doc comments. Does not see XML doc comment exterior trivia, and is a no op unless we are in the interior.
            </summary>
            <param name="trivia">List in which to collect the trivia</param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.Interpolation.ColonRange">
            <summary>
            Range of the format colon in the interpolation.  Empty if there is no colon.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.Interpolation.CloseBraceRange">
            <summary>
            Range of the close brace.  Empty if there was no close brace (an error condition).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ConsumeCharSequence(System.Char)">
            <returns>The number of quotes that were consumed</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.StartsWith(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Returns true if <paramref name="sb"/> starts with <paramref name="value"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.RescanInterpolatedString(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax)">
            <summary>
            Turn a (parsed) interpolated string nonterminal into an interpolated string token.
            </summary>
            <param name="interpolatedString"></param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringKind.Normal">
            <summary>
            Normal interpolated string that just starts with <c>$"</c>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringKind.Verbatim">
            <summary>
            Verbatim interpolated string that starts with <c>$@"</c> or <c>@$"</c>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringKind.SingleLineRaw">
            <summary>
            Single-line raw interpolated string that starts with at least one <c>$</c>, and at least three <c>"</c>s.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringKind.MultiLineRaw">
            <summary>
            Multi-line raw interpolated string that starts with at least one <c>$</c>, and at least three <c>"</c>s.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner">
            <summary>
            Non-copyable ref-struct so that this will only live on the stack for the lifetime of the lexer/parser
            recursing to process interpolated strings.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.Error">
            <summary>
            Error encountered while scanning.  If we run into an error, then we'll attempt to stop parsing at the
            next potential ending location to prevent compounding the issue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanOpenQuote(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringKind@,System.Int32@,System.Int32@)">
            <param name="startingDollarSignCount">
            Number of '$' characters this interpolated string started with.  We'll need to see that many '{' in a
            row to start an interpolation.  Any less and we'll treat that as just text.  Note if this count is '1'
            then this is a normal (non-raw) interpolation and `{{` is treated as an escape.
            </param>
            <param name="startingQuoteCount">Number of '"' characters this interpolated string started with.</param>
            <returns><see langword="true"/> if we successfully processed the open quote range and can proceed to the
            rest of the literal. <see langword="false"/> if we were not successful and should stop
            processing.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.IsEndDelimiterOtherwiseConsume(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringKind,System.Int32)">
            <summary>
            Returns <see langword="true"/> if the quote was an end delimiter and lexing of the contents of the
            interpolated string literal should stop.  If it was an end delimiter it will not be consumed.  If it is
            content and should not terminate the string then it will be consumed by this method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringKind,System.Char,System.Boolean,System.Range@)">
            <summary>
            Scan past the hole inside an interpolated string literal, leaving the current character on the '}' (if any)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.RecoveringFromRunawayLexing">
            <summary>
            The lexer can run away consuming the rest of the input when delimiters are mismatched. This is a test
            for when we are attempting to recover from that situation.  Note that just running into new lines will
            not make us think we're in runaway lexing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow">
            <summary>
            Keeps a sliding buffer over the SourceText of a file for the lexer. Also
            provides the lexer with the ability to keep track of a current "lexeme"
            by leaving a marker and advancing ahead the offset. The lexer can then
            decide to "keep" the lexeme by erasing the marker, or abandon the current
            lexeme by moving the offset back to the marker.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.InvalidCharacter">
            <summary>
            In many cases, e.g. PeekChar, we need the ability to indicate that there are
            no characters left and we have reached the end of the stream, or some other
            invalid or not present character was asked for. Due to perf concerns, things
            like nullable or out variables are not viable. Instead we need to choose a
            char value which can never be legal.
            
            In .NET, all characters are represented in 16 bits using the UTF-16 encoding.
            Fortunately for us, there are a variety of different bit patterns which
            are *not* legal UTF-16 characters. 0xffff (char.MaxValue) is one of these
            characters -- a legal Unicode code point, but not a legal UTF-16 bit pattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.Position">
            <summary>
            The current absolute position in the text file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.Offset">
            <summary>
            The current offset inside the window (relative to the window start).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.CharacterWindow">
            <summary>
            The buffer backing the current window.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.LexemeRelativeStart">
            <summary>
            Returns the start of the current lexeme relative to the window start.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.CharacterWindowCount">
            <summary>
            Number of characters in the character window.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.LexemeStartPosition">
            <summary>
            The absolute position of the start of the current lexeme in the given
            SourceText.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.Width">
            <summary>
            The number of characters in the current lexeme.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.Start">
            <summary>
            Start parsing a new lexeme.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.IsReallyAtEnd">
            <summary>
            After reading <see cref="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.InvalidCharacter"/>, a consumer can determine
            if the InvalidCharacter was in the user's source or a sentinel.
            
            Comments and string literals are allowed to contain any Unicode character.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.AdvanceChar">
            <summary>
            Advance the current position by one. No guarantee that this
            position is valid.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.AdvanceChar(System.Int32)">
            <summary>
            Advance the current position by n. No guarantee that this position
            is valid.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.AdvancePastNewLine">
            <summary>
            Moves past the newline that the text window is currently pointing at.  The text window must be pointing at a
            newline.  If the newline is <c>\r\n</c> then that entire sequence will be skipped.  Otherwise, the text
            window will only advance past a single character.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.GetNewLineWidth">
            <summary>
            Gets the length of the newline the text window must be pointing at here.  For <c>\r\n</c> this is <c>2</c>,
            for everything else, this is <c>1</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.NextChar">
            <summary>
            Grab the next character and advance the position.
            </summary>
            <returns>
            The next character, <see cref="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.InvalidCharacter" /> if there were no characters 
            remaining.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.PeekChar">
            <summary>
            Gets the next character if there are any characters in the 
            SourceText. May advance the window if we are at the end.
            </summary>
            <returns>
            The next character if any are available. InvalidCharacter otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.PeekChar(System.Int32)">
            <summary>
            Gets the character at the given offset to the current position if
            the position is valid within the SourceText.
            </summary>
            <returns>
            The next character if any are available. InvalidCharacter otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.TryScanXmlEntity(System.Char@,System.Char@)">
            <summary>
            Given that the next character is an ampersand ('&amp;'), attempt to interpret the
            following characters as an XML entity.  On success, populate the out parameters
            with the low and high UTF-16 surrogates for the character represented by the
            entity.
            </summary>
            <param name="ch">e.g. '&lt;' for &amp;lt;.</param>
            <param name="surrogate">e.g. '\uDC00' for &amp;#x10000; (ch == '\uD800').</param>
            <returns>True if a valid XML entity was consumed.</returns>
            <remarks>
            NOTE: Always advances, even on failure.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.AdvanceIfMatches(System.String)">
            <summary>
            If the next characters in the window match the given string,
            then advance past those characters.  Otherwise, do nothing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactoryContext">
            <summary>
            Because syntax nodes need to be constructed with context information - to allow us to 
            determine whether or not they can be reused during incremental parsing - the syntax
            factory needs a view of some internal parser state.
            </summary>
            <remarks>
            Read-only outside SyntaxParser (not enforced for perf reasons).
            Reference type so that the factory stays up-to-date.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactoryContext.IsInAsync">
            <summary>
            If a method goes from async to non-async, or vice versa, then every occurrence of "await"
            within the method (but not within a lambda) needs to be reinterpreted, to determine whether
            it is a keyword or an identifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactoryContext.IsInQuery">
            <summary>
            If the end of a query expression statement is commented out, then the following statement may
            appear to be part of the query.  When this occurs, identifiers within the following statement
            may need to be reinterpreted as query keywords.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.TryEatToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns and consumes the current token if it has the requested <paramref name="kind"/>.
            Otherwise, returns <see langword="null"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.AddSkippedSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.GreenNode,System.Boolean)">
            <summary>
            Converts skippedSyntax node into tokens and adds these as trivia on the target token.
            Also adds the first error (in depth-first preorder) found in the skipped syntax tree to the target token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.FindOffset(Microsoft.CodeAnalysis.GreenNode,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode,System.Int32@)">
            <summary>
            This function searches for the given location node within the subtree rooted at root node. 
            If it finds it, the function computes the offset span of that child node within the root and returns true, 
            otherwise it returns false.
            </summary>
            <param name="root">Root node</param>
            <param name="location">Node to search in the subtree rooted at root node</param>
            <param name="offset">Offset of the location node within the subtree rooted at child</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.CheckFeatureAvailability``1(``0,Microsoft.CodeAnalysis.CSharp.MessageID,System.Boolean)">
            <remarks>
            NOTE: we are specifically diverging from dev11 to improve the user experience.
            Since treating the "async" keyword as an identifier in older language
            versions can never result in a correct program, we instead accept it as a
            keyword regardless of the language version and produce an error if the version
            is insufficient.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.IsMakingProgress(System.Int32@,System.Boolean)">
            <summary>
            Whenever parsing in a <c>while (true)</c> loop and a bug could prevent the loop from making progress,
            this method can prevent the parsing from hanging.
            Use as:
                int tokenProgress = -1;
                while (IsMakingProgress(ref tokenProgress))
            It should be used as a guardrail, not as a crutch, so it asserts if no progress was made.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode.SetFactoryContext(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactoryContext)">
            <summary>
            Should only be called during construction.
            </summary>
            <remarks>
            This should probably be an extra constructor parameter, but we don't need more constructor overloads.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode.GetStructure(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Gets the syntax node represented the structure of this trivia, if any. The HasStructure property can be used to 
            determine if this trivia has structure.
            </summary>
            <returns>
            A CSharpSyntaxNode derived from StructuredTriviaSyntax, with the structured view of this trivia node. 
            If this trivia node does not have structure, returns null.
            </returns>
            <remarks>
            Some types of trivia have structure that can be accessed as additional syntax nodes.
            These forms of trivia include: 
              directives, where the structure describes the structure of the directive.
              documentation comments, where the structure describes the XML structure of the comment.
              skipped tokens, where the structure describes the tokens that were skipped by the parser.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax">
            <summary>Class which represents the syntax node for identifier name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax.Identifier">
            <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax">
            <summary>Class which represents the syntax node for name colon syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax.Name">
            <summary>IdentifierNameSyntax representing the identifier name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax.ColonToken">
            <summary>SyntaxToken representing colon.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Token(Microsoft.CodeAnalysis.GreenNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.String,Microsoft.CodeAnalysis.GreenNode)">
            <summary>
            Creates a token whose <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken.Text"/> and <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken.ValueText"/> are the same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken.ToString">
            <summary>
            Returns the string representation of this token, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this token, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax">
            <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax">
            <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax">
            <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax.Identifier">
            <summary>SyntaxToken representing the identifier of the simple name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedNameSyntax">
            <summary>Class which represents the syntax node for qualified name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedNameSyntax.Left">
            <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedNameSyntax.DotToken">
            <summary>SyntaxToken representing the dot.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedNameSyntax.Right">
            <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GenericNameSyntax">
            <summary>Class which represents the syntax node for generic name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GenericNameSyntax.Identifier">
            <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GenericNameSyntax.TypeArgumentList">
            <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax">
            <summary>Class which represents the syntax node for type argument list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax.LessThanToken">
            <summary>SyntaxToken representing less than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax.GreaterThanToken">
            <summary>SyntaxToken representing greater than.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AliasQualifiedNameSyntax">
            <summary>Class which represents the syntax node for alias qualified name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AliasQualifiedNameSyntax.Alias">
            <summary>IdentifierNameSyntax node representing the name of the alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AliasQualifiedNameSyntax.ColonColonToken">
            <summary>SyntaxToken representing colon colon.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AliasQualifiedNameSyntax.Name">
            <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PredefinedTypeSyntax">
            <summary>Class which represents the syntax node for predefined types.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PredefinedTypeSyntax.Keyword">
            <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayTypeSyntax">
            <summary>Class which represents the syntax node for the array type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element of the array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayTypeSyntax.RankSpecifiers">
            <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PointerTypeSyntax">
            <summary>Class which represents the syntax node for pointer type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PointerTypeSyntax.ElementType">
            <summary>TypeSyntax node that represents the element type of the pointer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PointerTypeSyntax.AsteriskToken">
            <summary>SyntaxToken representing the asterisk.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerTypeSyntax.DelegateKeyword">
            <summary>SyntaxToken representing the delegate keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerTypeSyntax.AsteriskToken">
            <summary>SyntaxToken representing the asterisk.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerTypeSyntax.CallingConvention">
            <summary>Node representing the optional calling convention.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerTypeSyntax.ParameterList">
            <summary>List of the parameter types and return type of the function pointer.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerParameterListSyntax">
            <summary>Function pointer parameter list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerParameterListSyntax.LessThanToken">
            <summary>SyntaxToken representing the less than token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerParameterListSyntax.Parameters">
            <summary>SeparatedSyntaxList of ParameterSyntaxes representing the list of parameters and return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerParameterListSyntax.GreaterThanToken">
            <summary>SyntaxToken representing the greater than token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerCallingConventionSyntax">
            <summary>Function pointer calling convention syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerCallingConventionSyntax.ManagedOrUnmanagedKeyword">
            <summary>SyntaxToken representing whether the calling convention is managed or unmanaged.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerCallingConventionSyntax.UnmanagedCallingConventionList">
            <summary>Optional list of identifiers that will contribute to an unmanaged calling convention.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerUnmanagedCallingConventionListSyntax">
            <summary>Function pointer calling convention syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerUnmanagedCallingConventionListSyntax.OpenBracketToken">
            <summary>SyntaxToken representing open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerUnmanagedCallingConventionListSyntax.CallingConventions">
            <summary>SeparatedSyntaxList of calling convention identifiers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerUnmanagedCallingConventionListSyntax.CloseBracketToken">
            <summary>SyntaxToken representing close bracket.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerUnmanagedCallingConventionSyntax">
            <summary>Individual function pointer unmanaged calling convention.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerUnmanagedCallingConventionSyntax.Name">
            <summary>SyntaxToken representing the calling convention identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NullableTypeSyntax">
            <summary>Class which represents the syntax node for a nullable type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NullableTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NullableTypeSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleTypeSyntax">
            <summary>Class which represents the syntax node for tuple type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleTypeSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleTypeSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleElementSyntax">
            <summary>Tuple type element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleElementSyntax.Type">
            <summary>Gets the type of the tuple element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleElementSyntax.Identifier">
            <summary>Gets the name of the tuple element.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedTypeArgumentSyntax">
            <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedTypeArgumentSyntax.OmittedTypeArgumentToken">
            <summary>SyntaxToken representing the omitted type argument.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeSyntax">
            <summary>The ref modifier of a method's return value or a local.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeSyntax.ReadOnlyKeyword">
            <summary>Gets the optional "readonly" keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ScopedTypeSyntax">
            <summary>The 'scoped' modifier of a local.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax">
            <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleExpressionSyntax">
            <summary>Class which represents the syntax node for tuple expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleExpressionSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PrefixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for prefix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PrefixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PrefixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AwaitExpressionSyntax">
            <summary>Class which represents the syntax node for an "await" expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AwaitExpressionSyntax.AwaitKeyword">
            <summary>SyntaxToken representing the kind "await" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AwaitExpressionSyntax.Expression">
            <summary>ExpressionSyntax representing the operand of the "await" operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PostfixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for postfix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PostfixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PostfixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberAccessExpressionSyntax">
            <summary>Class which represents the syntax node for member access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberAccessExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax">
            <summary>Class which represents the syntax node for conditional access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax.WhenNotNull">
            <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberBindingExpressionSyntax">
            <summary>Class which represents the syntax node for member binding expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberBindingExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing dot.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberBindingExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being bound to.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementBindingExpressionSyntax">
            <summary>Class which represents the syntax node for element binding expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementBindingExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RangeExpressionSyntax">
            <summary>Class which represents the syntax node for a range expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RangeExpressionSyntax.LeftOperand">
            <summary>ExpressionSyntax node representing the expression on the left of the range operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RangeExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the range expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RangeExpressionSyntax.RightOperand">
            <summary>ExpressionSyntax node representing the expression on the right of the range operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitElementAccessSyntax">
            <summary>Class which represents the syntax node for implicit element access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitElementAccessSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BinaryExpressionSyntax">
            <summary>Class which represents an expression that has a binary operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BinaryExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BinaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the binary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BinaryExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AssignmentExpressionSyntax">
            <summary>Class which represents an expression that has an assignment operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AssignmentExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AssignmentExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the assignment expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AssignmentExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax">
            <summary>Class which represents the syntax node for conditional expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax.Condition">
            <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax.WhenTrue">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax.ColonToken">
            <summary>SyntaxToken representing the colon.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax.WhenFalse">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InstanceExpressionSyntax">
            <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ThisExpressionSyntax">
            <summary>Class which represents the syntax node for a this expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ThisExpressionSyntax.Token">
            <summary>SyntaxToken representing the this keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseExpressionSyntax">
            <summary>Class which represents the syntax node for a base expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseExpressionSyntax.Token">
            <summary>SyntaxToken representing the base keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LiteralExpressionSyntax">
            <summary>Class which represents the syntax node for a literal expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LiteralExpressionSyntax.Token">
            <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax">
            <summary>Class which represents the syntax node for MakeRef expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the MakeRefKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax">
            <summary>Class which represents the syntax node for RefType expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefTypeKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax">
            <summary>Class which represents the syntax node for RefValue expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefValueKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.Expression">
            <summary>Typed reference expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.Comma">
            <summary>Comma separating the arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.Type">
            <summary>The type of the value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax">
            <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax">
            <summary>Class which represents the syntax node for Default expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the DefaultKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax">
            <summary>Class which represents the syntax node for TypeOf expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the TypeOfKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax.Type">
            <summary>The expression to return type of.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax">
            <summary>Class which represents the syntax node for SizeOf expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the SizeOfKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InvocationExpressionSyntax">
            <summary>Class which represents the syntax node for invocation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InvocationExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InvocationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementAccessExpressionSyntax">
            <summary>Class which represents the syntax node for element access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementAccessExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseArgumentListSyntax">
            <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax">
            <summary>Class which represents the syntax node for the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax">
            <summary>Class which represents the syntax node for bracketed argument list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax.OpenBracketToken">
            <summary>SyntaxToken representing open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax.CloseBracketToken">
            <summary>SyntaxToken representing close bracket.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax">
            <summary>Class which represents the syntax node for argument.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax.NameColon">
            <summary>NameColonSyntax node representing the optional name arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax.RefKindKeyword">
            <summary>SyntaxToken representing the optional ref or out keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax.Expression">
            <summary>ExpressionSyntax node representing the argument.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DeclarationExpressionSyntax">
            <summary>Class which represents the syntax node for the variable declaration in an out var declaration or a deconstruction declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DeclarationExpressionSyntax.Designation">
            <summary>Declaration representing the variable declared in an out parameter or deconstruction.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax">
            <summary>Class which represents the syntax node for cast expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type to which the expression is being cast.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousFunctionExpressionSyntax">
            <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousFunctionExpressionSyntax.Block">
            <summary>
            BlockSyntax node representing the body of the anonymous function.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousFunctionExpressionSyntax.ExpressionBody">
            <summary>
            ExpressionSyntax node representing the body of the anonymous function.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous method expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax.DelegateKeyword">
            <summary>SyntaxToken representing the delegate keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax.ParameterList">
            <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax.Block">
            <summary>
            BlockSyntax node representing the body of the anonymous function.
            This will never be null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax.ExpressionBody">
            <summary>
            Inherited from AnonymousFunctionExpressionSyntax, but not used for
            AnonymousMethodExpressionSyntax.  This will always be null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LambdaExpressionSyntax">
            <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for a simple lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax.Parameter">
            <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax.Block">
            <summary>
            BlockSyntax node representing the body of the lambda.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax.ExpressionBody">
            <summary>
            ExpressionSyntax node representing the body of the lambda.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax.ParameterList">
            <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax.Block">
            <summary>
            BlockSyntax node representing the body of the lambda.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax.ExpressionBody">
            <summary>
            ExpressionSyntax node representing the body of the lambda.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax">
            <summary>Class which represents the syntax node for initializer expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax.Expressions">
            <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseObjectCreationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitObjectCreationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax.Type">
            <summary>TypeSyntax representing the type of the object being created.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WithExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the with expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectMemberDeclaratorSyntax.NameEquals">
            <summary>NameEqualsSyntax representing the optional name of the member being initialized.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectMemberDeclaratorSyntax.Expression">
            <summary>ExpressionSyntax representing the value the member is initialized with.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax.Initializers">
            <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayCreationExpressionSyntax.Type">
            <summary>ArrayTypeSyntax node representing the type of the array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax.OpenBracketToken">
            <summary>SyntaxToken representing the open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax.Commas">
            <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax.CloseBracketToken">
            <summary>SyntaxToken representing the close bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StackAllocArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StackAllocArrayCreationExpressionSyntax.StackAllocKeyword">
            <summary>SyntaxToken representing the stackalloc keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StackAllocArrayCreationExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StackAllocArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax node representing the initializer of the stackalloc array creation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitStackAllocArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit stackalloc array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitStackAllocArrayCreationExpressionSyntax.StackAllocKeyword">
            <summary>SyntaxToken representing the stackalloc keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitStackAllocArrayCreationExpressionSyntax.OpenBracketToken">
            <summary>SyntaxToken representing the open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitStackAllocArrayCreationExpressionSyntax.CloseBracketToken">
            <summary>SyntaxToken representing the close bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitStackAllocArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression of the implicit stackalloc array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FromClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LetClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinIntoClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryContinuationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedArraySizeExpressionSyntax">
            <summary>Class which represents a placeholder in an array size list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedArraySizeExpressionSyntax.OmittedArraySizeExpressionToken">
            <summary>SyntaxToken representing the omitted array size expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax.StringStartToken">
            <summary>The first part of an interpolated string, <c>$"</c> or <c>$@"</c> or <c>$"""</c></summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax.Contents">
            <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax.StringEndToken">
            <summary>The closing quote of the interpolated string.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IsPatternExpressionSyntax">
            <summary>Class which represents a simple pattern-matching expression using the "is" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IsPatternExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression on the left of the "is" operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IsPatternExpressionSyntax.Pattern">
            <summary>PatternSyntax node representing the pattern on the right of the "is" operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstantPatternSyntax.Expression">
            <summary>ExpressionSyntax node representing the constant expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RelationalPatternSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the relational pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypePatternSyntax.Type">
            <summary>The type for the type pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringTextSyntax.TextToken">
            <summary>The text contents of a part of the interpolated string.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationSyntax.OpenBraceToken">
            <summary>This could be a single <c>{</c> or multiple in a row (in the case of an interpolation in a raw interpolated string).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationSyntax.CloseBraceToken">
            <summary>
            This could be a single <c>}</c> or multiple in a row (in the case of an interpolation in a raw interpolated string).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationFormatClauseSyntax.FormatStringToken">
            <summary>The text contents of the format specifier for an interpolation.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax">
            <summary>Represents the base class for all statements syntax classes.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LocalFunctionStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LocalFunctionStatementSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LocalDeclarationStatementSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclaratorSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LabeledStatementSyntax">
            <summary>Represents a labeled statement syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LabeledStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LabeledStatementSyntax.ColonToken">
            <summary>Gets a SyntaxToken that represents the colon following the statement's label.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax">
            <summary>
            Represents a goto statement syntax
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax.GotoKeyword">
            <summary>
            Gets a SyntaxToken that represents the goto keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax.CaseOrDefaultKeyword">
            <summary>
            Gets a SyntaxToken that represents the case or default keywords if any exists.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax.Expression">
            <summary>
            Gets a constant expression for a goto case statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax.SemicolonToken">
            <summary>
            Gets a SyntaxToken that represents the semi-colon at the end of the statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForEachStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForEachVariableStatementSyntax.Variable">
            <summary>
            The variable(s) of the loop. In correct code this is a tuple
            literal, declaration expression with a tuple designator, or
            a discard syntax in the form of a simple identifier. In broken
            code it could be something else.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax">
            <summary>
            Represents an if statement syntax.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.IfKeyword">
            <summary>
            Gets a SyntaxToken that represents the if keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.Condition">
            <summary>
            Gets an ExpressionSyntax that represents the condition of the if statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.Statement">
            <summary>
            Gets a StatementSyntax the represents the statement to be executed when the condition is true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.Else">
            <summary>
            Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseClauseSyntax">
            <summary>Represents an else statement syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseClauseSyntax.ElseKeyword">
            <summary>
            Gets a syntax token
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax">
            <summary>Represents a switch statement syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.SwitchKeyword">
            <summary>
            Gets a SyntaxToken that represents the switch keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.Expression">
            <summary>
            Gets an ExpressionSyntax representing the expression of the switch statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis following the switch governing expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.OpenBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces preceding the switch sections.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.Sections">
            <summary>
            Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.CloseBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces following the switch sections.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchSectionSyntax">
            <summary>Represents a switch section syntax of a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchSectionSyntax.Labels">
            <summary>
            Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchSectionSyntax.Statements">
            <summary>
            Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchLabelSyntax">
            <summary>Represents a switch label within a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchLabelSyntax.Keyword">
            <summary>
            Gets a SyntaxToken that represents a case or default keyword that belongs to a switch label.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchLabelSyntax.ColonToken">
            <summary>
            Gets a SyntaxToken that represents the colon that terminates the switch label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CasePatternSwitchLabelSyntax">
            <summary>Represents a case label within a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CasePatternSwitchLabelSyntax.Keyword">
            <summary>Gets the case keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CasePatternSwitchLabelSyntax.Pattern">
            <summary>
            Gets a PatternSyntax that represents the pattern that gets matched for the case label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CaseSwitchLabelSyntax">
            <summary>Represents a case label within a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CaseSwitchLabelSyntax.Keyword">
            <summary>Gets the case keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CaseSwitchLabelSyntax.Value">
            <summary>
            Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultSwitchLabelSyntax">
            <summary>Represents a default label within a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultSwitchLabelSyntax.Keyword">
            <summary>Gets the default keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CompilationUnitSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax">
            <summary>
            Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax.ExternKeyword">
            <summary>SyntaxToken representing the extern keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax.AliasKeyword">
            <summary>SyntaxToken representing the alias keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax.SemicolonToken">
            <summary>SyntaxToken representing the semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax">
            <summary>Member declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NamespaceDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax">
            <summary>Class representing one or more attributes applied to a language construct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax.Target">
            <summary>Gets the optional construct targeted by the attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax">
            <summary>Class representing what language construct an attribute targets.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeSyntax">
            <summary>Attribute syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeSyntax.Name">
            <summary>Gets the name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax">
            <summary>Attribute argument list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax.Arguments">
            <summary>Gets the arguments syntax list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentSyntax">
            <summary>Attribute argument syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentSyntax.Expression">
            <summary>Gets the expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax">
            <summary>Class representing an identifier name followed by an equals token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax.Name">
            <summary>Gets the identifier name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax">
            <summary>Type parameter list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax.LessThanToken">
            <summary>Gets the &lt; token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax.GreaterThanToken">
            <summary>Gets the &gt; token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterSyntax">
            <summary>Type parameter syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax">
            <summary>Base class for type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.BaseList">
            <summary>Gets the base type list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.OpenBraceToken">
            <summary>Gets the open brace token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.CloseBraceToken">
            <summary>Gets the close brace token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeDeclarationSyntax">
            <summary>Base class for type declaration syntax (class, struct, interface, record).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeDeclarationSyntax.Keyword">
            <summary>Gets the type keyword token ("class", "struct", "interface", "record").</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeDeclarationSyntax.ConstraintClauses">
            <summary>Gets the type constraint list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeDeclarationSyntax.Members">
            <summary>Gets the member declarations.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassDeclarationSyntax">
            <summary>Class type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassDeclarationSyntax.Keyword">
            <summary>Gets the class keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StructDeclarationSyntax">
            <summary>Struct type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StructDeclarationSyntax.Keyword">
            <summary>Gets the struct keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterfaceDeclarationSyntax">
            <summary>Interface type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterfaceDeclarationSyntax.Keyword">
            <summary>Gets the interface keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax">
            <summary>Enum type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax.EnumKeyword">
            <summary>Gets the enum keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax.Members">
            <summary>Gets the members declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax">
            <summary>Delegate declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.DelegateKeyword">
            <summary>Gets the "delegate" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.SemicolonToken">
            <summary>Gets the semicolon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumMemberDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax">
            <summary>Base list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax.Types">
            <summary>Gets the base type references.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeSyntax">
            <summary>Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax">
            <summary>Type parameter constraint clause.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax.Name">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax.Constraints">
            <summary>Gets the constraints list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintSyntax">
            <summary>Base type for type parameter constraint syntax.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax">
            <summary>Constructor constraint syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax.NewKeyword">
            <summary>Gets the "new" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax.OpenParenToken">
            <summary>Gets the open paren keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax.CloseParenToken">
            <summary>Gets the close paren keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassOrStructConstraintSyntax">
            <summary>Class or struct constraint syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassOrStructConstraintSyntax.ClassOrStructKeyword">
            <summary>Gets the constraint keyword ("class" or "struct").</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassOrStructConstraintSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeConstraintSyntax">
            <summary>Type constraint syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeConstraintSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultConstraintSyntax">
            <summary>Default constraint syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultConstraintSyntax.DefaultKeyword">
            <summary>Gets the "default" keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseMethodDeclarationSyntax">
            <summary>Base type for method declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseMethodDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseMethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax">
            <summary>Method declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax.ReturnType">
            <summary>Gets the return type syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax">
            <summary>Operator declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax.CheckedKeyword">
            <summary>Gets the "checked" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax">
            <summary>Conversion operator declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax.ImplicitOrExplicitKeyword">
            <summary>Gets the "implicit" or "explicit" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax.CheckedKeyword">
            <summary>Gets the "checked" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax.Type">
            <summary>Gets the type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorDeclarationSyntax">
            <summary>Constructor declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorInitializerSyntax">
            <summary>Constructor initializer syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorInitializerSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorInitializerSyntax.ThisOrBaseKeyword">
            <summary>Gets the "this" or "base" keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax">
            <summary>Destructor declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax.TildeToken">
            <summary>Gets the tilde token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BasePropertyDeclarationSyntax">
            <summary>Base type for property declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BasePropertyDeclarationSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BasePropertyDeclarationSyntax.ExplicitInterfaceSpecifier">
            <summary>Gets the optional explicit interface specifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PropertyDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax">
            <summary>The syntax for the expression body of an expression-bodied member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EventDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IndexerDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax.Keyword">
            <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax.Body">
            <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax.ExpressionBody">
            <summary>Gets the optional expression body.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseParameterListSyntax">
            <summary>Base type for parameter list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax">
            <summary>Parameter list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedParameterListSyntax">
            <summary>Parameter list syntax with surrounding brackets.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseParameterSyntax">
            <summary>Base parameter syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax">
            <summary>Parameter syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerParameterSyntax">
            <summary>Parameter syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FunctionPointerParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefSyntax">
            <summary>
            A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
            For example, the M in &lt;see cref="M" /&gt;.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeCrefSyntax">
            <summary>
            A symbol reference that definitely refers to a type.
            For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedCrefSyntax">
            <summary>
            A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
            For example, cref="System.String.ToString()".
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberCrefSyntax">
            <summary>
            The unqualified part of a CrefSyntax.
            For example, "ToString()" in "object.ToString()".
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,
            with an optional type parameter list) and an optional parameter list.
            For example, "M", "M&lt;T&gt;" or "M(int)".
            Also, "A::B()" or "string()".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IndexerMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by a this keyword and an optional parameter list.
            For example, "this" or "this[int]".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
            For example, "operator +" or "operator -[int]".
            NOTE: the operator must be overloadable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorMemberCrefSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.
            For example, "implicit operator int" or "explicit operator MyType(int)".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseCrefParameterListSyntax">
            <summary>
            A list of cref parameters with surrounding punctuation.
            Unlike regular parameters, cref parameters do not have names.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseCrefParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax">
            <summary>
            A parenthesized list of cref parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefBracketedParameterListSyntax">
            <summary>
            A bracketed list of cref parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefBracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefBracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterSyntax">
            <summary>
            An element of a BaseCrefParameterListSyntax.
            Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
            there is no name and there are no attributes or other modifiers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax">
            <summary>Class which represents the syntax node for alias qualified name.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AliasQualifiedName"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax.Alias">
            <summary>IdentifierNameSyntax node representing the name of the alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax.ColonColonToken">
            <summary>SyntaxToken representing colon colon.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax.Name">
            <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax">
            <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax.Body">
            <summary>
            Either the <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax.Block"/> if it is not <c>null</c> or the
            <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax.ExpressionBody"/> otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax.UpdateAsyncKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            If the given <paramref name="asyncKeyword"/> is default, remove all async keywords, if any.
            Otherwise, replace the existing <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax.AsyncKeyword"/> (the first one) or add a new one.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax.Block">
            <summary>
            BlockSyntax node representing the body of the anonymous function.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax.ExpressionBody">
            <summary>
            ExpressionSyntax node representing the body of the anonymous function.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous method expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AnonymousMethodExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax.DelegateKeyword">
            <summary>SyntaxToken representing the delegate keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax.ParameterList">
            <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax.Block">
            <summary>
            BlockSyntax node representing the body of the anonymous function.
            This will never be null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax.ExpressionBody">
            <summary>
            Inherited from AnonymousFunctionExpressionSyntax, but not used for
            AnonymousMethodExpressionSyntax.  This will always be null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax">
            <summary>Class which represents the syntax node for argument.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.Argument"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.RefOrOutKeyword">
            <summary>
            Pre C# 7.2 back-compat overload, which simply calls the replacement property <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.RefKindKeyword"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.WithRefOrOutKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Pre C# 7.2 back-compat overload, which simply calls the replacement method <see cref="M:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.NameColon">
            <summary>NameColonSyntax node representing the optional name arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.RefKindKeyword">
            <summary>SyntaxToken representing the optional ref or out keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.Expression">
            <summary>ExpressionSyntax node representing the argument.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ArrayRankSpecifier"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax">
            <summary>Attribute syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.Attribute"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.GetErrorDisplayName">
            <summary>
            Return the name used in syntax for the attribute. This is typically the class
            name without the "Attribute" suffix. (For certain diagnostics, the native
            compiler uses the attribute name from syntax rather than the class name.)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.Name">
            <summary>Gets the name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax">
            <summary>Class representing what language construct an attribute targets.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AttributeTargetSpecifier"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax">
            <summary>Base type for method declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax">
            <summary>Base type for property declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax.ExplicitInterfaceSpecifier">
            <summary>Gets the optional explicit interface specifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.Block"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BreakStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CheckedStatement"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UncheckedStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax">
            <summary>Class or struct constraint syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ClassConstraint"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.StructConstraint"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax.ClassOrStructKeyword">
            <summary>Gets the constraint keyword ("class" or "struct").</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CompilationUnit"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.GetReferenceDirectives">
            <summary>
            Returns #r directives specified in the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.GetLoadDirectives">
            <summary>
            Returns #load directives specified in the compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax">
            <summary>Constructor declaration syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ConstructorDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ContinueStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax">
            <summary>Conversion operator declaration syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ConversionOperatorDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax.ImplicitOrExplicitKeyword">
            <summary>Gets the "implicit" or "explicit" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax.CheckedKeyword">
            <summary>Gets the "checked" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax.Type">
            <summary>Gets the type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.
            For example, "implicit operator int" or "explicit operator MyType(int)".
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ConversionOperatorMemberCref"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax">
            <summary>
            An element of a BaseCrefParameterListSyntax.
            Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
            there is no name and there are no attributes or other modifiers.
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CrefParameter"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax.RefOrOutKeyword">
            <summary>
            Pre C# 7.2 back-compat overload, which simply calls the replacement property <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax.RefKindKeyword"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax.WithRefOrOutKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Pre C# 7.2 back-compat overload, which simply calls the replacement method <see cref="M:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax.Update(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CSharpLineDirectiveMap">
            <summary>
            Adds C# specific parts to the line directive map.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningState">
            <summary>
            Describes how to report a warning diagnostic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningState.Default">
            <summary>
            Report a diagnostic by default.
            Either there is no corresponding #pragma, or the action is "restore".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningState.Enabled">
            <summary>
            Diagnostic is enabled.
            NOTE: this may be removed as part of https://github.com/dotnet/roslyn/issues/36550
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningState.Disabled">
            <summary>
            Diagnostic is disabled.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LocalDeclarationStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax">
            <summary>Delegate declaration syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DelegateDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.DelegateKeyword">
            <summary>Gets the "delegate" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.SemicolonToken">
            <summary>Gets the semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax">
            <summary>Destructor declaration syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DestructorDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax.TildeToken">
            <summary>Gets the tilde token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DoStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EmptyStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EnumMemberDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EventDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ExpressionStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax.AllowsAnyExpression">
            <summary>
            Returns true if the <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax.Expression"/> property is allowed by the rules of the
            language to be an arbitrary expression, not just a statement expression.
            </summary>
            <remarks>
            True if, for example, this expression statement represents the last expression statement
            of the interactive top-level code.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FixedStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ForEachStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ForEachVariableStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax.Variable">
            <summary>
            The variable(s) of the loop. In correct code this is a tuple
            literal, declaration expression with a tuple designator, or
            a discard syntax in the form of a simple identifier. In broken
            code it could be something else.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ForStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax">
            <summary>Class which represents the syntax node for generic name.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GenericName"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax.Identifier">
            <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax.TypeArgumentList">
            <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GlobalStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax">
            <summary>
            Represents a goto statement syntax
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GotoStatement"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GotoCaseStatement"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GotoDefaultStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax.GotoKeyword">
            <summary>
            Gets a SyntaxToken that represents the goto keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax.CaseOrDefaultKeyword">
            <summary>
            Gets a SyntaxToken that represents the case or default keywords if any exists.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax.Expression">
            <summary>
            Gets a constant expression for a goto case statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax.SemicolonToken">
            <summary>
            Gets a SyntaxToken that represents the semi-colon at the end of the statement.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax">
            <summary>Class which represents the syntax node for identifier name.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IdentifierName"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax.Identifier">
            <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax">
            <summary>
            Represents an if statement syntax.
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IfStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.IfKeyword">
            <summary>
            Gets a SyntaxToken that represents the if keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.Condition">
            <summary>
            Gets an ExpressionSyntax that represents the condition of the if statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.Statement">
            <summary>
            Gets a StatementSyntax the represents the statement to be executed when the condition is true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.Else">
            <summary>
            Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IndexerDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax">
            <summary>Represents a labeled statement syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LabeledStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax.ColonToken">
            <summary>Gets a SyntaxToken that represents the colon following the statement's label.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax">
            <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LocalFunctionStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LockStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition">
            <summary>
            This class contains a variety of helper methods for determining whether a
            position is within the scope (and not just the span) of a node.  In general,
            general, the scope extends from the first token up to, but not including,
            the last token. For example, the open brace of a block is within the scope
            of the block, but the close brace is not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInBlock(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>
            A position is considered to be inside a block if it is on or after
            the open brace and strictly before the close brace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInBody(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)">
            <summary>
            A position is inside a property body only if it is inside an expression body.
            All block bodies for properties are part of the accessor declaration (a type
            of BaseMethodDeclaration), not the property declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInBody(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax)">
            <summary>
            A position is inside a property body only if it is inside an expression body.
            All block bodies for properties are part of the accessor declaration (a type
            of BaseMethodDeclaration), not the property declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInBody(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax)">
            <summary>
            A position is inside an accessor body if it is inside the block or expression
            body. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInBody(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax)">
             <summary>
             A position is inside a body if it is inside the block or expression
             body. 
            
             A position is considered to be inside a block if it is on or after
             the open brace and strictly before the close brace. A position is
             considered to be inside an expression body if it is on or after
             the '=>' and strictly before the semicolon.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsBeforeToken(System.Int32,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns true if position is within the given node and before the first excluded token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInStatementScope(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <remarks>
            Used to determine whether it would be appropriate to use the binder for the statement (if any).
            Not used to determine whether the position is syntactically within the statement.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInSwitchSectionScope(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax)">
            <remarks>
            Used to determine whether it would be appropriate to use the binder for the switch section (if any).
            Not used to determine whether the position is syntactically within the statement.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInCatchBlockScope(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax)">
            <remarks>
            Used to determine whether it would be appropriate to use the binder for the statement (if any).
            Not used to determine whether the position is syntactically within the statement.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInCatchFilterScope(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax)">
            <remarks>
            Used to determine whether it would be appropriate to use the binder for the statement (if any).
            Not used to determine whether the position is syntactically within the statement.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax">
            <summary>Method declaration syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MethodDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.ReturnType">
            <summary>Gets the return type syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax">
            <summary>Class which represents the syntax node for name colon syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NameColon"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax.Name">
            <summary>IdentifierNameSyntax representing the identifier name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax.ColonToken">
            <summary>SyntaxToken representing colon.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NamespaceDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax">
            <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax.GetUnqualifiedName">
            <summary>
            Returns the unqualified (right-most) part of a qualified or alias-qualified name, or the name itself if already unqualified. 
            </summary>
            <returns>The unqualified (right-most) part of a qualified or alias-qualified name, or the name itself if already unqualified.
            If called on an instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax"/> returns the value of the <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax.Name"/> property.
            If called on an instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax"/> returns the value of the <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Right"/> property.
            If called on an instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax"/> returns the instance itself.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax.ErrorDisplayName">
            <summary>
            Return the name in string form, without trivia or generic arguments, for use in diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax.GetAliasQualifierOpt">
            <remarks>
            This inspection is entirely syntactic.  We are not trying to find the alias corresponding to the assembly symbol
            containing the explicitly implemented interface symbol - there may be more than one.  We just want to know
            how the name was qualified in source so that we can make a similar qualification (for uniqueness purposes).
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NullableContextState">
            <summary>
            Contains the nullable warnings and annotations context state at a given position in source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.NullableContextStateMap.IsNullableAnalysisEnabled(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns whether nullable warnings are enabled within the span.
            Returns true if nullable warnings are enabled anywhere in the span;
            false if nullable warnings are disabled throughout the span; and
            null otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax">
            <summary>Operator declaration syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OperatorDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax.CheckedKeyword">
            <summary>Gets the "checked" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
            For example, "operator +" or "operator -[int]".
            NOTE: the operator must be overloadable.
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OperatorMemberCref"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax">
            <summary>Parameter list syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ParameterList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax">
            <summary>Parameter syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.Parameter"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ParenthesizedLambdaExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax.ParameterList">
            <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax.Block">
            <summary>
            BlockSyntax node representing the body of the lambda.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax.ExpressionBody">
            <summary>
            ExpressionSyntax node representing the body of the lambda.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PropertyDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GetAccessorDeclaration"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SetAccessorDeclaration"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InitAccessorDeclaration"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddAccessorDeclaration"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RemoveAccessorDeclaration"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UnknownAccessorDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.Keyword">
            <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.Body">
            <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.ExpressionBody">
            <summary>Gets the optional expression body.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax">
            <summary>Class which represents the syntax node for qualified name.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.QualifiedName"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Left">
            <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.DotToken">
            <summary>SyntaxToken representing the dot.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Right">
            <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RecordDeclaration"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RecordStructDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax">
            <summary>The ref modifier of a method's return value or a local.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RefType"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax.ReadOnlyKeyword">
            <summary>Gets the optional "readonly" keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ReturnStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for a simple lambda expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SimpleLambdaExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax.Parameter">
            <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax.Block">
            <summary>
            BlockSyntax node representing the body of the lambda.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax.ExpressionBody">
            <summary>
            ExpressionSyntax node representing the body of the lambda.
            Only one of Block or ExpressionBody will be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax">
            <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax.Identifier">
            <summary>SyntaxToken representing the identifier of the simple name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.StackAllocArrayCreationExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax.StackAllocKeyword">
            <summary>SyntaxToken representing the stackalloc keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax node representing the initializer of the stackalloc array creation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax">
            <summary>
            It's a non terminal Trivia CSharpSyntaxNode that has a tree underneath it.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax.ParentTrivia">
            <summary>
            Get parent trivia.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.Subpattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax">
            <summary>Represents a switch statement syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SwitchStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.SwitchKeyword">
            <summary>
            Gets a SyntaxToken that represents the switch keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.Expression">
            <summary>
            Gets an ExpressionSyntax representing the expression of the switch statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis following the switch governing expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.OpenBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces preceding the switch sections.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.Sections">
            <summary>
            Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.CloseBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces following the switch sections.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxNodeRemover.SyntaxRemover.IsEndOfLine(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Returns whether the specified <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/> token is also the end of the line.  This will
            be true for <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia"/>, <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SingleLineCommentTrivia"/>,
            and all preprocessor directives.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxNodeRemover.SyntaxRemover.GetEndOfLine(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Returns the first end of line found in a <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ThrowStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TryStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax">
            <summary>Base class for type declaration syntax (class, struct, interface, record).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax.Keyword">
            <summary>Gets the type keyword token ("class", "struct", "interface", "record").</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax.ConstraintClauses">
            <summary>Gets the type constraint list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax.Members">
            <summary>Gets the member declarations.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax">
            <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UnsafeStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UsingDirective"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UsingStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhileStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.YieldReturnStatement"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.YieldBreakStatement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax">
            <summary>Class which represents the syntax node for type argument list.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TypeArgumentList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax.LessThanToken">
            <summary>SyntaxToken representing less than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax.GreaterThanToken">
            <summary>SyntaxToken representing greater than.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax">
            <summary>Class which represents the syntax node for predefined types.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PredefinedType"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax.Keyword">
            <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax">
            <summary>Class which represents the syntax node for the array type.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ArrayType"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element of the array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax.RankSpecifiers">
            <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax">
            <summary>Class which represents the syntax node for pointer type.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PointerType"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax.ElementType">
            <summary>TypeSyntax node that represents the element type of the pointer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax.AsteriskToken">
            <summary>SyntaxToken representing the asterisk.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FunctionPointerType"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax.DelegateKeyword">
            <summary>SyntaxToken representing the delegate keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax.AsteriskToken">
            <summary>SyntaxToken representing the asterisk.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax.CallingConvention">
            <summary>Node representing the optional calling convention.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax.ParameterList">
            <summary>List of the parameter types and return type of the function pointer.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax">
            <summary>Function pointer parameter list syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FunctionPointerParameterList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax.LessThanToken">
            <summary>SyntaxToken representing the less than token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax.Parameters">
            <summary>SeparatedSyntaxList of ParameterSyntaxes representing the list of parameters and return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax.GreaterThanToken">
            <summary>SyntaxToken representing the greater than token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax">
            <summary>Function pointer calling convention syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FunctionPointerCallingConvention"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax.ManagedOrUnmanagedKeyword">
            <summary>SyntaxToken representing whether the calling convention is managed or unmanaged.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax.UnmanagedCallingConventionList">
            <summary>Optional list of identifiers that will contribute to an unmanaged calling convention.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax">
            <summary>Function pointer calling convention syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FunctionPointerUnmanagedCallingConventionList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax.OpenBracketToken">
            <summary>SyntaxToken representing open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax.CallingConventions">
            <summary>SeparatedSyntaxList of calling convention identifiers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax.CloseBracketToken">
            <summary>SyntaxToken representing close bracket.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax">
            <summary>Individual function pointer unmanaged calling convention.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FunctionPointerUnmanagedCallingConvention"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax.Name">
            <summary>SyntaxToken representing the calling convention identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax">
            <summary>Class which represents the syntax node for a nullable type.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NullableType"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax">
            <summary>Class which represents the syntax node for tuple type.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TupleType"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax">
            <summary>Tuple type element.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TupleElement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax.Type">
            <summary>Gets the type of the tuple element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax.Identifier">
            <summary>Gets the name of the tuple element.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax">
            <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OmittedTypeArgument"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax.OmittedTypeArgumentToken">
            <summary>SyntaxToken representing the omitted type argument.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ScopedTypeSyntax">
            <summary>The 'scoped' modifier of a local.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ScopedType"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax">
            <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ParenthesizedExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax">
            <summary>Class which represents the syntax node for tuple expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TupleExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for prefix unary expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UnaryPlusExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UnaryMinusExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BitwiseNotExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LogicalNotExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PreIncrementExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PreDecrementExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddressOfExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PointerIndirectionExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IndexExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax">
            <summary>Class which represents the syntax node for an "await" expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AwaitExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax.AwaitKeyword">
            <summary>SyntaxToken representing the kind "await" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax.Expression">
            <summary>ExpressionSyntax representing the operand of the "await" operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for postfix unary expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PostIncrementExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PostDecrementExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SuppressNullableWarningExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax">
            <summary>Class which represents the syntax node for member access expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SimpleMemberAccessExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PointerMemberAccessExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax">
            <summary>Class which represents the syntax node for conditional access expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ConditionalAccessExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax.WhenNotNull">
            <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax">
            <summary>Class which represents the syntax node for member binding expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MemberBindingExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing dot.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being bound to.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax">
            <summary>Class which represents the syntax node for element binding expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ElementBindingExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax">
            <summary>Class which represents the syntax node for a range expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RangeExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax.LeftOperand">
            <summary>ExpressionSyntax node representing the expression on the left of the range operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the range expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax.RightOperand">
            <summary>ExpressionSyntax node representing the expression on the right of the range operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax">
            <summary>Class which represents the syntax node for implicit element access expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ImplicitElementAccess"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax">
            <summary>Class which represents an expression that has a binary operator.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DivideExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ModuloExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LeftShiftExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RightShiftExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UnsignedRightShiftExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LogicalOrExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LogicalAndExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BitwiseOrExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BitwiseAndExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ExclusiveOrExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EqualsExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NotEqualsExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LessThanExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LessThanOrEqualExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GreaterThanExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GreaterThanOrEqualExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IsExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AsExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CoalesceExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the binary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax">
            <summary>Class which represents an expression that has an assignment operator.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SimpleAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DivideAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ModuloAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AndAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ExclusiveOrAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OrAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LeftShiftAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RightShiftAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UnsignedRightShiftAssignmentExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CoalesceAssignmentExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the assignment expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax">
            <summary>Class which represents the syntax node for conditional expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ConditionalExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax.Condition">
            <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax.WhenTrue">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax.ColonToken">
            <summary>SyntaxToken representing the colon.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax.WhenFalse">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InstanceExpressionSyntax">
            <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax">
            <summary>Class which represents the syntax node for a this expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ThisExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax.Token">
            <summary>SyntaxToken representing the this keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax">
            <summary>Class which represents the syntax node for a base expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BaseExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax.Token">
            <summary>SyntaxToken representing the base keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax">
            <summary>Class which represents the syntax node for a literal expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ArgListExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NumericLiteralExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.StringLiteralExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.Utf8StringLiteralExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CharacterLiteralExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TrueLiteralExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FalseLiteralExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NullLiteralExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DefaultLiteralExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax.Token">
            <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax">
            <summary>Class which represents the syntax node for MakeRef expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MakeRefExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the MakeRefKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax">
            <summary>Class which represents the syntax node for RefType expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RefTypeExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefTypeKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax">
            <summary>Class which represents the syntax node for RefValue expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RefValueExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefValueKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.Expression">
            <summary>Typed reference expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.Comma">
            <summary>Comma separating the arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.Type">
            <summary>The type of the value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax">
            <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CheckedExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UncheckedExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax">
            <summary>Class which represents the syntax node for Default expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DefaultExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the DefaultKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax">
            <summary>Class which represents the syntax node for TypeOf expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TypeOfExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the TypeOfKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax.Type">
            <summary>The expression to return type of.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax">
            <summary>Class which represents the syntax node for SizeOf expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SizeOfExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the SizeOfKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax">
            <summary>Class which represents the syntax node for invocation expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InvocationExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax">
            <summary>Class which represents the syntax node for element access expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ElementAccessExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax">
            <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax">
            <summary>Class which represents the syntax node for the list of arguments.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ArgumentList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax">
            <summary>Class which represents the syntax node for bracketed argument list.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BracketedArgumentList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax.OpenBracketToken">
            <summary>SyntaxToken representing open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax.CloseBracketToken">
            <summary>SyntaxToken representing close bracket.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionColonSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ExpressionColon"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax">
            <summary>Class which represents the syntax node for the variable declaration in an out var declaration or a deconstruction declaration.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DeclarationExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax.Designation">
            <summary>Declaration representing the variable declared in an out parameter or deconstruction.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax">
            <summary>Class which represents the syntax node for cast expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CastExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type to which the expression is being cast.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RefExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax">
            <summary>Class which represents the syntax node for initializer expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ObjectInitializerExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CollectionInitializerExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ArrayInitializerExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ComplexElementInitializerExpression"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WithInitializerExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax.Expressions">
            <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit object creation expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ImplicitObjectCreationExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for object creation expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ObjectCreationExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.Type">
            <summary>TypeSyntax representing the type of the object being created.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WithExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the with expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AnonymousObjectMemberDeclarator"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax.NameEquals">
            <summary>NameEqualsSyntax representing the optional name of the member being initialized.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax.Expression">
            <summary>ExpressionSyntax representing the value the member is initialized with.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AnonymousObjectCreationExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax.Initializers">
            <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for array creation expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ArrayCreationExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax.Type">
            <summary>ArrayTypeSyntax node representing the type of the array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit array creation expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ImplicitArrayCreationExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax.OpenBracketToken">
            <summary>SyntaxToken representing the open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax.Commas">
            <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax.CloseBracketToken">
            <summary>SyntaxToken representing the close bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit stackalloc array creation expression.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ImplicitStackAllocArrayCreationExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax.StackAllocKeyword">
            <summary>SyntaxToken representing the stackalloc keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax.OpenBracketToken">
            <summary>SyntaxToken representing the open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax.CloseBracketToken">
            <summary>SyntaxToken representing the close bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression of the implicit stackalloc array creation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.QueryExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.QueryBody"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FromClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LetClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.JoinClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.JoinIntoClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhereClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OrderByClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AscendingOrdering"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DescendingOrdering"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SelectClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GroupClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.QueryContinuation"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax">
            <summary>Class which represents a placeholder in an array size list.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OmittedArraySizeExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax.OmittedArraySizeExpressionToken">
            <summary>SyntaxToken representing the omitted array size expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InterpolatedStringExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax.StringStartToken">
            <summary>The first part of an interpolated string, <c>$"</c> or <c>$@"</c> or <c>$"""</c></summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax.Contents">
            <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax.StringEndToken">
            <summary>The closing quote of the interpolated string.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax">
            <summary>Class which represents a simple pattern-matching expression using the "is" keyword.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IsPatternExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression on the left of the "is" operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax.Pattern">
            <summary>PatternSyntax node representing the pattern on the right of the "is" operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ThrowExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhenClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DiscardPatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DiscardPattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DeclarationPattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.VarPatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.VarPattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RecursivePattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PositionalPatternClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PropertyPatternClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ConstantPattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax.Expression">
            <summary>ExpressionSyntax node representing the constant expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ParenthesizedPattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.RelationalPatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RelationalPattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RelationalPatternSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the relational pattern.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypePatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TypePattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypePatternSyntax.Type">
            <summary>The type for the type pattern.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OrPattern"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AndPattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.UnaryPatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NotPattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ListPatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ListPattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SlicePatternSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SlicePattern"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InterpolatedStringText"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax.TextToken">
            <summary>The text contents of a part of the interpolated string.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.Interpolation"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax.OpenBraceToken">
            <summary>This could be a single <c>{</c> or multiple in a row (in the case of an interpolation in a raw interpolated string).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax.CloseBraceToken">
            <summary>
            This could be a single <c>}</c> or multiple in a row (in the case of an interpolation in a raw interpolated string).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InterpolationAlignmentClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InterpolationFormatClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax.FormatStringToken">
            <summary>The text contents of the format specifier for an interpolation.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax">
            <summary>Represents the base class for all statements syntax classes.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.VariableDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.VariableDeclarator"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EqualsValueClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SingleVariableDesignation"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DiscardDesignation"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ParenthesizedVariableDesignation"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax">
            <summary>Represents an else statement syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ElseClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax.ElseKeyword">
            <summary>
            Gets a syntax token
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax">
            <summary>Represents a switch section syntax of a switch statement.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SwitchSection"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax.Labels">
            <summary>
            Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax.Statements">
            <summary>
            Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax">
            <summary>Represents a switch label within a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax.Keyword">
            <summary>
            Gets a SyntaxToken that represents a case or default keyword that belongs to a switch label.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax.ColonToken">
            <summary>
            Gets a SyntaxToken that represents the colon that terminates the switch label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax">
            <summary>Represents a case label within a switch statement.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CasePatternSwitchLabel"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax.Keyword">
            <summary>Gets the case keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax.Pattern">
            <summary>
            Gets a PatternSyntax that represents the pattern that gets matched for the case label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax">
            <summary>Represents a case label within a switch statement.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CaseSwitchLabel"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax.Keyword">
            <summary>Gets the case keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax.Value">
            <summary>
            Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax">
            <summary>Represents a default label within a switch statement.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DefaultSwitchLabel"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax.Keyword">
            <summary>Gets the default keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SwitchExpression"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SwitchExpressionArm"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CatchClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CatchDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CatchFilterClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FinallyClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax">
            <summary>
            Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ExternAliasDirective"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax.ExternKeyword">
            <summary>SyntaxToken representing the extern keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax.AliasKeyword">
            <summary>SyntaxToken representing the alias keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax.SemicolonToken">
            <summary>SyntaxToken representing the semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax">
            <summary>Member declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FileScopedNamespaceDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax">
            <summary>Class representing one or more attributes applied to a language construct.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AttributeList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax.Target">
            <summary>Gets the optional construct targeted by the attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax">
            <summary>Attribute argument list syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AttributeArgumentList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax.Arguments">
            <summary>Gets the arguments syntax list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax">
            <summary>Attribute argument syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AttributeArgument"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax.Expression">
            <summary>Gets the expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax">
            <summary>Class representing an identifier name followed by an equals token.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NameEquals"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax.Name">
            <summary>Gets the identifier name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax">
            <summary>Type parameter list syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TypeParameterList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax.LessThanToken">
            <summary>Gets the &lt; token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax.GreaterThanToken">
            <summary>Gets the &gt; token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax">
            <summary>Type parameter syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TypeParameter"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax">
            <summary>Base class for type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.BaseList">
            <summary>Gets the base type list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.OpenBraceToken">
            <summary>Gets the open brace token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.CloseBraceToken">
            <summary>Gets the close brace token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax">
            <summary>Class type declaration syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ClassDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Keyword">
            <summary>Gets the class keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax">
            <summary>Struct type declaration syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.StructDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax.Keyword">
            <summary>Gets the struct keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax">
            <summary>Interface type declaration syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InterfaceDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax.Keyword">
            <summary>Gets the interface keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax">
            <summary>Enum type declaration syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EnumDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax.EnumKeyword">
            <summary>Gets the enum keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax.Members">
            <summary>Gets the members declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax">
            <summary>Base list syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BaseList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax.Types">
            <summary>Gets the base type references.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax">
            <summary>Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SimpleBaseType"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PrimaryConstructorBaseType"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax">
            <summary>Type parameter constraint clause.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TypeParameterConstraintClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax.Name">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax.Constraints">
            <summary>Gets the constraints list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax">
            <summary>Base type for type parameter constraint syntax.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax">
            <summary>Constructor constraint syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ConstructorConstraint"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax.NewKeyword">
            <summary>Gets the "new" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax.OpenParenToken">
            <summary>Gets the open paren keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax.CloseParenToken">
            <summary>Gets the close paren keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax">
            <summary>Type constraint syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TypeConstraint"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultConstraintSyntax">
            <summary>Default constraint syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DefaultConstraint"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultConstraintSyntax.DefaultKeyword">
            <summary>Gets the "default" keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FieldDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EventFieldDeclaration"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ExplicitInterfaceSpecifier"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax">
            <summary>Constructor initializer syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BaseConstructorInitializer"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ThisConstructorInitializer"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax.ThisOrBaseKeyword">
            <summary>Gets the "this" or "base" keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax">
            <summary>The syntax for the expression body of an expression-bodied member.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ArrowExpressionClause"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AccessorList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax">
            <summary>Base type for parameter list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax">
            <summary>Parameter list syntax with surrounding brackets.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BracketedParameterList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax">
            <summary>Base parameter syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax">
            <summary>Parameter syntax.</summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FunctionPointerParameter"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IncompleteMember"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SingleLineDocumentationCommentTrivia"/></description></item>
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiLineDocumentationCommentTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax">
            <summary>
            A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
            For example, the M in &lt;see cref="M" /&gt;.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax">
            <summary>
            A symbol reference that definitely refers to a type.
            For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TypeCref"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax">
            <summary>
            A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
            For example, cref="System.String.ToString()".
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.QualifiedCref"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax">
            <summary>
            The unqualified part of a CrefSyntax.
            For example, "ToString()" in "object.ToString()".
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,
            with an optional type parameter list) and an optional parameter list.
            For example, "M", "M&lt;T&gt;" or "M(int)".
            Also, "A::B()" or "string()".
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NameMemberCref"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by a this keyword and an optional parameter list.
            For example, "this" or "this[int]".
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IndexerMemberCref"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax">
            <summary>
            A list of cref parameters with surrounding punctuation.
            Unlike regular parameters, cref parameters do not have names.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax">
            <summary>
            A parenthesized list of cref parameters.
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CrefParameterList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax">
            <summary>
            A bracketed list of cref parameters.
            </summary>
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CrefBracketedParameterList"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlElement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlElementStartTag"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlElementEndTag"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlEmptyElement"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlName"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlPrefix"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlTextAttribute"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlCrefAttribute"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlNameAttribute"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlText"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlCDataSection"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlProcessingInstruction"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlComment"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IfDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ElifDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ElseDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndIfDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RegionDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndRegionDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ErrorDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WarningDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BadDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DefineDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UndefDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LineDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LineDirectivePosition"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LineSpanDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PragmaWarningDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PragmaChecksumDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ReferenceDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LoadDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ShebangDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax">
            <remarks>
            <para>This node is associated with the following syntax kinds:</para>
            <list type="bullet">
            <item><description><see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NullableDirectiveTrivia"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntaxFacts">
            <summary>
            Defines a set of methods to determine how Unicode characters are treated by the C# compiler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsHexDigit(System.Char)">
            <summary>
            Returns true if the Unicode character is a hexadecimal digit.
            </summary>
            <param name="c">The Unicode character.</param>
            <returns>true if the character is a hexadecimal digit 0-9, A-F, a-f.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsBinaryDigit(System.Char)">
            <summary>
            Returns true if the Unicode character is a binary (0-1) digit.
            </summary>
            <param name="c">The Unicode character.</param>
            <returns>true if the character is a binary digit.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsDecDigit(System.Char)">
            <summary>
            Returns true if the Unicode character is a decimal digit.
            </summary>
            <param name="c">The Unicode character.</param>
            <returns>true if the Unicode character is a decimal digit.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.HexValue(System.Char)">
            <summary>
            Returns the value of a hexadecimal Unicode character.
            </summary>
            <param name="c">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.BinaryValue(System.Char)">
            <summary>
            Returns the value of a binary Unicode character.
            </summary>
            <param name="c">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.DecValue(System.Char)">
            <summary>
            Returns the value of a decimal Unicode character.
            </summary>
            <param name="c">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsWhitespace(System.Char)">
            <summary>
            Returns true if the Unicode character represents a whitespace.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsNewLine(System.Char)">
            <summary>
            Returns true if the Unicode character is a newline character.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsIdentifierStartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be the starting character of a C# identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsIdentifierPartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be a part of a C# identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsValidIdentifier(System.String)">
            <summary>
            Check that the name is a valid identifier.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.ContainsDroppedIdentifierCharacters(System.String)">
            <summary>
            Spec section 2.4.2 says that identifiers are compared without regard
            to leading "@" characters or unicode formatting characters.  As in dev10,
            this is actually accomplished by dropping such characters during parsing.
            Unfortunately, metadata names can still contain these characters and will
            not be referenceable from source if they do (lookup will fail since the
            characters will have been dropped from the search string).
            See DevDiv #14432 for more.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsAliasQualifier(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the node is the alias of an AliasQualifiedNameSyntax
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsInvoked(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Returns true if the node is the object of an invocation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsIndexed(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Returns true if the node is the object of an element access expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsInTypeOnlyContext(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Returns true if the node is in a tree location that is expected to be a type
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsInNamespaceOrTypeContext(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Returns true if a node is in a tree location that is expected to be either a namespace or type
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsNamedArgumentName(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Is the node the name of a named argument of an invocation, object creation expression, 
            constructor initializer, or element access, but not an attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsFixedStatementExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Is the expression the initializer in a fixed statement?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.TryGetInferredMemberName(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given an initializer expression infer the name of anonymous property or tuple element.
            Returns null if unsuccessful
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsReservedTupleElementName(System.String)">
             <summary>
             Checks whether the element name is reserved.
            
             For example:
             "Item3" is reserved (at certain positions).
             "Rest", "ToString" and other members of System.ValueTuple are reserved (in any position).
             Names that are not reserved return false.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.EqualityComparer">
            <summary>
            A custom equality comparer for <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/>
            </summary>
            <remarks>
            PERF: The framework specializes EqualityComparer for enums, but only if the underlying type is System.Int32
            Since SyntaxKind's underlying type is System.UInt16, ObjectEqualityComparer will be chosen instead.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsPreprocessorContextualKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Some preprocessor keywords are only keywords when they appear after a
            hash sign (#).  For these keywords, the lexer will produce tokens with
            Kind = SyntaxKind.IdentifierToken and ContextualKind set to the keyword
            SyntaxKind.
            </summary>
            <remarks>
            This wrinkle is specifically not publicly exposed.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsGlobalMemberDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Member declarations that can appear in global code (other than type declarations).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.GeneratorDriver"/> implementation for the CSharp language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver.#ctor(Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISourceGenerator},Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AdditionalText},Microsoft.CodeAnalysis.GeneratorDriverOptions)">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver"/>
            </summary>
            <param name="parseOptions">The <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions"/> that should be used when parsing generated files.</param>
            <param name="generators">The generators that will run as part of this driver.</param>
            <param name="optionsProvider">An <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider"/> that can be used to retrieve analyzer config values by the generators in this driver.</param>
            <param name="additionalTexts">A list of <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/>s available to generators in this driver.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver.Create(Microsoft.CodeAnalysis.ISourceGenerator[])">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver"/> with the specified <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/>s and default options
            </summary>
            <param name="generators">The generators to create this driver with</param>
            <returns>A new <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver.Create(Microsoft.CodeAnalysis.IIncrementalGenerator[])">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver"/> with the specified <see cref="T:Microsoft.CodeAnalysis.IIncrementalGenerator"/>s and default options
            </summary>
            <param name="incrementalGenerators">The incremental generators to create this driver with</param>
            <returns>A new <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver.Create(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISourceGenerator},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.AdditionalText},Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider,Microsoft.CodeAnalysis.GeneratorDriverOptions)">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver"/> with the specified <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/>s and the provided options or default.
            </summary>
            <param name="generators">The generators to create this driver with</param>
            <param name="additionalTexts">A list of <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/>s available to generators in this driver, or <c>null</c> if there are none.</param>
            <param name="parseOptions">The <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions"/> that should be used when parsing generated files, or <c>null</c> to use <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.Default"/></param>
            <param name="optionsProvider">An <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider"/> that can be used to retrieve analyzer config values by the generators in this driver, or <c>null</c> if there are none.</param>
            <param name="driverOptions">A <see cref="T:Microsoft.CodeAnalysis.GeneratorDriverOptions"/> that controls the behavior of the created driver.</param>
            <returns>A new <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver"/> instance.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ObjectDisplay">
            <summary>
            Displays a value in the C# style.
            </summary>
            <remarks>
            Separate from <see cref="T:Microsoft.CodeAnalysis.CSharp.SymbolDisplay"/> because we want to link this functionality into
            the Formatter project and we don't want it to be public there.
            </remarks>
            <seealso cref="T:Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ObjectDisplay.FormatPrimitive(System.Object,Microsoft.CodeAnalysis.ObjectDisplayOptions)">
            <summary>
            Returns a string representation of an object of primitive type.
            </summary>
            <param name="obj">A value to display as a string.</param>
            <param name="options">Options used to customize formatting of an object value.</param>
            <returns>A string representation of an object of primitive type (or null if the type is not supported).</returns>
            <remarks>
            Handles <see cref="T:System.Boolean"/>, <see cref="T:System.String"/>, <see cref="T:System.Char"/>, <see cref="T:System.SByte"/>
            <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>,
            <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Double"/>, <see cref="T:System.Single"/>, <see cref="T:System.Decimal"/>,
            and <c>null</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ObjectDisplay.TryReplaceChar(System.Char,System.String@)">
            <summary>
            Returns true if the character should be replaced and sets
            <paramref name="replaceWith"/> to the replacement text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ObjectDisplay.FormatLiteral(System.String,Microsoft.CodeAnalysis.ObjectDisplayOptions)">
            <summary>
            Returns a C# string literal with the given value.
            </summary>
            <param name="value">The value that the resulting string literal should have.</param>
            <param name="options">Options used to customize formatting of an object value.</param>
            <returns>A string literal with the given value.</returns>
            <remarks>
            Optionally escapes non-printable characters.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ObjectDisplay.FormatLiteral(System.Char,Microsoft.CodeAnalysis.ObjectDisplayOptions)">
            <summary>
            Returns a C# character literal with the given value.
            </summary>
            <param name="c">The value that the resulting character literal should have.</param>
            <param name="options">Options used to customize formatting of an object value.</param>
            <returns>A character literal with the given value.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SymbolDisplay">
            <summary>
            Displays a symbol in the C# style.
            </summary>
            <seealso cref="T:Microsoft.CodeAnalysis.VisualBasic.SymbolDisplay"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.ToDisplayString(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Displays a symbol in the C# style, based on a <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayFormat"/>.
            </summary>
            <param name="symbol">The symbol to be displayed.</param>
            <param name="format">The formatting options to apply.  If null is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat"/> will be used.</param>
            <returns>A formatted string that can be displayed to the user.</returns>
            <remarks>
            The return value is not expected to be syntactically valid C#.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.ToMinimalDisplayString(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Displays a symbol in the C# style, based on a <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayFormat"/>.
            Based on the context, qualify type and member names as little as possible without
            introducing ambiguities.
            </summary>
            <param name="symbol">The symbol to be displayed.</param>
            <param name="semanticModel">Semantic information about the context in which the symbol is being displayed.</param>
            <param name="position">A position within the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <paramref name="semanticModel"/>.</param>
            <param name="format">The formatting options to apply.  If null is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat"/> will be used.</param>
            <returns>A formatted string that can be displayed to the user.</returns>
            <remarks>
            The return value is not expected to be syntactically valid C#.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.ToDisplayParts(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. Useful for
            colorizing the display string.
            </summary>
            <param name="symbol">The symbol to be displayed.</param>
            <param name="format">The formatting options to apply.  If null is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat"/> will be used.</param>
            <returns>A list of display parts.</returns>
            <remarks>
            Parts are not localized until they are converted to strings.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.ToMinimalDisplayParts(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. Useful for
            colorizing the display string.
            </summary>
            <param name="symbol">The symbol to be displayed.</param>
            <param name="semanticModel">Semantic information about the context in which the symbol is being displayed.</param>
            <param name="position">A position within the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <paramref name="semanticModel"/>.</param>
            <param name="format">The formatting options to apply.  If null is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat"/> will be used.</param>
            <returns>A list of display parts.</returns>
            <remarks>
            Parts are not localized until they are converted to strings.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatPrimitive(System.Object,System.Boolean,System.Boolean)">
            <summary>
            Returns a string representation of an object of primitive type.
            </summary>
            <param name="obj">A value to display as a string.</param>
            <param name="quoteStrings">Whether or not to quote string literals.</param>
            <param name="useHexadecimalNumbers">Whether or not to display integral literals in hexadecimal.</param>
            <returns>A string representation of an object of primitive type (or null if the type is not supported).</returns>
            <remarks>
            Handles <see cref="T:System.Boolean"/>, <see cref="T:System.String"/>, <see cref="T:System.Char"/>, <see cref="T:System.SByte"/>
            <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>,
            <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Double"/>, <see cref="T:System.Single"/>, <see cref="T:System.Decimal"/>,
            and <c>null</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatLiteral(System.String,System.Boolean)">
            <summary>
            Returns a C# string literal with the given value.
            </summary>
            <param name="value">The value that the resulting string literal should have.</param>
            <param name="quote">True to put (double) quotes around the string literal.</param>
            <returns>A string literal with the given value.</returns>
            <remarks>
            Escapes non-printable characters.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatLiteral(System.Char,System.Boolean)">
            <summary>
            Returns a C# character literal with the given value.
            </summary>
            <param name="c">The value that the resulting character literal should have.</param>
            <param name="quote">True to put (single) quotes around the character literal.</param>
            <returns>A character literal with the given value.</returns>
            <remarks>
            Escapes non-printable characters.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplayVisitor.CanUseTupleSyntax(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns true if tuple type syntax can be used to refer to the tuple type without loss of information.
            For example, it cannot be used when extension tuple is using non-default friendly names. 
            </summary>
            <param name="tupleSymbol"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableAnnotation">
            <summary>
            The nullable annotations that can apply in source.
            </summary>
            <remarks>
            The order of values here is used in the computation of <see cref="M:Microsoft.CodeAnalysis.CSharp.NullableAnnotationExtensions.Meet(Microsoft.CodeAnalysis.CSharp.NullableAnnotation,Microsoft.CodeAnalysis.CSharp.NullableAnnotation)"/>,
            <see cref="M:Microsoft.CodeAnalysis.CSharp.NullableAnnotationExtensions.Join(Microsoft.CodeAnalysis.CSharp.NullableAnnotation,Microsoft.CodeAnalysis.CSharp.NullableAnnotation)"/>, and
            <see cref="M:Microsoft.CodeAnalysis.CSharp.NullableAnnotationExtensions.EnsureCompatible(Microsoft.CodeAnalysis.CSharp.NullableAnnotation,Microsoft.CodeAnalysis.CSharp.NullableAnnotation)"/>.  If the order here is changed
            then those implementations may have to be revised (or simplified).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableAnnotation.NotAnnotated">
            <summary>
            Type is not annotated - string, int, T (including the case when T is unconstrained).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableAnnotation.Oblivious">
            <summary>
            The type is not annotated in a context where the nullable feature is not enabled.
            Used for interoperation with existing pre-nullable code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableAnnotation.Annotated">
            <summary>
            Type is annotated with '?' - string?, T?.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableAnnotation.Ignored">
             <summary>
             Used for indexed type parameters and used locally in override/implementation checks.
             When substituting a type parameter with Ignored annotation into some original type parameter
             with some other annotation, the result is the annotation from the original symbol.
            
             T annotated + (T -> U ignored) = U annotated
             T oblivious + (T -> U ignored) = U oblivious
             T not-annotated + (T -> U ignored) = U not-annotated
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableAnnotationExtensions.Join(Microsoft.CodeAnalysis.CSharp.NullableAnnotation,Microsoft.CodeAnalysis.CSharp.NullableAnnotation)">
            <summary>
            Join nullable annotations from the set of lower bounds for fixing a type parameter.
            This uses the covariant merging rules. (Annotated wins over Oblivious which wins over NotAnnotated)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableAnnotationExtensions.Meet(Microsoft.CodeAnalysis.CSharp.NullableAnnotation,Microsoft.CodeAnalysis.CSharp.NullableAnnotation)">
            <summary>
            Meet two nullable annotations for computing the nullable annotation of a type parameter from upper bounds.
            This uses the contravariant merging rules. (NotAnnotated wins over Oblivious which wins over Annotated)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableAnnotationExtensions.EnsureCompatible(Microsoft.CodeAnalysis.CSharp.NullableAnnotation,Microsoft.CodeAnalysis.CSharp.NullableAnnotation)">
            <summary>
            Return the nullable annotation to use when two annotations are expected to be "compatible", which means
            they could be the same. These are the "invariant" merging rules. (NotAnnotated wins over Annotated which wins over Oblivious)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableAnnotationExtensions.MergeNullableAnnotation(Microsoft.CodeAnalysis.CSharp.NullableAnnotation,Microsoft.CodeAnalysis.CSharp.NullableAnnotation,Microsoft.CodeAnalysis.VarianceKind)">
            <summary>
            Merges nullability.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableAnnotationExtensions.NotAnnotatedAttributeValue">
            <summary>
            The attribute (metadata) representation of <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableAnnotation.NotAnnotated"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableAnnotationExtensions.AnnotatedAttributeValue">
            <summary>
            The attribute (metadata) representation of <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableAnnotation.Annotated"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableAnnotationExtensions.ObliviousAttributeValue">
            <summary>
            The attribute (metadata) representation of <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableAnnotation.Oblivious"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NullableFlowState">
            <summary>
            The nullable state of an rvalue computed in <see cref="T:Microsoft.CodeAnalysis.CSharp.NullableWalker"/>.
            When in doubt we conservatively use <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableFlowState.NotNull"/>
            to minimize diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableFlowState.NotNull">
            <summary>
            Not null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableFlowState.MaybeNull">
            <summary>
            Maybe null (type is nullable).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.NullableFlowState.MaybeDefault">
            <summary>
            Maybe null (type may be not nullable).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableFlowStateExtensions.Join(Microsoft.CodeAnalysis.CSharp.NullableFlowState,Microsoft.CodeAnalysis.CSharp.NullableFlowState)">
            <summary>
            Join nullable flow states from distinct branches during flow analysis.
            The result is <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableFlowState.MaybeNull"/> if either operand is that.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.NullableFlowStateExtensions.Meet(Microsoft.CodeAnalysis.CSharp.NullableFlowState,Microsoft.CodeAnalysis.CSharp.NullableFlowState)">
            <summary>
            Meet two nullable flow states from distinct states for the meet (union) operation in flow analysis.
            The result is <see cref="F:Microsoft.CodeAnalysis.CSharp.NullableFlowState.NotNull"/> if either operand is that.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SymbolDistinguisher">
            <summary>
            Some error messages are particularly confusing if multiple placeholders are substituted
            with the same string.  For example, "cannot convert from 'Goo' to 'Goo'".  Usually, this
            occurs because there are two types in different contexts with the same qualified name.
            The solution is to provide additional qualification on each symbol - either a source
            location, an assembly path, or an assembly identity.
            </summary>
            <remarks>
            Performs the same function as ErrArgFlags::Unique in the native compiler.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2">
            <summary>
            Virtual dispatch based on a symbol's particular class. 
            </summary>
            <typeparam name="TArgument">Additional argument type</typeparam>
            <typeparam name="TResult">Result type</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.Visit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)">
            <summary>
            Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
            Return default(TResult) if symbol is null
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)">
            <summary>
            The default Visit method called when visiting any <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbol" /> and 
            if visiting specific symbol method VisitXXX is not overridden
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitAssembly(Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol" />; Override this method with
            specific implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not
            overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitModule(Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol" />; Override this method with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitNamespace(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol" />; Should override this method if
            want to visit members of the namespace; Calling <see
            cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetMembers" />
            and loop over each member; calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.Visit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> on it Or override this with
            specific implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not
            overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol" />; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitArrayType(Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol" />; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitPointerType(Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol" />; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitFunctionPointerType(Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.FunctionPointerTypeSymbol"/>; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)"/>  if it's not overridden
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitErrorType(Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol" /> 
            Error symbol is created when there is compiler error; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol" />; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitDynamicType(Microsoft.CodeAnalysis.CSharp.Symbols.DynamicTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.DynamicTypeSymbol" />; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitDiscard(Microsoft.CodeAnalysis.CSharp.Symbols.DiscardSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.DiscardSymbol" />; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitField(Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitProperty(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitEvent(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitParameter(Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitLocal(Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitLabel(Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitAlias(Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitRangeVariable(Microsoft.CodeAnalysis.CSharp.Symbols.RangeVariableSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.RangeVariableSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions.ToCSharpString(Microsoft.CodeAnalysis.TypedConstant)">
            <summary>
            Returns the System.String that represents the current TypedConstant.
            </summary>
            <returns>A System.String that represents the current TypedConstant.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeUnification.CanUnify(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Determine whether there is any substitution of type parameters that will
            make two types identical.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeUnification.CanUnifyHelper(Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithAnnotations,Microsoft.CodeAnalysis.CSharp.Symbols.MutableTypeMap@)">
            <summary>
            Determine whether there is any substitution of type parameters that will
            make two types identical.
            </summary>
            <param name="t1">LHS</param>
            <param name="t2">RHS</param>
            <param name="substitution">
            Substitutions performed so far (or null for none).
            Keys are type parameters, values are types (possibly type parameters).
            Will be updated with new substitutions by the callee.
            Should be ignored when false is returned.
            </param>
            <returns>True if there exists a type map such that Map(LHS) == Map(RHS).</returns>
            <remarks>
            Derived from Dev10's BSYMMGR::UnifyTypes.
            Two types will not unify if they have different custom modifiers.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeUnification.Contains(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol)">
            <summary>
            Return true if the given type contains the specified type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntaxFactory">
            <summary>
            A class containing factory methods for constructing syntax nodes, tokens and trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousMethodExpression">
            <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>Creates a new LiteralExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefType(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new RefTypeSyntax instance.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CarriageReturnLineFeed">
            <summary>
            A trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineFeed">
            <summary>
            A trivia with kind EndOfLineTrivia containing a single line feed character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CarriageReturn">
            <summary>
            A trivia with kind EndOfLineTrivia containing a single carriage return character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Space">
            <summary>
             A trivia with kind WhitespaceTrivia containing a single space character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Tab">
            <summary>
            A trivia with kind WhitespaceTrivia containing a single tab character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticCarriageReturnLineFeed">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.
            Elastic trivia are used to denote trivia that was not produced by parsing source text, and are usually not
            preserved during formatting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticLineFeed">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used
            to denote trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticCarriageReturn">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia
            are used to denote trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticSpace">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticTab">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticMarker">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included
            automatically by factory methods when trivia is not specified. Syntax formatting will replace elastic
            markers with appropriate trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EndOfLine(System.String)">
            <summary>
            Creates a trivia with kind EndOfLineTrivia containing the specified text. 
            </summary>
            <param name="text">The text of the end of line. Any text can be specified here, however only carriage return and
            line feed characters are recognized by the parser as end of line.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticEndOfLine(System.String)">
            <summary>
            Creates a trivia with kind EndOfLineTrivia containing the specified text. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
            <param name="text">The text of the end of line. Any text can be specified here, however only carriage return and
            line feed characters are recognized by the parser as end of line.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Whitespace(System.String)">
            <summary>
            Creates a trivia with kind WhitespaceTrivia containing the specified text.
            </summary>
            <param name="text">The text of the whitespace. Any text can be specified here, however only specific
            whitespace characters are recognized by the parser.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticWhitespace(System.String)">
            <summary>
            Creates a trivia with kind WhitespaceTrivia containing the specified text. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
            <param name="text">The text of the whitespace. Any text can be specified here, however only specific
            whitespace characters are recognized by the parser.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Comment(System.String)">
            <summary>
            Creates a trivia with kind either SingleLineCommentTrivia or MultiLineCommentTrivia containing the specified
            text.
            </summary>
            <param name="text">The entire text of the comment including the leading '//' token for single line comments
            or stop or start tokens for multiline comments.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DisabledText(System.String)">
            <summary>
            Creates a trivia with kind DisabledTextTrivia. Disabled text corresponds to any text between directives that
            is not considered active.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PreprocessingMessage(System.String)">
            <summary>
            Creates a trivia with kind PreprocessingMessageTrivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SyntaxTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.String)">
            <summary>
            Trivia nodes represent parts of the program text that are not parts of the
            syntactic grammar, such as spaces, newlines, comments, preprocessor
            directives, and disabled code.
            </summary>
            <param name="kind">
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> representing the specific kind of <see cref="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SyntaxTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.String)"/>. One of
            <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia"/>, <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia"/>,
            <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SingleLineCommentTrivia"/>, <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiLineCommentTrivia"/>,
            <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DocumentationCommentExteriorTrivia"/>, <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DisabledTextTrivia"/>
            </param>
            <param name="text">
            The actual text of this token.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Token(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Creates a token corresponding to a syntax kind. This method can be used for token syntax kinds whose text
            can be inferred by the kind alone.
            </summary>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Token(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can
            be inferred by the kind alone.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Token(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token corresponding to syntax kind. This method gives control over token Text and ValueText.
            
            For example, consider the text '&lt;see cref="operator &amp;#43;"/&gt;'.  To create a token for the value of
            the operator symbol (&amp;#43;), one would call 
            Token(default(SyntaxTriviaList), SyntaxKind.PlusToken, "&amp;#43;", "+", default(SyntaxTriviaList)).
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="text">The text from which this token was created (e.g. lexed).</param>
            <param name="valueText">How C# should interpret the text of this token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MissingToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an
            expected token is not found. A missing token has no text and normally has associated diagnostics.
            </summary>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MissingToken(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an
            expected token is not found. A missing token has no text and normally has associated diagnostics.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier(System.String)">
            <summary>
            Creates a token with kind IdentifierToken containing the specified text.
            </summary>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@' character.</param>        
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind IdentifierToken containing the specified text.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a verbatim token with kind IdentifierToken containing the specified text.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The identifier, not including any escapes or leading '@'
            character.</param>
            <param name="valueText">The canonical value of the token's text.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind IdentifierToken containing the specified text.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="contextualKind">An alternative SyntaxKind that can be inferred for this token in special
            contexts. These are usually keywords.</param>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            <param name="valueText">The text of the identifier name without escapes or leading '@' character.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Int32)">
            <summary>
            Creates a token with kind NumericLiteralToken from a 4-byte signed integer value.
            </summary>
            <param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Int32)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Int32,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.UInt32)">
            <summary>
            Creates a token with kind NumericLiteralToken from a 4-byte unsigned integer value.
            </summary>
            <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.UInt32)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte unsigned integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.UInt32,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte unsigned integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Int64)">
            <summary>
            Creates a token with kind NumericLiteralToken from an 8-byte signed integer value.
            </summary>
            <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Int64)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Int64,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.UInt64)">
            <summary>
            Creates a token with kind NumericLiteralToken from an 8-byte unsigned integer value.
            </summary>
            <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.UInt64)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.UInt64,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Single)">
            <summary>
            Creates a token with kind NumericLiteralToken from a 4-byte floating point value.
            </summary>
            <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Single)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Single,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Double)">
            <summary>
            Creates a token with kind NumericLiteralToken from an 8-byte floating point value.
            </summary>
            <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Double)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Double,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Decimal)">
            <summary>
            Creates a token with kind NumericLiteralToken from a decimal value.
            </summary>
            <param name="value">The decimal value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Decimal)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The decimal value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Decimal,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The decimal value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String)">
            <summary>
            Creates a token with kind StringLiteralToken from a string value.
            </summary>
            <param name="value">The string value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.String)">
            <summary>
            Creates a token with kind StringLiteralToken from the text and corresponding string value.
            </summary>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The string value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind StringLiteralToken from the text and corresponding string value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The string value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Char)">
            <summary>
            Creates a token with kind CharacterLiteralToken from a character value.
            </summary>
            <param name="value">The character value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Char)">
            <summary>
            Creates a token with kind CharacterLiteralToken from the text and corresponding character value.
            </summary>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The character value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Char,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind CharacterLiteralToken from the text and corresponding character value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The character value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BadToken(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind BadToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the bad token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextLiteral(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlTextLiteralToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml text value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlEntity(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlEntityLiteralToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml entity value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DocumentationComment(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[])">
            <summary>
            Creates an xml documentation comment that abstracts xml syntax creation.
            </summary>
            <param name="content">
            A list of xml node syntax that will be the content within the xml documentation comment
            (e.g. a summary element, a returns element, exception element and so on).
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlSummaryElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[])">
            <summary>
            Creates a summary element within an xml documentation comment.
            </summary>
            <param name="content">A list of xml node syntax that will be the content within the summary element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlSummaryElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates a summary element within an xml documentation comment.
            </summary>
            <param name="content">A list of xml node syntax that will be the content within the summary element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlSeeElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax)">
            <summary>
            Creates a see element within an xml documentation comment.
            </summary>
            <param name="cref">A cref syntax node that points to the referenced item (e.g. a class, struct).</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlSeeAlsoElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax)">
            <summary>
            Creates a seealso element within an xml documentation comment.
            </summary>
            <param name="cref">A cref syntax node that points to the referenced item (e.g. a class, struct).</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlSeeAlsoElement(System.Uri,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates a seealso element within an xml documentation comment.
            </summary>
            <param name="linkAddress">The uri of the referenced item.</param>
            <param name="linkText">A list of xml node syntax that will be used as the link text for the referenced item.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlThreadSafetyElement">
            <summary>
            Creates a threadsafety element within an xml documentation comment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlThreadSafetyElement(System.Boolean,System.Boolean)">
            <summary>
            Creates a threadsafety element within an xml documentation comment.
            </summary>
            <param name="isStatic">Indicates whether static member of this type are safe for multi-threaded operations.</param>
            <param name="isInstance">Indicates whether instance members of this type are safe for multi-threaded operations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlNameAttribute(System.String)">
            <summary>
            Creates a syntax node for a name attribute in a xml element within a xml documentation comment.
            </summary>
            <param name="parameterName">The value of the name attribute.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlPreliminaryElement">
            <summary>
            Creates a syntax node for a preliminary element within a xml documentation comment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax)">
            <summary>
            Creates a syntax node for a cref attribute within a xml documentation comment.
            </summary>
            <param name="cref">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax"/> used for the xml cref attribute syntax.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Creates a syntax node for a cref attribute within a xml documentation comment.
            </summary>
            <param name="cref">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax"/> used for the xml cref attribute syntax.</param>
            <param name="quoteKind">The kind of the quote for the referenced item in the cref attribute.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlRemarksElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[])">
            <summary>
            Creates a remarks element within an xml documentation comment.
            </summary>
            <param name="content">A list of xml node syntax that will be the content within the remarks element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlRemarksElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates a remarks element within an xml documentation comment.
            </summary>
            <param name="content">A list of xml node syntax that will be the content within the remarks element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlReturnsElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[])">
            <summary>
            Creates a returns element within an xml documentation comment.
            </summary>
            <param name="content">A list of xml node syntax that will be the content within the returns element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlReturnsElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates a returns element within an xml documentation comment.
            </summary>
            <param name="content">A list of xml node syntax that will be the content within the returns element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlValueElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[])">
            <summary>
            Creates the syntax representation of an xml value element (e.g. for xml documentation comments).
            </summary>
            <param name="content">A list of xml syntax nodes that represents the content of the value element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlValueElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates the syntax representation of an xml value element (e.g. for xml documentation comments).
            </summary>
            <param name="content">A list of xml syntax nodes that represents the content of the value element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlExceptionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[])">
            <summary>
            Creates the syntax representation of an exception element within xml documentation comments.
            </summary>
            <param name="cref">Syntax representation of the reference to the exception type.</param>
            <param name="content">A list of syntax nodes that represents the content of the exception element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlExceptionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates the syntax representation of an exception element within xml documentation comments.
            </summary>
            <param name="cref">Syntax representation of the reference to the exception type.</param>
            <param name="content">A list of syntax nodes that represents the content of the exception element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlPermissionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[])">
            <summary>
            Creates the syntax representation of a permission element within xml documentation comments.
            </summary>
            <param name="cref">Syntax representation of the reference to the permission type.</param>
            <param name="content">A list of syntax nodes that represents the content of the permission element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlPermissionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates the syntax representation of a permission element within xml documentation comments.
            </summary>
            <param name="cref">Syntax representation of the reference to the permission type.</param>
            <param name="content">A list of syntax nodes that represents the content of the permission element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlExampleElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[])">
            <summary>
            Creates the syntax representation of an example element within xml documentation comments.
            </summary>
            <param name="content">A list of syntax nodes that represents the content of the example element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlExampleElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates the syntax representation of an example element within xml documentation comments.
            </summary>
            <param name="content">A list of syntax nodes that represents the content of the example element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlParaElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[])">
            <summary>
            Creates the syntax representation of a para element within xml documentation comments.
            </summary>
            <param name="content">A list of syntax nodes that represents the content of the para element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlParaElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates the syntax representation of a para element within xml documentation comments.
            </summary>
            <param name="content">A list of syntax nodes that represents the content of the para element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlParamElement(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[])">
            <summary>
            Creates the syntax representation of a param element within xml documentation comments (e.g. for
            documentation of method parameters).
            </summary>
            <param name="parameterName">The name of the parameter.</param>
            <param name="content">A list of syntax nodes that represents the content of the param element (e.g. 
            the description and meaning of the parameter).</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlParamElement(System.String,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates the syntax representation of a param element within xml documentation comments (e.g. for
            documentation of method parameters).
            </summary>
            <param name="parameterName">The name of the parameter.</param>
            <param name="content">A list of syntax nodes that represents the content of the param element (e.g. 
            the description and meaning of the parameter).</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlParamRefElement(System.String)">
            <summary>
            Creates the syntax representation of a paramref element within xml documentation comments (e.g. for
            referencing particular parameters of a method).
            </summary>
            <param name="parameterName">The name of the referenced parameter.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlNullKeywordElement">
            <summary>
            Creates the syntax representation of a see element within xml documentation comments,
            that points to the 'null' language keyword.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlKeywordElement(System.String)">
            <summary>
            Creates the syntax representation of a see element within xml documentation comments,
            that points to a language keyword.
            </summary>
            <param name="keyword">The language keyword to which the see element points to.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlPlaceholderElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[])">
            <summary>
            Creates the syntax representation of a placeholder element within xml documentation comments.
            </summary>
            <param name="content">A list of syntax nodes that represents the content of the placeholder element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlPlaceholderElement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates the syntax representation of a placeholder element within xml documentation comments.
            </summary>
            <param name="content">A list of syntax nodes that represents the content of the placeholder element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlEmptyElement(System.String)">
            <summary>
            Creates the syntax representation of a named empty xml element within xml documentation comments.
            </summary>
            <param name="localName">The name of the empty xml element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElement(System.String,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates the syntax representation of a named xml element within xml documentation comments.
            </summary>
            <param name="localName">The name of the empty xml element.</param>
            <param name="content">A list of syntax nodes that represents the content of the xml element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates the syntax representation of a named xml element within xml documentation comments.
            </summary>
            <param name="name">The name of the empty xml element.</param>
            <param name="content">A list of syntax nodes that represents the content of the xml element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextAttribute(System.String,System.String)">
            <summary>
            Creates the syntax representation of an xml text attribute.
            </summary>
            <param name="name">The name of the xml text attribute.</param>
            <param name="value">The value of the xml text attribute.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextAttribute(System.String,Microsoft.CodeAnalysis.SyntaxToken[])">
            <summary>
            Creates the syntax representation of an xml text attribute.
            </summary>
            <param name="name">The name of the xml text attribute.</param>
            <param name="textTokens">A list of tokens used for the value of the xml text attribute.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextAttribute(System.String,Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Creates the syntax representation of an xml text attribute.
            </summary>
            <param name="name">The name of the xml text attribute.</param>
            <param name="quoteKind">The kind of the quote token to be used to quote the value (e.g. " or ').</param>
            <param name="textTokens">A list of tokens used for the value of the xml text attribute.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Creates the syntax representation of an xml text attribute.
            </summary>
            <param name="name">The name of the xml text attribute.</param>
            <param name="quoteKind">The kind of the quote token to be used to quote the value (e.g. " or ').</param>
            <param name="textTokens">A list of tokens used for the value of the xml text attribute.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlMultiLineElement(System.String,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates the syntax representation of an xml element that spans multiple text lines.
            </summary>
            <param name="localName">The name of the xml element.</param>
            <param name="content">A list of syntax nodes that represents the content of the xml multi line element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlMultiLineElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>
            Creates the syntax representation of an xml element that spans multiple text lines.
            </summary>
            <param name="name">The name of the xml element.</param>
            <param name="content">A list of syntax nodes that represents the content of the xml multi line element.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlNewLine(System.String)">
            <summary>
            Creates the syntax representation of an xml text that contains a newline token with a documentation comment 
            exterior trivia at the end (continued documentation comment).
            </summary>
            <param name="text">The raw text within the new line.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextNewLine(System.String)">
            <summary>
            Creates the syntax representation of an xml newline token with a documentation comment exterior trivia at 
            the end (continued documentation comment).
            </summary>
            <param name="text">The raw text within the new line.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextNewLine(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlTextLiteralNewLineToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml text new line value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextNewLine(System.String,System.Boolean)">
            <summary>
            Creates the syntax representation of an xml newline token for xml documentation comments.
            </summary>
            <param name="text">The raw text within the new line.</param>
            <param name="continueXmlDocumentationComment">
            If set to true, a documentation comment exterior token will be added to the trailing trivia
            of the new token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlText(System.String)">
            <summary>
            Generates the syntax representation of a xml text node (e.g. for xml documentation comments).
            </summary>
            <param name="value">The string literal used as the text of the xml text node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlText(Microsoft.CodeAnalysis.SyntaxToken[])">
            <summary>
            Generates the syntax representation of a xml text node (e.g. for xml documentation comments).
            </summary>
            <param name="textTokens">A list of text tokens used as the text of the xml text node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextLiteral(System.String)">
            <summary>
            Generates the syntax representation of an xml text literal.
            </summary>
            <param name="value">The text used within the xml text literal.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextLiteral(System.String,System.String)">
            <summary>
            Generates the syntax representation of an xml text literal.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The text used within the xml text literal.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlReplaceBracketTokens(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Helper method that replaces less-than and greater-than characters with brackets. 
            </summary>
            <param name="originalToken">The original token that is to be replaced.</param>
            <param name="rewrittenToken">The new rewritten token.</param>
            <returns>Returns the new rewritten token with replaced characters.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DocumentationCommentExterior(System.String)">
            <summary>
            Creates a trivia with kind DocumentationCommentExteriorTrivia.
            </summary>
            <param name="text">The raw text of the literal.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.List``1">
            <summary>
            Creates an empty list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SingletonList``1(``0)">
            <summary>
            Creates a singleton list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="node">The single element node.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.List``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of element nodes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TokenList">
            <summary>
            Creates an empty list of tokens.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TokenList(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a singleton list of tokens.
            </summary>
            <param name="token">The single token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TokenList(Microsoft.CodeAnalysis.SyntaxToken[])">
            <summary>
            Creates a list of tokens.
            </summary>
            <param name="tokens">An array of tokens.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TokenList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a list of tokens.
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Trivia(Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax)">
            <summary>
            Creates a trivia from a StructuredTriviaSyntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TriviaList">
            <summary>
            Creates an empty list of trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TriviaList(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a singleton list of trivia.
            </summary>
            <param name="trivia">A single trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TriviaList(Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a list of trivia.
            </summary>
            <param name="trivias">An array of trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TriviaList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a list of trivia.
            </summary>
            <param name="trivias">A sequence of trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SeparatedList``1">
            <summary>
            Creates an empty separated list.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SingletonSeparatedList``1(``0)">
            <summary>
            Creates a singleton separated list.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="node">A single node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SeparatedList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a separated list of nodes from a sequence of nodes, synthesizing comma separators in between.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of syntax nodes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SeparatedList``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of syntax nodes.</param>
            <param name="separators">A sequence of token to be interleaved between the nodes. The number of tokens must
            be one less than the number of nodes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SeparatedList``1(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Creates a separated list from a sequence of nodes and tokens, starting with a node and alternating between additional nodes and separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodesAndTokens">A sequence of nodes or tokens, alternating between nodes and separator tokens.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SeparatedList``1(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Creates a separated list from a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/>, where the list elements start with a node and then alternate between
            additional nodes and separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodesAndTokens">The list of nodes and tokens.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NodeOrTokenList">
            <summary>
            Creates an empty <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NodeOrTokenList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> from a sequence of <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodesAndTokens">The sequence of nodes and tokens</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NodeOrTokenList(Microsoft.CodeAnalysis.SyntaxNodeOrToken[])">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> from one or more <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodesAndTokens">The nodes and tokens</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)">
            <summary>
            Creates an IdentifierNameSyntax node.
            </summary>
            <param name="name">The identifier name.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SyntaxTree(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ParseOptions,System.String,System.Text.Encoding)">
            <summary>
            Create a new syntax tree from a syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(System.String,Microsoft.CodeAnalysis.ParseOptions,System.String,System.Text.Encoding,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(System.String,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Text.Encoding,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.ParseOptions,System.String,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseLeadingTrivia(System.String,System.Int32)">
            <summary>
            Parse a list of trivia rules for leading trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseLeadingTrivia(System.String,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.Int32)">
            <summary>
            Parse a list of trivia rules for leading trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseTrailingTrivia(System.String,System.Int32)">
            <summary>
            Parse a list of trivia using the parsing rules for trailing trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseToken(System.String,System.Int32)">
            <summary>
            Parse a C# language token.
            </summary>
            <param name="text">The text of the token including leading and trailing trivia.</param>
            <param name="offset">Optional offset into text.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseTokens(System.String,System.Int32,System.Int32,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions)">
            <summary>
            Parse a sequence of C# language tokens.
            Since this API does not create a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> that owns all produced tokens,
            the <see cref="M:Microsoft.CodeAnalysis.SyntaxToken.GetLocation"/> API may yield surprising results for
            the produced tokens and its behavior is generally unspecified.
            </summary>
            <param name="text">The text of all the tokens.</param>
            <param name="initialTokenPosition">An integer to use as the starting position of the first token.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">Parse options.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseName(System.String,System.Int32,System.Boolean)">
            <summary>
            Parse a NameSyntax node using the grammar rule for names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseTypeName(System.String,System.Int32,System.Boolean)">
            <summary>
            Parse a TypeNameSyntax node using the grammar rule for type names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseTypeName(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse a TypeNameSyntax node using the grammar rule for type names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseExpression(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse an ExpressionSyntax node using the lowest precedence grammar rule for expressions.
            </summary>
            <param name="text">The text of the expression.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseStatement(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse a StatementSyntaxNode using grammar rule for statements.
            </summary>
            <param name="text">The text of the statement.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseMemberDeclaration(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse a MemberDeclarationSyntax. This includes all of the kinds of members that could occur in a type declaration.
            If nothing resembling a valid member declaration is found in the input, returns null.
            </summary>
            <param name="text">The text of the declaration.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input following a declaration should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseCompilationUnit(System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions)">
            <summary>
            Parse a CompilationUnitSyntax using the grammar rule for an entire compilation unit (file). To produce a
            SyntaxTree instance, use CSharpSyntaxTree.ParseText instead.
            </summary>
            <param name="text">The text of the compilation unit.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseParameterList(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse a ParameterListSyntax node.
            </summary>
            <param name="text">The text of the parenthesized parameter list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseBracketedParameterList(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse a BracketedParameterListSyntax node.
            </summary>
            <param name="text">The text of the bracketed parameter list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseArgumentList(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse an ArgumentListSyntax node.
            </summary>
            <param name="text">The text of the parenthesized argument list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseBracketedArgumentList(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse a BracketedArgumentListSyntax node.
            </summary>
            <param name="text">The text of the bracketed argument list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseAttributeArgumentList(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse an AttributeArgumentListSyntax node.
            </summary>
            <param name="text">The text of the attribute argument list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MakeSourceText(System.String,System.Int32)">
            <summary>
            Helper method for wrapping a string in a SourceText.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="oldTree">The original tree.</param>
            <param name="newTree">The new tree.</param>
            <param name="topLevel"> 
            If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Determines if two syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldNode">The old node.</param>
            <param name="newNode">The new node.</param>
            <param name="topLevel"> 
            If true then the nodes are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Boolean})">
            <summary>
            Determines if two syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldNode">The old node.</param>
            <param name="newNode">The new node.</param>
            <param name="ignoreChildNode">
            If specified called for every child syntax node (not token) that is visited during the comparison. 
            If it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines if two syntax tokens are the same, disregarding trivia differences.
            </summary>
            <param name="oldToken">The old token.</param>
            <param name="newToken">The new token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Determines if two lists of tokens are the same, disregarding trivia differences.
            </summary>
            <param name="oldList">The old token list.</param>
            <param name="newList">The new token list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.SyntaxList{``0},System.Boolean)">
            <summary>
            Determines if two lists of syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldList">The old list.</param>
            <param name="newList">The new list.</param>
            <param name="topLevel"> 
            If true then the nodes are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.SyntaxList{``0},System.Func{Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Boolean})">
            <summary>
            Determines if two lists of syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldList">The old list.</param>
            <param name="newList">The new list.</param>
            <param name="ignoreChildNode">
            If specified called for every child syntax node (not token) that is visited during the comparison. 
            If it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},System.Boolean)">
            <summary>
            Determines if two lists of syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldList">The old list.</param>
            <param name="newList">The new list.</param>
            <param name="topLevel"> 
            If true then the nodes are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},System.Func{Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Boolean})">
            <summary>
            Determines if two lists of syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldList">The old list.</param>
            <param name="newList">The new list.</param>
            <param name="ignoreChildNode">
            If specified called for every child syntax node (not token) that is visited during the comparison. 
            If it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GetStandaloneExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Gets the containing expression that is actually a language expression and not just typed
            as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side
            of qualified names and member access expressions are not language expressions, yet the
            containing qualified names or member access expressions are indeed expressions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GetStandaloneNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Gets the containing expression that is actually a language expression (or something that
            GetSymbolInfo can be applied to) and not just typed
            as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side
            of qualified names and member access expressions are not language expressions, yet the
            containing qualified names or member access expressions are indeed expressions.
            Similarly, if the input node is a cref part that is not independently meaningful, then
            the result will be the full cref. Besides an expression, an input that is a NameSyntax
            of a SubpatternSyntax, e.g. in `name: 3` may cause this method to return the enclosing
            SubpatternSyntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FindConditionalAccessNodeForBinding(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Given a conditional binding expression, find corresponding conditional access node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GetNonGenericExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Converts a generic name expression into one without the generic arguments.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IsCompleteSubmission(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Determines whether the given text is considered a syntactically complete submission.
            Throws <see cref="T:System.ArgumentException"/> if the tree was not compiled as an interactive submission.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new CaseSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultSwitchLabel">
            <summary>Creates a new DefaultSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Block(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[])">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Block(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax})">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax"/> instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax"/> instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax})">
            <summary>Creates a new SwitchStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SwitchStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax"/> instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax"/> instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new IdentifierNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new QualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new QualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GenericName(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax)">
            <summary>Creates a new GenericNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GenericName(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new GenericNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GenericName(System.String)">
            <summary>Creates a new GenericNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeArgumentList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TypeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax})">
            <summary>Creates a new TypeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AliasQualifiedName(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PredefinedType(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PredefinedTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax})">
            <summary>Creates a new ArrayTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new ArrayTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayRankSpecifier(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayRankSpecifier(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax})">
            <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PointerType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PointerTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PointerType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new PointerTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerType(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax)">
            <summary>Creates a new FunctionPointerTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax)">
            <summary>Creates a new FunctionPointerTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerType">
            <summary>Creates a new FunctionPointerTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new FunctionPointerParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax})">
            <summary>Creates a new FunctionPointerParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerCallingConvention(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax)">
            <summary>Creates a new FunctionPointerCallingConventionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerCallingConvention(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new FunctionPointerCallingConventionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerUnmanagedCallingConventionList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new FunctionPointerUnmanagedCallingConventionListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerUnmanagedCallingConventionList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax})">
            <summary>Creates a new FunctionPointerUnmanagedCallingConventionListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerUnmanagedCallingConvention(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new FunctionPointerUnmanagedCallingConventionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NullableType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new NullableTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NullableType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new NullableTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TupleType(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TupleTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TupleType(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax})">
            <summary>Creates a new TupleTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TupleElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new TupleElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OmittedTypeArgument(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OmittedTypeArgument">
            <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefType(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new RefTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new RefTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ScopedType(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new ScopedTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ScopedType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new ScopedTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TupleExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TupleExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TupleExpression(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax})">
            <summary>Creates a new TupleExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AwaitExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AwaitExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AwaitExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MemberAccessExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MemberAccessExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ConditionalAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ConditionalAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MemberBindingExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new MemberBindingExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new MemberBindingExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax)">
            <summary>Creates a new ElementBindingExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElementBindingExpression">
            <summary>Creates a new ElementBindingExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RangeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new RangeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RangeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new RangeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RangeExpression">
            <summary>Creates a new RangeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax)">
            <summary>Creates a new ImplicitElementAccessSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitElementAccess">
            <summary>Creates a new ImplicitElementAccessSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new BinaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new BinaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AssignmentExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AssignmentExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ThisExpression(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ThisExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ThisExpression">
            <summary>Creates a new ThisExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BaseExpression(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new BaseExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BaseExpression">
            <summary>Creates a new BaseExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new LiteralExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MakeRefExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefTypeExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefValueExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new RefValueExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new RefValueExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CheckedExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CheckedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CheckedExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new CheckedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DefaultExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new DefaultExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeOfExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SizeOfExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax)">
            <summary>Creates a new InvocationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new InvocationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax)">
            <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArgumentList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax})">
            <summary>Creates a new ArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BracketedArgumentList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BracketedArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax})">
            <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Argument(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Argument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExpressionColon(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ExpressionColonSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameColon(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new NameColonSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax)">
            <summary>Creates a new DeclarationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CastExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new CastExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new CastExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousMethodExpression(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SimpleLambdaExpression(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SimpleLambdaExpression(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax)">
            <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new RefExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new RefExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedLambdaExpression">
            <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InitializerExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InitializerExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InitializerExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax})">
            <summary>Creates a new InitializerExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitObjectCreationExpression">
            <summary>Creates a new ImplicitObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new WithExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new WithExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax})">
            <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax)">
            <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StackAllocArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitStackAllocArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitStackAllocArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Creates a new QueryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryBody(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax)">
            <summary>Creates a new QueryBodySyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax)">
            <summary>Creates a new QueryBodySyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FromClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FromClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FromClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FromClause(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LetClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new LetClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LetClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new LetClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LetClause(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new LetClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinClause(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinIntoClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinIntoClause(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinIntoClause(System.String)">
            <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WhereClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new WhereClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new WhereClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OrderByClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax})">
            <summary>Creates a new OrderByClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OrderByClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax})">
            <summary>Creates a new OrderByClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Ordering(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OrderingSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Ordering(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new OrderingSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SelectClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SelectClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SelectClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GroupClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new GroupClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new GroupClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryContinuation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Creates a new QueryContinuationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryContinuation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Creates a new QueryContinuationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryContinuation(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Creates a new QueryContinuationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OmittedArraySizeExpression(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OmittedArraySizeExpression">
            <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax)">
            <summary>Creates a new IsPatternExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax)">
            <summary>Creates a new IsPatternExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ThrowExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ThrowExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ThrowExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ThrowExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WhenClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new WhenClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new WhenClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DiscardPattern(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DiscardPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DiscardPattern">
            <summary>Creates a new DiscardPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax)">
            <summary>Creates a new DeclarationPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VarPattern(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax)">
            <summary>Creates a new VarPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VarPattern(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax)">
            <summary>Creates a new VarPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RecursivePattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax)">
            <summary>Creates a new RecursivePatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RecursivePattern">
            <summary>Creates a new RecursivePatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PositionalPatternClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PositionalPatternClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PositionalPatternClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax})">
            <summary>Creates a new PositionalPatternClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PropertyPatternClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PropertyPatternClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PropertyPatternClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax})">
            <summary>Creates a new PropertyPatternClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Subpattern(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionColonSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax)">
            <summary>Creates a new SubpatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Subpattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax)">
            <summary>Creates a new SubpatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstantPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ConstantPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedPattern(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ParenthesizedPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax)">
            <summary>Creates a new ParenthesizedPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RelationalPattern(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new RelationalPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypePattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new TypePatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BinaryPattern(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax)">
            <summary>Creates a new BinaryPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BinaryPattern(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax)">
            <summary>Creates a new BinaryPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UnaryPattern(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax)">
            <summary>Creates a new UnaryPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UnaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax)">
            <summary>Creates a new UnaryPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ListPattern(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax)">
            <summary>Creates a new ListPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ListPattern(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax)">
            <summary>Creates a new ListPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ListPattern(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax})">
            <summary>Creates a new ListPatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SlicePattern(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax)">
            <summary>Creates a new SlicePatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SlicePattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax)">
            <summary>Creates a new SlicePatternSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolatedStringText(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolatedStringTextSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolatedStringText">
            <summary>Creates a new InterpolatedStringTextSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Interpolation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Interpolation(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax)">
            <summary>Creates a new InterpolationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Interpolation(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new InterpolationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolationAlignmentClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new InterpolationAlignmentClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolationFormatClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolationFormatClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolationFormatClause(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolationFormatClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GlobalStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new GlobalStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new GlobalStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Block(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Block(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax})">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Block(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax})">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LocalFunctionStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LocalFunctionStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.String)">
            <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax})">
            <summary>Creates a new VariableDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new VariableDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VariableDeclarator(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VariableDeclarator(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VariableDeclarator(System.String)">
            <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EqualsValueClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SingleVariableDesignation(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new SingleVariableDesignationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DiscardDesignation(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DiscardDesignationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DiscardDesignation">
            <summary>Creates a new DiscardDesignationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedVariableDesignation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ParenthesizedVariableDesignationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedVariableDesignation(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax})">
            <summary>Creates a new ParenthesizedVariableDesignationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExpressionStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ExpressionStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExpressionStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ExpressionStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ExpressionStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EmptyStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EmptyStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EmptyStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax})">
            <summary>Creates a new EmptyStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EmptyStatement">
            <summary>Creates a new EmptyStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LabeledStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LabeledStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LabeledStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LabeledStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LabeledStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LabeledStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LabeledStatement(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LabeledStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new GotoStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new GotoStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new GotoStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BreakStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new BreakStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BreakStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax})">
            <summary>Creates a new BreakStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BreakStatement">
            <summary>Creates a new BreakStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ContinueStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ContinueStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ContinueStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax})">
            <summary>Creates a new ContinueStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ContinueStatement">
            <summary>Creates a new ContinueStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ReturnStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ReturnStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ReturnStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ReturnStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ReturnStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ThrowStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ThrowStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ThrowStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ThrowStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ThrowStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.YieldStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new YieldStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.YieldStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new YieldStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.YieldStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new YieldStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WhileStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new WhileStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WhileStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new WhileStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new WhileStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DoStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DoStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DoStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new DoStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new DoStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForEachStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForEachStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForEachStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForEachStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForEachStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.String,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForEachStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForEachVariableStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForEachVariableStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForEachVariableStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForEachVariableStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForEachVariableStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForEachVariableStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new UsingStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new UsingStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new UsingStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FixedStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new FixedStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FixedStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new FixedStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new FixedStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CheckedStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new CheckedStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CheckedStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new CheckedStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CheckedStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new CheckedStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UnsafeStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new UnsafeStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UnsafeStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new UnsafeStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new UnsafeStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LockStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LockStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LockStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LockStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LockStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IfStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax)">
            <summary>Creates a new IfStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IfStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax)">
            <summary>Creates a new IfStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new IfStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElseClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ElseClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ElseClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new SwitchStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchSection(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax})">
            <summary>Creates a new SwitchSectionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchSection">
            <summary>Creates a new SwitchSectionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CasePatternSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CasePatternSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CasePatternSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CasePatternSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CaseSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CaseSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CaseSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DefaultSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DefaultSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new SwitchExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax})">
            <summary>Creates a new SwitchExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SwitchExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchExpressionArm(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SwitchExpressionArmSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchExpressionArm(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SwitchExpressionArmSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchExpressionArm(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SwitchExpressionArmSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TryStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax)">
            <summary>Creates a new TryStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TryStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax)">
            <summary>Creates a new TryStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TryStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax})">
            <summary>Creates a new TryStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new CatchClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new CatchClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchClause">
            <summary>Creates a new CatchClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchDeclaration(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CatchDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CatchDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new CatchDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchFilterClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CatchFilterClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new CatchFilterClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FinallyClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new FinallyClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new FinallyClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CompilationUnit(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CompilationUnitSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CompilationUnit(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new CompilationUnitSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CompilationUnit">
            <summary>Creates a new CompilationUnitSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExternAliasDirective(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExternAliasDirective(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExternAliasDirective(System.String)">
            <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingDirective(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingDirective(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FileScopedNamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new FileScopedNamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FileScopedNamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new FileScopedNamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FileScopedNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new FileScopedNamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AttributeListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax})">
            <summary>Creates a new AttributeListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax})">
            <summary>Creates a new AttributeListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeTargetSpecifier(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeTargetSpecifier(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Attribute(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax)">
            <summary>Creates a new AttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Attribute(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new AttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeArgumentList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax})">
            <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AttributeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AttributeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new NameEqualsSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)">
            <summary>Creates a new NameEqualsSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameEquals(System.String)">
            <summary>Creates a new NameEqualsSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TypeParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax})">
            <summary>Creates a new TypeParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameter(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TypeParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameter(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TypeParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameter(System.String)">
            <summary>Creates a new TypeParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassDeclaration(System.String)">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StructDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StructDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StructDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StructDeclaration(System.String)">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterfaceDeclaration(System.String)">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RecordDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new RecordDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RecordDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new RecordDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RecordDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new RecordDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RecordDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,System.String)">
            <summary>Creates a new RecordDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax})">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumDeclaration(System.String)">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DelegateDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DelegateDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax})">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.String)">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumMemberDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumMemberDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumMemberDeclaration(System.String)">
            <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BaseList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax})">
            <summary>Creates a new BaseListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BaseList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax})">
            <summary>Creates a new BaseListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new SimpleBaseTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PrimaryConstructorBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax)">
            <summary>Creates a new PrimaryConstructorBaseTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PrimaryConstructorBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new PrimaryConstructorBaseTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterConstraintClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax})">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax})">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterConstraintClause(System.String)">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorConstraint(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorConstraint">
            <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new TypeConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultConstraint(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DefaultConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultConstraint">
            <summary>Creates a new DefaultConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FieldDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new FieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FieldDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new FieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new FieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventFieldDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventFieldDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MethodDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MethodDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.String)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorDeclaration(System.String)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorInitializer(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax)">
            <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorInitializer(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax)">
            <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DestructorDeclaration(System.String)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PropertyDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PropertyDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.String)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrowExpressionClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ArrowExpressionClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ArrowExpressionClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.String)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IndexerDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IndexerDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AccessorList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AccessorListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AccessorList(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax})">
            <summary>Creates a new AccessorListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax})">
            <summary>Creates a new ParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BracketedParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new BracketedParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BracketedParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax})">
            <summary>Creates a new BracketedParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Parameter(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Creates a new ParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Parameter(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerParameter(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new FunctionPointerParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FunctionPointerParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new FunctionPointerParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IncompleteMember(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new IncompleteMemberSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new IncompleteMemberSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SkippedTokensTrivia(Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SkippedTokensTrivia">
            <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DocumentationCommentTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>Creates a new DocumentationCommentTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new TypeCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax)">
            <summary>Creates a new QualifiedCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax)">
            <summary>Creates a new QualifiedCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new NameMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new NameMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IndexerMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax)">
            <summary>Creates a new IndexerMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax)">
            <summary>Creates a new IndexerMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CrefParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax})">
            <summary>Creates a new CrefParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefBracketedParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CrefBracketedParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefBracketedParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax})">
            <summary>Creates a new CrefBracketedParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefParameter(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new CrefParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new CrefParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax)">
            <summary>Creates a new XmlElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax)">
            <summary>Creates a new XmlElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElementStartTag(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax})">
            <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElementEndTag(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlEmptyElement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax})">
            <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlName(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlName(System.String)">
            <summary>Creates a new XmlNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlPrefix(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlPrefixSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlPrefix(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlPrefixSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlPrefix(System.String)">
            <summary>Creates a new XmlPrefixSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlCrefAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlCrefAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,System.String,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlText(Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>Creates a new XmlTextSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlText">
            <summary>Creates a new XmlTextSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlCDataSection(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlCDataSection(Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlProcessingInstruction(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlComment(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlCommentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlComment(Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>Creates a new XmlCommentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new IfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new IfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElifDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new ElifDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new ElifDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElseDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean,System.Boolean)">
            <summary>Creates a new ElseDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElseDirectiveTrivia(System.Boolean,System.Boolean)">
            <summary>Creates a new ElseDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EndIfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new EndIfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EndIfDirectiveTrivia(System.Boolean)">
            <summary>Creates a new EndIfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RegionDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new RegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RegionDirectiveTrivia(System.Boolean)">
            <summary>Creates a new RegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EndRegionDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new EndRegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EndRegionDirectiveTrivia(System.Boolean)">
            <summary>Creates a new EndRegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ErrorDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new ErrorDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ErrorDirectiveTrivia(System.Boolean)">
            <summary>Creates a new ErrorDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new WarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WarningDirectiveTrivia(System.Boolean)">
            <summary>Creates a new WarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new BadDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new BadDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefineDirectiveTrivia(System.String,System.Boolean)">
            <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UndefDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UndefDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UndefDirectiveTrivia(System.String,System.Boolean)">
            <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineDirectivePosition(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new LineDirectivePositionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineDirectivePosition(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new LineDirectivePositionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineSpanDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineSpanDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineSpanDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineSpanDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineSpanDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineSpanDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},System.Boolean)">
            <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaChecksumDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaChecksumDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ReferenceDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new ReferenceDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ReferenceDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new ReferenceDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LoadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new LoadDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LoadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new LoadDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ShebangDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new ShebangDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ShebangDirectiveTrivia(System.Boolean)">
            <summary>Creates a new ShebangDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NullableDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new NullableDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NullableDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new NullableDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NullableDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new NullableDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode">
            <summary>
            Represents a non-terminal node in the syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.#ctor(Microsoft.CodeAnalysis.GreenNode,System.Int32,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Used by structured trivia which has "parent == null", and therefore must know its
            SyntaxTree explicitly when created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree">
            <summary>
            Returns a non-null <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree"/> that owns this node.
            If this node was created with an explicit non-null <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree"/>, returns that tree.
            Otherwise, if this node has a non-null parent, then returns the parent's <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree"/>.
            Otherwise, returns a newly created <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree"/> rooted at this node, preserving this node's reference identity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.Parent">
            <summary>
            The node that contains this node in its Children collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.Kind">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> of the node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.Language">
            <summary>
            The language name that this node is syntax of.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetLeadingTrivia">
            <summary>
            The list of trivia that appears before this node in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetTrailingTrivia">
            <summary>
            The list of trivia that appears after this node in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.DeserializeFrom(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Deserialize a syntax node from the byte stream.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetLocation">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Location"/> for this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetReference">
            <summary>
            Gets a SyntaxReference for this syntax node. SyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has this node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetFirstDirective(System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})">
            <summary>
            Gets the first directive of the tree rooted by this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetLastDirective(System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})">
            <summary>
            Gets the last directive of the tree rooted by this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the first token of the tree rooted by this node.
            </summary>
            <param name="includeZeroWidth">True if zero width tokens should be included, false by
            default.</param>
            <param name="includeSkipped">True if skipped tokens should be included, false by default.</param>
            <param name="includeDirectives">True if directives should be included, false by default.</param>
            <param name="includeDocumentationComments">True if documentation comments should be
            included, false by default.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetFirstToken(System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Gets the first token of the tree rooted by this node.
            </summary>
            <param name="predicate">Only tokens for which this predicate returns true are included.  Pass null to include
            all tokens.</param>
            <param name="stepInto">Steps into trivia if this is not null.  Only trivia for which this delegate returns
            true are included.</param> 
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the last non-zero-width token of the tree rooted by this node.
            </summary>
            <param name="includeZeroWidth">True if zero width tokens should be included, false by
            default.</param>
            <param name="includeSkipped">True if skipped tokens should be included, false by default.</param>
            <param name="includeDirectives">True if directives should be included, false by default.</param>
            <param name="includeDocumentationComments">True if documentation comments should be
            included, false by default.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.FindToken(System.Int32,System.Boolean)">
            <summary>
            Finds a token according to the following rules:
            1) If position matches the End of the node/s FullSpan and the node is CompilationUnit,
               then EoF is returned. 
            
             2) If node.FullSpan.Contains(position) then the token that contains given position is
                returned.
            
             3) Otherwise an ArgumentOutOfRangeException is thrown
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.FindTokenIncludingCrefAndNameAttributes(System.Int32)">
            <summary>
            Finds a token according to the following rules:
            1) If position matches the End of the node/s FullSpan and the node is CompilationUnit,
               then EoF is returned. 
            
             2) If node.FullSpan.Contains(position) then the token that contains given position is
                returned.
            
             3) Otherwise an ArgumentOutOfRangeException is thrown
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.FindTrivia(System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Finds a descendant trivia of this node at the specified position, where the position is
            within the span of the node.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of
            the file.</param>
            <param name="stepInto">Specifies a function that determines per trivia node, whether to
            descend into structured trivia of that node.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.FindTrivia(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of
            the file.</param>
            <param name="findInsideTrivia">Whether to search inside structured trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.EquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine if this node is structurally equivalent to another.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1"/> which descends an entire <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> graph and
            may replace or remove visited SyntaxNodes in depth-first order.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree">
            <summary>
            The parsed representation of a C# source document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree._preprocessorStateChangePositions">
            <summary>
            Stores positions where preprocessor state changes. Sorted by position.
            The updated state can be found in <see cref="F:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree._preprocessorStates"/> array at the same index.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree._preprocessorStates">
            <summary>
            Preprocessor states corresponding to positions in <see cref="F:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree._preprocessorStateChangePositions"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.Options">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.CloneNodeAsRoot``1(``0)">
             <summary>
             Produces a clone of a <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> which will have current syntax tree as its parent.
            
             Caller must guarantee that if the same instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> makes multiple calls
             to this function, only one result is observable.
             </summary>
             <typeparam name="T">Type of the syntax node.</typeparam>
             <param name="node">The original syntax node.</param>
             <returns>A clone of the original syntax node that has current <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree"/> as its parent.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetRoot(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.TryGetRoot(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode@)">
            <summary>
            Gets the root node of the syntax tree if it is already available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetRootAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
            <remarks>
            By default, the work associated with this method will be executed immediately on the current thread.
            Implementations that wish to schedule this work differently should override <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetRootAsync(System.Threading.CancellationToken)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetCompilationUnitRoot(System.Threading.CancellationToken)">
            <summary>
            Gets the root of the syntax tree statically typed as <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax"/>.
            </summary>
            <remarks>
            Ensure that <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot"/> is true for this tree prior to invoking this method.
            </remarks>
            <exception cref="T:System.InvalidCastException">Throws this exception if <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot"/> is false.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="tree">The tree to compare against.</param>
            <param name="topLevel">
            If true then the trees are equivalent if the contained nodes and tokens declaring metadata visible symbolic information are equivalent,
            ignoring any differences of nodes inside method bodies or initializer expressions, otherwise all nodes and tokens must be equivalent.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.Create(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Text.Encoding)">
            <summary>
            Creates a new syntax tree from a syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.Create(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Text.Encoding,System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic},System.Nullable{System.Boolean})">
            <summary>
            Creates a new syntax tree from a syntax node.
            </summary>
            <param name="diagnosticOptions">An obsolete parameter. Diagnostic options should now be passed with <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.SyntaxTreeOptionsProvider"/></param>
            <param name="isGeneratedCode">An obsolete parameter. It is unused.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.CreateForDebugger(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions)">
            <summary>
            Creates a new syntax tree from a syntax node with text that should correspond to the syntax node.
            </summary>
            <remarks>This is used by the ExpressionEvaluator.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.CreateWithoutClone(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            <para>
            Internal helper for <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> class to create a new syntax tree rooted at the given root node.
            This method does not create a clone of the given root, but instead preserves it's reference identity.
            </para>
            <para>NOTE: This method is only intended to be used from <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree"/> property.</para>
            <para>NOTE: Do not use this method elsewhere, instead use <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.Create(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Text.Encoding)"/> method for creating a syntax tree.</para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseTextLazy(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String)">
            <summary>
            Produces a syntax tree by parsing the source text lazily. The syntax tree is realized when
            <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetRoot(System.Threading.CancellationToken)"/> is called.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(System.String,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(System.String,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Text.Encoding,System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic},System.Nullable{System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
            <param name="diagnosticOptions">An obsolete parameter. Diagnostic options should now be passed with <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.SyntaxTreeOptionsProvider"/></param>
            <param name="isGeneratedCode">An obsolete parameter. It is unused.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic},System.Nullable{System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
            <param name="diagnosticOptions">An obsolete parameter. Diagnostic options should now be passed with <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.SyntaxTreeOptionsProvider"/></param>
            <param name="isGeneratedCode">An obsolete parameter. It is unused.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new syntax based off this tree using a new source text.
            </summary>
            <remarks>
            If the new source text is a minor change from the current source text an incremental parse will occur
            reusing most of the current syntax tree internal data.  Otherwise, a full parse will occur using the new
            source text.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Produces a pessimistic list of spans that denote the regions of text in this tree that
            are changed from the text of the old tree.
            </summary>
            <param name="oldTree">The old tree. Cannot be <c>null</c>.</param>
            <remarks>The list is pessimistic because it may claim more or larger regions than actually changed.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetChanges(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets a list of text changes that when applied to the old tree produce this tree.
            </summary>
            <param name="oldTree">The old tree. Cannot be <c>null</c>.</param>
            <remarks>The list of changes may be different than the original changes that produced this tree.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Gets the location in terms of path, line and column for a given span.
            </summary>
            <param name="span">Span within the tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.
            </returns>
            <remarks>The values are not affected by line mapping directives (<c>#line</c>).</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Gets the location in terms of path, line and column after applying source line mapping directives (<c>#line</c>).
            </summary>
            <param name="span">Span within the tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>
            <para>A valid <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.</para>
            <para>
            If the location path is mapped the resulting path is the path specified in the corresponding <c>#line</c>,
            otherwise it's <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath"/>.
            </para>
            <para>
            A location path is considered mapped if the first <c>#line</c> directive that precedes it and that
            either specifies an explicit file path or is <c>#line default</c> exists and specifies an explicit path.
            </para>
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetLineVisibility(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetLineMappings(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetMappedLineSpanAndVisibility(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean@)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> for a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>. FileLinePositionSpans are used
            primarily for diagnostics and source locations.
            </summary>
            <param name="span">The source <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan" /> to convert.</param>
            <param name="isHiddenPosition">When the method returns, contains a boolean value indicating whether this span is considered hidden or not.</param>
            <returns>A resulting <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.HasHiddenRegions">
            <summary>
            Gets a boolean value indicating whether there are any hidden regions in the tree.
            </summary>
            <returns>True if there is at least one hidden region.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetPragmaDirectiveWarningState(System.String,System.Int32)">
            <summary>
            Given the error code and the source location, get the warning state based on <c>#pragma warning</c> directives.
            </summary>
            <param name="id">Error code.</param>
            <param name="position">Source location.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetLocation(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Location"/> for the specified text <paramref name="span"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
            </summary>
            <remarks>
            This method does not filter diagnostics based on <c>#pragma</c>s and compiler options
            like /nowarn, /warnaserror etc.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets a list of all the diagnostics associated with the token and any related trivia.
            </summary>
            <remarks>
            This method does not filter diagnostics based on <c>#pragma</c>s and compiler options
            like /nowarn, /warnaserror etc.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Gets a list of all the diagnostics associated with the trivia.
            </summary>
            <remarks>
            This method does not filter diagnostics based on <c>#pragma</c>s and compiler options
            like /nowarn, /warnaserror etc.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
            associated with the token and its related trivia.
            </summary>
            <remarks>
            This method does not filter diagnostics based on <c>#pragma</c>s and compiler options
            like /nowarn, /warnaserror etc.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets a list of all the diagnostics in the syntax tree.
            </summary>
            <remarks>
            This method does not filter diagnostics based on <c>#pragma</c>s and compiler options
            like /nowarn, /warnaserror etc.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> visitor that visits only the single CSharpSyntaxNode
            passed into its Visit method and produces 
            a value of the type specified by the <typeparamref name="TResult"/> parameter.
            </summary>
            <typeparam name="TResult">
            The type of the return value this visitor's Visit method.
            </typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)">
            <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax)">
            <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitGenericName(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax)">
            <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax)">
            <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax)">
            <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPredefinedType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax)">
            <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax)">
            <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArrayRankSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax)">
            <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax)">
            <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFunctionPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax)">
            <summary>Called when the visitor visits a FunctionPointerTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFunctionPointerParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax)">
            <summary>Called when the visitor visits a FunctionPointerParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFunctionPointerCallingConvention(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax)">
            <summary>Called when the visitor visits a FunctionPointerCallingConventionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFunctionPointerUnmanagedCallingConventionList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax)">
            <summary>Called when the visitor visits a FunctionPointerUnmanagedCallingConventionListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFunctionPointerUnmanagedCallingConvention(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax)">
            <summary>Called when the visitor visits a FunctionPointerUnmanagedCallingConventionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitNullableType(Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax)">
            <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTupleType(Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax)">
            <summary>Called when the visitor visits a TupleTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax)">
            <summary>Called when the visitor visits a TupleElementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOmittedTypeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax)">
            <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRefType(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax)">
            <summary>Called when the visitor visits a RefTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitScopedType(Microsoft.CodeAnalysis.CSharp.Syntax.ScopedTypeSyntax)">
            <summary>Called when the visitor visits a ScopedTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTupleExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax)">
            <summary>Called when the visitor visits a TupleExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)">
            <summary>Called when the visitor visits a AwaitExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitMemberAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax)">
            <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitMemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax)">
            <summary>Called when the visitor visits a MemberBindingExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax)">
            <summary>Called when the visitor visits a ElementBindingExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRangeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax)">
            <summary>Called when the visitor visits a RangeExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax)">
            <summary>Called when the visitor visits a ImplicitElementAccessSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBinaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax)">
            <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax)">
            <summary>Called when the visitor visits a AssignmentExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitThisExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax)">
            <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBaseExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax)">
            <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLiteralExpression(Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax)">
            <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitMakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax)">
            <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax)">
            <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax)">
            <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCheckedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax)">
            <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax)">
            <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax)">
            <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax)">
            <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax)">
            <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax)">
            <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBracketedArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax)">
            <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax)">
            <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitExpressionColon(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionColonSyntax)">
            <summary>Called when the visitor visits a ExpressionColonSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax)">
            <summary>Called when the visitor visits a NameColonSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax)">
            <summary>Called when the visitor visits a DeclarationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax)">
            <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax)">
            <summary>Called when the visitor visits a RefExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInitializerExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitImplicitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitWithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax)">
            <summary>Called when the visitor visits a WithExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAnonymousObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitImplicitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitStackAllocArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax)">
            <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitQueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax)">
            <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLetClause(Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax)">
            <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitJoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax)">
            <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitJoinIntoClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax)">
            <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitWhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax)">
            <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOrderByClause(Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax)">
            <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOrdering(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax)">
            <summary>Called when the visitor visits a OrderingSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax)">
            <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitGroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax)">
            <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitQueryContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax)">
            <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOmittedArraySizeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax)">
            <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterpolatedStringExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax)">
            <summary>Called when the visitor visits a InterpolatedStringExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax)">
            <summary>Called when the visitor visits a IsPatternExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitThrowExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax)">
            <summary>Called when the visitor visits a ThrowExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitWhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax)">
            <summary>Called when the visitor visits a WhenClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDiscardPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardPatternSyntax)">
            <summary>Called when the visitor visits a DiscardPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax)">
            <summary>Called when the visitor visits a DeclarationPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitVarPattern(Microsoft.CodeAnalysis.CSharp.Syntax.VarPatternSyntax)">
            <summary>Called when the visitor visits a VarPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRecursivePattern(Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax)">
            <summary>Called when the visitor visits a RecursivePatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPositionalPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax)">
            <summary>Called when the visitor visits a PositionalPatternClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPropertyPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax)">
            <summary>Called when the visitor visits a PropertyPatternClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSubpattern(Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax)">
            <summary>Called when the visitor visits a SubpatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConstantPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax)">
            <summary>Called when the visitor visits a ConstantPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitParenthesizedPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax)">
            <summary>Called when the visitor visits a ParenthesizedPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRelationalPattern(Microsoft.CodeAnalysis.CSharp.Syntax.RelationalPatternSyntax)">
            <summary>Called when the visitor visits a RelationalPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypePattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypePatternSyntax)">
            <summary>Called when the visitor visits a TypePatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBinaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax)">
            <summary>Called when the visitor visits a BinaryPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitUnaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.UnaryPatternSyntax)">
            <summary>Called when the visitor visits a UnaryPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitListPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ListPatternSyntax)">
            <summary>Called when the visitor visits a ListPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSlicePattern(Microsoft.CodeAnalysis.CSharp.Syntax.SlicePatternSyntax)">
            <summary>Called when the visitor visits a SlicePatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterpolatedStringText(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax)">
            <summary>Called when the visitor visits a InterpolatedStringTextSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterpolation(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax)">
            <summary>Called when the visitor visits a InterpolationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterpolationAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax)">
            <summary>Called when the visitor visits a InterpolationAlignmentClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterpolationFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax)">
            <summary>Called when the visitor visits a InterpolationFormatClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitGlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax)">
            <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Called when the visitor visits a BlockSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax)">
            <summary>Called when the visitor visits a LocalFunctionStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)">
            <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitVariableDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax)">
            <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSingleVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax)">
            <summary>Called when the visitor visits a SingleVariableDesignationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDiscardDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax)">
            <summary>Called when the visitor visits a DiscardDesignationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitParenthesizedVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax)">
            <summary>Called when the visitor visits a ParenthesizedVariableDesignationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax)">
            <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEmptyStatement(Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax)">
            <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLabeledStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax)">
            <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitGotoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax)">
            <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBreakStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax)">
            <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitContinueStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax)">
            <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax)">
            <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax)">
            <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitYieldStatement(Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax)">
            <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitWhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax)">
            <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax)">
            <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax)">
            <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)">
            <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitForEachVariableStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax)">
            <summary>Called when the visitor visits a ForEachVariableStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax)">
            <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax)">
            <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCheckedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax)">
            <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitUnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax)">
            <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax)">
            <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax)">
            <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax)">
            <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax)">
            <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSwitchSection(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax)">
            <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax)">
            <summary>Called when the visitor visits a CasePatternSwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax)">
            <summary>Called when the visitor visits a CaseSwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDefaultSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax)">
            <summary>Called when the visitor visits a DefaultSwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSwitchExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax)">
            <summary>Called when the visitor visits a SwitchExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSwitchExpressionArm(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax)">
            <summary>Called when the visitor visits a SwitchExpressionArmSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax)">
            <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax)">
            <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax)">
            <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax)">
            <summary>Called when the visitor visits a CatchFilterClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax)">
            <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCompilationUnit(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax)">
            <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitExternAliasDirective(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax)">
            <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)">
            <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax)">
            <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFileScopedNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax)">
            <summary>Called when the visitor visits a FileScopedNamespaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax)">
            <summary>Called when the visitor visits a AttributeListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax)">
            <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>Called when the visitor visits a AttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAttributeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax)">
            <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax)">
            <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax)">
            <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax)">
            <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax)">
            <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterfaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax)">
            <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRecordDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax)">
            <summary>Called when the visitor visits a RecordDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEnumDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax)">
            <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEnumMemberDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax)">
            <summary>Called when the visitor visits a BaseListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax)">
            <summary>Called when the visitor visits a SimpleBaseTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPrimaryConstructorBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax)">
            <summary>Called when the visitor visits a PrimaryConstructorBaseTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax)">
            <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConstructorConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax)">
            <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax)">
            <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax)">
            <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDefaultConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultConstraintSyntax)">
            <summary>Called when the visitor visits a DefaultConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax)">
            <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax)">
            <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax)">
            <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitMethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax)">
            <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConversionOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConstructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)">
            <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDestructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax)">
            <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)">
            <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Called when the visitor visits a ArrowExpressionClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax)">
            <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax)">
            <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)">
            <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax)">
            <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax)">
            <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax)">
            <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax)">
            <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFunctionPointerParameter(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax)">
            <summary>Called when the visitor visits a FunctionPointerParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax)">
            <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSkippedTokensTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax)">
            <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax)">
            <summary>Called when the visitor visits a DocumentationCommentTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax)">
            <summary>Called when the visitor visits a TypeCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitQualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax)">
            <summary>Called when the visitor visits a QualifiedCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitNameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax)">
            <summary>Called when the visitor visits a NameMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax)">
            <summary>Called when the visitor visits a IndexerMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax)">
            <summary>Called when the visitor visits a OperatorMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCrefParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Called when the visitor visits a CrefParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCrefBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax)">
            <summary>Called when the visitor visits a CrefBracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax)">
            <summary>Called when the visitor visits a CrefParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax)">
            <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax)">
            <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax)">
            <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax)">
            <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax)">
            <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax)">
            <summary>Called when the visitor visits a XmlTextAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax)">
            <summary>Called when the visitor visits a XmlCrefAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax)">
            <summary>Called when the visitor visits a XmlNameAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlText(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax)">
            <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlCDataSection(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax)">
            <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax)">
            <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlComment(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax)">
            <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a IfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElifDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitElseDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElseDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEndIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndIfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a RegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEndRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndRegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitErrorDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ErrorDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a WarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a BadDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDefineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a DefineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitUndefDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a UndefDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a LineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLineDirectivePosition(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax)">
            <summary>Called when the visitor visits a LineDirectivePositionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLineSpanDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a LineSpanDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaWarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaChecksumDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitReferenceDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ReferenceDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLoadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a LoadDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitShebangDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ShebangDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitNullableDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a NullableDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> visitor that visits only the single CSharpSyntaxNode
            passed into its Visit method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)">
            <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax)">
            <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitGenericName(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax)">
            <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax)">
            <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax)">
            <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPredefinedType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax)">
            <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax)">
            <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArrayRankSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax)">
            <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax)">
            <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFunctionPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax)">
            <summary>Called when the visitor visits a FunctionPointerTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFunctionPointerParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax)">
            <summary>Called when the visitor visits a FunctionPointerParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFunctionPointerCallingConvention(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax)">
            <summary>Called when the visitor visits a FunctionPointerCallingConventionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFunctionPointerUnmanagedCallingConventionList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax)">
            <summary>Called when the visitor visits a FunctionPointerUnmanagedCallingConventionListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFunctionPointerUnmanagedCallingConvention(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax)">
            <summary>Called when the visitor visits a FunctionPointerUnmanagedCallingConventionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitNullableType(Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax)">
            <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTupleType(Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax)">
            <summary>Called when the visitor visits a TupleTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax)">
            <summary>Called when the visitor visits a TupleElementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOmittedTypeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax)">
            <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRefType(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax)">
            <summary>Called when the visitor visits a RefTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitScopedType(Microsoft.CodeAnalysis.CSharp.Syntax.ScopedTypeSyntax)">
            <summary>Called when the visitor visits a ScopedTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTupleExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax)">
            <summary>Called when the visitor visits a TupleExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)">
            <summary>Called when the visitor visits a AwaitExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitMemberAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax)">
            <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitMemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax)">
            <summary>Called when the visitor visits a MemberBindingExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax)">
            <summary>Called when the visitor visits a ElementBindingExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRangeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax)">
            <summary>Called when the visitor visits a RangeExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax)">
            <summary>Called when the visitor visits a ImplicitElementAccessSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBinaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax)">
            <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax)">
            <summary>Called when the visitor visits a AssignmentExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitThisExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax)">
            <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBaseExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax)">
            <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLiteralExpression(Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax)">
            <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitMakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax)">
            <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax)">
            <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax)">
            <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCheckedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax)">
            <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax)">
            <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax)">
            <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax)">
            <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax)">
            <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax)">
            <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBracketedArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax)">
            <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax)">
            <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitExpressionColon(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionColonSyntax)">
            <summary>Called when the visitor visits a ExpressionColonSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax)">
            <summary>Called when the visitor visits a NameColonSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax)">
            <summary>Called when the visitor visits a DeclarationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax)">
            <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax)">
            <summary>Called when the visitor visits a RefExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInitializerExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitImplicitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitWithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax)">
            <summary>Called when the visitor visits a WithExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAnonymousObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitImplicitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitStackAllocArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax)">
            <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitQueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax)">
            <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLetClause(Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax)">
            <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitJoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax)">
            <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitJoinIntoClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax)">
            <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitWhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax)">
            <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOrderByClause(Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax)">
            <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOrdering(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax)">
            <summary>Called when the visitor visits a OrderingSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax)">
            <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitGroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax)">
            <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitQueryContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax)">
            <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOmittedArraySizeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax)">
            <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterpolatedStringExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax)">
            <summary>Called when the visitor visits a InterpolatedStringExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax)">
            <summary>Called when the visitor visits a IsPatternExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitThrowExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax)">
            <summary>Called when the visitor visits a ThrowExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitWhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax)">
            <summary>Called when the visitor visits a WhenClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDiscardPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardPatternSyntax)">
            <summary>Called when the visitor visits a DiscardPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax)">
            <summary>Called when the visitor visits a DeclarationPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitVarPattern(Microsoft.CodeAnalysis.CSharp.Syntax.VarPatternSyntax)">
            <summary>Called when the visitor visits a VarPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRecursivePattern(Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax)">
            <summary>Called when the visitor visits a RecursivePatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPositionalPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax)">
            <summary>Called when the visitor visits a PositionalPatternClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax)">
            <summary>Called when the visitor visits a PropertyPatternClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSubpattern(Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax)">
            <summary>Called when the visitor visits a SubpatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConstantPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax)">
            <summary>Called when the visitor visits a ConstantPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitParenthesizedPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax)">
            <summary>Called when the visitor visits a ParenthesizedPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRelationalPattern(Microsoft.CodeAnalysis.CSharp.Syntax.RelationalPatternSyntax)">
            <summary>Called when the visitor visits a RelationalPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypePattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypePatternSyntax)">
            <summary>Called when the visitor visits a TypePatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBinaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax)">
            <summary>Called when the visitor visits a BinaryPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUnaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.UnaryPatternSyntax)">
            <summary>Called when the visitor visits a UnaryPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitListPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ListPatternSyntax)">
            <summary>Called when the visitor visits a ListPatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSlicePattern(Microsoft.CodeAnalysis.CSharp.Syntax.SlicePatternSyntax)">
            <summary>Called when the visitor visits a SlicePatternSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterpolatedStringText(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax)">
            <summary>Called when the visitor visits a InterpolatedStringTextSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterpolation(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax)">
            <summary>Called when the visitor visits a InterpolationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterpolationAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax)">
            <summary>Called when the visitor visits a InterpolationAlignmentClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterpolationFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax)">
            <summary>Called when the visitor visits a InterpolationFormatClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitGlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax)">
            <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Called when the visitor visits a BlockSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax)">
            <summary>Called when the visitor visits a LocalFunctionStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)">
            <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitVariableDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax)">
            <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSingleVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax)">
            <summary>Called when the visitor visits a SingleVariableDesignationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDiscardDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax)">
            <summary>Called when the visitor visits a DiscardDesignationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitParenthesizedVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax)">
            <summary>Called when the visitor visits a ParenthesizedVariableDesignationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax)">
            <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEmptyStatement(Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax)">
            <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLabeledStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax)">
            <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitGotoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax)">
            <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBreakStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax)">
            <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitContinueStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax)">
            <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax)">
            <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax)">
            <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitYieldStatement(Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax)">
            <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitWhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax)">
            <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax)">
            <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax)">
            <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)">
            <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitForEachVariableStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax)">
            <summary>Called when the visitor visits a ForEachVariableStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax)">
            <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax)">
            <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCheckedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax)">
            <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax)">
            <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax)">
            <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax)">
            <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax)">
            <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax)">
            <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSwitchSection(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax)">
            <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax)">
            <summary>Called when the visitor visits a CasePatternSwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax)">
            <summary>Called when the visitor visits a CaseSwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDefaultSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax)">
            <summary>Called when the visitor visits a DefaultSwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSwitchExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax)">
            <summary>Called when the visitor visits a SwitchExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSwitchExpressionArm(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax)">
            <summary>Called when the visitor visits a SwitchExpressionArmSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax)">
            <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax)">
            <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax)">
            <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax)">
            <summary>Called when the visitor visits a CatchFilterClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax)">
            <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCompilationUnit(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax)">
            <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitExternAliasDirective(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax)">
            <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)">
            <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax)">
            <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFileScopedNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax)">
            <summary>Called when the visitor visits a FileScopedNamespaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax)">
            <summary>Called when the visitor visits a AttributeListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax)">
            <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>Called when the visitor visits a AttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAttributeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax)">
            <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax)">
            <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax)">
            <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax)">
            <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax)">
            <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterfaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax)">
            <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRecordDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax)">
            <summary>Called when the visitor visits a RecordDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEnumDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax)">
            <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEnumMemberDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax)">
            <summary>Called when the visitor visits a BaseListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax)">
            <summary>Called when the visitor visits a SimpleBaseTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPrimaryConstructorBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax)">
            <summary>Called when the visitor visits a PrimaryConstructorBaseTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax)">
            <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConstructorConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax)">
            <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax)">
            <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax)">
            <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDefaultConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultConstraintSyntax)">
            <summary>Called when the visitor visits a DefaultConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax)">
            <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax)">
            <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax)">
            <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitMethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax)">
            <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConversionOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConstructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)">
            <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDestructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax)">
            <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)">
            <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Called when the visitor visits a ArrowExpressionClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax)">
            <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax)">
            <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)">
            <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax)">
            <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax)">
            <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax)">
            <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax)">
            <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFunctionPointerParameter(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax)">
            <summary>Called when the visitor visits a FunctionPointerParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax)">
            <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSkippedTokensTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax)">
            <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax)">
            <summary>Called when the visitor visits a DocumentationCommentTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax)">
            <summary>Called when the visitor visits a TypeCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitQualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax)">
            <summary>Called when the visitor visits a QualifiedCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitNameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax)">
            <summary>Called when the visitor visits a NameMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax)">
            <summary>Called when the visitor visits a IndexerMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax)">
            <summary>Called when the visitor visits a OperatorMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCrefParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Called when the visitor visits a CrefParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCrefBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax)">
            <summary>Called when the visitor visits a CrefBracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax)">
            <summary>Called when the visitor visits a CrefParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax)">
            <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax)">
            <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax)">
            <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax)">
            <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax)">
            <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax)">
            <summary>Called when the visitor visits a XmlTextAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax)">
            <summary>Called when the visitor visits a XmlCrefAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax)">
            <summary>Called when the visitor visits a XmlNameAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlText(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax)">
            <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlCDataSection(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax)">
            <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax)">
            <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlComment(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax)">
            <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a IfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElifDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitElseDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElseDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEndIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndIfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a RegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEndRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndRegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitErrorDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ErrorDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a WarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a BadDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDefineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a DefineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUndefDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a UndefDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a LineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLineDirectivePosition(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax)">
            <summary>Called when the visitor visits a LineDirectivePositionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLineSpanDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a LineSpanDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaWarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaChecksumDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitReferenceDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ReferenceDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLoadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a LoadDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitShebangDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ShebangDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitNullableDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a NullableDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor"/> that descends an entire <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> graph
            visiting each CSharpSyntaxNode and its child SyntaxNodes and <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>s in depth-first order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the specified node represents a lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.GetLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a node that represents a lambda body returns a node that represents the lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.TryGetCorrespondingLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            See SyntaxNode.GetCorrespondingLambdaBody.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Returns true if the specified <paramref name="node"/> represents a body of a lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsReducedSelectOrGroupByClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            When queries are translated into expressions select and group-by expressions such that
            1) select/group-by expression is the same identifier as the "source" identifier and
            2) at least one Where or OrderBy clause but no other clause is present in the contained query body or
               the expression in question is a group-by expression and the body has no clause
            
            do not translate into lambdas.
            By "source" identifier we mean the identifier specified in the from clause that initiates the query or the query continuation that includes the body.
            
            The above condition can be derived from the language specification (chapter 7.16.2) as follows:
            - In order for 7.16.2.5 "Select clauses" to be applicable the following conditions must hold:
              - There has to be at least one clause in the body, otherwise the query is reduced into a final form by 7.16.2.3 "Degenerate query expressions".
              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 "From, let, where, join and orderby clauses"
                produces pattern that doesn't match the requirements of 7.16.2.5.
              
            - In order for 7.16.2.6 "Groupby clauses" to be applicable the following conditions must hold:
              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 "From, let, where, join and orderby clauses"
                produces pattern that doesn't match the requirements of 7.16.2.5.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambdaBodyStatementOrExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <remarks>
            In C# lambda bodies are expressions or block statements. In both cases it's a single node.
            In VB a lambda body might be a sequence of nodes (statements). 
            We define this function to minimize differences between C# and VB implementation.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.TryGetLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            If the specified node represents a lambda returns a node (or nodes) that represent its body (bodies).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.AreEquivalentIgnoringLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Compares content of two nodes ignoring lambda bodies and trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsQueryPairLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            "Pair lambda" is a synthesized lambda that creates an instance of an anonymous type representing a pair of values. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsClosureScope(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the specified node is of a kind that could represent a closure scope -- that
            is, a scope of a captured variable.
            Doesn't check whether or not the node actually declares any captured variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.GetDeclaratorPosition(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a node that represents a variable declaration, lambda or a closure scope return the position to be used to calculate 
            the node's syntax offset with respect to its containing member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NamespaceDeclarationSyntaxReference">
            <summary>
            A SyntaxReference implementation that lazily translates the result (CSharpSyntaxNode) of the
            original syntax reference to a syntax reference for its NamespaceDeclarationSyntax.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SimpleSyntaxReference">
            <summary>
            this is a basic do-nothing implementation of a syntax reference
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.GetExpressionBodySyntax(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Gets the expression-body syntax from an expression-bodied member. The
            given syntax must be for a member which could contain an expression-body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.Boolean)">
            <summary>
            Creates a new syntax token with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <param name="token">The token to normalize.</param>
            <param name="indentation">A sequence of whitespace characters that defines a single level of indentation.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Identifier(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax)">
            <summary>
            Return the identifier of an out declaration argument expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean)">
            <summary>
            Creates a new syntax token with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <param name="token">The token to normalize.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
            <param name="eol">An optional sequence of whitespace characters used for end of line.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Boolean)">
            <summary>
            Creates a new syntax trivia list with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <param name="list">The trivia list to normalize.</param>
            <param name="indentation">A sequence of whitespace characters that defines a single level of indentation.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,System.Boolean)">
            <summary>
            Creates a new syntax trivia list with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <param name="list">The trivia list to normalize.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
            <param name="eol">An optional sequence of whitespace characters used for end of line.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.WithIdentifier(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Updates the given SimpleNameSyntax node with the given identifier token.
            This function is a wrapper that calls WithIdentifier on derived syntax nodes.
            </summary>
            <param name="simpleName"></param>
            <param name="identifier"></param>
            <returns>The given simple name updated with the given identifier.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.IsDeconstructionLeft(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Returns true if the expression on the left-hand-side of an assignment causes the assignment to be a deconstruction.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.GetContainingDeconstruction(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            If this declaration or identifier is part of a deconstruction, find the deconstruction.
            If found, returns either an assignment expression or a foreach variable statement.
            Returns null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.VisitRankSpecifiers``1(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.Action{Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax,``0},``0@)">
            <summary>
            Visits all the ArrayRankSpecifiers of a typeSyntax, invoking an action on each one in turn.
            </summary>
            <param name="type"></param>
            <param name="action"></param>
            <param name="argument">The argument that is passed to the action whenever it is invoked</param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TildeToken">
            <summary>Represents <c>~</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ExclamationToken">
            <summary>Represents <c>!</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DollarToken">
            <summary>Represents <c>$</c> token.
            <para>
            This is a debugger special punctuation and not related to string interpolation.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PercentToken">
            <summary>Represents <c>%</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CaretToken">
            <summary>Represents <c>^</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AmpersandToken">
            <summary>Represents <c>&amp;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AsteriskToken">
            <summary>Represents <c>*</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OpenParenToken">
            <summary>Represents <c>(</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CloseParenToken">
            <summary>Represents <c>)</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MinusToken">
            <summary>Represents <c>-</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PlusToken">
            <summary>Represents <c>+</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EqualsToken">
            <summary>Represents <c>=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OpenBraceToken">
            <summary>Represents <c>{</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CloseBraceToken">
            <summary>Represents <c>}</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OpenBracketToken">
            <summary>Represents <c>[</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CloseBracketToken">
            <summary>Represents <c>]</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BarToken">
            <summary>Represents <c>|</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BackslashToken">
            <summary>Represents <c>\</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ColonToken">
            <summary>Represents <c>:</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SemicolonToken">
            <summary>Represents <c>;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DoubleQuoteToken">
            <summary>Represents <c>"</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SingleQuoteToken">
            <summary>Represents <c>'</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LessThanToken">
            <summary>Represents <c>&lt;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CommaToken">
            <summary>Represents <c>,</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GreaterThanToken">
            <summary>Represents <c>&gt;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DotToken">
            <summary>Represents <c>.</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.QuestionToken">
            <summary>Represents <c>?</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.HashToken">
            <summary>Represents <c>#</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SlashToken">
            <summary>Represents <c>/</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DotDotToken">
            <summary>Represents <c>..</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SlashGreaterThanToken">
            <summary>Represents <c>/&gt;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LessThanSlashToken">
            <summary>Represents <c>&lt;/</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlCommentStartToken">
            <summary>Represents <c>&lt;!--</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlCommentEndToken">
            <summary>Represents <c>--&gt;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlCDataStartToken">
            <summary>Represents <c>&lt;![CDATA[</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlCDataEndToken">
            <summary>Represents <c>]]&gt;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlProcessingInstructionStartToken">
            <summary>Represents <c>&lt;?</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlProcessingInstructionEndToken">
            <summary>Represents <c>?&gt;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BarBarToken">
            <summary>Represents <c>||</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AmpersandAmpersandToken">
            <summary>Represents <c>&amp;&amp;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MinusMinusToken">
            <summary>Represents <c>--</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PlusPlusToken">
            <summary>Represents <c>++</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ColonColonToken">
            <summary>Represents <c>::</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.QuestionQuestionToken">
            <summary>Represents <c>??</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MinusGreaterThanToken">
            <summary>Represents <c>-&gt;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ExclamationEqualsToken">
            <summary>Represents <c>!=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EqualsEqualsToken">
            <summary>Represents <c>==</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EqualsGreaterThanToken">
            <summary>Represents <c>=&gt;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LessThanEqualsToken">
            <summary>Represents <c>&lt;=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LessThanLessThanToken">
            <summary>Represents <c>&lt;&lt;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LessThanLessThanEqualsToken">
            <summary>Represents <c>&lt;&lt;=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GreaterThanEqualsToken">
            <summary>Represents <c>&gt;=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GreaterThanGreaterThanToken">
            <summary>Represents <c>&gt;&gt;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GreaterThanGreaterThanEqualsToken">
            <summary>Represents <c>&gt;&gt;=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SlashEqualsToken">
            <summary>Represents <c>/=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AsteriskEqualsToken">
            <summary>Represents <c>*=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BarEqualsToken">
            <summary>Represents <c>|=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AmpersandEqualsToken">
            <summary>Represents <c>&amp;=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PlusEqualsToken">
            <summary>Represents <c>+=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MinusEqualsToken">
            <summary>Represents <c>-=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CaretEqualsToken">
            <summary>Represents <c>^=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PercentEqualsToken">
            <summary>Represents <c>%=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.QuestionQuestionEqualsToken">
            <summary>Represents <c>??=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GreaterThanGreaterThanGreaterThanToken">
            <summary>Represents <c>&gt;&gt;&gt;</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken">
            <summary>Represents <c>&gt;&gt;&gt;=</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BoolKeyword">
            <summary>Represents <see langword="bool"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ByteKeyword">
            <summary>Represents <see langword="byte"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SByteKeyword">
            <summary>Represents <see langword="sbyte"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ShortKeyword">
            <summary>Represents <see langword="short"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UShortKeyword">
            <summary>Represents <see langword="ushort"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IntKeyword">
            <summary>Represents <see langword="int"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UIntKeyword">
            <summary>Represents <see langword="uint"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LongKeyword">
            <summary>Represents <see langword="long"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ULongKeyword">
            <summary>Represents <see langword="ulong"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DoubleKeyword">
            <summary>Represents <see langword="double"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FloatKeyword">
            <summary>Represents <see langword="float"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DecimalKeyword">
            <summary>Represents <see langword="decimal"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.StringKeyword">
            <summary>Represents <see langword="string"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CharKeyword">
            <summary>Represents <see langword="char"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.VoidKeyword">
            <summary>Represents <see langword="void"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ObjectKeyword">
            <summary>Represents <see langword="object"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TypeOfKeyword">
            <summary>Represents <see langword="typeof"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SizeOfKeyword">
            <summary>Represents <see langword="sizeof"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NullKeyword">
            <summary>Represents <see langword="null"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TrueKeyword">
            <summary>Represents <see langword="true"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FalseKeyword">
            <summary>Represents <see langword="false"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IfKeyword">
            <summary>Represents <see langword="if"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ElseKeyword">
            <summary>Represents <see langword="else"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhileKeyword">
            <summary>Represents <see langword="while"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ForKeyword">
            <summary>Represents <see langword="for"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ForEachKeyword">
            <summary>Represents <see langword="foreach"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DoKeyword">
            <summary>Represents <see langword="do"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SwitchKeyword">
            <summary>Represents <see langword="switch"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CaseKeyword">
            <summary>Represents <see langword="case"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DefaultKeyword">
            <summary>Represents <see langword="default"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TryKeyword">
            <summary>Represents <see langword="try"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CatchKeyword">
            <summary>Represents <see langword="catch"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FinallyKeyword">
            <summary>Represents <see langword="finally"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LockKeyword">
            <summary>Represents <see langword="lock"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GotoKeyword">
            <summary>Represents <see langword="goto"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BreakKeyword">
            <summary>Represents <see langword="break"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ContinueKeyword">
            <summary>Represents <see langword="continue"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ReturnKeyword">
            <summary>Represents <see langword="return"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ThrowKeyword">
            <summary>Represents <see langword="throw"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PublicKeyword">
            <summary>Represents <see langword="public"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PrivateKeyword">
            <summary>Represents <see langword="private"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InternalKeyword">
            <summary>Represents <see langword="internal"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ProtectedKeyword">
            <summary>Represents <see langword="protected"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.StaticKeyword">
            <summary>Represents <see langword="static"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ReadOnlyKeyword">
            <summary>Represents <see langword="readonly"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SealedKeyword">
            <summary>Represents <see langword="sealed"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ConstKeyword">
            <summary>Represents <see langword="const"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FixedKeyword">
            <summary>Represents <see langword="fixed"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.StackAllocKeyword">
            <summary>Represents <see langword="stackalloc"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.VolatileKeyword">
            <summary>Represents <see langword="volatile"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NewKeyword">
            <summary>Represents <see langword="new"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OverrideKeyword">
            <summary>Represents <see langword="override"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AbstractKeyword">
            <summary>Represents <see langword="abstract"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.VirtualKeyword">
            <summary>Represents <see langword="virtual"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EventKeyword">
            <summary>Represents <see langword="event"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ExternKeyword">
            <summary>Represents <see langword="extern"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RefKeyword">
            <summary>Represents <see langword="ref"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OutKeyword">
            <summary>Represents <see langword="out"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InKeyword">
            <summary>Represents <see langword="in"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IsKeyword">
            <summary>Represents <see langword="is"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AsKeyword">
            <summary>Represents <see langword="as"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ParamsKeyword">
            <summary>Represents <see langword="params"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ArgListKeyword">
            <summary>Represents <see langword="__arglist"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MakeRefKeyword">
            <summary>Represents <see langword="__makeref"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RefTypeKeyword">
            <summary>Represents <see langword="__reftype"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RefValueKeyword">
            <summary>Represents <see langword="__refvalue"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ThisKeyword">
            <summary>Represents <see langword="this"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.BaseKeyword">
            <summary>Represents <see langword="base"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NamespaceKeyword">
            <summary>Represents <see langword="namespace"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UsingKeyword">
            <summary>Represents <see langword="using"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ClassKeyword">
            <summary>Represents <see langword="class"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.StructKeyword">
            <summary>Represents <see langword="struct"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InterfaceKeyword">
            <summary>Represents <see langword="interface"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EnumKeyword">
            <summary>Represents <see langword="enum"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DelegateKeyword">
            <summary>Represents <see langword="delegate"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CheckedKeyword">
            <summary>Represents <see langword="checked"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UncheckedKeyword">
            <summary>Represents <see langword="unchecked"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UnsafeKeyword">
            <summary>Represents <see langword="unsafe"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OperatorKeyword">
            <summary>Represents <see langword="operator"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ExplicitKeyword">
            <summary>Represents <see langword="explicit"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ImplicitKeyword">
            <summary>Represents <see langword="implicit"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.YieldKeyword">
            <summary>Represents <see langword="yield"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PartialKeyword">
            <summary>Represents <see langword="partial"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AliasKeyword">
            <summary>Represents <see langword="alias"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GlobalKeyword">
            <summary>Represents <see langword="global"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AssemblyKeyword">
            <summary>Represents <see langword="assembly"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ModuleKeyword">
            <summary>Represents <see langword="module"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TypeKeyword">
            <summary>Represents <see langword="type"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FieldKeyword">
            <summary>Represents <see langword="field"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MethodKeyword">
            <summary>Represents <see langword="method"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ParamKeyword">
            <summary>Represents <see langword="param"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PropertyKeyword">
            <summary>Represents <see langword="property"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.TypeVarKeyword">
            <summary>Represents <see langword="typevar"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GetKeyword">
            <summary>Represents <see langword="get"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SetKeyword">
            <summary>Represents <see langword="set"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddKeyword">
            <summary>Represents <see langword="add"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RemoveKeyword">
            <summary>Represents <see langword="remove"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhereKeyword">
            <summary>Represents <see langword="where"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FromKeyword">
            <summary>Represents <see langword="from"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.GroupKeyword">
            <summary>Represents <see langword="group"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.JoinKeyword">
            <summary>Represents <see langword="join"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.IntoKeyword">
            <summary>Represents <see langword="into"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LetKeyword">
            <summary>Represents <see langword="let"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ByKeyword">
            <summary>Represents <see langword="by"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SelectKeyword">
            <summary>Represents <see langword="select"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OrderByKeyword">
            <summary>Represents <see langword="orderby"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OnKeyword">
            <summary>Represents <see langword="on"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EqualsKeyword">
            <summary>Represents <see langword="equals"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AscendingKeyword">
            <summary>Represents <see langword="ascending"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DescendingKeyword">
            <summary>Represents <see langword="descending"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NameOfKeyword">
            <summary>Represents <see langword="nameof"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AsyncKeyword">
            <summary>Represents <see langword="async"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AwaitKeyword">
            <summary>Represents <see langword="await"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhenKeyword">
            <summary>Represents <see langword="when"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OrKeyword">
            <summary>Represents <see langword="or"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AndKeyword">
            <summary>Represents <see langword="and"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NotKeyword">
            <summary>Represents <see langword="not"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WithKeyword">
            <summary>Represents <see langword="with"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InitKeyword">
            <summary>Represents <see langword="init"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RecordKeyword">
            <summary>Represents <see langword="record"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ManagedKeyword">
            <summary>Represents <see langword="managed"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UnmanagedKeyword">
            <summary>Represents <see langword="unmanaged"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RequiredKeyword">
            <summary>Represents <see langword="required"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ScopedKeyword">
            <summary>Represents <see langword="scoped"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.FileKeyword">
            <summary>Represents <see langword="file"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ElifKeyword">
            <summary>Represents <see langword="elif"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndIfKeyword">
            <summary>Represents <see langword="endif"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RegionKeyword">
            <summary>Represents <see langword="region"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndRegionKeyword">
            <summary>Represents <see langword="endregion"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DefineKeyword">
            <summary>Represents <see langword="define"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UndefKeyword">
            <summary>Represents <see langword="undef"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WarningKeyword">
            <summary>Represents <see langword="warning"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ErrorKeyword">
            <summary>Represents <see langword="error"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LineKeyword">
            <summary>Represents <see langword="line"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.PragmaKeyword">
            <summary>Represents <see langword="pragma"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.HiddenKeyword">
            <summary>Represents <see langword="hidden"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ChecksumKeyword">
            <summary>Represents <see langword="checksum"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.DisableKeyword">
            <summary>Represents <see langword="disable"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.RestoreKeyword">
            <summary>Represents <see langword="restore"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.ReferenceKeyword">
            <summary>Represents <see langword="r"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InterpolatedStringStartToken">
            <summary>Represents <c>$"</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InterpolatedStringEndToken">
            <summary>Represents <c>"</c> token that is closing <c>$"</c>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InterpolatedVerbatimStringStartToken">
            <summary>Represents <c>$@</c> or <c>@$</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LoadKeyword">
            <summary>Represents <see langword="load"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.NullableKeyword">
            <summary>Represents <see langword="nullable"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EnableKeyword">
            <summary>Represents <see langword="enable"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WarningsKeyword">
            <summary>Represents <see langword="warnings"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AnnotationsKeyword">
            <summary>Represents <see langword="annotations"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.VarKeyword">
            <summary>Represents <see langword="var"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.UnderscoreToken">
            <summary>Represents <c>_</c> token.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OmittedTypeArgumentToken">
            <summary>Represents that nothing was specified as a type argument.
            <para>For example <c>Dictionary&lt;,&gt;</c> which has <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OmittedTypeArgumentToken"/> as a child of
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax"/> before and after the <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CommaToken"/>.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OmittedArraySizeExpressionToken">
            <summary>Represents that nothing was specified as an array size.
            <para>For example <c>int[,]</c> which has <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.OmittedArraySizeExpressionToken"/> as a child of
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax"/> before and after the <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.CommaToken"/>.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfDirectiveToken">
            <summary>Represents a token that comes after the end of a directive such as <c>#endif</c>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfDocumentationCommentToken">
            <summary>Represents the end of a triple-slash documentation comment.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfFileToken">
            <summary>Represents the end of a file.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.InterpolatedStringToken">
            <summary>
            Token for a whole interpolated string <c>$""" ... { expr } ..."""</c>. This only exists in transient form during parsing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxNodeExtensions.CanHaveAssociatedLocalBinder(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            This method is used to keep the code that generates binders in sync
            with the code that searches for binders.  We don't want the searcher
            to skip over any nodes that could have associated binders, especially
            if changes are made later.
            
            "Local binder" is a term that refers to binders that are
            created by LocalBinderFactory.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxNodeExtensions.IsLegalCSharp73SpanStackAllocPosition(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Because the instruction cannot have any values on the stack before CLR execution
            we limited it to assignments and conditional expressions in C# 7.
            See https://github.com/dotnet/roslyn/issues/22046.
            In C# 8 we relaxed
            that by rewriting the code to move it to the statement level where the stack is empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxNodeExtensions.ExtractAnonymousTypeMemberName(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Given an initializer expression infer the name of anonymous property or tuple element.
            Returns default if unsuccessful
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxNodeExtensions.IsDeconstructionCompatibleArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            See if the expression is an invocation of a method named 'var',
            I.e. something like "var(x, y)" or "var(x, (y, z))" or "var(1)".
            We report an error when such an invocation is used in a certain syntactic contexts that
            will require an lvalue because we may elect to support deconstruction
            in the future. We need to ensure that we do not successfully interpret this as an invocation of a
            ref-returning method named var.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntaxTreeDiagnosticEnumerator">
            <summary>
            An enumerator for diagnostic lists.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeDiagnosticEnumerator.MoveNext">
            <summary>
            Moves the enumerator to the next diagnostic instance in the diagnostic list.
            </summary>
            <returns>Returns true if enumerator moved to the next diagnostic, false if the
            enumerator was at the end of the diagnostic list.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxTreeDiagnosticEnumerator.Current">
            <summary>
            The current diagnostic that the enumerator is pointing at.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IValueSet">
            <summary>
            An interface representing a set of values of a specific type.  During construction of the state machine
            for pattern-matching, we track the set of values of each intermediate result that can reach each state.
            That permits us to determine when tests can be eliminated either because they are impossible (and can be
            replaced by an always-false test) or always true with the set of values that can reach that state (and
            can be replaced by an always-true test).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSet.Intersect(Microsoft.CodeAnalysis.CSharp.IValueSet)">
            <summary>
            Return the intersection of this value set with another. Both must have been created with the same <see cref="T:Microsoft.CodeAnalysis.CSharp.IValueSetFactory`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSet.Union(Microsoft.CodeAnalysis.CSharp.IValueSet)">
            <summary>
            Return this union of this value set with another. Both must have been created with the same <see cref="T:Microsoft.CodeAnalysis.CSharp.IValueSetFactory`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSet.Complement">
            <summary>
            Return the complement of this value set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSet.Any(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            Test if the value set contains any values that satisfy the given relation with the given value.  Supported values for <paramref name="relation"/>
            are <see cref="F:Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind.Equal"/> for all supported types, and for numeric types we also support
            <see cref="F:Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind.LessThan"/>, <see cref="F:Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind.LessThanOrEqual"/>, <see cref="F:Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind.GreaterThan"/>, and
            <see cref="F:Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind.GreaterThanOrEqual"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSet.All(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            Test if all of the value in the set satisfy the given relation with the given value. Note that the empty set trivially satisfies this.
            Because of that all four combinations of results from <see cref="M:Microsoft.CodeAnalysis.CSharp.IValueSet.Any(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.ConstantValue)"/> and <see cref="M:Microsoft.CodeAnalysis.CSharp.IValueSet.All(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.ConstantValue)"/>
            are possible: both true when the set is nonempty and all values satisfy the relation; both false when the set is nonempty and none of
            the values satisfy the relation; all but not any when the set is empty; any but not all when the set is nonempty and some values satisfy
            the relation and some do not.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.IValueSet.IsEmpty">
            <summary>
            Does this value set contain no values?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.IValueSet.Sample">
            <summary>
            Produce a sample value contained in the set. Throws <see cref="T:System.ArgumentException"/> if the set is empty. If the set
            contains values but we cannot produce a particular value (e.g. for the set `nint > int.MaxValue`), returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IValueSet`1">
            <summary>
            An interface representing a set of values of a specific type.  Like <see cref="T:Microsoft.CodeAnalysis.CSharp.IValueSet"/> but strongly typed to <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSet`1.Intersect(Microsoft.CodeAnalysis.CSharp.IValueSet{`0})">
            <summary>
            Return the intersection of this value set with another. Both must have been created with the same <see cref="T:Microsoft.CodeAnalysis.CSharp.IValueSetFactory`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSet`1.Union(Microsoft.CodeAnalysis.CSharp.IValueSet{`0})">
            <summary>
            Return this union of this value set with another. Both must have been created with the same <see cref="T:Microsoft.CodeAnalysis.CSharp.IValueSetFactory`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSet`1.Complement">
            <summary>
            Return the complement of this value set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSet`1.Any(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,`0)">
            <summary>
            Test if the value set contains any values that satisfy the given relation with the given value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSet`1.All(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,`0)">
            <summary>
            Test if all of the value in the set satisfy the given relation with the given value. Note that the empty set trivially satisfies this.
            Because of that all four combinations of results from <see cref="M:Microsoft.CodeAnalysis.CSharp.IValueSet`1.Any(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,`0)"/> and <see cref="M:Microsoft.CodeAnalysis.CSharp.IValueSet`1.All(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,`0)"/>
            are possible: both true when the set is nonempty and all values satisfy the relation; both false when the set is nonempty and none of
            the values satisfy the relation; all but not any when the set is empty; any but not all when the set is nonempty and some values satisfy
            the relation and some do not.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IValueSetFactory">
            <summary>
            A value set factory, which can be used to create a value set instance.  A given instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.IValueSetFactory"/>
            supports only one type for the value sets it can produce.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSetFactory.Related(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            Returns a value set that includes any values that satisfy the given relation when compared to the given value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSetFactory.Related(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            Returns true iff the values are related according to the given relation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSetFactory.Random(System.Int32,System.Random)">
            <summary>
            Produce a random value set with the given expected size for testing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSetFactory.RandomValue(System.Random)">
            <summary>
            Produce a random value for testing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.IValueSetFactory.AllValues">
            <summary>
            The set containing all values of the type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.IValueSetFactory.NoValues">
            <summary>
            The empty set of values.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IValueSetFactory`1">
            <summary>
            A value set factory, which can be used to create a value set instance.  Like <see cref="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory"/> but strongly
            typed to <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IValueSetFactory`1.Related(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,`0)">
            <summary>
            Returns a value set that includes any values that satisfy the given relation when compared to the given value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory">
            <summary>
            A collection of value set factory instances for built-in types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.BoolValueSetFactory">
            <summary>
            A value set factory for boolean values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.DoubleTC.Next(System.Double)">
            <summary>
            The implementation of Next depends critically on the internal representation of an IEEE floating-point
            number.  Every bit sequence between the representation of 0 and MaxValue represents a distinct
            value, and the integer representations are ordered by value the same as the floating-point numbers they represent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.DoubleTC.Microsoft#CodeAnalysis#CSharp#ValueSetFactory#INumericTC{System#Double}#ToString(System.Double)">
            <summary>
            Produce a string for testing purposes that is likely to be the same independent of platform and locale.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.EnumeratedValueSet`2">
            <summary>
            A value set that only supports equality and works by including or excluding specific values.
            This is used for value set of <see cref="T:System.String"/> because the language defines no
            relational operators for it; such a set can be formed only by including explicitly mentioned
            members (or the inverse, excluding them, by complementing the set).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.EnumeratedValueSet`2._included">
            <summary>
            In <see cref="F:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.EnumeratedValueSet`2._included"/>, then members are listed by inclusion.  Otherwise all members
            are assumed to be contained in the set unless excluded.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.EnumeratedValueSetFactory`2">
            <summary>
            A value set factory that only supports equality and works by including or excluding specific values.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.FloatingTC`1">
            <summary>
            A type class providing primitive operations needed to support a value set for a floating-point type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.FloatingTC`1.NaN">
            <summary>
            A "not a number" value for the floating-point type <typeparamref name="T"/>.
            All NaN values are treated as equivalent.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.FloatingValueSet`2">
            <summary>
            A value set implementation for <see cref="T:System.Single"/> and <see cref="T:System.Double"/>.
            </summary>
            <typeparam name="TFloating">A floating-point type.</typeparam>
            <typeparam name="TFloatingTC">A typeclass supporting that floating-point type.</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.IEquatableValueTC`1">
            <summary>
            A type class for values (of type <typeparamref name="T"/>) that can be directly compared for equality 
            using <see cref="M:System.Object.Equals(System.Object,System.Object)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.IEquatableValueTC`1.FromConstantValue(Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            Get the constant value of type <typeparamref name="T"/> from a <see cref="T:Microsoft.CodeAnalysis.ConstantValue"/>. This method is shared among all
            typeclasses for value sets.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.IEquatableValueTC`1.ToConstantValue(`0)">
            <summary>
            Translate a numeric value of type <typeparamref name="T"/> into a <see cref="T:Microsoft.CodeAnalysis.ConstantValue"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.IEquatableValueTC`1.RandomValues(System.Int32,System.Random,System.Int32)">
            <summary>
            Generate <paramref name="count"/> random values of type <typeparamref name="T"/>.
            If the domain of <typeparamref name="T"/> is infinite (for example, a string type),
            the <paramref name="count"/> parameter is used to identify the size of a restricted
            domain.  If the domain is finite (for example the numeric types), then
            <paramref name="scope"/> is ignored.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1">
            <summary>
            A type class providing the primitive operations needed to support a value set.
            </summary>
            <typeparam name="T">the underlying primitive numeric type</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.FromConstantValue(Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            Get the constant value of type <typeparamref name="T"/> from a <see cref="T:Microsoft.CodeAnalysis.ConstantValue"/>. This method is shared among all
            typeclasses for value sets.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.ToConstantValue(`0)">
            <summary>
            Translate a numeric value of type <typeparamref name="T"/> into a <see cref="T:Microsoft.CodeAnalysis.ConstantValue"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.Related(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,`0,`0)">
            <summary>
            Compute the value of the binary relational operator on the given operands.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.MinValue">
            <summary>
            The smallest value of <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.MaxValue">
            <summary>
            The largest value of <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.Next(`0)">
            <summary>
            The successor (next larger) value to a given value. The result is not defined
            when <paramref name="value"/> is <see cref="P:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.MaxValue"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.Prev(`0)">
            <summary>
            The predecessor (previous larger) value to a given value. The result is not defined
            when <paramref name="value"/> is <see cref="P:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.MinValue"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.Random(System.Random)">
            <summary>
            Produce a randomly-selected value for testing purposes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.Zero">
            <summary>
            Produce the zero value for the type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1.ToString(`0)">
            <summary>
            A formatter for values of type <typeparamref name="T"/>.  This is needed for testing because
            the default ToString output for float and double changed between desktop and .net core,
            and also because we want the string representation to be locale-independent.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.NintValueSet._hasSmall">
            <summary>
            A value of type nint may, in a 64-bit runtime, take on values less than <see cref="F:System.Int32.MinValue"/>.
            A value set representing values of type nint groups them all together, so that it is not possible to
            distinguish one such value from another.  The flag <see cref="F:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.NintValueSet._hasSmall"/> is true when the set is considered
            to contain all values less than <see cref="F:System.Int32.MinValue"/> (if any).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.NintValueSet._hasLarge">
            <summary>
            A value of type nint may, in a 64-bit runtime, take on values greater than <see cref="F:System.Int32.MaxValue"/>.
            A value set representing values of type nint groups them all together, so that it is not possible to
            distinguish one such value from another.  The flag <see cref="F:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.NintValueSet._hasLarge"/> is true when the set is considered
            to contain all values greater than <see cref="F:System.Int32.MaxValue"/> (if any).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.NuintValueSet._hasLarge">
            <summary>
            A value of type nuint may, in a 64-bit runtime, take on values greater than <see cref="F:System.UInt32.MaxValue"/>.
            A value set representing values of type nuint groups them all together, so that it is not possible to
            distinguish one such value from another.  The flag <see cref="F:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.NuintValueSet._hasLarge"/> is true when the set is considered
            to contain all values greater than <see cref="F:System.UInt32.MaxValue"/> (if any).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.NumericValueSet`2">
            <summary>
            The implementation of a value set for an numeric type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.NumericValueSet`2.Add(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.ValueTuple{`0,`0}},`0,`0)">
            <summary>
            Add an interval to the end of the builder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.NumericValueSet`2.Random(System.Int32,System.Random)">
            <summary>
            Produce a random value set for testing purposes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.NumericValueSet`2.ToString">
            <summary>
            A string representation for testing purposes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.NumericValueSetFactory`2">
            <summary>
            The implementation of a value set factory of any numeric type <typeparamref name="T"/>,
            parameterized by a type class
            <see cref="T:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.INumericTC`1"/> that provides the primitives for that type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.SingleTC.Next(System.Single)">
            <summary>
            The implementation of Next depends critically on the internal representation of an IEEE floating-point
            number.  Every bit sequence between the representation of 0 and MaxValue represents a distinct
            value, and the integer representations are ordered by value the same as the floating-point numbers they represent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ValueSetFactory.SingleTC.Microsoft#CodeAnalysis#CSharp#ValueSetFactory#INumericTC{System#Single}#ToString(System.Single)">
            <summary>
            Produce a string for testing purposes that is likely to be the same independent of platform and locale.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpDeclarationComputer.GetExpressionBodySyntax(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Gets the expression-body syntax from an expression-bodied member. The
            given syntax must be for a member which could contain an expression-body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_NULL">
            <summary>&lt;null&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_ThrowExpression">
            <summary>&lt;throw expression&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureSwitchExpression">
            <summary>&lt;switch expression&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureLocalFunctionAttributes">
            <summary>local function attributes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExternLocalFunctions">
            <summary>extern local functions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_RELATEDERROR">
            <summary>(Location of symbol related to previous error)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_RELATEDWARNING">
            <summary>(Location of symbol related to previous warning)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLIGNORED">
            <summary>&lt;!-- Badly formed XML comment ignored for member "{0}" --&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLIGNORED2">
            <summary>Badly formed XML file "{0}" cannot be included</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLFAILEDINCLUDE">
            <summary>Failed to insert some or all of included XML</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLBADINCLUDE">
            <summary>Include tag is invalid</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLNOINCLUDE">
            <summary>No matching elements were found for the following include tag</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLMISSINGINCLUDEFILE">
            <summary>Missing file attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLMISSINGINCLUDEPATH">
            <summary>Missing path attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_GlobalNamespace">
            <summary>&lt;global namespace&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureGenerics">
            <summary>generics</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAnonDelegates">
            <summary>anonymous methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureModuleAttrLoc">
            <summary>module as an attribute target specifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureGlobalNamespace">
            <summary>namespace alias qualifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureFixedBuffer">
            <summary>fixed size buffers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePragma">
            <summary>#pragma</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureStaticClasses">
            <summary>static classes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureReadOnlyStructs">
            <summary>readonly structs</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePartialTypes">
            <summary>partial types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAsync">
            <summary>async function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureSwitchOnBool">
            <summary>switch on boolean type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_MethodGroup">
            <summary>method group</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_AnonMethod">
            <summary>anonymous method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Lambda">
            <summary>lambda expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Collection">
            <summary>collection</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Disposable">
            <summary>disposable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePropertyAccessorMods">
            <summary>access modifiers on properties</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExternAlias">
            <summary>extern alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureIterators">
            <summary>iterators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDefault">
            <summary>default operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAsyncStreams">
            <summary>async streams</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureUnmanagedConstructedTypes">
            <summary>unmanaged constructed types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureReadOnlyMembers">
            <summary>readonly members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDefaultLiteral">
            <summary>default literal</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePrivateProtected">
            <summary>private protected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureTupleEquality">
            <summary>tuple equality</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNullable">
            <summary>nullable types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePatternMatching">
            <summary>pattern matching</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExpressionBodiedAccessor">
            <summary>expression body property accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExpressionBodiedDeOrConstructor">
            <summary>expression body constructor and destructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureThrowExpression">
            <summary>throw expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureImplicitArray">
            <summary>implicitly typed array</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureImplicitLocal">
            <summary>implicitly typed local variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAnonymousTypes">
            <summary>anonymous types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAutoImplementedProperties">
            <summary>automatically implemented properties</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureReadonlyAutoImplementedProperties">
            <summary>readonly automatically implemented properties</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureObjectInitializer">
            <summary>object initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureCollectionInitializer">
            <summary>collection initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureQueryExpression">
            <summary>query expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExtensionMethod">
            <summary>extension method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePartialMethod">
            <summary>partial method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_METHOD">
            <summary>method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_TYPE">
            <summary>type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_NAMESPACE">
            <summary>namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_FIELD">
            <summary>field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_PROPERTY">
            <summary>property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_UNKNOWN">
            <summary>element</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_VARIABLE">
            <summary>variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_LABEL">
            <summary>label</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_EVENT">
            <summary>event</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_TYVAR">
            <summary>type parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_ALIAS">
            <summary>using alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_EXTERNALIAS">
            <summary>extern alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_CONSTRUCTOR">
            <summary>constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FOREACHLOCAL">
            <summary>foreach iteration variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FIXEDLOCAL">
            <summary>fixed variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_USINGLOCAL">
            <summary>using variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Contravariant">
            <summary>contravariant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Contravariantly">
            <summary>contravariantly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Covariant">
            <summary>covariant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Covariantly">
            <summary>covariantly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Invariantly">
            <summary>invariantly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDynamic">
            <summary>dynamic</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNamedArgument">
            <summary>named argument</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureOptionalParameter">
            <summary>optional parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExceptionFilter">
            <summary>exception filter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureTypeVariance">
            <summary>type variance</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Parameter">
            <summary>parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Return">
            <summary>return</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_InvalidToken">
            <summary>The character(s) '{0}' cannot be used at this location.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_IncorrectComment">
            <summary>Incorrect syntax was used in a comment.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_InvalidCharEntity">
            <summary>An invalid character was found inside an entity reference.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_ExpectedEndOfTag">
            <summary>Expected '&gt;' or '/&gt;' to close tag '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_ExpectedIdentifier">
            <summary>An identifier was expected.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_InvalidUnicodeChar">
            <summary>Invalid unicode character.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_InvalidWhitespace">
            <summary>Whitespace is not allowed at this location.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_LessThanInAttributeValue">
            <summary>The character '&lt;' cannot be used in an attribute value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_MissingEqualsAttribute">
            <summary>Missing equals sign between attribute and attribute value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_RefUndefinedEntity_1">
            <summary>Reference to undefined entity '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_StringLiteralNoStartQuote">
            <summary>A string literal was expected, but no opening quotation mark was found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_StringLiteralNoEndQuote">
            <summary>Missing closing quotation mark for string literal.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_StringLiteralNonAsciiQuote">
            <summary>Non-ASCII quotations marks may not be used around string literals.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_EndTagNotExpected">
            <summary>End tag was not expected at this location.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_ElementTypeMatch">
            <summary>End tag '{0}' does not match the start tag '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_EndTagExpected">
            <summary>Expected an end tag for element '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_WhitespaceMissing">
            <summary>Required white space was missing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_ExpectedEndOfXml">
            <summary>Unexpected character at this location.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_CDataEndTagNotAllowed">
            <summary>The literal string ']]&gt;' is not allowed in element content.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_DuplicateAttribute">
            <summary>Duplicate '{0}' attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoMetadataFile">
            <summary>Metadata file '{0}' could not be found</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MetadataReferencesNotSupported">
            <summary>Metadata references are not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_MetadataCantOpenFile">
            <summary>Metadata file '{0}' could not be opened -- {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoTypeDef">
            <summary>The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoTypeDefFromModule">
            <summary>The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OutputWriteFailed">
            <summary>Could not write to output file '{0}' -- '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultipleEntryPoints">
            <summary>Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBinaryOps">
            <summary>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigBinaryOpsOnUnconstrainedDefault">
            <summary>Operator '{0}' cannot be applied to 'default' and operand of type '{1}' because it is a type parameter that is not known to be a reference type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IntDivByZero">
            <summary>Division by constant zero</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIndexLHS">
            <summary>Cannot apply indexing with [] to an expression of type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIndexCount">
            <summary>Wrong number of indices inside []; expected {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadUnaryOp">
            <summary>Operator '{0}' cannot be applied to operand of type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadOpOnNullOrDefaultOrNew">
            <summary>Operator '{0}' cannot be applied to operand '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ThisInStaticMeth">
            <summary>Keyword 'this' is not valid in a static property, static method, or static field initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ThisInBadContext">
            <summary>Keyword 'this' is not available in the current context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OmittedTypeArgument">
            <summary>Omitting the type argument is not allowed in the current context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidMainSig">
            <summary>'{0}' has the wrong signature to be an entry point</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidMainSig_Title">
            <summary>Method has the wrong signature to be an entry point</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoImplicitConv">
            <summary>Cannot implicitly convert type '{0}' to '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoExplicitConv">
            <summary>Cannot convert type '{0}' to '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstOutOfRange">
            <summary>Constant value '{0}' cannot be converted to a '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigBinaryOps">
            <summary>Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigBinaryOpsOnDefault">
            <summary>Operator '{0}' is ambiguous on operands '{1}' and '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigUnaryOp">
            <summary>Operator '{0}' is ambiguous on an operand of type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InAttrOnOutParam">
            <summary>An out parameter cannot have the In attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ValueCantBeNull">
            <summary>Cannot convert null to '{0}' because it is a non-nullable value type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoExplicitBuiltinConv">
            <summary>Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_DebugEmitFailure">
            <summary>Unexpected error writing debug information -- '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisReturnType">
            <summary>Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisParamType">
            <summary>Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisFieldType">
            <summary>Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisPropertyType">
            <summary>Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisIndexerReturn">
            <summary>Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisIndexerParam">
            <summary>Inconsistent accessibility: parameter type '{1}' is less accessible than indexer '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisOpReturn">
            <summary>Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisOpParam">
            <summary>Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisDelegateReturn">
            <summary>Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisDelegateParam">
            <summary>Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisBaseClass">
            <summary>Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisBaseInterface">
            <summary>Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EventNeedsBothAccessors">
            <summary>'{0}': event property must have both add and remove accessors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractEventHasAccessors">
            <summary>'{0}': abstract event cannot use event accessor syntax</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EventNotDelegate">
            <summary>'{0}': event must be of a delegate type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedEvent">
            <summary>The event '{0}' is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedEvent_Title">
            <summary>Event is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfaceEventInitializer">
            <summary>'{0}': instance event in interface cannot have initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadEventUsage">
            <summary>The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitEventFieldImpl">
            <summary>An explicit interface implementation of an event must use event accessor syntax</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideNonEvent">
            <summary>'{0}': cannot override; '{1}' is not an event</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AddRemoveMustHaveBody">
            <summary>An add or remove accessor must have a body</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractEventInitializer">
            <summary>'{0}': abstract event cannot have initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReservedAssemblyName">
            <summary>The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReservedEnumerator">
            <summary>The enumerator name '{0}' is reserved and cannot be used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AsMustHaveReferenceType">
            <summary>The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_LowercaseEllSuffix">
            <summary>The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_LowercaseEllSuffix_Title">
            <summary>The 'l' suffix is easily confused with the digit '1'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadEventUsageNoField">
            <summary>The event '{0}' can only appear on the left hand side of += or -=</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstraintOnlyAllowedOnGenericDecl">
            <summary>Constraints are not allowed on non-generic declarations</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeParamMustBeIdentifier">
            <summary>Type parameter declaration must be an identifier not a type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberReserved">
            <summary>Type '{1}' already reserves a member called '{0}' with the same parameter types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateParamName">
            <summary>The parameter name '{0}' is a duplicate</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateNameInNS">
            <summary>The namespace '{1}' already contains a definition for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateNameInClass">
            <summary>The type '{0}' already contains a definition for '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NameNotInContext">
            <summary>The name '{0}' does not exist in the current context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NameNotInContextPossibleMissingReference">
            <summary>The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigContext">
            <summary>'{0}' is an ambiguous reference between '{1}' and '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateUsing">
            <summary>The using directive for '{0}' appeared previously in this namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateUsing_Title">
            <summary>Using directive appeared previously in this namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadMemberFlag">
            <summary>The modifier '{0}' is not valid for this item</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadInitAccessor">
            <summary>The 'init' accessor is not valid on static members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadMemberProtection">
            <summary>More than one protection modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewRequired">
            <summary>'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewRequired_Title">
            <summary>Member hides inherited member; missing new keyword</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewRequired_Description">
            <summary>A variable was declared with the same name as a variable in a base type. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewNotRequired">
            <summary>The member '{0}' does not hide an accessible member. The new keyword is not required.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewNotRequired_Title">
            <summary>Member does not hide an inherited member; new keyword is not required</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CircConstValue">
            <summary>The evaluation of the constant value for '{0}' involves a circular definition</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberAlreadyExists">
            <summary>Type '{1}' already defines a member called '{0}' with the same parameter types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticNotVirtual">
            <summary>A static member cannot be marked as '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideNotNew">
            <summary>A member '{0}' marked as override cannot be marked as new or virtual</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewOrOverrideExpected">
            <summary>'{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewOrOverrideExpected_Title">
            <summary>Member hides inherited member; missing override keyword</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideNotExpected">
            <summary>'{0}': no suitable method found to override</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamespaceUnexpected">
            <summary>A namespace cannot directly contain members such as fields, methods or statements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoSuchMember">
            <summary>'{0}' does not contain a definition for '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadSKknown">
            <summary>'{0}' is a {1} but is used like a {2}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadSKunknown">
            <summary>'{0}' is a {1}, which is not valid in the given context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ObjectRequired">
            <summary>An object reference is required for the non-static field, method, or property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigCall">
            <summary>The call is ambiguous between the following methods or properties: '{0}' and '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAccess">
            <summary>'{0}' is inaccessible due to its protection level</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethDelegateMismatch">
            <summary>No overload for '{0}' matches delegate '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RetObjectRequired">
            <summary>An object of a type convertible to '{0}' is required</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RetNoObjectRequired">
            <summary>Since '{0}' returns void, a return keyword must not be followed by an object expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LocalDuplicate">
            <summary>A local variable or function named '{0}' is already defined in this scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgLvalueExpected">
            <summary>The left-hand side of an assignment must be a variable, property or indexer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticConstParam">
            <summary>'{0}': a static constructor must be parameterless</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotConstantExpression">
            <summary>The expression being assigned to '{0}' must be constant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotNullConstRefField">
            <summary>'{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LocalIllegallyOverrides">
            <summary>A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadUsingNamespace">
            <summary>A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadUsingType">
            <summary>A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoAliasHere">
            <summary>A 'using static' directive cannot be used to declare an alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoBreakOrCont">
            <summary>No enclosing loop out of which to break or continue</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateLabel">
            <summary>The label '{0}' is a duplicate</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConstructors">
            <summary>The type '{0}' has no constructors defined</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoNewAbstract">
            <summary>Cannot create an instance of the abstract type or interface '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstValueRequired">
            <summary>A const field requires a value to be provided</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CircularBase">
            <summary>Circular base type dependency involving '{0}' and '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDelegateConstructor">
            <summary>The delegate '{0}' does not have a valid constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethodNameExpected">
            <summary>Method name expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstantExpected">
            <summary>A constant value is expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_V6SwitchGoverningTypeValueExpected">
            <summary>A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IntegralTypeValueExpected">
            <summary>A value of an integral type expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateCaseLabel">
            <summary>The switch statement contains multiple cases with the label value '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidGotoCase">
            <summary>A goto case is only valid inside a switch statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PropertyLacksGet">
            <summary>The property or indexer '{0}' cannot be used in this context because it lacks the get accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadExceptionType">
            <summary>The type caught or thrown must be derived from System.Exception</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadEmptyThrow">
            <summary>A throw statement with no arguments is not allowed outside of a catch clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadFinallyLeave">
            <summary>Control cannot leave the body of a finally clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LabelShadow">
            <summary>The label '{0}' shadows another label by the same name in a contained scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LabelNotFound">
            <summary>No such label '{0}' within the scope of the goto statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnreachableCatch">
            <summary>A previous catch clause already catches all exceptions of this or of a super type ('{0}')</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FilterIsConstantTrue">
            <summary>Filter expression is a constant 'true', consider removing the filter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FilterIsConstantTrue_Title">
            <summary>Filter expression is a constant 'true'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReturnExpected">
            <summary>'{0}': not all code paths return a value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreachableCode">
            <summary>Unreachable code detected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreachableCode_Title">
            <summary>Unreachable code detected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchFallThrough">
            <summary>Control cannot fall through from one case label ('{0}') to another</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedLabel">
            <summary>This label has not been referenced</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedLabel_Title">
            <summary>This label has not been referenced</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolation">
            <summary>Use of unassigned local variable '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolation">
            <summary>Use of unassigned local variable '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolation_Title">
            <summary>Use of unassigned local variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedVar">
            <summary>The variable '{0}' is declared but never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedVar_Title">
            <summary>Variable is declared but never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedField">
            <summary>The field '{0}' is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedField_Title">
            <summary>Field is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolationField">
            <summary>Use of possibly unassigned field '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationField">
            <summary>Use of possibly unassigned field '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationField_Title">
            <summary>Use of possibly unassigned field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolationProperty">
            <summary>Use of possibly unassigned auto-implemented property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationProperty">
            <summary>Use of possibly unassigned auto-implemented property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationProperty_Title">
            <summary>Use of possibly unassigned auto-implemented property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnassignedThisUnsupportedVersion">
            <summary>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedThisUnsupportedVersion">
            <summary>Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedThisUnsupportedVersion_Title">
            <summary>Fields of a struct must be fully assigned in a constructor before control is returned to the caller. Consider updating the language version to auto-default the field.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigQM">
            <summary>Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidQM">
            <summary>Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoBaseClass">
            <summary>A base class is required for a 'base' reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BaseIllegal">
            <summary>Use of keyword 'base' is not valid in this context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ObjectProhibited">
            <summary>Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParamUnassigned">
            <summary>The out parameter '{0}' must be assigned to before control leaves the current method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParamUnassigned">
            <summary>The out parameter '{0}' must be assigned to before control leaves the current method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParamUnassigned_Title">
            <summary>An out parameter must be assigned to before control leaves the method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidArray">
            <summary>Invalid rank specifier: expected ',' or ']'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExternHasBody">
            <summary>'{0}' cannot be extern and declare a body</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExternHasConstructorInitializer">
            <summary>'{0}' cannot be extern and have a constructor initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractAndExtern">
            <summary>'{0}' cannot be both extern and abstract</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAttributeParamType">
            <summary>Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAttributeArgument">
            <summary>An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAttributeParamDefaultArgument">
            <summary>Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsAlwaysTrue">
            <summary>The given expression is always of the provided ('{0}') type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsAlwaysTrue_Title">
            <summary>'is' expression's given expression is always of the provided type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsAlwaysFalse">
            <summary>The given expression is never of the provided ('{0}') type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsAlwaysFalse_Title">
            <summary>'is' expression's given expression is never of the provided type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LockNeedsReference">
            <summary>'{0}' is not a reference type as required by the lock statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NullNotValid">
            <summary>Use of null is not valid in this context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultLiteralNotValid">
            <summary>Use of default literal is not valid in this context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolationThisUnsupportedVersion">
            <summary>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationThisUnsupportedVersion">
            <summary>The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationThisUnsupportedVersion_Title">
            <summary>The 'this' object cannot be used in a constructor before all of its fields have been assigned. Consider updating the language version to auto-default the unassigned fields.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArgsInvalid">
            <summary>The __arglist construct is valid only within a variable argument method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PtrExpected">
            <summary>The * or -&gt; operator must be applied to a pointer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PtrIndexSingle">
            <summary>A pointer must be indexed by only one value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ByRefNonAgileField">
            <summary>Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ByRefNonAgileField_Title">
            <summary>Using a field of a marshal-by-reference class as a ref or out value or taking its address may cause a runtime exception</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyStatic">
            <summary>A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyStatic">
            <summary>A static readonly field cannot be used as a ref or out value (except in a static constructor)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyProp">
            <summary>Property or indexer '{0}' cannot be assigned to -- it is read only</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalStatement">
            <summary>Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadGetEnumerator">
            <summary>foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadGetAsyncEnumerator">
            <summary>Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TooManyLocals">
            <summary>Only 65534 locals, including those generated by the compiler, are allowed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractBaseCall">
            <summary>Cannot call an abstract base member: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefProperty">
            <summary>A property or indexer may not be passed as an out or ref parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ManagedAddr">
            <summary>Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ManagedAddr">
            <summary>This takes the address of, gets the size of, or declares a pointer to a managed type ('{0}')</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ManagedAddr_Title">
            <summary>This takes the address of, gets the size of, or declares a pointer to a managed type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadFixedInitType">
            <summary>The type of a local declared in a fixed statement must be a pointer type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedMustInit">
            <summary>You must provide an initializer in a fixed or using statement declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAddrOp">
            <summary>Cannot take the address of the given expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedNeeded">
            <summary>You can only take the address of an unfixed expression inside of a fixed statement initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedNotNeeded">
            <summary>You cannot use the fixed statement to take the address of an already fixed expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExprCannotBeFixed">
            <summary>The given expression cannot be used in a fixed statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsafeNeeded">
            <summary>Pointers and fixed size buffers may only be used in an unsafe context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OpTFRetType">
            <summary>The return type of operator True or False must be bool</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OperatorNeedsMatch">
            <summary>The operator '{0}' requires a matching operator '{1}' to also be defined</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBoolOp">
            <summary>In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MustHaveOpTF">
            <summary>In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedVarAssg">
            <summary>The variable '{0}' is assigned but its value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedVarAssg_Title">
            <summary>Variable is assigned but its value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CheckedOverflow">
            <summary>The operation overflows at compile time in checked mode</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstOutOfRangeChecked">
            <summary>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVarargs">
            <summary>A method with vararg cannot be generic, be in a generic type, or have a params parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParamsMustBeArray">
            <summary>The params parameter must be a single dimensional array</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalArglist">
            <summary>An __arglist expression may only appear inside of a call or new expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalUnsafe">
            <summary>Unsafe code may only appear if compiling with /unsafe</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigMember">
            <summary>Ambiguity between '{0}' and '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadForeachDecl">
            <summary>Type and identifier are both required in a foreach statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParamsLast">
            <summary>A params parameter must be the last parameter in a parameter list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SizeofUnsafe">
            <summary>'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DottedTypeNameNotFoundInNS">
            <summary>The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldInitRefNonstatic">
            <summary>A field initializer cannot reference the non-static field, method, or property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SealedNonOverride">
            <summary>'{0}' cannot be sealed because it is not an override</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideSealed">
            <summary>'{0}': cannot override inherited member '{1}' because it is sealed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VoidError">
            <summary>The operation in question is undefined on void pointers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalOnOverride">
            <summary>The Conditional attribute is not valid on '{0}' because it is an override method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalOnLocalFunction">
            <summary>Local function '{0}' must be 'static' in order to use the Conditional attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PointerInAsOrIs">
            <summary>Neither 'is' nor 'as' is valid on pointer types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CallingFinalizeDeprecated">
            <summary>Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SingleTypeNameNotFound">
            <summary>The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NegativeStackAllocSize">
            <summary>Cannot use a negative size with stackalloc</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NegativeArraySize">
            <summary>Cannot create an array with a negative size</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideFinalizeDeprecated">
            <summary>Do not override object.Finalize. Instead, provide a destructor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CallingBaseFinalizeDeprecated">
            <summary>Do not directly call your base type Finalize method. It is called automatically from your destructor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NegativeArrayIndex">
            <summary>Indexing an array with a negative index (array indices always start at zero)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NegativeArrayIndex_Title">
            <summary>Indexing an array with a negative index</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRefCompareLeft">
            <summary>Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRefCompareLeft_Title">
            <summary>Possible unintended reference comparison; left hand side needs cast</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRefCompareRight">
            <summary>Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRefCompareRight_Title">
            <summary>Possible unintended reference comparison; right hand side needs cast</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCastInFixed">
            <summary>The right hand side of a fixed statement assignment may not be a cast expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StackallocInCatchFinally">
            <summary>stackalloc may not be used in a catch or finally block</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarargsLast">
            <summary>An __arglist parameter must be the last parameter in a parameter list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingPartial">
            <summary>Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialTypeKindConflict">
            <summary>Partial declarations of '{0}' must be all classes, all record classes, all structs, all record structs, or all interfaces</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialModifierConflict">
            <summary>Partial declarations of '{0}' have conflicting accessibility modifiers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMultipleBases">
            <summary>Partial declarations of '{0}' must not specify different base classes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialWrongTypeParams">
            <summary>Partial declarations of '{0}' must have the same type parameter names in the same order</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialWrongConstraints">
            <summary>Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoImplicitConvCast">
            <summary>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMisplaced">
            <summary>The 'partial' modifier can only appear immediately before 'class', 'record', 'struct', 'interface', or a method return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImportedCircularBase">
            <summary>Imported type '{0}' is invalid. It contains a circular base type dependency.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolationOut">
            <summary>Use of unassigned out parameter '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationOut">
            <summary>Use of unassigned out parameter '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationOut_Title">
            <summary>Use of unassigned out parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArraySizeInDeclaration">
            <summary>Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InaccessibleGetter">
            <summary>The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InaccessibleSetter">
            <summary>The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidPropertyAccessMod">
            <summary>The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicatePropertyAccessMods">
            <summary>Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AccessModMissingAccessor">
            <summary>'{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnimplementedInterfaceAccessor">
            <summary>'{0}' does not implement interface member '{1}'. '{2}' is not public.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternIsAmbiguous">
            <summary>'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternIsAmbiguous_Title">
            <summary>Type does not implement the collection pattern; members are ambiguous</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternNotPublicOrNotInstance">
            <summary>'{0}' does not implement the '{1}' pattern. '{2}' is not a public instance or extension method.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternNotPublicOrNotInstance_Title">
            <summary>Type does not implement the collection pattern; member is is not a public instance or extension method.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternBadSignature">
            <summary>'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternBadSignature_Title">
            <summary>Type does not implement the collection pattern; member has the wrong signature</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FriendRefNotEqualToThis">
            <summary>Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FriendRefSigningMismatch">
            <summary>Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SequentialOnPartialClass">
            <summary>There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SequentialOnPartialClass_Title">
            <summary>There is no defined ordering between fields in multiple declarations of partial struct</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadConstType">
            <summary>The type '{0}' cannot be declared const</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoNewTyvar">
            <summary>Cannot create an instance of the variable type '{0}' because it does not have the new() constraint</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArity">
            <summary>Using the generic {1} '{0}' requires {2} type arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadTypeArgument">
            <summary>The type '{0}' may not be used as a type argument</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeArgsNotAllowed">
            <summary>The {1} '{0}' cannot be used with type arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_HasNoTypeVars">
            <summary>The non-generic {1} '{0}' cannot be used with type arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewConstraintNotSatisfied">
            <summary>'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericConstraintNotSatisfiedRefType">
            <summary>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericConstraintNotSatisfiedNullableEnum">
            <summary>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericConstraintNotSatisfiedNullableInterface">
            <summary>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericConstraintNotSatisfiedTyVar">
            <summary>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericConstraintNotSatisfiedValType">
            <summary>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateGeneratedName">
            <summary>The parameter name '{0}' conflicts with an automatically-generated parameter name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalSingleTypeNameNotFound">
            <summary>The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewBoundMustBeLast">
            <summary>The new() constraint must be the last constraint specified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MainCantBeGeneric">
            <summary>'{0}': an entry point cannot be generic or in a generic type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MainCantBeGeneric_Title">
            <summary>An entry point cannot be generic or in a generic type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeVarCantBeNull">
            <summary>Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateBound">
            <summary>Duplicate constraint '{0}' for type parameter '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ClassBoundNotFirst">
            <summary>The class type constraint '{0}' must come before any other constraints</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadRetType">
            <summary>'{1} {0}' has the wrong return type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DelegateRefMismatch">
            <summary>Ref mismatch between '{0}' and delegate '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateConstraintClause">
            <summary>A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantInferMethTypeArgs">
            <summary>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LocalSameNameAsTypeParam">
            <summary>'{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AsWithTypeVar">
            <summary>The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedFieldAssg">
            <summary>The field '{0}' is assigned but its value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedFieldAssg_Title">
            <summary>Field is assigned but its value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIndexerNameAttr">
            <summary>The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttrArgWithTypeVars">
            <summary>'{0}': an attribute argument cannot use type parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttrTypeArgCannotBeTypeVar">
            <summary>'{0}': an attribute type argument cannot use type parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AttrDependentTypeNotAllowed">
            <summary>Type '{0}' cannot be used in this context because it cannot be represented in metadata.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AttrDependentTypeNotAllowed_Title">
            <summary>Type cannot be used in this context because it cannot be represented in metadata.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttrDependentTypeNotAllowed">
            <summary>Type '{0}' cannot be used in this context because it cannot be represented in metadata.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewTyvarWithArgs">
            <summary>'{0}': cannot provide arguments when creating an instance of a variable type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractSealedStatic">
            <summary>'{0}': an abstract type cannot be sealed or static</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AmbiguousXMLReference">
            <summary>Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AmbiguousXMLReference_Title">
            <summary>Ambiguous reference in cref attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_VolatileByRef">
            <summary>'{0}': a reference to a volatile field will not be treated as volatile</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_VolatileByRef_Title">
            <summary>A reference to a volatile field will not be treated as volatile</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_VolatileByRef_Description">
            <summary>A volatile field should not normally be used as a ref or out value, since it will not be treated as volatile. There are exceptions to this, such as when calling an interlocked API.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComImportWithImpl">
            <summary>Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComImportWithBase">
            <summary>'{0}': a class with the ComImport attribute cannot specify a base class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplBadConstraints">
            <summary>The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplBadTupleNames">
            <summary>The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DottedTypeNameNotFoundInAgg">
            <summary>The type name '{0}' does not exist in the type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethGrpToNonDel">
            <summary>Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MethGrpToNonDel">
            <summary>Converting method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MethGrpToNonDel_Title">
            <summary>Converting method group to non-delegate type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadExternAlias">
            <summary>The extern alias '{0}' was not specified in a /reference option</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ColColWithTypeAlias">
            <summary>Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AliasNotFound">
            <summary>Alias '{0}' not found</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SameFullNameAggAgg">
            <summary>The type '{1}' exists in both '{0}' and '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SameFullNameNsAgg">
            <summary>The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisNsAgg">
            <summary>The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisNsAgg_Title">
            <summary>Namespace conflicts with imported type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisAggAgg">
            <summary>The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisAggAgg_Title">
            <summary>Type conflicts with imported type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisAggNs">
            <summary>The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisAggNs_Title">
            <summary>Type conflicts with imported namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SameFullNameThisAggThisNs">
            <summary>The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExternAfterElements">
            <summary>An extern alias declaration must precede all other elements defined in the namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GlobalAliasDefn">
            <summary>Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GlobalAliasDefn_Title">
            <summary>Defining an alias named 'global' is ill-advised</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SealedStaticClass">
            <summary>'{0}': a type cannot be both static and sealed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PrivateAbstractAccessor">
            <summary>'{0}': abstract properties cannot have private accessors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ValueExpected">
            <summary>Syntax error; value expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnboxNotLValue">
            <summary>Cannot modify the result of an unboxing conversion</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonMethGrpInForEach">
            <summary>Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIncDecRetType">
            <summary>The return type for ++ or -- operator must match the parameter type or be derived from the parameter type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeConstraintsMustBeUniqueAndFirst">
            <summary>The 'class', 'struct', 'unmanaged', 'notnull', and 'default' constraints cannot be combined or duplicated, and must be specified first in the constraints list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefValBoundWithClass">
            <summary>'{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnmanagedBoundWithClass">
            <summary>'{0}': cannot specify both a constraint class and the 'unmanaged' constraint</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewBoundWithVal">
            <summary>The 'new()' constraint cannot be used with the 'struct' constraint</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefConstraintNotSatisfied">
            <summary>The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ValConstraintNotSatisfied">
            <summary>The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CircularConstraint">
            <summary>Circular constraint dependency involving '{0}' and '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BaseConstraintConflict">
            <summary>Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConWithValCon">
            <summary>Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigUDConv">
            <summary>Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AlwaysNull">
            <summary>The result of the expression is always 'null' of type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AlwaysNull_Title">
            <summary>The result of the expression is always 'null'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnThis">
            <summary>Cannot return 'this' by reference.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeCtorInParameter">
            <summary>Cannot use attribute constructor '{0}' because it has 'in' parameters.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideWithConstraints">
            <summary>Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigOverride">
            <summary>The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DecConstError">
            <summary>Evaluation of the decimal constant expression failed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CmpAlwaysFalse">
            <summary>Comparing with null of type '{0}' always produces 'false'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CmpAlwaysFalse_Title">
            <summary>Comparing with null of struct type always produces 'false'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FinalizeMethod">
            <summary>Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FinalizeMethod_Title">
            <summary>Introducing a 'Finalize' method can interfere with destructor invocation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FinalizeMethod_Description">
            <summary>This warning occurs when you create a class with a method whose signature is public virtual void Finalize.
            
            If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitImplParams">
            <summary>'{0}' should not have a params parameter since '{1}' does not</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GotoCaseShouldConvert">
            <summary>The 'goto case' value is not implicitly convertible to type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GotoCaseShouldConvert_Title">
            <summary>The 'goto case' value is not implicitly convertible to the switch type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethodImplementingAccessor">
            <summary>Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NubExprIsConstBool">
            <summary>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NubExprIsConstBool_Title">
            <summary>The result of the expression is always the same since a value of this type is never equal to 'null'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NubExprIsConstBool2">
            <summary>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NubExprIsConstBool2_Title">
            <summary>The result of the expression is always the same since a value of this type is never equal to 'null'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExplicitImplCollision">
            <summary>Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExplicitImplCollision_Title">
            <summary>Explicit interface implementation matches more than one interface member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractHasBody">
            <summary>'{0}' cannot declare a body because it is marked abstract</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConcreteMissingBody">
            <summary>'{0}' must declare a body because it is not marked abstract, extern, or partial</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractAndSealed">
            <summary>'{0}' cannot be both abstract and sealed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractNotVirtual">
            <summary>The abstract {0} '{1}' cannot be marked virtual</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticConstant">
            <summary>The constant '{0}' cannot be marked static</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideNonFunction">
            <summary>'{0}': cannot override because '{1}' is not a function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideNonVirtual">
            <summary>'{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantChangeAccessOnOverride">
            <summary>'{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantChangeTupleNamesOnOverride">
            <summary>'{0}': cannot change tuple element names when overriding inherited member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantChangeReturnTypeOnOverride">
            <summary>'{0}': return type must be '{2}' to match overridden member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantDeriveFromSealedType">
            <summary>'{0}': cannot derive from sealed type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractInConcreteClass">
            <summary>'{0}' is abstract but it is contained in non-abstract type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticConstructorWithExplicitConstructorCall">
            <summary>'{0}': static constructor cannot have an explicit 'this' or 'base' constructor call</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticConstructorWithAccessModifiers">
            <summary>'{0}': access modifiers are not allowed on static constructors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RecursiveConstructorCall">
            <summary>Constructor '{0}' cannot call itself</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndirectRecursiveConstructorCall">
            <summary>Constructor '{0}' cannot call itself through another constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ObjectCallingBaseConstructor">
            <summary>'{0}' has no base class and cannot call a base constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PredefinedTypeNotFound">
            <summary>Predefined type '{0}' is not defined or imported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PredefinedValueTupleTypeNotFound">
            <summary>Predefined type '{0}' is not defined or imported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PredefinedValueTupleTypeAmbiguous3">
            <summary>Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StructWithBaseConstructorCall">
            <summary>'{0}': structs cannot call base class constructors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StructLayoutCycle">
            <summary>Struct member '{0}' of type '{1}' causes a cycle in the struct layout</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfacesCantContainFields">
            <summary>Interfaces cannot contain instance fields</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfacesCantContainConstructors">
            <summary>Interfaces cannot contain instance constructors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NonInterfaceInInterfaceList">
            <summary>Type '{0}' in interface list is not an interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateInterfaceInBaseList">
            <summary>'{0}' is already listed in interface list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateInterfaceWithTupleNamesInBaseList">
            <summary>'{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateInterfaceWithDifferencesInBaseList">
            <summary>'{0}' is already listed in the interface list on type '{2}' as '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CycleInInterfaceInheritance">
            <summary>Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_HidingAbstractMethod">
            <summary>'{0}' hides inherited abstract member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnimplementedAbstractMethod">
            <summary>'{0}' does not implement inherited abstract member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnimplementedInterfaceMember">
            <summary>'{0}' does not implement interface member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ObjectCantHaveBases">
            <summary>The class System.Object cannot have a base class or implement an interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitInterfaceImplementationNotInterface">
            <summary>'{0}' in explicit interface declaration is not an interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfaceMemberNotFound">
            <summary>'{0}' in explicit interface declaration is not found among members of the interface that can be implemented</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ClassDoesntImplementInterface">
            <summary>'{0}': containing type does not implement interface '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitInterfaceImplementationInNonClassOrStruct">
            <summary>'{0}': explicit interface declaration can only be declared in a class, record, struct or interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberNameSameAsType">
            <summary>'{0}': member names cannot be the same as their enclosing type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EnumeratorOverflow">
            <summary>'{0}': the enumerator value is too large to fit in its type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideNonProperty">
            <summary>'{0}': cannot override because '{1}' is not a property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoGetToOverride">
            <summary>'{0}': cannot override because '{1}' does not have an overridable get accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoSetToOverride">
            <summary>'{0}': cannot override because '{1}' does not have an overridable set accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PropertyCantHaveVoidType">
            <summary>'{0}': property or indexer cannot have void type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PropertyWithNoAccessors">
            <summary>'{0}': property or indexer must have at least one accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantUseVoidInArglist">
            <summary>__arglist cannot have an argument of void type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewVirtualInSealed">
            <summary>'{0}' is a new virtual member in sealed type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitPropertyAddingAccessor">
            <summary>'{0}' adds an accessor not found in interface member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitPropertyMismatchInitOnly">
            <summary>Accessors '{0}' and '{1}' should both be init-only or neither</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitPropertyMissingAccessor">
            <summary>Explicit interface implementation '{0}' is missing accessor '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConversionWithInterface">
            <summary>'{0}': user-defined conversions to or from an interface are not allowed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConversionWithBase">
            <summary>'{0}': user-defined conversions to or from a base type are not allowed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConversionWithDerived">
            <summary>'{0}': user-defined conversions to or from a derived type are not allowed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IdentityConversion">
            <summary>User-defined operator cannot convert a type to itself</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConversionNotInvolvingContainedType">
            <summary>User-defined conversion must convert to or from the enclosing type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateConversionInClass">
            <summary>Duplicate user-defined conversion in type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OperatorsMustBeStatic">
            <summary>User-defined operator '{0}' must be declared static and public</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIncDecSignature">
            <summary>The parameter type for ++ or -- operator must be the containing type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadUnaryOperatorSignature">
            <summary>The parameter of a unary operator must be the containing type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBinaryOperatorSignature">
            <summary>One of the parameters of a binary operator must be the containing type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadShiftOperatorSignature">
            <summary>The first operand of an overloaded shift operator must have the same type as the containing type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfacesCantContainConversionOrEqualityOperators">
            <summary>Conversion, equality, or inequality operators declared in interfaces must be abstract or virtual</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EnumsCantContainDefaultConstructor">
            <summary>Enums cannot contain explicit parameterless constructors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideBogusMethod">
            <summary>'{0}': cannot override '{1}' because it is not supported by the language</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BindToBogus">
            <summary>'{0}' is not supported by the language</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantCallSpecialMethod">
            <summary>'{0}': cannot explicitly call operator or accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadTypeReference">
            <summary>'{0}': cannot reference a type through an expression; try '{1}' instead</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDestructorName">
            <summary>Name of destructor must match name of type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OnlyClassesCanContainDestructors">
            <summary>Only class types can contain destructors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConflictAliasAndMember">
            <summary>Namespace '{1}' contains a definition conflicting with alias '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConflictingAliasAndDefinition">
            <summary>Alias '{0}' conflicts with {1} definition</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalOnSpecialMethod">
            <summary>The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, lambda expression, or explicit interface implementation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalMustReturnVoid">
            <summary>The Conditional attribute is not valid on '{0}' because its return type is not void</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateAttribute">
            <summary>Duplicate '{0}' attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateAttributeInNetModule">
            <summary>Duplicate '{0}' attribute in '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalOnInterfaceMethod">
            <summary>The Conditional attribute is not valid on interface members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OperatorCantReturnVoid">
            <summary>User-defined operators cannot return void</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicConversion">
            <summary>'{0}': user-defined conversions to or from the dynamic type are not allowed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAttributeArgument">
            <summary>Invalid value for argument to '{0}' attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParameterNotValidForType">
            <summary>Parameter not valid for the specified unmanaged type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeParameterRequired1">
            <summary>Attribute parameter '{0}' must be specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeParameterRequired2">
            <summary>Attribute parameter '{0}' or '{1}' must be specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MarshalUnmanagedTypeNotValidForFields">
            <summary>Unmanaged type '{0}' not valid for fields.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MarshalUnmanagedTypeOnlyValidForFields">
            <summary>Unmanaged type '{0}' is only valid for fields.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeOnBadSymbolType">
            <summary>Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FloatOverflow">
            <summary>Floating-point constant is outside the range of type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComImportWithoutUuidAttribute">
            <summary>The Guid attribute must be specified with the ComImport attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidNamedArgument">
            <summary>Invalid value for named attribute argument '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DllImportOnInvalidMethod">
            <summary>The DllImport attribute must be specified on a method marked 'static' and 'extern'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EncUpdateFailedMissingAttribute">
            <summary>Cannot update '{0}'; attribute '{1}' is missing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DllImportOnGenericMethod">
            <summary>The DllImport attribute cannot be applied to a method that is generic or contained in a generic method or type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldCantBeRefAny">
            <summary>Field or property cannot be of type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldAutoPropCantBeByRefLike">
            <summary>Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayElementCantBeRefAny">
            <summary>Array elements cannot be of type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedSymbol">
            <summary>'{0}' is obsolete</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedSymbol_Title">
            <summary>Type or member is obsolete</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotAnAttributeClass">
            <summary>'{0}' is not an attribute class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNamedAttributeArgument">
            <summary>'{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedSymbolStr">
            <summary>'{0}' is obsolete: '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedSymbolStr_Title">
            <summary>Type or member is obsolete</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeprecatedSymbolStr">
            <summary>'{0}' is obsolete: '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndexerCantHaveVoidType">
            <summary>Indexers cannot have void type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VirtualPrivate">
            <summary>'{0}': virtual or abstract members cannot be private</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayInitToNonArrayType">
            <summary>Can only use array initializer expressions to assign to array types. Try using a new expression instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayInitInBadPlace">
            <summary>Array initializers can only be used in a variable or field initializer. Try using a new expression instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingStructOffset">
            <summary>'{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExternMethodNoImplementation">
            <summary>Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExternMethodNoImplementation_Title">
            <summary>Method, operator, or accessor is marked external and has no attributes on it</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ProtectedInSealed">
            <summary>'{0}': new protected member declared in sealed type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ProtectedInSealed_Title">
            <summary>New protected member declared in sealed type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfaceImplementedByConditional">
            <summary>Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfaceImplementedImplicitlyByVariadic">
            <summary>'{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalRefParam">
            <summary>ref and out are not valid in this context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgumentToAttribute">
            <summary>The argument to the '{0}' attribute must be a valid identifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StructOffsetOnBadStruct">
            <summary>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StructOffsetOnBadField">
            <summary>The FieldOffset attribute is not allowed on static or const fields</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeUsageOnNonAttributeClass">
            <summary>Attribute '{0}' is only valid on classes derived from System.Attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PossibleMistakenNullStatement">
            <summary>Possible mistaken empty statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PossibleMistakenNullStatement_Title">
            <summary>Possible mistaken empty statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateNamedAttributeArgument">
            <summary>'{0}' duplicate named attribute argument</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeriveFromEnumOrValueType">
            <summary>'{0}' cannot derive from special class '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultMemberOnIndexedType">
            <summary>Cannot specify the DefaultMember attribute on a type containing an indexer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BogusType">
            <summary>'{0}' is a type not supported by the language</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedInternalField">
            <summary>Field '{0}' is never assigned to, and will always have its default value {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedInternalField_Title">
            <summary>Field is never assigned to, and will always have its default value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CStyleArray">
            <summary>Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_VacuousIntegralComp">
            <summary>Comparison to integral constant is useless; the constant is outside the range of type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_VacuousIntegralComp_Title">
            <summary>Comparison to integral constant is useless; the constant is outside the range of the type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractAttributeClass">
            <summary>Cannot apply attribute class '{0}' because it is abstract</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNamedAttributeArgumentType">
            <summary>'{0}' is not a valid named attribute argument because it is not a valid attribute parameter type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingPredefinedMember">
            <summary>Missing compiler required member '{0}.{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AttributeLocationOnBadDeclaration">
            <summary>'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AttributeLocationOnBadDeclaration_Title">
            <summary>Not a valid attribute location for this declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidAttributeLocation">
            <summary>'{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidAttributeLocation_Title">
            <summary>Not a recognized attribute location</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualsWithoutGetHashCode">
            <summary>'{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualsWithoutGetHashCode_Title">
            <summary>Type overrides Object.Equals(object o) but does not override Object.GetHashCode()</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualityOpWithoutEquals">
            <summary>'{0}' defines operator == or operator != but does not override Object.Equals(object o)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualityOpWithoutEquals_Title">
            <summary>Type defines operator == or operator != but does not override Object.Equals(object o)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualityOpWithoutGetHashCode">
            <summary>'{0}' defines operator == or operator != but does not override Object.GetHashCode()</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualityOpWithoutGetHashCode_Title">
            <summary>Type defines operator == or operator != but does not override Object.GetHashCode()</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OutAttrOnRefParam">
            <summary>Cannot specify the Out attribute on a ref parameter without also specifying the In attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverloadRefKind">
            <summary>'{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LiteralDoubleCast">
            <summary>Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IncorrectBooleanAssg">
            <summary>Assignment in conditional expression is always constant; did you mean to use == instead of = ?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IncorrectBooleanAssg_Title">
            <summary>Assignment in conditional expression is always constant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ProtectedInStruct">
            <summary>'{0}': new protected member declared in struct</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InconsistentIndexerNames">
            <summary>Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComImportWithUserCtor">
            <summary>A class with the ComImport attribute cannot have a user-defined constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldCantHaveVoidType">
            <summary>Field cannot have void type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NonObsoleteOverridingObsolete">
            <summary>Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NonObsoleteOverridingObsolete_Title">
            <summary>Member overrides obsolete member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SystemVoid">
            <summary>System.Void cannot be used from C# -- use typeof(void) to get the void type object</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitParamArray">
            <summary>Do not use 'System.ParamArrayAttribute'. Use the 'params' keyword instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BitwiseOrSignExtend">
            <summary>Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BitwiseOrSignExtend_Title">
            <summary>Bitwise-or operator used on a sign-extended operand</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BitwiseOrSignExtend_Description">
            <summary>The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VolatileStruct">
            <summary>'{0}': a volatile field cannot be of the type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VolatileAndReadonly">
            <summary>'{0}': a field cannot be both volatile and readonly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractField">
            <summary>The modifier 'abstract' is not valid on fields. Try using a property instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BogusExplicitImpl">
            <summary>'{0}' cannot implement '{1}' because it is not supported by the language</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitMethodImplAccessor">
            <summary>'{0}' explicit method implementation cannot implement '{1}' because it is an accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CoClassWithoutComImport">
            <summary>'{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CoClassWithoutComImport_Title">
            <summary>Interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalWithOutParam">
            <summary>Conditional member '{0}' cannot have an out parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AccessorImplementingMethod">
            <summary>Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AliasQualAsExpression">
            <summary>The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DerivingFromATyVar">
            <summary>Cannot derive from '{0}' because it is a type parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateTypeParameter">
            <summary>Duplicate type parameter '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TypeParameterSameAsOuterTypeParameter">
            <summary>Type parameter '{0}' has the same name as the type parameter from outer type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TypeParameterSameAsOuterTypeParameter_Title">
            <summary>Type parameter has the same name as the type parameter from outer type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TypeParameterSameAsOuterMethodTypeParameter">
            <summary>Type parameter '{0}' has the same name as the type parameter from outer method '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TypeParameterSameAsOuterMethodTypeParameter_Title">
            <summary>Type parameter has the same type as the type parameter from outer method.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeVariableSameAsParent">
            <summary>Type parameter '{0}' has the same name as the containing type, or method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnifyingInterfaceInstantiations">
            <summary>'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TyVarNotFoundInConstraint">
            <summary>'{1}' does not define type parameter '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBoundType">
            <summary>'{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SpecialTypeAsBound">
            <summary>Constraint cannot be special class '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisBound">
            <summary>Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LookupInTypeVariable">
            <summary>Cannot do non-virtual member lookup in '{0}' because it is a type parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadConstraintType">
            <summary>Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InstanceMemberInStaticClass">
            <summary>'{0}': cannot declare instance members in a static class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticBaseClass">
            <summary>'{1}': cannot derive from static class '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstructorInStaticClass">
            <summary>Static classes cannot have instance constructors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DestructorInStaticClass">
            <summary>Static classes cannot contain destructors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InstantiatingStaticClass">
            <summary>Cannot create an instance of the static class '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticDerivedFromNonObject">
            <summary>Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticClassInterfaceImpl">
            <summary>'{0}': static classes cannot implement interfaces</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefStructInterfaceImpl">
            <summary>'{0}': ref structs cannot implement interfaces</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OperatorInStaticClass">
            <summary>'{0}': static classes cannot contain user-defined operators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConvertToStaticClass">
            <summary>Cannot convert to static type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstraintIsStaticClass">
            <summary>'{0}': static classes cannot be used as constraints</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericArgIsStaticClass">
            <summary>'{0}': static types cannot be used as type arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayOfStaticClass">
            <summary>'{0}': array elements cannot be of static type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndexerInStaticClass">
            <summary>'{0}': cannot declare indexers in a static class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParameterIsStaticClass">
            <summary>'{0}': static types cannot be used as parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParameterIsStaticClass">
            <summary>'{0}': static types cannot be used as parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParameterIsStaticClass_Title">
            <summary>Static types cannot be used as parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReturnTypeIsStaticClass">
            <summary>'{0}': static types cannot be used as return types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReturnTypeIsStaticClass">
            <summary>'{0}': static types cannot be used as return types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReturnTypeIsStaticClass_Title">
            <summary>Static types cannot be used as return types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarDeclIsStaticClass">
            <summary>Cannot declare a variable of static type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadEmptyThrowInFinally">
            <summary>A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidSpecifier">
            <summary>'{0}' is not a valid format specifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssignmentToLockOrDispose">
            <summary>Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssignmentToLockOrDispose_Title">
            <summary>Possibly incorrect assignment to local which is the argument to a using or lock statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForwardedTypeInThisAssembly">
            <summary>Type '{0}' is defined in this assembly, but a type forwarder is specified for it</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForwardedTypeIsNested">
            <summary>Cannot forward type '{0}' because it is a nested type of '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CycleInTypeForwarder">
            <summary>The type forwarder for type '{0}' in assembly '{1}' causes a cycle</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssemblyNameOnNonModule">
            <summary>The /moduleassemblyname option may only be specified when building a target type of 'module'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAssemblyName">
            <summary>Assembly reference '{0}' is invalid and cannot be resolved</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidFwdType">
            <summary>Invalid type specified as an argument for TypeForwardedTo attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloseUnimplementedInterfaceMemberStatic">
            <summary>'{0}' does not implement instance interface member '{1}'. '{2}' cannot implement the interface member because it is static.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloseUnimplementedInterfaceMemberNotPublic">
            <summary>'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloseUnimplementedInterfaceMemberWrongReturnType">
            <summary>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateTypeForwarder">
            <summary>'{0}' duplicate TypeForwardedToAttribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedSelectOrGroup">
            <summary>A query body must end with a select clause or a group clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedContextualKeywordOn">
            <summary>Expected contextual keyword 'on'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedContextualKeywordEquals">
            <summary>Expected contextual keyword 'equals'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedContextualKeywordBy">
            <summary>Expected contextual keyword 'by'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAnonymousTypeMemberDeclarator">
            <summary>Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidInitializerElementInitializer">
            <summary>Invalid initializer member declarator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InconsistentLambdaParameterUsage">
            <summary>Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodInvalidModifier">
            <summary>A partial method cannot have the 'abstract' modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodOnlyInPartialClass">
            <summary>A partial method must be declared within a partial type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodNotExplicit">
            <summary>A partial method may not explicitly implement an interface method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodExtensionDifference">
            <summary>Both partial method declarations must be extension methods or neither may be an extension method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodOnlyOneLatent">
            <summary>A partial method may not have multiple defining declarations</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodOnlyOneActual">
            <summary>A partial method may not have multiple implementing declarations</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodParamsDifference">
            <summary>Both partial method declarations must use a params parameter or neither may use a params parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodMustHaveLatent">
            <summary>No defining declaration found for implementing declaration of partial method '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodInconsistentTupleNames">
            <summary>Both partial method declarations, '{0}' and '{1}', must use the same tuple element names.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodInconsistentConstraints">
            <summary>Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodToDelegate">
            <summary>Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodStaticDifference">
            <summary>Both partial method declarations must be static or neither may be static</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodUnsafeDifference">
            <summary>Both partial method declarations must be unsafe or neither may be unsafe</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodInExpressionTree">
            <summary>Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ObsoleteOverridingNonObsolete">
            <summary>Obsolete member '{0}' overrides non-obsolete member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ObsoleteOverridingNonObsolete_Title">
            <summary>Obsolete member overrides non-obsolete member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DebugFullNameTooLong">
            <summary>The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DebugFullNameTooLong_Title">
            <summary>Fully qualified name is too long for debug information</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedVariableAssignedBadValue">
            <summary>Cannot assign {0} to an implicitly-typed variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedVariableWithNoInitializer">
            <summary>Implicitly-typed variables must be initialized</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedVariableMultipleDeclarator">
            <summary>Implicitly-typed variables cannot have multiple declarators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedVariableAssignedArrayInitializer">
            <summary>Cannot initialize an implicitly-typed variable with an array initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedLocalCannotBeFixed">
            <summary>Implicitly-typed local variables cannot be fixed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedVariableCannotBeConst">
            <summary>Implicitly-typed variables cannot be constant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExternCtorNoImplementation">
            <summary>Constructor '{0}' is marked external</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExternCtorNoImplementation_Title">
            <summary>Constructor is marked external</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeVarNotFound">
            <summary>The contextual keyword 'var' may only appear within a local variable declaration or in script code</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedArrayNoBestType">
            <summary>No best type found for implicitly-typed array</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonymousTypePropertyAssignedBadValue">
            <summary>Cannot assign '{0}' to anonymous type property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsBaseAccess">
            <summary>An expression tree may not contain a base access</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsTupleBinOp">
            <summary>An expression tree may not contain a tuple == or != operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsAssignment">
            <summary>An expression tree may not contain an assignment operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonymousTypeDuplicatePropertyName">
            <summary>An anonymous type cannot have multiple properties with the same name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StatementLambdaToExpressionTree">
            <summary>A lambda expression with a statement body cannot be converted to an expression tree</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeMustHaveDelegate">
            <summary>Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonymousTypeNotAvailable">
            <summary>Cannot use anonymous type in a constant expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LambdaInIsAs">
            <summary>The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypelessTupleInAs">
            <summary>The first operand of an 'as' operator may not be a tuple literal without a natural type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer">
            <summary>An expression tree may not contain a multidimensional array initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingArgument">
            <summary>Argument missing</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VariableUsedBeforeDeclaration">
            <summary>Cannot use local variable '{0}' before it is declared</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RecursivelyTypedVariable">
            <summary>Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnassignedThisAutoPropertyUnsupportedVersion">
            <summary>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedThisAutoPropertyUnsupportedVersion">
            <summary>Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedThisAutoPropertyUnsupportedVersion_Title">
            <summary>An auto-implemented property must be fully assigned before control is returned to the caller. Consider updating the language version to auto-default the property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VariableUsedBeforeDeclarationAndHidesField">
            <summary>Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsBadCoalesce">
            <summary>An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IdentifierExpected">
            <summary>Identifier expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SemicolonExpected">
            <summary>; expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SyntaxError">
            <summary>Syntax error, '{0}' expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateModifier">
            <summary>Duplicate '{0}' modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateAccessor">
            <summary>Property accessor already defined</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IntegralTypeExpected">
            <summary>Type byte, sbyte, short, ushort, int, uint, long, or ulong expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalEscape">
            <summary>Unrecognized escape sequence</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewlineInConst">
            <summary>Newline in constant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EmptyCharConst">
            <summary>Empty character literal</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TooManyCharsInConst">
            <summary>Too many characters in character literal</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidNumber">
            <summary>Invalid number</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GetOrSetExpected">
            <summary>A get or set accessor expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ClassTypeExpected">
            <summary>An object, string, or class type expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamedArgumentExpected">
            <summary>Named attribute argument expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TooManyCatches">
            <summary>Catch clauses cannot follow the general catch clause of a try statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ThisOrBaseExpected">
            <summary>Keyword 'this' or 'base' expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OvlUnaryOperatorExpected">
            <summary>Overloadable unary operator expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OvlBinaryOperatorExpected">
            <summary>Overloadable binary operator expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IntOverflow">
            <summary>Integral constant is too large</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EOFExpected">
            <summary>Type or namespace definition, or end-of-file expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalDefinitionOrStatementExpected">
            <summary>Member definition, statement, or end-of-file expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadEmbeddedStmt">
            <summary>Embedded statement cannot be a declaration or labeled statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PPDirectiveExpected">
            <summary>Preprocessor directive expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EndOfPPLineExpected">
            <summary>Single-line comment or end-of-line expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloseParenExpected">
            <summary>) expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EndifDirectiveExpected">
            <summary>#endif directive expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedDirective">
            <summary>Unexpected preprocessor directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ErrorDirective">
            <summary>#error: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_WarningDirective">
            <summary>#warning: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_WarningDirective_Title">
            <summary>#warning directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeExpected">
            <summary>Type expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PPDefFollowsToken">
            <summary>Cannot define/undefine preprocessor symbols after first token in file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PPReferenceFollowsToken">
            <summary>Cannot use #r after first token in file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OpenEndedComment">
            <summary>End-of-file found, '*/' expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_Merge_conflict_marker_encountered">
            <summary>Merge conflict marker encountered</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoRefOutWhenRefOnly">
            <summary>Do not use refout when using refonly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoNetModuleOutputWhenRefOutOrRefOnly">
            <summary>Cannot compile net modules when using /refout or /refonly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OvlOperatorExpected">
            <summary>Overloadable operator expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EndRegionDirectiveExpected">
            <summary>#endregion directive expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnterminatedStringLit">
            <summary>Unterminated string literal</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDirectivePlacement">
            <summary>Preprocessor directives must appear as the first non-whitespace character on a line</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IdentifierExpectedKW">
            <summary>Identifier expected; '{1}' is a keyword</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SemiOrLBraceExpected">
            <summary>{ or ; expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultiTypeInDeclaration">
            <summary>Cannot use more than one type in a for, using, fixed, or declaration statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AddOrRemoveExpected">
            <summary>An add or remove accessor expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedCharacter">
            <summary>Unexpected character '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedToken">
            <summary>Unexpected token '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ProtectedInStatic">
            <summary>'{0}': static classes cannot contain protected members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreachableGeneralCatch">
            <summary>A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreachableGeneralCatch_Title">
            <summary>A previous catch clause already catches all exceptions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreachableGeneralCatch_Description">
            <summary>This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.
            
            A catch() block after a catch (System.Exception e) block can ca ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IncrementLvalueExpected">
            <summary>The operand of an increment or decrement operator must be a variable, property or indexer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoSuchMemberOrExtension">
            <summary>'{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoSuchMemberOrExtensionNeedUsing">
            <summary>'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadThisParam">
            <summary>Method '{0}' has a parameter modifier 'this' which is not on the first parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadParameterModifiers">
            <summary>The parameter modifier '{0}' cannot be used with '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadTypeforThis">
            <summary>The first parameter of an extension method cannot be of type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadParamModThis">
            <summary>A parameter array cannot be used with 'this' modifier on an extension method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadExtensionMeth">
            <summary>Extension method must be static</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadExtensionAgg">
            <summary>Extension method must be defined in a non-generic static class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DupParamMod">
            <summary>A parameter can only have one '{0}' modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExtensionMethodsDecl">
            <summary>Extension methods must be defined in a top level static class; {0} is a nested class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExtensionAttrNotFound">
            <summary>Cannot define a new extension method because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitExtension">
            <summary>Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitDynamicAttr">
            <summary>Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoDynamicPhantomOnBaseCtor">
            <summary>The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ValueTypeExtDelegate">
            <summary>Extension method '{0}' defined on value type '{1}' cannot be used to create delegates</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgCount">
            <summary>No overload for method '{0}' takes {1} arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgType">
            <summary>Argument {0}: cannot convert from '{1}' to '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoSourceFile">
            <summary>Source file '{0}' could not be opened -- {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantRefResource">
            <summary>Cannot link resource files when building a module</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ResourceNotUnique">
            <summary>Resource identifier '{0}' has already been used in this assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ResourceFileNameNotUnique">
            <summary>Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImportNonAssembly">
            <summary>The referenced file '{0}' is not an assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefLvalueExpected">
            <summary>A ref or out value must be an assignable variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BaseInStaticMeth">
            <summary>Keyword 'base' is not available in a static method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BaseInBadContext">
            <summary>Keyword 'base' is not available in the current context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RbraceExpected">
            <summary>} expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LbraceExpected">
            <summary>{ expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InExpected">
            <summary>'in' expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidPreprocExpr">
            <summary>Invalid preprocessor expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidMemberDecl">
            <summary>Invalid token '{0}' in class, record, struct, or interface member declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberNeedsType">
            <summary>Method must have a return type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBaseType">
            <summary>Invalid base type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EmptySwitch">
            <summary>Empty switch block</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EmptySwitch_Title">
            <summary>Empty switch block</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedEndTry">
            <summary>Expected catch or finally</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidExprTerm">
            <summary>Invalid expression term '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNewExpr">
            <summary>A new expression requires an argument list or (), [], or {} after type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoNamespacePrivate">
            <summary>Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVarDecl">
            <summary>Expected ; or = (cannot specify constructor arguments in declaration)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UsingAfterElements">
            <summary>A using clause must precede all other elements defined in the namespace except extern alias declarations</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBinOpArgs">
            <summary>Overloaded binary operator '{0}' takes two parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadUnOpArgs">
            <summary>Overloaded unary operator '{0}' takes one parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoVoidParameter">
            <summary>Invalid parameter type 'void'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateAlias">
            <summary>The using alias '{0}' appeared previously in this namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadProtectedAccess">
            <summary>Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AddModuleAssembly">
            <summary>'{0}' cannot be added to this assembly because it already is an assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BindToBogusProp2">
            <summary>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BindToBogusProp1">
            <summary>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoVoidHere">
            <summary>Keyword 'void' cannot be used in this context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndexerNeedsParam">
            <summary>Indexers must have at least one parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArraySyntax">
            <summary>Array type specifier, [], must appear before parameter name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadOperatorSyntax">
            <summary>Declaration is not valid; use '{0} operator &lt;dest-type&gt; (...' instead</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MainClassNotFound">
            <summary>Could not find '{0}' specified for Main method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MainClassNotClass">
            <summary>'{0}' specified for Main method must be a non-generic class, record, struct, or interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoMainInClass">
            <summary>'{0}' does not have a suitable static 'Main' method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MainClassIsImport">
            <summary>Cannot use '{0}' for Main method because it is imported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OutputNeedsName">
            <summary>Outputs without source must have the /out option specified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoOutputDirectory">
            <summary>Output directory could not be determined</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantHaveWin32ResAndManifest">
            <summary>Conflicting options specified: Win32 resource file; Win32 manifest</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantHaveWin32ResAndIcon">
            <summary>Conflicting options specified: Win32 resource file; Win32 icon</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantReadResource">
            <summary>Error reading resource '{0}' -- '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DocFileGen">
            <summary>Error writing to XML documentation file: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_XMLParseError">
            <summary>XML comment has badly formed XML -- '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_XMLParseError_Title">
            <summary>XML comment has badly formed XML</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateParamTag">
            <summary>XML comment has a duplicate param tag for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateParamTag_Title">
            <summary>XML comment has a duplicate param tag</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedParamTag">
            <summary>XML comment has a param tag for '{0}', but there is no parameter by that name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedParamTag_Title">
            <summary>XML comment has a param tag, but there is no parameter by that name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedParamRefTag">
            <summary>XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedParamRefTag_Title">
            <summary>XML comment has a paramref tag, but there is no parameter by that name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingParamTag">
            <summary>Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingParamTag_Title">
            <summary>Parameter has no matching param tag in the XML comment (but other parameters do)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRef">
            <summary>XML comment has cref attribute '{0}' that could not be resolved</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRef_Title">
            <summary>XML comment has cref attribute that could not be resolved</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadStackAllocExpr">
            <summary>A stackalloc expression requires [] after type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidLineNumber">
            <summary>The line number specified for #line directive is missing or invalid</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingPPFile">
            <summary>Quoted file name, single-line comment or end-of-line expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedPPFile">
            <summary>Quoted file name expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReferenceDirectiveOnlyAllowedInScripts">
            <summary>#r is only allowed in scripts</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForEachMissingMember">
            <summary>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AwaitForEachMissingMember">
            <summary>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance or extension definition for '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForEachMissingMemberWrongAsync">
            <summary>foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AwaitForEachMissingMemberWrongAsync">
            <summary>Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PossibleAsyncIteratorWithoutYield">
            <summary>The body of an async-iterator method must contain a 'yield' statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PossibleAsyncIteratorWithoutYieldOrAwait">
            <summary>The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticLocalFunctionCannotCaptureVariable">
            <summary>A static local function cannot contain a reference to '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticLocalFunctionCannotCaptureThis">
            <summary>A static local function cannot contain a reference to 'this' or 'base'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefParamType">
            <summary>Invalid type for parameter {0} in XML comment cref attribute: '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefParamType_Title">
            <summary>Invalid type for parameter in XML comment cref attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefReturnType">
            <summary>Invalid return type in XML comment cref attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefReturnType_Title">
            <summary>Invalid return type in XML comment cref attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadWin32Res">
            <summary>Error reading Win32 resources -- {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefSyntax">
            <summary>XML comment has syntactically incorrect cref attribute '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefSyntax_Title">
            <summary>XML comment has syntactically incorrect cref attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadModifierLocation">
            <summary>Member modifier '{0}' must precede the member type and name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingArraySize">
            <summary>Array creation must have array size or array initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnprocessedXMLComment">
            <summary>XML comment is not placed on a valid language element</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnprocessedXMLComment_Title">
            <summary>XML comment is not placed on a valid language element</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FailedInclude">
            <summary>Unable to include XML fragment '{1}' of file '{0}' -- {2}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FailedInclude_Title">
            <summary>Unable to include XML fragment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidInclude">
            <summary>Invalid XML include element -- {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidInclude_Title">
            <summary>Invalid XML include element</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingXMLComment">
            <summary>Missing XML comment for publicly visible type or member '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingXMLComment_Title">
            <summary>Missing XML comment for publicly visible type or member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingXMLComment_Description">
            <summary>The /doc compiler option was specified, but one or more constructs did not have comments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_XMLParseIncludeError">
            <summary>Badly formed XML in included comments file -- '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_XMLParseIncludeError_Title">
            <summary>Badly formed XML in included comments file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDelArgCount">
            <summary>Delegate '{0}' does not take {1} arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedSemicolon">
            <summary>Semicolon after method or accessor block is not valid</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethodReturnCantBeRefAny">
            <summary>The return type of a method, delegate, or function pointer cannot be '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CompileCancelled">
            <summary>Compilation cancelled by user</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethodArgCantBeRefAny">
            <summary>Cannot make reference to variable of type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyLocal">
            <summary>Cannot assign to '{0}' because it is read-only</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyLocal">
            <summary>Cannot use '{0}' as a ref or out value because it is read-only</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantUseRequiredAttribute">
            <summary>The RequiredAttribute attribute is not permitted on C# types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoModifiersOnAccessor">
            <summary>Modifiers cannot be placed on event accessor declarations</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParamsCantBeWithModifier">
            <summary>The params parameter cannot be declared as {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReturnNotLValue">
            <summary>Cannot modify the return value of '{0}' because it is not a variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingCoClass">
            <summary>The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbiguousAttribute">
            <summary>'{0}' is ambiguous between '{1}' and '{2}'. Either use '@{0}' or explicitly include the 'Attribute' suffix.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgExtraRef">
            <summary>Argument {0} may not be passed with the '{1}' keyword</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CmdOptionConflictsSource">
            <summary>Option '{0}' overrides attribute '{1}' given in a source file or added module</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CmdOptionConflictsSource_Title">
            <summary>Option overrides attribute given in a source file or added module</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CmdOptionConflictsSource_Description">
            <summary>This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCompatMode">
            <summary>Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DelegateOnConditional">
            <summary>Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantMakeTempFile">
            <summary>Cannot create temporary file -- {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgRef">
            <summary>Argument {0} must be passed with the '{1}' keyword</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_YieldInAnonMeth">
            <summary>The yield statement cannot be used inside an anonymous method or lambda expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReturnInIterator">
            <summary>Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIteratorArgType">
            <summary>Iterators cannot have ref, in or out parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIteratorReturn">
            <summary>The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadYieldInFinally">
            <summary>Cannot yield in the body of a finally clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IteratorMustBeAsync">
            <summary>Method '{0}' with an iterator block must be 'async' to return '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadYieldInTryOfCatch">
            <summary>Cannot yield a value in the body of a try block with a catch clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EmptyYield">
            <summary>Expression expected after yield return</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonDelegateCantUse">
            <summary>Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalInnerUnsafe">
            <summary>Unsafe code may not appear in iterators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadYieldInCatch">
            <summary>Cannot yield a value in the body of a catch clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDelegateLeave">
            <summary>Control cannot leave the body of an anonymous method or lambda expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalSuppression">
            <summary>The suppression operator is not allowed in this context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPragma">
            <summary>Unrecognized #pragma directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPragma_Title">
            <summary>Unrecognized #pragma directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPPWarning">
            <summary>Expected 'disable' or 'restore'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPPWarning_Title">
            <summary>Expected 'disable' or 'restore' after #pragma warning</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRestoreNumber">
            <summary>Cannot restore warning 'CS{0}' because it was disabled globally</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRestoreNumber_Title">
            <summary>Cannot restore warning because it was disabled globally</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarargsIterator">
            <summary>__arglist is not allowed in the parameter list of iterators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsafeIteratorArgType">
            <summary>Iterators cannot have unsafe parameters or yield types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCoClassSig">
            <summary>The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultipleIEnumOfT">
            <summary>foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultipleIAsyncEnumOfT">
            <summary>Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedDimsRequired">
            <summary>A fixed size buffer field must have the array size specifier after the field name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedNotInStruct">
            <summary>Fixed size buffer fields may only be members of structs</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonymousReturnExpected">
            <summary>Not all code paths return a value in {0} of type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NonECMAFeature">
            <summary>Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NonECMAFeature_Title">
            <summary>Feature is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedVerbatimLiteral">
            <summary>Keyword, identifier, or string expected after verbatim specifier: @</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonly">
            <summary>A readonly field cannot be used as a ref or out value (except in a constructor)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonly2">
            <summary>Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonly">
            <summary>A readonly field cannot be assigned to (except in a constructor or init-only setter of the type in which the field is defined or a variable initializer)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonly2">
            <summary>Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyNotField">
            <summary>Cannot use {0} '{1}' as a ref or out value because it is a readonly variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyNotField2">
            <summary>Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssignReadonlyNotField">
            <summary>Cannot assign to {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssignReadonlyNotField2">
            <summary>Cannot assign to a member of {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnReadonlyNotField">
            <summary>Cannot return {0} '{1}' by writable reference because it is a readonly variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnReadonlyNotField2">
            <summary>Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyStatic2">
            <summary>Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyStatic2">
            <summary>Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyLocal2Cause">
            <summary>Cannot modify members of '{0}' because it is a '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyLocal2Cause">
            <summary>Cannot use fields of '{0}' as a ref or out value because it is a '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyLocalCause">
            <summary>Cannot assign to '{0}' because it is a '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyLocalCause">
            <summary>Cannot use '{0}' as a ref or out value because it is a '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ErrorOverride">
            <summary>{0}. See also error CS{1}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ErrorOverride_Title">
            <summary>Warning is overriding an error</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ErrorOverride_Description">
            <summary>The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonMethToNonDel">
            <summary>Cannot convert {0} to type '{1}' because it is not a delegate type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantConvAnonMethParams">
            <summary>Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantConvAnonMethReturnType">
            <summary>Cannot convert {0} to type '{1}' because the return type does not match the delegate return type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantConvAnonMethReturns">
            <summary>Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncReturnExpression">
            <summary>Since this is an async method, the return expression must be of type '{0}' rather than 'Task&lt;{0}&gt;'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantConvAsyncAnonFuncReturns">
            <summary>Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task&lt;T&gt;, none of which are convertible to '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalFixedType">
            <summary>Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedOverflow">
            <summary>Fixed size buffer of length {0} and type '{1}' is too big</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidFixedArraySize">
            <summary>Fixed size buffers must have a length greater than zero</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedBufferNotFixed">
            <summary>You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeNotOnAccessor">
            <summary>Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidSearchPathDir">
            <summary>Invalid search path '{0}' specified in '{1}' -- '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidSearchPathDir_Title">
            <summary>Invalid search path specified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalVarArgs">
            <summary>__arglist is not valid in this context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalParams">
            <summary>params is not valid in this context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadModifiersOnNamespace">
            <summary>A namespace declaration cannot have modifiers or attributes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadPlatformType">
            <summary>Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ThisStructNotInAnonMeth">
            <summary>Anonymous methods, lambda expressions, query expressions, and local functions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression, query expression, or local f ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConvToIDisp">
            <summary>'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConvToIDispWrongAsync">
            <summary>'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'. Did you mean 'await using' rather than 'using'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConvToIAsyncDisp">
            <summary>'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConvToIAsyncDispWrongAsync">
            <summary>'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadParamRef">
            <summary>Parameter {0} must be declared with the '{1}' keyword</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadParamExtraRef">
            <summary>Parameter {0} should not be declared with the '{1}' keyword</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadParamType">
            <summary>Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadExternIdentifier">
            <summary>Invalid extern alias for '/reference'; '{0}' is not a valid identifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AliasMissingFile">
            <summary>Invalid reference alias option: '{0}=' -- missing filename</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalExternAlias">
            <summary>You cannot redefine the global extern alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingTypeInSource">
            <summary>Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingTypeInAssembly">
            <summary>Reference to type '{0}' claims it is defined in '{1}', but it could not be found</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultiplePredefTypes">
            <summary>The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultiplePredefTypes_Title">
            <summary>Predefined type is defined in multiple assemblies in the global alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultiplePredefTypes_Description">
            <summary>This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Fram ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LocalCantBeFixedAndHoisted">
            <summary>Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TooManyLinesForDebugger">
            <summary>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TooManyLinesForDebugger_Title">
            <summary>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantConvAnonMethNoParams">
            <summary>Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalOnNonAttributeClass">
            <summary>Attribute '{0}' is only valid on methods or attribute classes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallOnNonAgileField">
            <summary>Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallOnNonAgileField_Title">
            <summary>Accessing a member on a field of a marshal-by-reference class may cause a runtime exception</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallOnNonAgileField_Description">
            <summary>This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by refe ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadWarningNumber">
            <summary>'{0}' is not a valid warning number</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadWarningNumber_Title">
            <summary>Not a valid warning number</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadWarningNumber_Description">
            <summary>A number that was passed to the #pragma warning preprocessor directive was not a valid warning number. Verify that the number represents a warning, not an error.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidNumber">
            <summary>Invalid number</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidNumber_Title">
            <summary>Invalid number</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FileNameTooLong">
            <summary>Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FileNameTooLong_Title">
            <summary>Invalid filename specified for preprocessor directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPPChecksum">
            <summary>Invalid #pragma checksum syntax; should be #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPPChecksum_Title">
            <summary>Invalid #pragma checksum syntax</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EndOfPPLineExpected">
            <summary>Single-line comment or end-of-line expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EndOfPPLineExpected_Title">
            <summary>Single-line comment or end-of-line expected after #pragma directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConflictingChecksum">
            <summary>Different checksum values given for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConflictingChecksum_Title">
            <summary>Different #pragma checksum values given</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidAssemblyName">
            <summary>Assembly reference '{0}' is invalid and cannot be resolved</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidAssemblyName_Title">
            <summary>Assembly reference is invalid and cannot be resolved</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidAssemblyName_Description">
            <summary>This warning indicates that an attribute, such as InternalsVisibleToAttribute, was not specified correctly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceMajMin">
            <summary>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceMajMin_Title">
            <summary>Assuming assembly reference matches identity</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceMajMin_Description">
            <summary>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceBldRev">
            <summary>Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceBldRev_Title">
            <summary>Assuming assembly reference matches identity</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceBldRev_Description">
            <summary>The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateImport">
            <summary>Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateImportSimple">
            <summary>An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssemblyMatchBadVersion">
            <summary>Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedNeedsLvalue">
            <summary>Fixed size buffers can only be accessed through locals or fields</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateTypeParamTag">
            <summary>XML comment has a duplicate typeparam tag for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateTypeParamTag_Title">
            <summary>XML comment has a duplicate typeparam tag</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedTypeParamTag">
            <summary>XML comment has a typeparam tag for '{0}', but there is no type parameter by that name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedTypeParamTag_Title">
            <summary>XML comment has a typeparam tag, but there is no type parameter by that name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedTypeParamRefTag">
            <summary>XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedTypeParamRefTag_Title">
            <summary>XML comment has a typeparamref tag, but there is no type parameter by that name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingTypeParamTag">
            <summary>Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingTypeParamTag_Title">
            <summary>Type parameter has no matching typeparam tag in the XML comment (but other type parameters do)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantChangeTypeOnOverride">
            <summary>'{0}': type must be '{2}' to match overridden member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DoNotUseFixedBufferAttr">
            <summary>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DoNotUseFixedBufferAttrOnProperty">
            <summary>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssignmentToSelf">
            <summary>Assignment made to same variable; did you mean to assign something else?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssignmentToSelf_Title">
            <summary>Assignment made to same variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ComparisonToSelf">
            <summary>Comparison made to same variable; did you mean to compare something else?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ComparisonToSelf_Title">
            <summary>Comparison made to same variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOpenWin32Res">
            <summary>Error opening Win32 resource file '{0}' -- '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DotOnDefault">
            <summary>Expression will always cause a System.NullReferenceException because the default value of '{0}' is null</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DotOnDefault_Title">
            <summary>Expression will always cause a System.NullReferenceException because the type's default value is null</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoMultipleInheritance">
            <summary>Class '{0}' cannot have multiple base classes: '{1}' and '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BaseClassMustBeFirst">
            <summary>Base class '{0}' must come before any interfaces</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefTypeVar">
            <summary>XML comment has cref attribute '{0}' that refers to a type parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefTypeVar_Title">
            <summary>XML comment has cref attribute that refers to a type parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FriendAssemblyBadArgs">
            <summary>Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FriendAssemblySNReq">
            <summary>Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DelegateOnNullable">
            <summary>Cannot bind delegate to '{0}' because it is a member of 'System.Nullable&lt;T&gt;'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCtorArgCount">
            <summary>'{0}' does not contain a constructor that takes {1} arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalAttributesNotFirst">
            <summary>Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionExpected">
            <summary>Expected expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidSubsystemVersion">
            <summary>Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InteropMethodWithBody">
            <summary>Embedded interop method '{0}' contains a body.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadWarningLevel">
            <summary>Warning level must be zero or greater</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDebugType">
            <summary>Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadResourceVis">
            <summary>Invalid option '{0}'; Resource visibility must be either 'public' or 'private'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueTypeMustMatch">
            <summary>The type of the argument to the DefaultParameterValue attribute must match the parameter type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueBadValueType">
            <summary>Argument of type '{0}' is not applicable for the DefaultParameterValue attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberAlreadyInitialized">
            <summary>Duplicate initialization of member '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberCannotBeInitialized">
            <summary>Member '{0}' cannot be initialized. It is not a field or property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticMemberInObjectInitializer">
            <summary>Static field or property '{0}' cannot be assigned in an object initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReadonlyValueTypeInObjectInitializer">
            <summary>Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ValueTypePropertyInObjectInitializer">
            <summary>Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsafeTypeInObjectCreation">
            <summary>Unsafe type '{0}' cannot be used in object creation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EmptyElementInitializer">
            <summary>Element initializer cannot be empty</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InitializerAddHasWrongSignature">
            <summary>The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CollectionInitRequiresIEnumerable">
            <summary>Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantSetWin32Manifest">
            <summary>Error reading Win32 manifest file '{0}' -- '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CantHaveManifestForModule">
            <summary>Ignoring /win32manifest for module because it only applies to assemblies</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CantHaveManifestForModule_Title">
            <summary>Ignoring /win32manifest for module because it only applies to assemblies</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadInstanceArgType">
            <summary>'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryDuplicateRangeVariable">
            <summary>The range variable '{0}' has already been declared</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryRangeVariableOverrides">
            <summary>The range variable '{0}' conflicts with a previous declaration of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryRangeVariableAssignedBadValue">
            <summary>Cannot assign {0} to a range variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryNoProviderCastable">
            <summary>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryNoProviderStandard">
            <summary>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing required assembly references or a using directive for 'System.Linq'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryNoProvider">
            <summary>Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryOuterKey">
            <summary>The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryInnerKey">
            <summary>The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryOutRefRangeVariable">
            <summary>Cannot pass the range variable '{0}' as an out or ref parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryMultipleProviders">
            <summary>Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryTypeInferenceFailedMulti">
            <summary>The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryTypeInferenceFailed">
            <summary>The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryTypeInferenceFailedSelectMany">
            <summary>An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsPointerOp">
            <summary>An expression tree may not contain an unsafe pointer operation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsAnonymousMethod">
            <summary>An expression tree may not contain an anonymous method expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonymousMethodToExpressionTree">
            <summary>An anonymous method expression cannot be converted to an expression tree</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryRangeVariableReadOnly">
            <summary>Range variable '{0}' cannot be assigned to -- it is read only</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryRangeVariableSameAsTypeParam">
            <summary>The range variable '{0}' cannot have the same name as a method type parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeVarNotFoundRangeVariable">
            <summary>The contextual keyword 'var' cannot be used in a range variable declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgTypesForCollectionAdd">
            <summary>The best overloaded Add method '{0}' for the collection initializer has some invalid arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ByRefParameterInExpressionTree">
            <summary>An expression tree lambda may not contain a ref, in or out parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarArgsInExpressionTree">
            <summary>An expression tree lambda may not contain a method with variable arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemGroupInExpressionTree">
            <summary>An expression tree lambda may not contain a method group</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InitializerAddHasParamModifiers">
            <summary>The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NonInvocableMemberCalled">
            <summary>Non-invocable member '{0}' cannot be used like a method.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultipleRuntimeImplementationMatches">
            <summary>Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultipleRuntimeImplementationMatches_Title">
            <summary>Member implements interface member with multiple matches at run-time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultipleRuntimeImplementationMatches_Description">
            <summary>This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultipleRuntimeOverrideMatches">
            <summary>Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called. Please use a newer runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultipleRuntimeOverrideMatches_Title">
            <summary>Member overrides base member with multiple override candidates at run-time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ObjectOrCollectionInitializerWithDelegateCreation">
            <summary>Object and collection initializer expressions may not be applied to a delegate creation expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidConstantDeclarationType">
            <summary>'{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FileNotFound">
            <summary>Source file '{0}' could not be found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FileAlreadyIncluded">
            <summary>Source file '{0}' specified multiple times</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FileAlreadyIncluded_Title">
            <summary>Source file specified multiple times</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoFileSpec">
            <summary>Missing file specification for '{0}' option</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchNeedsString">
            <summary>Command-line syntax error: Missing '{0}' for '{1}' option</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadSwitch">
            <summary>Unrecognized option: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoSources">
            <summary>No source files specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoSources_Title">
            <summary>No source files specified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedSingleScript">
            <summary>Expected a script (.csx file) but none specified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OpenResponseFile">
            <summary>Error opening response file '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOpenFileWrite">
            <summary>Cannot open '{0}' for writing -- '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBaseNumber">
            <summary>Invalid image base number '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BinaryFile">
            <summary>'{0}' is a binary file instead of a text file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_BadCodepage">
            <summary>Code page '{0}' is invalid or not installed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_BadChecksumAlgorithm">
            <summary>Algorithm '{0}' is not supported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoMainOnDLL">
            <summary>Cannot specify /main if building a module or library</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_InvalidTarget">
            <summary>Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_InvalidInputFileName">
            <summary>File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoConfigNotOnCommandLine">
            <summary>Ignoring /noconfig option because it was specified in a response file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoConfigNotOnCommandLine_Title">
            <summary>Ignoring /noconfig option because it was specified in a response file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidFileAlignment">
            <summary>Invalid file section alignment '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidOutputName">
            <summary>Invalid output name: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidDebugInformationFormat">
            <summary>Invalid debug information format: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LegacyObjectIdSyntax">
            <summary>'id#' syntax is no longer supported. Use '$id' instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DefineIdentifierRequired">
            <summary>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DefineIdentifierRequired_Title">
            <summary>Invalid name for a preprocessing symbol; not a valid identifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_OutputFileExists">
            <summary>Cannot create short filename '{0}' when a long filename with the same short filename already exists</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OneAliasPerReference">
            <summary>A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchNeedsNumber">
            <summary>Command-line syntax error: Missing ':&lt;number&gt;' for '{0}' option</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingDebugSwitch">
            <summary>The /pdb option requires that the /debug option also be used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComRefCallInExpressionTree">
            <summary>An expression tree lambda may not contain a COM call with ref omitted on arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidFormatForGuidForOption">
            <summary>Command-line syntax error: Invalid Guid format '{0}' for option '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingGuidForOption">
            <summary>Command-line syntax error: Missing Guid for option '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NoVarArgs">
            <summary>Methods with variable arguments are not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NoVarArgs_Title">
            <summary>Methods with variable arguments are not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadArgType">
            <summary>Argument type '{0}' is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadArgType_Title">
            <summary>Argument type is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadReturnType">
            <summary>Return type of '{0}' is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadReturnType_Title">
            <summary>Return type is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadFieldPropType">
            <summary>Type of '{0}' is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadFieldPropType_Title">
            <summary>Type is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadFieldPropType_Description">
            <summary>A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadIdentifierCase">
            <summary>Identifier '{0}' differing only in case is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadIdentifierCase_Title">
            <summary>Identifier differing only in case is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_OverloadRefOut">
            <summary>Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_OverloadRefOut_Title">
            <summary>Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_OverloadUnnamed">
            <summary>Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_OverloadUnnamed_Title">
            <summary>Overloaded method differing only by unnamed array types is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_OverloadUnnamed_Description">
            <summary>This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadIdentifier">
            <summary>Identifier '{0}' is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadIdentifier_Title">
            <summary>Identifier is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadBase">
            <summary>'{0}': base type '{1}' is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadBase_Title">
            <summary>Base type is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadBase_Description">
            <summary>A base type was marked as not having to be compliant with the Common Language Specification (CLS) in an assembly that was marked as being CLS compliant. Either remove the attribute that specifies the assembly is CLS compliant or remove the attribute that i ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadInterfaceMember">
            <summary>'{0}': CLS-compliant interfaces must have only CLS-compliant members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadInterfaceMember_Title">
            <summary>CLS-compliant interfaces must have only CLS-compliant members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NoAbstractMembers">
            <summary>'{0}': only CLS-compliant members can be abstract</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NoAbstractMembers_Title">
            <summary>Only CLS-compliant members can be abstract</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NotOnModules">
            <summary>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NotOnModules_Title">
            <summary>You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_ModuleMissingCLS">
            <summary>Added modules must be marked with the CLSCompliant attribute to match the assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_ModuleMissingCLS_Title">
            <summary>Added modules must be marked with the CLSCompliant attribute to match the assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_AssemblyNotCLS">
            <summary>'{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_AssemblyNotCLS_Title">
            <summary>Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadAttributeType">
            <summary>'{0}' has no accessible constructors which use only CLS-compliant types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadAttributeType_Title">
            <summary>Type has no accessible constructors which use only CLS-compliant types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_ArrayArgumentToAttribute">
            <summary>Arrays as attribute arguments is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_ArrayArgumentToAttribute_Title">
            <summary>Arrays as attribute arguments is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NotOnModules2">
            <summary>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NotOnModules2_Title">
            <summary>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_IllegalTrueInFalse">
            <summary>'{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_IllegalTrueInFalse_Title">
            <summary>Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnPrivateType">
            <summary>CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnPrivateType_Title">
            <summary>CLS compliance checking will not be performed because it is not visible from outside this assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_AssemblyNotCLS2">
            <summary>'{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_AssemblyNotCLS2_Title">
            <summary>Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnParam">
            <summary>CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnParam_Title">
            <summary>CLSCompliant attribute has no meaning when applied to parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnReturn">
            <summary>CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnReturn_Title">
            <summary>CLSCompliant attribute has no meaning when applied to return types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadTypeVar">
            <summary>Constraint type '{0}' is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadTypeVar_Title">
            <summary>Constraint type is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_VolatileField">
            <summary>CLS-compliant field '{0}' cannot be volatile</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_VolatileField_Title">
            <summary>CLS-compliant field cannot be volatile</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadInterface">
            <summary>'{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadInterface_Title">
            <summary>Type is not CLS-compliant because base interface is not CLS-compliant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitArg">
            <summary>'await' requires that the type {0} have a suitable 'GetAwaiter' method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitArgIntrinsic">
            <summary>Cannot await '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaiterPattern">
            <summary>'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitArg_NeedSystem">
            <summary>'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitArgVoidCall">
            <summary>Cannot await 'void'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitAsIdentifier">
            <summary>'await' cannot be used as an identifier within an async method or lambda expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DoesntImplementAwaitInterface">
            <summary>'{0}' does not implement '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TaskRetNoObjectRequired">
            <summary>Since '{0}' is an async method that returns 'Task', a return keyword must not be followed by an object expression. Did you intend to return 'Task&lt;T&gt;'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncReturn">
            <summary>The return type of an async method must be void, Task, Task&lt;T&gt;, a task-like type, IAsyncEnumerable&lt;T&gt;, or IAsyncEnumerator&lt;T&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_WrongArityAsyncReturn">
            <summary>A generic task-like return type was expected, but the type '{0}' found in 'AsyncMethodBuilder' attribute was not suitable. It must be an unbound generic type of arity one, and its containing type (if any) must be non-generic.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantReturnVoid">
            <summary>Cannot return an expression of type 'void'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarargsAsync">
            <summary>__arglist is not allowed in the parameter list of async methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ByRefTypeAndAwait">
            <summary>'await' cannot be used in an expression containing the type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsafeAsyncArgType">
            <summary>Async methods cannot have unsafe parameters or return types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncArgType">
            <summary>Async methods cannot have ref, in or out parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitWithoutAsync">
            <summary>The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitWithoutAsyncLambda">
            <summary>The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitWithoutAsyncMethod">
            <summary>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task&lt;{0}&gt;'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitWithoutVoidAsyncMethod">
            <summary>The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitInFinally">
            <summary>Cannot await in the body of a finally clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitInCatch">
            <summary>Cannot await in a catch clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitInCatchFilter">
            <summary>Cannot await in the filter expression of a catch clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitInLock">
            <summary>Cannot await in the body of a lock statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitInStaticVariableInitializer">
            <summary>The 'await' operator cannot be used in a static script variable initializer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AwaitInUnsafeContext">
            <summary>Cannot await in an unsafe context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncLacksBody">
            <summary>The 'async' modifier can only be used in methods that have a body.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadSpecialByRefLocal">
            <summary>Parameters or locals of type '{0}' cannot be declared in async methods or async lambda expressions.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadSpecialByRefIterator">
            <summary>foreach statement cannot operate on enumerators of type '{0}' in async or iterator methods because '{0}' is a ref struct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync">
            <summary>Security attribute '{0}' cannot be applied to an Async method.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct">
            <summary>Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitInQuery">
            <summary>The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AsyncLacksAwaits">
            <summary>This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AsyncLacksAwaits_Title">
            <summary>Async method lacks 'await' operators and will run synchronously</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnobservedAwaitableExpression">
            <summary>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnobservedAwaitableExpression_Title">
            <summary>Because this call is not awaited, execution of the current method continues before the call is completed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnobservedAwaitableExpression_Description">
            <summary>The current method calls an async method that returns a Task or a Task&lt;TResult&gt; and doesn't apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continu ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SynchronizedAsyncMethod">
            <summary>'MethodImplOptions.Synchronized' cannot be applied to an async method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConversionForCallerLineNumberParam">
            <summary>CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConversionForCallerFilePathParam">
            <summary>CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConversionForCallerMemberNameParam">
            <summary>CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCallerLineNumberParamWithoutDefaultValue">
            <summary>The CallerLineNumberAttribute may only be applied to parameters with default values</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCallerFilePathParamWithoutDefaultValue">
            <summary>The CallerFilePathAttribute may only be applied to parameters with default values</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCallerMemberNameParamWithoutDefaultValue">
            <summary>The CallerMemberNameAttribute may only be applied to parameters with default values</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberParamForUnconsumedLocation">
            <summary>The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberParamForUnconsumedLocation_Title">
            <summary>The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerFilePathParamForUnconsumedLocation">
            <summary>The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerFilePathParamForUnconsumedLocation_Title">
            <summary>The CallerFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerMemberNameParamForUnconsumedLocation">
            <summary>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerMemberNameParamForUnconsumedLocation_Title">
            <summary>The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoEntryPoint">
            <summary>Program does not contain a static 'Main' method suitable for an entry point</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayInitializerIncorrectLength">
            <summary>An array initializer of length '{0}' is expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayInitializerExpected">
            <summary>A nested array initializer is expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalVarianceSyntax">
            <summary>Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedAliasedName">
            <summary>Unexpected use of an aliased name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedGenericName">
            <summary>Unexpected use of a generic name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedUnboundGenericName">
            <summary>Unexpected use of an unbound generic name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalStatement">
            <summary>Expressions and statements can only occur in a method body</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamedArgumentForArray">
            <summary>An array access may not have a named argument specifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotYetImplementedInRoslyn">
            <summary>This language feature ('{0}') is not yet implemented.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueNotAllowed">
            <summary>Default values are not valid in this context.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOpenIcon">
            <summary>Error opening icon file {0} -- {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOpenWin32Manifest">
            <summary>Error opening Win32 manifest file {0} -- {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ErrorBuildingWin32Resources">
            <summary>Error building Win32 resources -- {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueBeforeRequiredValue">
            <summary>Optional parameters must appear after all required parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitImplCollisionOnRefOut">
            <summary>Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialWrongTypeParamsVariance">
            <summary>Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedVariance">
            <summary>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedVarianceStaticMember">
            <summary>Invalid variance: The type parameter '{1}' must be {3} valid on '{0}' unless language version '{4}' or greater is used. '{1}' is {2}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeriveFromDynamic">
            <summary>'{0}': cannot derive from the dynamic type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeriveFromConstructedDynamic">
            <summary>'{0}': cannot implement a dynamic interface '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DynamicTypeAsBound">
            <summary>Constraint cannot be the dynamic type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstructedDynamicTypeAsBound">
            <summary>Constraint cannot be a dynamic type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DynamicRequiredTypesMissing">
            <summary>One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MetadataNameTooLong">
            <summary>Name '{0}' exceeds the maximum length allowed in metadata.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributesNotAllowed">
            <summary>Attributes are not valid in this context.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributesRequireParenthesizedLambdaExpression">
            <summary>Attributes on lambda expressions require a parenthesized parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExternAliasNotAllowed">
            <summary>'extern alias' is not valid in this context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsDynamicIsConfusing">
            <summary>Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsDynamicIsConfusing_Title">
            <summary>Using 'is' to test compatibility with 'dynamic' is essentially identical to testing compatibility with 'Object'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_YieldNotAllowedInScript">
            <summary>Cannot use 'yield' in top-level script code</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamespaceNotAllowedInScript">
            <summary>Cannot declare namespace in script code</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalAttributesNotAllowed">
            <summary>Assembly and module attributes are not allowed in this context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidDelegateType">
            <summary>Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MainIgnored">
            <summary>The entry point of the program is global code; ignoring '{0}' entry point.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MainIgnored_Title">
            <summary>The entry point of the program is global code; ignoring entry point</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_StaticInAsOrIs">
            <summary>The second operand of an 'is' or 'as' operator may not be static type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_StaticInAsOrIs_Title">
            <summary>The second operand of an 'is' or 'as' operator may not be a static type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisEventType">
            <summary>Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamedArgumentSpecificationBeforeFixedArgument">
            <summary>Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation">
            <summary>Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNamedArgument">
            <summary>The best overload for '{0}' does not have a parameter named '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNamedArgumentForDelegateInvoke">
            <summary>The delegate '{0}' does not have a parameter named '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateNamedArgument">
            <summary>Named argument '{0}' cannot be specified multiple times</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamedArgumentUsedInPositional">
            <summary>Named argument '{0}' specifies a parameter for which a positional argument has already been given</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNonTrailingNamedArgument">
            <summary>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueUsedWithAttributes">
            <summary>Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueMustBeConstant">
            <summary>Default parameter value for '{0}' must be a compile-time constant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefOutDefaultValue">
            <summary>A ref or out parameter cannot have a default value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueForExtensionParameter">
            <summary>Cannot specify a default value for the 'this' parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueForParamsParameter">
            <summary>Cannot specify a default value for a parameter array</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConversionForDefaultParam">
            <summary>A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConversionForNubDefaultParam">
            <summary>A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotNullRefDefaultParameter">
            <summary>'{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DefaultValueForUnconsumedLocation">
            <summary>The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DefaultValueForUnconsumedLocation_Title">
            <summary>The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PublicKeyFileFailure">
            <summary>Error signing output with public key from file '{0}' -- {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PublicKeyContainerFailure">
            <summary>Error signing output with public key from container '{0}' -- {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicTypeof">
            <summary>The typeof operator cannot be used on the dynamic type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNullableTypeof">
            <summary>The typeof operator cannot be used on a nullable reference type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsDynamicOperation">
            <summary>An expression tree may not contain a dynamic operation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncExpressionTree">
            <summary>Async lambda expressions cannot be converted to expression trees</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DynamicAttributeMissing">
            <summary>Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotPassNullForFriendAssembly">
            <summary>Cannot pass null for friend assembly name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SignButNoPrivateKey">
            <summary>Key file '{0}' is missing the private key needed for signing</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PublicSignButNoKey">
            <summary>Public signing was specified and requires a public key, but no public key was specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PublicSignNetModule">
            <summary>Public signing is not supported for netmodules.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DelaySignButNoKey">
            <summary>Delay signing was specified and requires a public key, but no public key was specified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DelaySignButNoKey_Title">
            <summary>Delay signing was specified and requires a public key, but no public key was specified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidVersionFormat">
            <summary>The specified version string does not conform to the required format - major[.minor[.build[.revision]]]</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidVersionFormatDeterministic">
            <summary>The specified version string contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidVersionFormat2">
            <summary>The specified version string does not conform to the required format - major.minor.build.revision (without wildcards)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidVersionFormat">
            <summary>The specified version string does not conform to the recommended format - major.minor.build.revision</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidVersionFormat_Title">
            <summary>The specified version string does not conform to the recommended format - major.minor.build.revision</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAssemblyCultureForExe">
            <summary>Executables cannot be satellite assemblies; culture should always be empty</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoCorrespondingArgument">
            <summary>There is no argument given that corresponds to the required parameter '{0}' of '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnimplementedCommandLineSwitch">
            <summary>The command line switch '{0}' is not yet implemented and was ignored.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnimplementedCommandLineSwitch_Title">
            <summary>Command line switch is not yet implemented</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ModuleEmitFailure">
            <summary>Failed to emit module '{0}': {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedLocalInLambda">
            <summary>Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsNamedArgument">
            <summary>An expression tree may not contain a named argument specification</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsOptionalArgument">
            <summary>An expression tree may not contain a call or invocation that uses optional arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsIndexedProperty">
            <summary>An expression tree may not contain an indexed property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndexedPropertyRequiresParams">
            <summary>Indexed property '{0}' has non-optional arguments which must be provided</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndexedPropertyMustHaveAllOptionalParams">
            <summary>Indexed property '{0}' must have all arguments optional</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SpecialByRefInLambda">
            <summary>Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityAttributeMissingAction">
            <summary>First argument to a security attribute must be a valid SecurityAction</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityAttributeInvalidAction">
            <summary>Security attribute '{0}' has an invalid SecurityAction value '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityAttributeInvalidActionAssembly">
            <summary>SecurityAction value '{0}' is invalid for security attributes applied to an assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityAttributeInvalidActionTypeOrMethod">
            <summary>SecurityAction value '{0}' is invalid for security attributes applied to a type or a method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PrincipalPermissionInvalidAction">
            <summary>SecurityAction value '{0}' is invalid for PrincipalPermission attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotValidInExpressionTree">
            <summary>An expression tree may not contain '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PermissionSetAttributeInvalidFile">
            <summary>Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PermissionSetAttributeFileReadError">
            <summary>Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalSingleTypeNameNotFoundFwd">
            <summary>The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DottedTypeNameNotFoundInNSFwd">
            <summary>The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SingleTypeNameNotFoundFwd">
            <summary>The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssemblySpecifiedForLinkAndRef">
            <summary>Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedCollectionInitAdd">
            <summary>The best overloaded Add method '{0}' for the collection initializer element is obsolete.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedCollectionInitAdd_Title">
            <summary>The best overloaded Add method for the collection initializer element is obsolete</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedCollectionInitAddStr">
            <summary>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedCollectionInitAddStr_Title">
            <summary>The best overloaded Add method for the collection initializer element is obsolete</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeprecatedCollectionInitAddStr">
            <summary>The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityAttributeInvalidTarget">
            <summary>Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicMethodArg">
            <summary>Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicMethodArgLambda">
            <summary>Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicMethodArgMemgrp">
            <summary>Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoDynamicPhantomOnBase">
            <summary>The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicQuery">
            <summary>Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoDynamicPhantomOnBaseIndexer">
            <summary>The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DynamicDispatchToConditionalMethod">
            <summary>The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DynamicDispatchToConditionalMethod_Title">
            <summary>Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgTypeDynamicExtension">
            <summary>'{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerFilePathPreferredOverCallerMemberName">
            <summary>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerFilePathPreferredOverCallerMemberName_Title">
            <summary>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberPreferredOverCallerMemberName">
            <summary>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberPreferredOverCallerMemberName_Title">
            <summary>The CallerMemberNameAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberPreferredOverCallerFilePath">
            <summary>The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberPreferredOverCallerFilePath_Title">
            <summary>The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidDynamicCondition">
            <summary>Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MixingWinRTEventWithRegular">
            <summary>'{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2000_DisposeObjectsBeforeLosingScope1">
            <summary>Call System.IDisposable.Dispose() on allocated instance of {0} before all references to it are out of scope.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title">
            <summary>Call System.IDisposable.Dispose() on allocated instance before all references to it are out of scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2000_DisposeObjectsBeforeLosingScope2">
            <summary>Allocated instance of {0} is not disposed along all exception paths.  Call System.IDisposable.Dispose() before all references to it are out of scope.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title">
            <summary>Allocated instance is not disposed along all exception paths</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2202_DoNotDisposeObjectsMultipleTimes">
            <summary>Object '{0}' can be disposed more than once.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title">
            <summary>Object can be disposed more than once</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewCoClassOnLink">
            <summary>Interop type '{0}' cannot be embedded. Use the applicable interface instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoPIANestedType">
            <summary>Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericsUsedInNoPIAType">
            <summary>Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InteropStructContainsMethods">
            <summary>Embedded interop struct '{0}' can contain only public instance fields.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_WinRtEventPassedByRef">
            <summary>A Windows Runtime event may not be passed as an out or ref parameter.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingMethodOnSourceInterface">
            <summary>Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingSourceInterface">
            <summary>Interface '{0}' has an invalid source interface which is required to embed event '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InteropTypeMissingAttribute">
            <summary>Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoPIAAssemblyMissingAttribute">
            <summary>Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoPIAAssemblyMissingAttributes">
            <summary>Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InteropTypesWithSameNameAndGuid">
            <summary>Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LocalTypeNameClash">
            <summary>Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReferencedAssemblyReferencesLinkedPIA">
            <summary>A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReferencedAssemblyReferencesLinkedPIA_Title">
            <summary>A reference was created to embedded interop assembly because of an indirect assembly reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReferencedAssemblyReferencesLinkedPIA_Description">
            <summary>You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assemb ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericsUsedAcrossAssemblies">
            <summary>Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoCanonicalView">
            <summary>Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NetModuleNameMismatch">
            <summary>Module name '{0}' stored in '{1}' must match its filename.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadModuleName">
            <summary>Invalid module name: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCompilationOptionValue">
            <summary>Invalid '{0}' value: '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAppConfigPath">
            <summary>AppConfigPath must be absolute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssemblyAttributeFromModuleIsOverridden">
            <summary>Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssemblyAttributeFromModuleIsOverridden_Title">
            <summary>Attribute will be ignored in favor of the instance appearing in source</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CmdOptionConflictsSource">
            <summary>Attribute '{0}' given in a source file conflicts with option '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedBufferTooManyDimensions">
            <summary>A fixed buffer may only have one dimension.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReferencedAssemblyDoesNotHaveStrongName">
            <summary>Referenced assembly '{0}' does not have a strong name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
            <summary>Referenced assembly does not have a strong name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidSignaturePublicKey">
            <summary>Invalid signature public key specified in AssemblySignatureKeyAttribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExportedTypeConflictsWithDeclaration">
            <summary>Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExportedTypesConflict">
            <summary>Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForwardedTypeConflictsWithDeclaration">
            <summary>Forwarded type '{0}' conflicts with type declared in primary module of this assembly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForwardedTypesConflict">
            <summary>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForwardedTypeConflictsWithExportedType">
            <summary>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefCultureMismatch">
            <summary>Referenced assembly '{0}' has different culture setting of '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefCultureMismatch_Title">
            <summary>Referenced assembly has different culture setting</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AgnosticToMachineModule">
            <summary>Agnostic assembly cannot have a processor specific module '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConflictingMachineModule">
            <summary>Assembly and module '{0}' cannot target different processors.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConflictingMachineAssembly">
            <summary>Referenced assembly '{0}' targets a different processor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConflictingMachineAssembly_Title">
            <summary>Referenced assembly targets a different processor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CryptoHashFailed">
            <summary>Cryptographic failure while creating hashes.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingNetModuleReference">
            <summary>Reference to '{0}' netmodule missing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NetModuleNameMustBeUnique">
            <summary>Module '{0}' is already defined in this assembly. Each module must have a unique filename.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantReadConfigFile">
            <summary>Cannot read config file '{0}' -- '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EncNoPIAReference">
            <summary>Cannot continue since the edit includes a reference to an embedded type: '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EncReferenceToAddedMember">
            <summary>Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MutuallyExclusiveOptions">
            <summary>Compilation options '{0}' and '{1}' can't both be specified at the same time.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
            <summary>Linked netmodule metadata must provide a full PE image: '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadPrefer32OnLib">
            <summary>/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_PathList">
            <summary>&lt;path list&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Text">
            <summary>&lt;text&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNullPropagatingOperator">
            <summary>null propagating operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExpressionBodiedMethod">
            <summary>expression-bodied method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExpressionBodiedProperty">
            <summary>expression-bodied property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExpressionBodiedIndexer">
            <summary>expression-bodied indexer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAutoPropertyInitializer">
            <summary>auto property initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Namespace1">
            <summary>&lt;namespace&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRefLocalsReturns">
            <summary>byref locals and returns</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureReadOnlyReferences">
            <summary>readonly references</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRefStructs">
            <summary>ref structs</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRefConditional">
            <summary>ref conditional expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRefReassignment">
            <summary>ref reassignment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRefFor">
            <summary>ref for-loop variables</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRefForEach">
            <summary>ref foreach iteration variables</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExtensibleFixedStatement">
            <summary>extensible fixed statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.CompilationC">
            <summary>Compilation (C#):</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SyntaxNodeIsNotWithinSynt">
            <summary>Syntax node is not within syntax tree</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.LocationMustBeProvided">
            <summary>Location must be provided in order to provide minimal type qualification.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SyntaxTreeSemanticModelMust">
            <summary>SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.CantReferenceCompilationOf">
            <summary>Can't reference compilation of type '{0}' from {1} compilation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SyntaxTreeAlreadyPresent">
            <summary>Syntax tree already present</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SubmissionCanOnlyInclude">
            <summary>Submission can only include script code.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SubmissionCanHaveAtMostOne">
            <summary>Submission can have at most one syntax tree.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SyntaxTreeNotFoundToRemove">
            <summary>SyntaxTree is not part of the compilation, so it cannot be removed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.TreeMustHaveARootNodeWith">
            <summary>tree must have a root node with SyntaxKind.CompilationUnit</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.TypeArgumentCannotBeNull">
            <summary>Type argument cannot be null</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WrongNumberOfTypeArguments">
            <summary>Wrong number of type arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.NameConflictForName">
            <summary>Name conflict for name {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.LookupOptionsHasInvalidCombo">
            <summary>LookupOptions has an invalid combination of options</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ItemsMustBeNonEmpty">
            <summary>items: must be non-empty</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.UseVerbatimIdentifier">
            <summary>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier or Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier to create identifier tokens.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.UseLiteralForTokens">
            <summary>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create character literal tokens.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.UseLiteralForNumeric">
            <summary>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create numeric literal tokens.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens">
            <summary>This method can only be used to create tokens - {0} is not a token kind.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.GenericParameterDefinition">
            <summary>Generic parameter is definition when expected to be reference {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.InvalidGetDeclarationNameMultipleDeclarators">
            <summary>Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.PositionIsNotWithinSyntax">
            <summary>Position is not within syntax tree with full span {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadUILang">
            <summary>The language name '{0}' is invalid.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadUILang_Title">
            <summary>The language name is invalid</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsupportedTransparentIdentifierAccess">
            <summary>Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParamDefaultValueDiffersFromAttribute">
            <summary>The parameter has multiple distinct default values.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldHasMultipleDistinctConstantValues">
            <summary>The field has multiple distinct constant values.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnqualifiedNestedTypeInCref">
            <summary>Within cref attributes, nested types of generic types should be qualified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnqualifiedNestedTypeInCref_Title">
            <summary>Within cref attributes, nested types of generic types should be qualified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.NotACSharpSymbol">
            <summary>Not a C# symbol.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.HDN_UnusedUsingDirective">
            <summary>Unnecessary using directive.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.HDN_UnusedExternAlias">
            <summary>Unused extern alias.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ElementsCannotBeNull">
            <summary>Elements cannot be null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_LIB_ENV">
            <summary>LIB environment variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_LIB_OPTION">
            <summary>/LIB option</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_REFERENCEPATH_OPTION">
            <summary>/REFERENCEPATH option</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_DirectoryDoesNotExist">
            <summary>directory does not exist</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_DirectoryHasInvalidPath">
            <summary>path is too long or invalid</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoRuntimeMetadataVersion">
            <summary>No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoRuntimeMetadataVersion_Title">
            <summary>No value for RuntimeMetadataVersion found</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WrongSemanticModelType">
            <summary>Expected a {0} SemanticModel.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureLambda">
            <summary>lambda expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion1">
            <summary>Feature '{0}' is not available in C# 1. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion2">
            <summary>Feature '{0}' is not available in C# 2. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion3">
            <summary>Feature '{0}' is not available in C# 3. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion4">
            <summary>Feature '{0}' is not available in C# 4. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion5">
            <summary>Feature '{0}' is not available in C# 5. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion6">
            <summary>Feature '{0}' is not available in C# 6. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion7">
            <summary>Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureIsExperimental">
            <summary>Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_VersionExperimental">
            <summary>'experimental'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.PositionNotWithinTree">
            <summary>Position must be within span of the syntax tree.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
            <summary>Syntax node to be speculated cannot belong to a syntax tree from the current compilation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ChainingSpeculativeModelIsNotSupported">
            <summary>Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_ToolName">
            <summary>Microsoft (R) Visual C# Compiler</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_LogoLine1">
            <summary>{0} version {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_LogoLine2">
            <summary>Copyright (C) Microsoft Corporation. All rights reserved.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_LangVersions">
            <summary>Supported language versions:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_CSCHelp">
            <summary>Visual C# Compiler Options
            
                                   - OUTPUT FILES -
            -out:&lt;file&gt;                   Specify output file name (default: base name of
                                          file with main class or first file)
            -target:exe                   Build a consol ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComImportWithInitializers">
            <summary>'{0}': a class with the ComImport attribute cannot specify field initializers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PdbLocalNameTooLong">
            <summary>Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PdbLocalNameTooLong_Title">
            <summary>Local name is too long for PDB</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RetNoObjectRequiredLambda">
            <summary>Anonymous function converted to a void returning delegate cannot return a value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TaskRetNoObjectRequiredLambda">
            <summary>Async lambda expression converted to a 'Task' returning delegate cannot return a value. Did you intend to return 'Task&lt;T&gt;'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AnalyzerCannotBeCreated">
            <summary>An instance of analyzer {0} cannot be created from {1} : {2}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AnalyzerCannotBeCreated_Title">
            <summary>An analyzer instance cannot be created</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoAnalyzerInAssembly">
            <summary>The assembly {0} does not contain any analyzers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoAnalyzerInAssembly_Title">
            <summary>Assembly does not contain any analyzers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnableToLoadAnalyzer">
            <summary>Unable to load Analyzer assembly {0} : {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnableToLoadAnalyzer_Title">
            <summary>Unable to load Analyzer assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.INF_UnableToLoadSomeTypesInAnalyzer">
            <summary>Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantReadRulesetFile">
            <summary>Error reading ruleset file {0} - {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadPdbData">
            <summary>Error reading debug information for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_OperationCausedStackOverflow">
            <summary>Operation caused a stack overflow.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IdentifierOrNumericLiteralExpected">
            <summary>Expected identifier or numeric literal.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IdentifierOrNumericLiteralExpected_Title">
            <summary>Expected identifier or numeric literal</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InitializerOnNonAutoProperty">
            <summary>Only auto-implemented properties can have initializers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InstancePropertyInitializerInInterface">
            <summary>Instance properties in interfaces cannot have initializers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AutoPropertyMustHaveGetAccessor">
            <summary>Auto-implemented properties must have get accessors.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AutoPropertyMustOverrideSet">
            <summary>Auto-implemented properties must override all accessors of the overridden property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InitializerInStructWithoutExplicitConstructor">
            <summary>Structs without explicit constructors cannot contain members with initializers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EncodinglessSyntaxTree">
            <summary>Cannot emit debug information for a source text without encoding.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BlockBodyAndExpressionBody">
            <summary>Block bodies and expression bodies cannot both be provided.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchFallOut">
            <summary>Control cannot fall out of switch from final case label ('{0}')</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedBoundGenericName">
            <summary>Type arguments are not allowed in the nameof operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NullPropagatingOpInExpressionTree">
            <summary>An expression tree lambda may not contain a null propagating operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DictionaryInitializerInExpressionTree">
            <summary>An expression tree lambda may not contain a dictionary initializer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExtensionCollectionElementInitializerInExpressionTree">
            <summary>An extension Add method is not supported for a collection initializer in an expression lambda.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNameof">
            <summary>nameof operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDictionaryInitializer">
            <summary>dictionary initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnclosedExpressionHole">
            <summary>Missing close delimiter '}' for interpolated expression started with '{'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SingleLineCommentInExpressionHole">
            <summary>A single-line comment may not be used in an interpolated string.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InsufficientStack">
            <summary>An expression is too long or complex to compile</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionHasNoName">
            <summary>Expression does not have a name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SubexpressionNotInNameof">
            <summary>Sub-expression cannot be used in an argument to nameof.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AliasQualifiedNameNotAnExpression">
            <summary>An alias-qualified name is not an expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NameofMethodGroupWithTypeParameters">
            <summary>Type parameters are not allowed on a method group as an argument to 'nameof'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.NoNoneSearchCriteria">
            <summary>SearchCriteria is expected.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAssemblyCulture">
            <summary>Assembly culture strings may not contain embedded NUL characters.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureUsingStatic">
            <summary>using static</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureInterpolatedStrings">
            <summary>interpolated strings</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAltInterpolatedVerbatimStrings">
            <summary>alternative interpolated verbatim strings</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_AwaitInCatchAndFinally">
            <summary>await in catch blocks and finally blocks</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureBinaryLiteral">
            <summary>binary literals</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDigitSeparator">
            <summary>digit separators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureLocalFunctions">
            <summary>local functions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnescapedCurly">
            <summary>A '{0}' character must be escaped (by doubling) in an interpolated string.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EscapedCurly">
            <summary>A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TrailingWhitespaceInFormatSpecifier">
            <summary>A format specifier may not contain trailing whitespace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EmptyFormatSpecifier">
            <summary>Empty format specifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ErrorInReferencedAssembly">
            <summary>There is an error in a referenced assembly '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionOrDeclarationExpected">
            <summary>Expression or declaration statement expected.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NameofExtensionMethod">
            <summary>Extension method groups are not allowed as an argument to 'nameof'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AlignmentMagnitude">
            <summary>Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.HDN_UnusedExternAlias_Title">
            <summary>Unused extern alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.HDN_UnusedUsingDirective_Title">
            <summary>Unnecessary using directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.INF_UnableToLoadSomeTypesInAnalyzer_Title">
            <summary>Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AlignmentMagnitude_Title">
            <summary>Alignment value has a magnitude that may result in a large formatted string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstantStringTooLong">
            <summary>Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TupleTooFewElements">
            <summary>Tuple must contain at least two elements.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DebugEntryPointNotSourceMethodDefinition">
            <summary>Debug entry point must be a definition of a method declared in the current compilation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LoadDirectiveOnlyAllowedInScripts">
            <summary>#load is only allowed in scripts</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PPLoadFollowsToken">
            <summary>Cannot use #load after first token in file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.CouldNotFindFile">
            <summary>Could not find file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SyntaxTreeFromLoadNoRemoveReplace">
            <summary>SyntaxTree resulted from a #load directive and cannot be removed or replaced directly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SourceFileReferencesNotSupported">
            <summary>Source file references are not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidPathMap">
            <summary>The pathmap option was incorrectly formatted.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidReal">
            <summary>Invalid real literal.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AutoPropertyCannotBeRefReturning">
            <summary>Auto-implemented properties cannot return by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefPropertyMustHaveGetAccessor">
            <summary>Properties which return by reference must have a get accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefPropertyCannotHaveSetAccessor">
            <summary>Properties which return by reference cannot have set accessors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantChangeRefReturnOnOverride">
            <summary>'{0}' must match by reference return of overridden member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantChangeInitOnlyOnOverride">
            <summary>'{0}' must match by init-only of overridden member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MustNotHaveRefReturn">
            <summary>By-reference returns may only be used in methods that return by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MustHaveRefReturn">
            <summary>By-value returns may only be used in methods that return by value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnMustHaveIdentityConversion">
            <summary>The return expression must be of type '{0}' because this method returns by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloseUnimplementedInterfaceMemberWrongRefReturn">
            <summary>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloseUnimplementedInterfaceMemberWrongInitOnly">
            <summary>'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIteratorReturnRef">
            <summary>The body of '{0}' cannot be an iterator block because '{0}' returns by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadRefReturnExpressionTree">
            <summary>Lambda expressions that return by reference cannot be converted to expression trees</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturningCallInExpressionTree">
            <summary>An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnLvalueExpected">
            <summary>An expression cannot be used in this context because it may not be passed or returned by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnNonreturnableLocal">
            <summary>Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnNonreturnableLocal2">
            <summary>Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnNonreturnableLocal">
            <summary>Local '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnNonreturnableLocal_Title">
            <summary>Local is returned by reference but was initialized to a value that cannot be returned by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnNonreturnableLocal2">
            <summary>A member of '{0}' is returned by reference but was initialized to a value that cannot be returned by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnNonreturnableLocal2_Title">
            <summary>A member is returned by reference but was initialized to a value that cannot be returned by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnReadonlyLocal">
            <summary>Cannot return '{0}' by reference because it is read-only</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnRangeVariable">
            <summary>Cannot return the range variable '{0}' by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnReadonlyLocalCause">
            <summary>Cannot return '{0}' by reference because it is a '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnReadonlyLocal2Cause">
            <summary>Cannot return fields of '{0}' by reference because it is a '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnReadonly">
            <summary>A readonly field cannot be returned by writable reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnReadonlyStatic">
            <summary>A static readonly field cannot be returned by writable reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnReadonly2">
            <summary>Members of readonly field '{0}' cannot be returned by writable reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnReadonlyStatic2">
            <summary>Fields of static readonly field '{0}' cannot be returned by writable reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnParameter">
            <summary>Cannot return a parameter by reference '{0}' because it is not a ref parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnParameter2">
            <summary>Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnScopedParameter">
            <summary>Cannot return a parameter by reference '{0}' because it is scoped to the current method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnScopedParameter2">
            <summary>Cannot return by reference a member of parameter '{0}' because it is scoped to the current method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnOnlyParameter">
            <summary>Cannot return a parameter by reference '{0}' through a ref parameter; it can only be returned in a return statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnOnlyParameter2">
            <summary>Cannot return by reference a member of parameter '{0}' through a ref parameter; it can only be returned in a return statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnOnlyParameter">
            <summary>This returns a parameter by reference '{0}' through a ref parameter; but it can only safely be returned in a return statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnOnlyParameter_Title">
            <summary>This returns a parameter by reference through a ref parameter; but it can only safely be returned in a return statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnOnlyParameter2">
            <summary>This returns by reference a member of parameter '{0}' through a ref parameter; but it can only safely be returned in a return statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnOnlyParameter2_Title">
            <summary>This returns by reference a member of parameter through a ref parameter; but it can only safely be returned in a return statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnParameter">
            <summary>This returns a parameter by reference '{0}' but it is not a ref parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnParameter_Title">
            <summary>This returns a parameter by reference but it is not a ref parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnScopedParameter">
            <summary>This returns a parameter by reference '{0}' but it is scoped to the current method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnScopedParameter_Title">
            <summary>This returns a parameter by reference but it is scoped to the current method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnParameter2">
            <summary>This returns by reference a member of parameter '{0}' that is not a ref or out parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnParameter2_Title">
            <summary>This returns by reference a member of parameter that is not a ref or out parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnScopedParameter2">
            <summary>This returns by reference a member of parameter '{0}' that is scoped to the current method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnScopedParameter2_Title">
            <summary>This returns by reference a member of parameter that is scoped to the current method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnLocal">
            <summary>Cannot return local '{0}' by reference because it is not a ref local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnLocal2">
            <summary>Cannot return a member of local '{0}' by reference because it is not a ref local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnLocal">
            <summary>This returns local '{0}' by reference but it is not a ref local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnLocal_Title">
            <summary>This returns local by reference but it is not a ref local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnLocal2">
            <summary>This returns a member of local '{0}' by reference but it is not a ref local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnLocal2_Title">
            <summary>This returns a member of local by reference but it is not a ref local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturnStructThis">
            <summary>Struct members cannot return 'this' or other instance members by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnStructThis">
            <summary>Struct member returns 'this' or other instance members by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefReturnStructThis_Title">
            <summary>Struct member returns 'this' or other instance members by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EscapeOther">
            <summary>Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EscapeVariable">
            <summary>Cannot use variable '{0}' in this context because it may expose referenced variables outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EscapeVariable">
            <summary>Use of variable '{0}' in this context may expose referenced variables outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EscapeVariable_Title">
            <summary>Use of variable in this context may expose referenced variables outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EscapeCall">
            <summary>Cannot use a result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EscapeCall2">
            <summary>Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EscapeCall">
            <summary>Use of result of '{0}' in this context may expose variables referenced by parameter '{1}' outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EscapeCall_Title">
            <summary>Use of result in this context may expose variables referenced by parameter outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EscapeCall2">
            <summary>Use of member of result of '{0}' in this context may expose variables referenced by parameter '{1}' outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EscapeCall2_Title">
            <summary>Use of member of result in this context may expose variables referenced by parameter outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CallArgMixing">
            <summary>This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallArgMixing">
            <summary>This combination of arguments to '{0}' may expose variables referenced by parameter '{1}' outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallArgMixing_Title">
            <summary>This combination of arguments may expose variables referenced by parameter outside of their declaration scope</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MismatchedRefEscapeInTernary">
            <summary>Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MismatchedRefEscapeInTernary">
            <summary>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MismatchedRefEscapeInTernary_Title">
            <summary>The branches of the ref conditional operator refer to variables with incompatible declaration scopes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EscapeStackAlloc">
            <summary>A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EscapeStackAlloc">
            <summary>A result of a stackalloc expression of type '{0}' in this context may be exposed outside of the containing method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EscapeStackAlloc_Title">
            <summary>A result of a stackalloc expression of this type in this context may be exposed outside of the containing method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InitializeByValueVariableWithReference">
            <summary>Cannot initialize a by-value variable with a reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InitializeByReferenceVariableWithValue">
            <summary>Cannot initialize a by-reference variable with a value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefAssignmentMustHaveIdentityConversion">
            <summary>The expression must be of type '{0}' because it is being assigned by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ByReferenceVariableMustBeInitialized">
            <summary>A declaration of a by-reference variable must have an initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonDelegateCantUseLocal">
            <summary>Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIteratorLocalType">
            <summary>Iterators cannot have by-reference locals</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncLocalType">
            <summary>Async methods cannot have by-reference locals</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturningCallAndAwait">
            <summary>'await' cannot be used in an expression containing a call to '{0}' because it returns by reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefConditionalAndAwait">
            <summary>'await' cannot be used in an expression containing a ref conditional operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefConditionalNeedsTwoRefs">
            <summary>Both conditional operator values must be ref values or neither may be a ref value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefConditionalDifferentTypes">
            <summary>The expression must be of type '{0}' to match the alternative ref value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsLocalFunction">
            <summary>An expression tree may not contain a reference to a local function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DynamicLocalFunctionParamsParameter">
            <summary>Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SyntaxTreeIsNotASubmission">
            <summary>Syntax tree should be created from a submission.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TooManyUserStrings">
            <summary>Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PatternNullableType">
            <summary>It is not legal to use nullable type '{0}?' in a pattern; use the underlying type '{0}' instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IsNullableType">
            <summary>It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AsNullableType">
            <summary>It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadPatternExpression">
            <summary>Invalid operand for pattern match; value required, but found '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PeWritingFailure">
            <summary>An error occurred while writing the output file: {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TupleDuplicateElementName">
            <summary>Tuple element names must be unique.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TupleReservedElementName">
            <summary>Tuple element name '{0}' is only allowed at position {1}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TupleReservedElementNameAnyPosition">
            <summary>Tuple element name '{0}' is disallowed at any position.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PredefinedTypeMemberNotFoundInAssembly">
            <summary>Member '{0}' was not found on type '{1}' from assembly '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureTuples">
            <summary>tuples</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingDeconstruct">
            <summary>No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeconstructRequiresExpression">
            <summary>Deconstruct assignment requires an expression with a type on the right-hand-side.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchExpressionValueExpected">
            <summary>The switch expression must be a value; found '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchCaseSubsumed">
            <summary>The switch case is unreachable. It has already been handled by a previous case or it is impossible to match.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StdInOptionProvidedButConsoleInputIsNotRedirected">
            <summary>stdin argument '-' is specified, but input has not been redirected from the standard input stream.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchArmSubsumed">
            <summary>The pattern is unreachable. It has already been handled by a previous arm of the switch expression or it is impossible to match.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PatternWrongType">
            <summary>An expression of type '{0}' cannot be handled by a pattern of type '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstantPatternVsOpenType">
            <summary>An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AttributeIgnoredWhenPublicSigning">
            <summary>Attribute '{0}' is ignored when public signing is specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AttributeIgnoredWhenPublicSigning_Title">
            <summary>Attribute is ignored when public signing is specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OptionMustBeAbsolutePath">
            <summary>Option '{0}' must be an absolute path.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConversionNotTupleCompatible">
            <summary>Tuple with {0} elements cannot be converted to type '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureOutVar">
            <summary>out variable declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList">
            <summary>Reference to an implicitly-typed out variable '{0}' is not permitted in the same argument list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeInferenceFailedForImplicitlyTypedOutVariable">
            <summary>Cannot infer the type of implicitly-typed out variable '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable">
            <summary>Cannot infer the type of implicitly-typed deconstruction variable '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DiscardTypeInferenceFailed">
            <summary>Cannot infer the type of implicitly-typed discard.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeconstructWrongCardinality">
            <summary>Cannot deconstruct a tuple of '{0}' elements into '{1}' variables.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotDeconstructDynamic">
            <summary>Cannot deconstruct dynamic objects.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeconstructTooFewElements">
            <summary>Deconstruction must contain at least two variables.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TupleLiteralNameMismatch">
            <summary>The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TupleLiteralNameMismatch_Title">
            <summary>The tuple element name is ignored because a different name or no name is specified by the assignment target.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TupleBinopLiteralNameMismatch">
            <summary>The tuple element name '{0}' is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TupleBinopLiteralNameMismatch_Title">
            <summary>The tuple element name is ignored because a different name or no name is specified on the other side of the tuple == or != operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PredefinedValueTupleTypeMustBeStruct">
            <summary>Predefined type '{0}' must be a struct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewWithTupleTypeSyntax">
            <summary>'new' cannot be used with tuple type. Use a tuple literal expression instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeconstructionVarFormDisallowsSpecificType">
            <summary>Deconstruction 'var (...)' form disallows a specific type for 'var'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TupleElementNamesAttributeMissing">
            <summary>Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitTupleElementNamesAttribute">
            <summary>Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsOutVariable">
            <summary>An expression tree may not contain an out argument variable declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsDiscard">
            <summary>An expression tree may not contain a discard.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsIsMatch">
            <summary>An expression tree may not contain an 'is' pattern-matching operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsTupleLiteral">
            <summary>An expression tree may not contain a tuple literal.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsTupleConversion">
            <summary>An expression tree may not contain a tuple conversion.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SourceLinkRequiresPdb">
            <summary>/sourcelink switch is only supported when emitting PDB.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotEmbedWithoutPdb">
            <summary>/embed switch is only supported when emitting a PDB.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidInstrumentationKind">
            <summary>Invalid instrumentation kind: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidHashAlgorithmName">
            <summary>Invalid hash algorithm name: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarInvocationLvalueReserved">
            <summary>The syntax 'var (...)' as an lvalue is reserved.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SemiOrLBraceOrArrowExpected">
            <summary>{ or ; or =&gt; expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ThrowMisplaced">
            <summary>A throw expression is not allowed in this context.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeclarationExpressionNotPermitted">
            <summary>A declaration is not allowed in this context.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MustDeclareForeachIteration">
            <summary>A foreach loop must declare its iteration variables.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TupleElementNamesInDeconstruction">
            <summary>Tuple element names are not permitted on the left of a deconstruction.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PossibleBadNegCast">
            <summary>To cast a negative value, you must enclose the value in parentheses.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsThrowExpression">
            <summary>An expression tree may not contain a throw-expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsWithExpression">
            <summary>An expression tree may not contain a with-expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAssemblyName">
            <summary>Invalid assembly name: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncMethodBuilderTaskProperty">
            <summary>For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeForwardedToMultipleAssemblies">
            <summary>Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PatternDynamicType">
            <summary>It is not legal to use the type 'dynamic' in a pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDocumentationMode">
            <summary>Provided documentation mode is unsupported or invalid: '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadSourceCodeKind">
            <summary>Provided source code kind is unsupported or invalid: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadLanguageVersion">
            <summary>Provided language version is unsupported or invalid: '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidPreprocessingSymbol">
            <summary>Invalid name for a preprocessing symbol; '{0}' is not a valid identifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion7_1">
            <summary>Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion7_2">
            <summary>Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion7_3">
            <summary>Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion8">
            <summary>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LanguageVersionCannotHaveLeadingZeroes">
            <summary>Specified language version '{0}' cannot have leading zeroes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VoidAssignment">
            <summary>A value of type 'void' may not be assigned.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_Experimental">
            <summary>'{0}' is for evaluation purposes only and is subject to change or removal in future updates.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_Experimental_Title">
            <summary>Type is for evaluation purposes only and is subject to change or removal in future updates.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CompilerAndLanguageVersion">
            <summary>Compiler version: '{0}'. Language version: {1}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAsyncMain">
            <summary>async main</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TupleInferredNamesNotAvailable">
            <summary>Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AltInterpolatedVerbatimStringsNotAvailable">
            <summary>To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AttributesOnBackingFieldsNotAvailable">
            <summary>Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AttributesOnBackingFieldsNotAvailable_Title">
            <summary>Field-targeted attributes on auto-properties are not supported in this version of the language.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VoidInTuple">
            <summary>A tuple may not contain a value of type 'void'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNullableReferenceTypes">
            <summary>nullable reference types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePragmaWarningEnable">
            <summary>warning action enable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConvertingNullableToNonNullable">
            <summary>Converting null literal or possible null value to non-nullable type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConvertingNullableToNonNullable_Title">
            <summary>Converting null literal or possible null value to non-nullable type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullReferenceAssignment">
            <summary>Possible null reference assignment.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullReferenceAssignment_Title">
            <summary>Possible null reference assignment.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullReferenceReceiver">
            <summary>Dereference of a possibly null reference.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullReferenceReceiver_Title">
            <summary>Dereference of a possibly null reference.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullReferenceReturn">
            <summary>Possible null reference return.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullReferenceReturn_Title">
            <summary>Possible null reference return.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullReferenceArgument">
            <summary>Possible null reference argument for parameter '{0}' in '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullReferenceArgument_Title">
            <summary>Possible null reference argument.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ThrowPossibleNull">
            <summary>Thrown value may be null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ThrowPossibleNull_Title">
            <summary>Thrown value may be null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnboxPossibleNull">
            <summary>Unboxing a possibly null value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnboxPossibleNull_Title">
            <summary>Unboxing a possibly null value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeOnOverride">
            <summary>Nullability of reference types in type doesn't match overridden member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeOnOverride_Title">
            <summary>Nullability of reference types in type doesn't match overridden member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInReturnTypeOnOverride">
            <summary>Nullability of reference types in return type doesn't match overridden member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInReturnTypeOnOverride_Title">
            <summary>Nullability of reference types in return type doesn't match overridden member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride">
            <summary>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride_Title">
            <summary>Nullability of return type doesn't match overridden member (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInParameterTypeOnOverride">
            <summary>Nullability of reference types in type of parameter '{0}' doesn't match overridden member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInParameterTypeOnOverride_Title">
            <summary>Nullability of reference types in type of parameter doesn't match overridden member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride">
            <summary>Nullability of type of parameter '{0}' doesn't match overridden member (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride_Title">
            <summary>Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInParameterTypeOnPartial">
            <summary>Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInParameterTypeOnPartial_Title">
            <summary>Nullability of reference types in type of parameter doesn't match partial method declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInReturnTypeOnPartial">
            <summary>Nullability of reference types in return type doesn't match partial method declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInReturnTypeOnPartial_Title">
            <summary>Nullability of reference types in return type doesn't match partial method declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeOnImplicitImplementation">
            <summary>Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeOnImplicitImplementation_Title">
            <summary>Nullability of reference types in type doesn't match implicitly implemented member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation">
            <summary>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
            <summary>Nullability of reference types in return type doesn't match implicitly implemented member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation">
            <summary>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
            <summary>Nullability of reference types in type of parameter doesn't match implicitly implemented member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation">
            <summary>Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation_Title">
            <summary>Nullability of reference types in return type doesn't match implicitly implemented member (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation">
            <summary>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation_Title">
            <summary>Nullability of reference types in type of parameter doesn't match implicitly implemented member (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeOnExplicitImplementation">
            <summary>Nullability of reference types in type doesn't match implemented member '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeOnExplicitImplementation_Title">
            <summary>Nullability of reference types in type doesn't match implemented member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation">
            <summary>Nullability of reference types in return type doesn't match implemented member '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
            <summary>Nullability of reference types in return type doesn't match implemented member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation">
            <summary>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
            <summary>Nullability of reference types in type of parameter doesn't match implemented member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation">
            <summary>Nullability of reference types in return type doesn't match implemented member '{0}' (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation_Title">
            <summary>Nullability of reference types in return type doesn't match implemented member (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation">
            <summary>Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation_Title">
            <summary>Nullability of reference types in type of parameter doesn't match implemented member (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UninitializedNonNullableField">
            <summary>Non-nullable {0} '{1}' must contain a non-null value when exiting constructor. Consider declaring the {0} as nullable.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UninitializedNonNullableField_Title">
            <summary>Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInAssignment">
            <summary>Nullability of reference types in value of type '{0}' doesn't match target type '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInAssignment_Title">
            <summary>Nullability of reference types in value doesn't match target type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ImplicitCopyInReadOnlyMember">
            <summary>Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ImplicitCopyInReadOnlyMember_Title">
            <summary>Call to non-readonly member from a 'readonly' member results in an implicit copy.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticMemberCantBeReadOnly">
            <summary>Static member '{0}' cannot be marked 'readonly'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AutoSetterCantBeReadOnly">
            <summary>Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AutoPropertyWithSetterCantBeReadOnly">
            <summary>Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidPropertyReadOnlyMods">
            <summary>Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicatePropertyReadOnlyMods">
            <summary>Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldLikeEventCantBeReadOnly">
            <summary>Field-like event '{0}' cannot be 'readonly'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodReadOnlyDifference">
            <summary>Both partial method declarations must be readonly or neither may be readonly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReadOnlyModMissingAccessor">
            <summary>'{0}': 'readonly' can only be used on accessors if the property or indexer has both a get and a set accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInArgument">
            <summary>Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInArgument_Title">
            <summary>Argument cannot be used for parameter due to differences in the nullability of reference types.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInArgumentForOutput">
            <summary>Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInArgumentForOutput_Title">
            <summary>Argument cannot be used as an output for parameter due to differences in the nullability of reference types.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DisallowNullAttributeForbidsMaybeNullAssignment">
            <summary>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DisallowNullAttributeForbidsMaybeNullAssignment_Title">
            <summary>A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParameterConditionallyDisallowsNull">
            <summary>Parameter '{0}' must have a non-null value when exiting with '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParameterConditionallyDisallowsNull_Title">
            <summary>Parameter must have a non-null value when exiting in some condition.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParameterDisallowsNull">
            <summary>Parameter '{0}' must have a non-null value when exiting.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParameterDisallowsNull_Title">
            <summary>Parameter must have a non-null value when exiting.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParameterNotNullIfNotNull">
            <summary>Parameter '{0}' must have a non-null value when exiting because parameter '{1}' is non-null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParameterNotNullIfNotNull_Title">
            <summary>Parameter must have a non-null value when exiting because parameter referenced by NotNullIfNotNull is non-null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReturnNotNullIfNotNull">
            <summary>Return value must be non-null because parameter '{0}' is non-null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReturnNotNullIfNotNull_Title">
            <summary>Return value must be non-null because parameter is non-null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MemberNotNull">
            <summary>Member '{0}' must have a non-null value when exiting.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MemberNotNull_Title">
            <summary>Member must have a non-null value when exiting.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MemberNotNullBadMember">
            <summary>Member '{0}' cannot be used in this attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MemberNotNullBadMember_Title">
            <summary>Member cannot be used in this attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MemberNotNullWhen">
            <summary>Member '{0}' must have a non-null value when exiting with '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MemberNotNullWhen_Title">
            <summary>Member must have a non-null value when exiting in some condition.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ShouldNotReturn">
            <summary>A method marked [DoesNotReturn] should not return.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ShouldNotReturn_Title">
            <summary>A method marked [DoesNotReturn] should not return.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DoesNotReturnMismatch">
            <summary>Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DoesNotReturnMismatch_Title">
            <summary>Method lacks `[DoesNotReturn]` annotation to match implemented or overridden member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate">
            <summary>Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}' (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate_Title">
            <summary>Nullability of reference types in return type doesn't match the target delegate (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate">
            <summary>Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}' (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate_Title">
            <summary>Nullability of reference types in type of parameter doesn't match the target delegate (possibly because of nullability attributes).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullAsNonNullable">
            <summary>Cannot convert null literal to non-nullable reference type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullAsNonNullable_Title">
            <summary>Cannot convert null literal to non-nullable reference type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnnotationDisallowedInObjectCreation">
            <summary>Cannot use a nullable reference type in object creation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullableValueTypeMayBeNull">
            <summary>Nullable value type may be null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullableValueTypeMayBeNull_Title">
            <summary>Nullable value type may be null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeParameterConstraint">
            <summary>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeParameterConstraint_Title">
            <summary>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingNonNullTypesContextForAnnotation">
            <summary>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingNonNullTypesContextForAnnotation_Title">
            <summary>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitNullableAttribute">
            <summary>Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NullableUnconstrainedTypeParameter">
            <summary>A nullable type parameter must be known to be a value type or non-nullable reference type unless language version '{0}' or greater is used. Consider changing the language version or adding a 'class', 'struct', or type constraint.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NullableOptionNotAvailable">
            <summary>Invalid '{0}' value: '{1}' for C# {2}. Please use language version '{3}' or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NonTaskMainCantBeAsync">
            <summary>A void or int returning entry point cannot be async</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PatternWrongGenericTypeInVersion">
            <summary>An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedLocalFunction">
            <summary>The local function '{0}' is declared but never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedLocalFunction_Title">
            <summary>Local function is declared but never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LocalFunctionMissingBody">
            <summary>Local function '{0}' must declare a body because it is not marked 'static extern'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidDebugInfo">
            <summary>Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IConversionExpressionIsNotCSharpConversion">
            <summary>{0} is not a valid C# conversion expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DynamicLocalFunctionTypeParameter">
            <summary>Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureLeadingDigitSeparator">
            <summary>leading digit separator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitReservedAttr">
            <summary>Do not use '{0}'. This is reserved for compiler usage.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeReserved">
            <summary>The type name '{0}' is reserved to be used by the compiler.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InExtensionMustBeValueType">
            <summary>The first parameter of the 'in' extension method '{0}' must be a concrete (non-generic) value type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldsInRoStruct">
            <summary>Instance fields of readonly structs must be readonly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AutoPropsInRoStruct">
            <summary>Auto-implemented instance properties in readonly structs must be readonly.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldlikeEventsInRoStruct">
            <summary>Field-like events are not allowed in readonly structs.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRefExtensionMethods">
            <summary>ref extension methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StackAllocConversionNotPossible">
            <summary>Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefExtensionMustBeValueTypeOrConstrainedToOne">
            <summary>The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OutAttrOnInParam">
            <summary>An in parameter cannot have the Out attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ICompoundAssignmentOperationIsNotCSharpCompoundAssignment">
            <summary>{0} is not a valid C# compound assignment operation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FilterIsConstantFalse">
            <summary>Filter expression is a constant 'false', consider removing the catch clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FilterIsConstantFalse_Title">
            <summary>Filter expression is a constant 'false'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FilterIsConstantFalseRedundantTryCatch">
            <summary>Filter expression is a constant 'false', consider removing the try-catch block</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FilterIsConstantFalseRedundantTryCatch_Title">
            <summary>Filter expression is a constant 'false'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalInInterpolation">
            <summary>A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InDynamicMethodArg">
            <summary>Arguments with 'in' modifier cannot be used in dynamically dispatched expressions.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TupleSizesMismatchForBinOps">
            <summary>Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefLocalOrParamExpected">
            <summary>The left-hand side of a ref assignment must be a ref variable.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefAssignNarrower">
            <summary>Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefAssignReturnOnly">
            <summary>Cannot ref-assign '{1}' to '{0}' because '{1}' can only escape the current method through a return statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefAssignReturnOnly">
            <summary>This ref-assigns '{1}' to '{0}' but '{1}' can only escape the current method through a return statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefAssignReturnOnly_Title">
            <summary>This ref-assigns a value that can only escape the current method through a return statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefAssignNarrower">
            <summary>This ref-assigns '{1}' to '{0}' but '{1}' has a narrower escape scope than '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefAssignNarrower_Title">
            <summary>This ref-assigns a value that has a narrower escape scope than the target.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureEnumGenericTypeConstraint">
            <summary>enum generic type constraints</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDelegateGenericTypeConstraint">
            <summary>delegate generic type constraints</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureUnmanagedGenericTypeConstraint">
            <summary>unmanaged generic type constraints</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewBoundWithUnmanaged">
            <summary>The 'new()' constraint cannot be used with the 'unmanaged' constraint</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnmanagedConstraintNotSatisfied">
            <summary>The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConWithUnmanagedCon">
            <summary>Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureStackAllocInitializer">
            <summary>stackalloc initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidStackAllocArray">
            <summary>"Invalid rank specifier: expected ']'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExpressionVariablesInQueriesAndInitializers">
            <summary>declaration of expression variables in member initializers and queries</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingPattern">
            <summary>Pattern missing</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRecursivePatterns">
            <summary>recursive patterns</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNullPointerConstantPattern">
            <summary>null pointer constant pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDefaultTypeParameterConstraint">
            <summary>default type parameter constraints</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_WrongNumberOfSubpatterns">
            <summary>Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PropertyPatternNameMissing">
            <summary>A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultPattern">
            <summary>A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchExpressionNoBestType">
            <summary>No best type was found for the switch expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultLiteralNoTargetType">
            <summary>There is no target type for the default literal.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotInferDelegateType">
            <summary>The delegate type could not be inferred.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LambdaExplicitReturnTypeVar">
            <summary>The contextual keyword 'var' cannot be used as an explicit lambda return type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SingleElementPositionalPatternRequiresDisambiguation">
            <summary>A single-element deconstruct pattern requires some other syntax for disambiguation. It is recommended to add a discard designator '_' after the close paren ')'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarMayNotBindToType">
            <summary>The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SwitchExpressionNotExhaustive">
            <summary>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SwitchExpressionNotExhaustive_Title">
            <summary>The switch expression does not handle all possible values of its input type (it is not exhaustive).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SwitchExpressionNotExhaustiveWithWhen">
            <summary>The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SwitchExpressionNotExhaustiveWithWhen_Title">
            <summary>The switch expression does not handle all possible values of its input type (it is not exhaustive).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue">
            <summary>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value. For example, the pattern '{0}' is not covered.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue_Title">
            <summary>The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CaseConstantNamedUnderscore">
            <summary>The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CaseConstantNamedUnderscore_Title">
            <summary>Do not use '_' for a case constant.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsTypeNamedUnderscore">
            <summary>The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsTypeNamedUnderscore_Title">
            <summary>Do not use '_' to refer to the type in an is-type expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsSwitchExpression">
            <summary>An expression tree may not contain a switch expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidObjectCreation">
            <summary>Invalid object creation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureIndexingMovableFixedBuffers">
            <summary>indexing movable fixed buffers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantUseInOrOutInArglist">
            <summary>__arglist cannot have an argument passed by 'in' or 'out'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SyntaxTreeNotFound">
            <summary>SyntaxTree is not part of the compilation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OutVariableCannotBeByRef">
            <summary>An out variable cannot be declared as a ref local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultipleAnalyzerConfigsInSameDir">
            <summary>Multiple analyzer config files cannot be in the same directory ('{0}').</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureCoalesceAssignmentExpression">
            <summary>coalescing assignment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.CannotCreateConstructedFromConstructed">
            <summary>Cannot create constructed generic type from another constructed generic type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.CannotCreateConstructedFromNongeneric">
            <summary>Cannot create constructed generic type from non-generic type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator">
            <summary>unconstrained type parameters in null coalescing operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation">
            <summary>Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation_Title">
            <summary>Nullability in constraints for type parameter doesn't match the constraints for type parameter in implicitly implemented interface method'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint">
            <summary>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint_Title">
            <summary>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'class' constraint.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TripleDotNotAllowed">
            <summary>Unexpected character sequence '...'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureIndexOperator">
            <summary>index operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRangeOperator">
            <summary>range operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureStaticLocalFunctions">
            <summary>static local functions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNameShadowingInNestedFunctions">
            <summary>name shadowing in nested functions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureLambdaDiscardParameters">
            <summary>lambda discard parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureMemberNotNull">
            <summary>MemberNotNull attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNativeInt">
            <summary>native-sized integers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicAwaitForEach">
            <summary>Cannot use a collection of dynamic type in an asynchronous foreach</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NullableDirectiveQualifierExpected">
            <summary>Expected 'enable', 'disable', or 'restore'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NullableDirectiveTargetExpected">
            <summary>Expected 'warnings', 'annotations', or end of directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode">
            <summary>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode_Title">
            <summary>The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullReferenceInitializer">
            <summary>Object or collection initializer implicitly dereferences possibly null member '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullReferenceInitializer_Title">
            <summary>Object or collection initializer implicitly dereferences possibly null member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeCantContainRefStruct">
            <summary>Expression tree cannot contain value of ref struct or restricted type '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ElseCannotStartStatement">
            <summary>'else' cannot start a statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeCantContainNullCoalescingAssignment">
            <summary>An expression tree may not contain a null coalescing assignment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNullableContextOption">
            <summary>Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchGoverningExpressionRequiresParens">
            <summary>Parentheses are required around the switch governing expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TupleElementNameMismatch">
            <summary>The name '{0}' does not identify tuple element '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeconstructParameterNameMismatch">
            <summary>The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IsPatternImpossible">
            <summary>An expression of type '{0}' can never match the provided pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsPatternAlways">
            <summary>An expression of type '{0}' always matches the provided pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsPatternAlways_Title">
            <summary>The input always matches the provided pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GivenExpressionNeverMatchesPattern">
            <summary>The given expression never matches the provided pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GivenExpressionNeverMatchesPattern_Title">
            <summary>The given expression never matches the provided pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GivenExpressionAlwaysMatchesConstant">
            <summary>The given expression always matches the provided constant.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GivenExpressionAlwaysMatchesConstant_Title">
            <summary>The given expression always matches the provided constant.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GivenExpressionAlwaysMatchesPattern">
            <summary>The given expression always matches the provided pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GivenExpressionAlwaysMatchesPattern_Title">
            <summary>The given expression always matches the provided pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion8_0">
            <summary>Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PointerTypeInPatternMatching">
            <summary>Pattern-matching is not permitted for pointer types.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArgumentNameInITuplePattern">
            <summary>Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DiscardPatternInSwitchStatement">
            <summary>The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInExplicitlyImplementedInterface">
            <summary>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInExplicitlyImplementedInterface_Title">
            <summary>Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInInterfaceImplementedByBase">
            <summary>'{0}' does not implement interface member '{1}'. Nullability of reference types in interface implemented by the base type doesn't match.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInInterfaceImplementedByBase_Title">
            <summary>Type does not implement interface member. Nullability of reference types in interface implemented by the base type doesn't match.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList">
            <summary>'{0}' is already listed in the interface list on type '{1}' with different nullability of reference types.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList_Title">
            <summary>Interface is already listed in the interface list with different nullability of reference types.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateExplicitImpl">
            <summary>'{0}' is explicitly implemented more than once.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UsingVarInSwitchCase">
            <summary>A using variable cannot be used directly within a switch section (consider using braces).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GoToForwardJumpOverUsingVar">
            <summary>A goto cannot jump to a location after a using declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GoToBackwardJumpOverUsingVar">
            <summary>A goto cannot jump to a location before a using declaration within the same block.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureUsingDeclarations">
            <summary>using declarations</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDisposalPattern">
            <summary>pattern-based disposal</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureInPreview">
            <summary>The feature '{0}' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_DefaultInterfaceImplementation">
            <summary>default interface implementation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation">
            <summary>Target runtime doesn't support default interface implementation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementationForMember">
            <summary>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidModifierForLanguageVersion">
            <summary>The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitImplementationOfNonPublicInterfaceMember">
            <summary>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member in C# {3}. Please use language version '{4}' or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MostSpecificImplementationIsNotFound">
            <summary>Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LanguageVersionDoesNotSupportInterfaceImplementationForMember">
            <summary>'{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember">
            <summary>Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultInterfaceImplementationInNoPIAType">
            <summary>Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SwitchExpressionNotExhaustiveForNull">
            <summary>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SwitchExpressionNotExhaustiveForNull_Title">
            <summary>The switch expression does not handle some null inputs.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SwitchExpressionNotExhaustiveForNullWithWhen">
            <summary>The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SwitchExpressionNotExhaustiveForNullWithWhen_Title">
            <summary>The switch expression does not handle some null inputs.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeNotOnEventAccessor">
            <summary>Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureObsoleteOnPropertyAccessor">
            <summary>obsolete on property accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnconsumedEnumeratorCancellationAttributeUsage">
            <summary>The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnconsumedEnumeratorCancellationAttributeUsage_Title">
            <summary>The EnumeratorCancellationAttribute will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UndecoratedCancellationTokenParameter">
            <summary>Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be un ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UndecoratedCancellationTokenParameter_Title">
            <summary>Async-iterator member has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' will be u ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultipleEnumeratorCancellationAttributes">
            <summary>The attribute [EnumeratorCancellation] cannot be used on multiple parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideRefConstraintNotSatisfied">
            <summary>Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideValConstraintNotSatisfied">
            <summary>Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideDefaultConstraintNotSatisfied">
            <summary>Method '{0}' specifies a 'default' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is constrained to a reference type or a value type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultConstraintOverrideOnly">
            <summary>The 'default' constraint is valid on override and explicit interface implementation methods only.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_OverrideWithConstraints">
            <summary>constraints for override and explicit interface implementation methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInConstraintsOnPartialImplementation">
            <summary>Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInConstraintsOnPartialImplementation_Title">
            <summary>Partial method declarations have inconsistent nullability in constraints for type parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNestedStackalloc">
            <summary>stackalloc in nested expressions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeParameterNotNullConstraint">
            <summary>The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NullabilityMismatchInTypeParameterNotNullConstraint_Title">
            <summary>The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNotNullGenericTypeConstraint">
            <summary>notnull generic type constraint</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateNullSuppression">
            <summary>Duplicate null suppression operator ('!')</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParameterNullCheckingNotSupported">
            <summary>The 'parameter null-checking' feature is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReAbstractionInNoPIAType">
            <summary>Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadSwitchValue">
            <summary>Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureFunctionPointers">
            <summary>function pointers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_AddressOfMethodGroup">
            <summary>&amp;method group</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidFunctionPointerCallingConvention">
            <summary>'{0}' is not a valid calling convention specifier for a function pointer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeNotFound">
            <summary>Type '{0}' is not defined.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeMustBePublic">
            <summary>Type '{0}' must be public to be used as a calling convention.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SyncAndAsyncEntryPoints">
            <summary>Method '{0}' will not be used as an entry point because a synchronous entry point '{1}' was found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InternalError">
            <summary>Internal error in the C# compiler.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureStaticAnonymousFunction">
            <summary>static anonymous function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticAnonymousFunctionCannotCaptureThis">
            <summary>A static anonymous function cannot contain a reference to 'this' or 'base'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticAnonymousFunctionCannotCaptureVariable">
            <summary>A static anonymous function cannot contain a reference to '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAsyncUsing">
            <summary>asynchronous using</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureParenthesizedPattern">
            <summary>parenthesized pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureOrPattern">
            <summary>or pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAndPattern">
            <summary>and pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNotPattern">
            <summary>not pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureTypePattern">
            <summary>type pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRelationalPattern">
            <summary>relational pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarianceInterfaceNesting">
            <summary>Enums, classes, and structures cannot be declared in an interface that has an 'in' or 'out' type parameter.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExternEventInitializer">
            <summary>'{0}': extern event cannot have initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitIndexIndexerWithName">
            <summary>Invocation of implicit Index Indexer cannot name the argument.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitRangeIndexerWithName">
            <summary>Invocation of implicit Range Indexer cannot name the argument.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitObjectCreationIllegalTargetType">
            <summary>The type '{0}' may not be used as the target type of new()</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitObjectCreationNotValid">
            <summary>Use of new() is not valid in this context</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitObjectCreationNoTargetType">
            <summary>There is no target type for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureImplicitObjectCreation">
            <summary>target-typed object creation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsPatternImplicitIndexer">
            <summary>An expression tree may not contain a pattern System.Index or System.Range indexer access</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsFromEndIndexExpression">
            <summary>An expression tree may not contain a from-end index ('^') expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsRangeExpression">
            <summary>An expression tree may not contain a range ('..') expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GeneratorFailedDuringGeneration">
            <summary>Generator '{0}' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GeneratorFailedDuringInitialization">
            <summary>Generator '{0}' failed to initialize. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GeneratorFailedDuringGeneration_Title">
            <summary>Generator failed to generate source.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GeneratorFailedDuringInitialization_Title">
            <summary>Generator failed to initialize.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GeneratorFailedDuringGeneration_Description">
            <summary>Generator threw the following exception:
            '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GeneratorFailedDuringInitialization_Description">
            <summary>Generator threw the following exception:
            '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRecords">
            <summary>records</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureInitOnlySetters">
            <summary>init-only setters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidWithReceiverType">
            <summary>The receiver of a `with` expression must have a non-void type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotClone">
            <summary>The receiver type '{0}' is not a valid record type and is not a struct type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssignmentInitOnly">
            <summary>Init-only property or indexer '{0}' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DesignatorBeneathPatternCombinator">
            <summary>A variable may not be declared within a 'not' or 'or' pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsupportedTypeForRelationalPattern">
            <summary>Relational patterns may not be used for a value of type '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RelationalPatternWithNaN">
            <summary>Relational patterns may not be used for a floating-point NaN.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureSpanCharConstantPattern">
            <summary>pattern matching ReadOnly/Span&lt;char&gt; on constant string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExtendedPartialMethods">
            <summary>extended partial methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureConstantInterpolatedStrings">
            <summary>constant interpolated strings</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodWithNonVoidReturnMustHaveAccessMods">
            <summary>Partial method '{0}' must have accessibility modifiers because it has a non-void return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodWithOutParamMustHaveAccessMods">
            <summary>Partial method '{0}' must have accessibility modifiers because it has 'out' parameters.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation">
            <summary>Partial method '{0}' must have an implementation part because it has accessibility modifiers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodWithExtendedModMustHaveAccessMods">
            <summary>Partial method '{0}' must have accessibility modifiers because it has a 'virtual', 'override', 'sealed', 'new', or 'extern' modifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodAccessibilityDifference">
            <summary>Both partial method declarations must have identical accessibility modifiers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodExtendedModDifference">
            <summary>Both partial method declarations must have identical combinations of 'virtual', 'override', 'sealed', and 'new' modifiers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodReturnTypeDifference">
            <summary>Both partial method declarations must have the same return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodRefReturnDifference">
            <summary>Partial method declarations must have matching ref return values.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PartialMethodTypeDifference">
            <summary>Partial method declarations '{0}' and '{1}' have signature differences.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PartialMethodTypeDifference_Title">
            <summary>Partial method declarations have signature differences.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_TopLevelStatements">
            <summary>top-level statements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SimpleProgramLocalIsReferencedOutsideOfTopLevelStatement">
            <summary>Cannot use local variable or local function '{0}' declared in a top-level statement in this context.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SimpleProgramMultipleUnitsWithTopLevelStatements">
            <summary>Only one compilation unit can have top-level statements.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TopLevelStatementAfterNamespaceOrType">
            <summary>Top-level statements must precede namespace and type declarations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SimpleProgramDisallowsMainType">
            <summary>Cannot specify /main if there is a compilation unit with top-level statements.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SimpleProgramNotAnExecutable">
            <summary>Program using top-level statements must be an executable.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidFuncPointerReturnTypeModifier">
            <summary>'{0}' is not a valid function pointer return type modifier. Valid modifiers are 'ref' and 'ref readonly'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DupReturnTypeMod">
            <summary>A return type can only have one '{0}' modifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadFuncPointerParamModifier">
            <summary>'{0}' cannot be used as a modifier on a function pointer parameter.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadFuncPointerArgCount">
            <summary>Function pointer '{0}' does not take {1} arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethFuncPtrMismatch">
            <summary>No overload for '{0}' matches function pointer '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FuncPtrRefMismatch">
            <summary>Ref mismatch between '{0}' and function pointer '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FuncPtrMethMustBeStatic">
            <summary>Cannot create a function pointer for '{0}' because it is not a static method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AddressOfMethodGroupInExpressionTree">
            <summary>'&amp;' on method groups cannot be used in expression trees</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_WrongFuncPtrCallingConvention">
            <summary>Calling convention of '{0}' is not compatible with '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingAddressOf">
            <summary>Cannot convert method group to function pointer (Are you missing a '&amp;'?)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotUseReducedExtensionMethodInAddressOf">
            <summary>Cannot use an extension method with a receiver as the target of a '&amp;' operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotUseFunctionPointerAsFixedLocal">
            <summary>The type of a local declared in a fixed statement cannot be a function pointer type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsupportedCallingConvention">
            <summary>The calling convention of '{0}' is not supported by the language.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RuntimeDoesNotSupportUnmanagedDefaultCallConv">
            <summary>The target runtime doesn't support extensible or runtime-environment default calling conventions.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.NotSameNumberParameterTypesAndRefKinds">
            <summary>Given {0} parameter types and {1} parameter ref kinds. These arrays must have the same length.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.OutIsNotValidForReturn">
            <summary>'RefKind.Out' is not a valid ref kind for a return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.CallingConventionTypesRequireUnmanaged">
            <summary>Passing '{0}' is not valid unless '{1}' is 'SignatureCallingConvention.Unmanaged'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.CallingConventionTypeIsInvalid">
            <summary>Cannot use '{0}' as a calling convention modifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotConvertAddressOfToDelegate">
            <summary>Cannot convert &amp;method group '{0}' to delegate type '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AddressOfToNonFunctionPointer">
            <summary>Cannot convert &amp;method group '{0}' to non-function pointer type '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotSpecifyManagedWithUnmanagedSpecifiers">
            <summary>'managed' calling convention cannot be combined with unmanaged calling convention specifiers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion9">
            <summary>Feature '{0}' is not available in C# 9.0. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion10">
            <summary>Feature '{0}' is not available in C# 10.0. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion11">
            <summary>Feature '{0}' is not available in C# 11.0. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedArgumentList">
            <summary>Unexpected argument list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedOrMissingConstructorInitializerInRecord">
            <summary>A constructor declared in a record with parameter list must have 'this' constructor initializer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultipleRecordParameterLists">
            <summary>Only a single record partial declaration may have a parameter list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadRecordBase">
            <summary>Records may only inherit from object or another record</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadInheritanceFromRecord">
            <summary>Only records may inherit from records.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadRecordMemberForPositionalParameter">
            <summary>Record member '{0}' must be a readable instance property or field of type '{1}' to match positional parameter '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoCopyConstructorInBaseType">
            <summary>No accessible copy constructor found in base type '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CopyConstructorMustInvokeBaseCopyConstructor">
            <summary>A copy constructor in a record must call a copy constructor of the base, or a parameterless object constructor if the record inherits from object.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureTargetTypedConditional">
            <summary>target-typed conditional expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoImplicitConvTargetTypedConditional">
            <summary>Conditional expression is not valid in language version {0} because a common type was not found between '{1}' and '{2}'. To use a target-typed conversion, upgrade to language version {3} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DoesNotOverrideMethodFromObject">
            <summary>'{0}' does not override expected method from 'object'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureCovariantReturnsForOverrides">
            <summary>covariant returns</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RuntimeDoesNotSupportCovariantReturnsOfClasses">
            <summary>'{0}': Target runtime doesn't support covariant return types in overrides. Return type must be '{2}' to match overridden member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RuntimeDoesNotSupportCovariantPropertiesOfClasses">
            <summary>'{0}': Target runtime doesn't support covariant types in overrides. Type must be '{2}' to match overridden member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SealedAPIInRecord">
            <summary>'{0}' cannot be sealed because containing record is not sealed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DoesNotOverrideBaseMethod">
            <summary>'{0}' does not override expected method from '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConstOutOfRangeChecked">
            <summary>Constant value '{0}' may overflow '{1}' at runtime (use 'unchecked' syntax to override)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConstOutOfRangeChecked_Title">
            <summary>Constant value may overflow at runtime (use 'unchecked' syntax to override)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloneDisallowedInRecord">
            <summary>Members named 'Clone' are disallowed in records.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RecordNamedDisallowed">
            <summary>Types and aliases should not be named 'record'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RecordNamedDisallowed_Title">
            <summary>Types and aliases should not be named 'record'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotOverridableAPIInRecord">
            <summary>'{0}' must allow overriding because the containing record is not sealed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NonPublicAPIInRecord">
            <summary>Record member '{0}' must be public.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SignatureMismatchInRecord">
            <summary>Record member '{0}' must return '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NonProtectedAPIInRecord">
            <summary>Record member '{0}' must be protected.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DoesNotOverrideBaseEqualityContract">
            <summary>'{0}' does not override expected property from '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticAPIInRecord">
            <summary>Record member '{0}' may not be static.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CopyConstructorWrongAccessibility">
            <summary>A copy constructor '{0}' must be public or protected because the record is not sealed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NonPrivateAPIInRecord">
            <summary>Record member '{0}' must be private.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PrecedenceInversion">
            <summary>Operator '{0}' cannot be used here due to precedence. Use parentheses to disambiguate.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PrecedenceInversion_Title">
            <summary>Operator cannot be used here due to precedence.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureModuleInitializers">
            <summary>module initializers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ModuleInitializerMethodMustBeAccessibleOutsideTopLevelType">
            <summary>Module initializer method '{0}' must be accessible at the module level</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ModuleInitializerMethodMustBeStaticParameterlessVoid">
            <summary>Module initializer method '{0}' must be static, and non-virtual, must have no parameters, and must return 'void'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ModuleInitializerMethodAndContainingTypesMustNotBeGeneric">
            <summary>Module initializer method '{0}' must not be generic and must not be contained in a generic type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ModuleInitializerMethodMustBeOrdinary">
            <summary>A module initializer must be an ordinary member method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExtensionGetAsyncEnumerator">
            <summary>extension GetAsyncEnumerator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExtensionGetEnumerator">
            <summary>extension GetEnumerator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnmanagedCallersOnlyRequiresStatic">
            <summary>'UnmanagedCallersOnly' can only be applied to ordinary static non-abstract, non-virtual methods or static local functions.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidUnmanagedCallersOnlyCallConv">
            <summary>'{0}' is not a valid calling convention type for 'UnmanagedCallersOnly'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotUseManagedTypeInUnmanagedCallersOnly">
            <summary>Cannot use '{0}' as a {1} type on a method attributed with 'UnmanagedCallersOnly'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnmanagedCallersOnlyMethodOrTypeCannotBeGeneric">
            <summary>Methods attributed with 'UnmanagedCallersOnly' cannot have generic type parameters and cannot be declared in a generic type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnmanagedCallersOnlyMethodsCannotBeCalledDirectly">
            <summary>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be called directly. Obtain a function pointer to this method.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnmanagedCallersOnlyMethodsCannotBeConvertedToDelegate">
            <summary>'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be converted to a delegate type. Obtain a function pointer to this method.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EntryPointCannotBeUnmanagedCallersOnly">
            <summary>Application entry points cannot be attributed with 'UnmanagedCallersOnly'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ModuleInitializerCannotBeUnmanagedCallersOnly">
            <summary>Module initializer cannot be attributed with 'UnmanagedCallersOnly'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RecordEqualsWithoutGetHashCode">
            <summary>'{0}' defines 'Equals' but not 'GetHashCode'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RecordEqualsWithoutGetHashCode_Title">
            <summary>Record defines 'Equals' but not 'GetHashCode'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InitCannotBeReadonly">
            <summary>'init' accessors cannot be marked 'readonly'. Mark '{0}' readonly instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDiscards">
            <summary>discards</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction">
            <summary>Mixed declarations and expressions in deconstruction</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRecordStructs">
            <summary>record structs</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureWithOnStructs">
            <summary>with on structs</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureWithOnAnonymousTypes">
            <summary>with on anonymous types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_AsyncMethodBuilderOverride">
            <summary>async method builder override</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePositionalFieldsInRecords">
            <summary>positional fields in records</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureParameterlessStructConstructors">
            <summary>parameterless struct constructors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureStructFieldInitializers">
            <summary>struct field initializers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRefFields">
            <summary>ref fields</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureVarianceSafetyForStaticInterfaceMembers">
            <summary>variance safety for static interface members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EqualityContractRequiresGetter">
            <summary>Record equality contract property '{0}' must have a get accessor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AnalyzerReferencesFramework">
            <summary>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AnalyzerReferencesFramework_Title">
            <summary>The loaded assembly references .NET Framework, which is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AnalyzerReferencesNewerCompiler">
            <summary>The analyzer assembly '{0}' references version '{1}' of the compiler, which is newer than the currently running version '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AnalyzerReferencesNewerCompiler_Title">
            <summary>The analyzer assembly references a newer version of the compiler than the currently running version.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadFieldTypeInRecord">
            <summary>The type '{0}' may not be used for a field of a record.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FunctionPointersCannotBeCalledWithNamedArguments">
            <summary>A function pointer cannot be called with named arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureFileScopedNamespace">
            <summary>file-scoped namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultipleFileScopedNamespace">
            <summary>Source file can only contain one file-scoped namespace declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FileScopedAndNormalNamespace">
            <summary>Source file can not contain both file-scoped and normal namespace declarations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FileScopedNamespaceNotBeforeAllMembers">
            <summary>File-scoped namespace must precede all other members in a file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreadRecordParameter">
            <summary>Parameter '{0}' is unread. Did you forget to use it to initialize the property with that name?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreadRecordParameter_Title">
            <summary>Parameter is unread. Did you forget to use it to initialize the property with that name?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RecordAmbigCtor">
            <summary>The primary constructor conflicts with the synthesized copy constructor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureLambdaAttributes">
            <summary>lambda attributes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureLambdaReturnType">
            <summary>lambda return type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureInferredDelegateType">
            <summary>inferred delegate type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAutoDefaultStructs">
            <summary>auto default struct fields</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LineSpanDirectiveInvalidValue">
            <summary>The #line directive value is missing or out of range</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LineSpanDirectiveEndLessThanStart">
            <summary>The #line directive end position must be greater than or equal to the start position</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LineSpanDirectiveRequiresSpace">
            <summary>The #line span directive requires space before the first parenthesis, before the character offset, and before the file name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DoNotCompareFunctionPointers">
            <summary>Comparison of function pointers might yield an unexpected result, since pointers to the same function may be distinct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DoNotCompareFunctionPointers_Title">
            <summary>Do not compare function pointer values</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FunctionPointerTypesInAttributeNotSupported">
            <summary>Using a function pointer type in a 'typeof' in an attribute is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCallerArgumentExpressionParamWithoutDefaultValue">
            <summary>The CallerArgumentExpressionAttribute may only be applied to parameters with default values</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConversionForCallerArgumentExpressionParam">
            <summary>CallerArgumentExpressionAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerArgumentExpressionParamForUnconsumedLocation">
            <summary>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerArgumentExpressionParamForUnconsumedLocation_Title">
            <summary>The CallerArgumentExpressionAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerFilePathPreferredOverCallerArgumentExpression">
            <summary>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerFilePathPreferredOverCallerArgumentExpression_Title">
            <summary>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerFilePathAttribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberPreferredOverCallerArgumentExpression">
            <summary>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberPreferredOverCallerArgumentExpression_Title">
            <summary>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerLineNumberAttribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerMemberNamePreferredOverCallerArgumentExpression">
            <summary>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerMemberNameAttribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerMemberNamePreferredOverCallerArgumentExpression_Title">
            <summary>The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerMemberNameAttribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerArgumentExpressionAttributeHasInvalidParameterName">
            <summary>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is applied with an invalid parameter name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerArgumentExpressionAttributeHasInvalidParameterName_Title">
            <summary>The CallerArgumentExpressionAttribute is applied with an invalid parameter name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerArgumentExpressionAttributeSelfReferential">
            <summary>The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it's self-referential.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerArgumentExpressionAttributeSelfReferential_Title">
            <summary>The CallerArgumentExpressionAttribute applied to parameter will have no effect because it's self-refential.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureSealedToStringInRecord">
            <summary>sealed ToString in record</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InheritingFromRecordWithSealedToString">
            <summary>Inheriting from a record with a sealed 'Object.ToString' is not supported in C# {0}. Please use language version '{1}' or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureListPattern">
            <summary>list pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsupportedTypeForListPattern">
            <summary>List patterns may not be used for a value of type '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ListPatternRequiresLength">
            <summary>List patterns may not be used for a value of type '{0}'. No suitable 'Length' or 'Count' property was found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ScopedRefAndRefStructOnly">
            <summary>The 'scoped' modifier can be used for refs and ref struct values only.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ScopedMismatchInParameterOfOverrideOrImplementation">
            <summary>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ScopedMismatchInParameterOfOverrideOrImplementation">
            <summary>The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ScopedMismatchInParameterOfOverrideOrImplementation_Title">
            <summary>The 'scoped' modifier of parameter doesn't match overridden or implemented member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ScopedMismatchInParameterOfTarget">
            <summary>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ScopedMismatchInParameterOfTarget">
            <summary>The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ScopedMismatchInParameterOfTarget_Title">
            <summary>The 'scoped' modifier of parameter doesn't match target.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ScopedMismatchInParameterOfPartial">
            <summary>The 'scoped' modifier of parameter '{0}' doesn't match partial method declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedFieldMustNotBeRef">
            <summary>A fixed field must not be a ref field.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefFieldCannotReferToRefStruct">
            <summary>A ref field cannot refer to a ref struct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefFieldInNonRefStruct">
            <summary>A ref field can only be declared in a ref struct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationPropertySupportedVersion">
            <summary>Auto-implemented property '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationPropertySupportedVersion_Title">
            <summary>Auto-implemented property is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationFieldSupportedVersion">
            <summary>Field '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationFieldSupportedVersion_Title">
            <summary>Field is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationThisSupportedVersion">
            <summary>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationThisSupportedVersion_Title">
            <summary>The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedThisAutoPropertySupportedVersion">
            <summary>Control is returned to caller before auto-implemented property '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedThisAutoPropertySupportedVersion_Title">
            <summary>Control is returned to caller before auto-implemented property is explicitly assigned, causing a preceding implicit assignment of 'default'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedThisSupportedVersion">
            <summary>Control is returned to caller before field '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedThisSupportedVersion_Title">
            <summary>Control is returned to caller before field is explicitly assigned, causing a preceding implicit assignment of 'default'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolationFieldUnsupportedVersion">
            <summary>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolationPropertyUnsupportedVersion">
            <summary>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationFieldUnsupportedVersion">
            <summary>Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationFieldUnsupportedVersion_Title">
            <summary>Use of possibly unassigned field. Consider updating the language version to auto-default the field.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationPropertyUnsupportedVersion">
            <summary>Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UseDefViolationPropertyUnsupportedVersion_Title">
            <summary>Use of possibly unassigned auto-implemented property. Consider updating the language version to auto-default the property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsupportedTypeForSlicePattern">
            <summary>Slice patterns may not be used for a value of type '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MisplacedSlicePattern">
            <summary>Slice patterns may only be used once and directly inside a list pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_HiddenPositionalMember">
            <summary>The positional member '{0}' found corresponding to this parameter is hidden.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureImprovedInterpolatedStrings">
            <summary>interpolated string handlers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterpolatedStringHandlerMethodReturnMalformed">
            <summary>Interpolated string handler method '{0}' is malformed. It does not return 'void' or 'bool'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterpolatedStringHandlerMethodReturnInconsistent">
            <summary>Interpolated string handler method '{0}' has inconsistent return type. Expected to return '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidNameInSubpattern">
            <summary>Identifier or a simple member access expected.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExtendedPropertyPatterns">
            <summary>extended property patterns</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureGlobalUsing">
            <summary>global using directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalUsingInNamespace">
            <summary>A global using directive cannot be used in a namespace declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalUsingOutOfOrder">
            <summary>A global using directive must precede all non-global using directives.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NullInvalidInterpolatedStringHandlerArgumentName">
            <summary>null is not a valid parameter name. To get access to the receiver of an instance method, use the empty string as the parameter name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotInstanceInvalidInterpolatedStringHandlerArgumentName">
            <summary>'{0}' is not an instance method, the receiver cannot be an interpolated string handler argument.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidInterpolatedStringHandlerArgumentName">
            <summary>'{0}' is not a valid parameter name from '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeIsNotAnInterpolatedStringHandlerType">
            <summary>'{0}' is not an interpolated string handler type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParameterOccursAfterInterpolatedStringHandlerParameter">
            <summary>Parameter '{0}' occurs after '{1}' in the parameter list, but is used as an argument for interpolated string handler conversions. This will require the caller to reorder parameters with named arguments at the call site. Consider putting the interpolated st ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ParameterOccursAfterInterpolatedStringHandlerParameter_Title">
            <summary>Parameter to interpolated string handler conversion occurs after handler parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotUseSelfAsInterpolatedStringHandlerArgument">
            <summary>InterpolatedStringHandlerArgumentAttribute arguments cannot refer to the parameter the attribute is used on.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterpolatedStringHandlerArgumentAttributeMalformed">
            <summary>The InterpolatedStringHandlerArgumentAttribute applied to parameter '{0}' is malformed and cannot be interpreted. Construct an instance of '{1}' manually.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterpolatedStringHandlerArgumentLocatedAfterInterpolatedString">
            <summary>Parameter '{0}' is an argument to the interpolated string handler conversion on parameter '{1}', but the corresponding argument is specified after the interpolated string expression. Reorder the arguments to move '{0}' before '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterpolatedStringHandlerArgumentOptionalNotSpecified">
            <summary>Parameter '{0}' is not explicitly provided, but is used as an argument to the interpolated string handler conversion on parameter '{1}'. Specify the value of '{0}' before '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsInterpolatedStringHandlerConversion">
            <summary>An expression tree may not contain an interpolated string handler conversion.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterpolatedStringHandlerCreationCannotUseDynamic">
            <summary>An interpolated string handler construction cannot use dynamic. Manually construct an instance of '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NonPublicParameterlessStructConstructor">
            <summary>The parameterless struct constructor must be 'public'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureStaticAbstractMembersInInterfaces">
            <summary>static abstract members in interfaces</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfaces">
            <summary>Target runtime doesn't support static abstract members in interfaces.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericConstraintNotSatisfiedInterfaceWithStaticAbstractMembers">
            <summary>The interface '{0}' cannot be used as type argument. Static member '{1}' does not have a most specific implementation in the interface.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAbstractUnaryOperatorSignature">
            <summary>The parameter of a unary operator must be the containing type, or its type parameter constrained to it.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAbstractIncDecSignature">
            <summary>The parameter type for ++ or -- operator must be the containing type, or its type parameter constrained to it.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAbstractIncDecRetType">
            <summary>The return type for ++ or -- operator must either match the parameter type, or be derived from the parameter type, or be the containing type's type parameter constrained to it unless the parameter type is a different type parameter.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAbstractBinaryOperatorSignature">
            <summary>One of the parameters of a binary operator must be the containing type, or its type parameter constrained to it.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAbstractShiftOperatorSignature">
            <summary>The first operand of an overloaded shift operator must have the same type as the containing type or its type parameter constrained to it</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAbstractStaticMemberAccess">
            <summary>A static virtual or abstract interface member can be accessed only on a type parameter.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsAbstractStaticMemberAccess">
            <summary>An expression tree may not contain an access of static virtual or abstract interface member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloseUnimplementedInterfaceMemberNotStatic">
            <summary>'{0}' does not implement static interface member '{1}'. '{2}' cannot implement the interface member because it is not static.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RuntimeDoesNotSupportStaticAbstractMembersInInterfacesForMember">
            <summary>'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support static abstract members in interfaces.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitImplementationOfOperatorsMustBeStatic">
            <summary>Explicit implementation of a user-defined operator '{0}' must be declared static</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractConversionNotInvolvingContainedType">
            <summary>User-defined conversion in an interface must convert to or from a type parameter on the enclosing type constrained to the enclosing type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfaceImplementedByUnmanagedCallersOnlyMethod">
            <summary>'UnmanagedCallersOnly' method '{0}' cannot implement interface member '{1}' in type '{2}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.HDN_DuplicateWithGlobalUsing">
            <summary>The using directive for '{0}' appeared previously as global using</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.HDN_DuplicateWithGlobalUsing_Title">
            <summary>The using directive appeared previously as global using</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BuilderAttributeDisallowed">
            <summary>The AsyncMethodBuilder attribute is disallowed on anonymous methods without an explicit return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SimpleProgramIsEmpty">
            <summary>At least one top-level statement must be non-empty.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LineDoesNotStartWithSameWhitespace">
            <summary>Line does not start with the same whitespace as the closing line of the raw string literal.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RawStringNotInDirectives">
            <summary>Raw string literals are not allowed in preprocessor directives.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RawStringDelimiterOnOwnLine">
            <summary>Raw string literal delimiter must be on its own line.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TooManyQuotesForRawString">
            <summary>The raw string literal does not start with enough quote characters to allow this many consecutive quote characters as content.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TooManyOpenBracesForRawString">
            <summary>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive opening braces as content.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TooManyCloseBracesForRawString">
            <summary>The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive closing braces as content.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotEnoughQuotesForRawString">
            <summary>Not enough quotes for raw string literal.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotEnoughCloseBracesForRawString">
            <summary>The interpolation must end with the same number of closing braces as the number of '$' characters that the raw string literal started with.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalAtSequence">
            <summary>Sequence of '@' characters is not allowed. A verbatim string or identifier can only have one '@' character and a raw string cannot have any.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StringMustStartWithQuoteCharacter">
            <summary>String must start with quote character: "</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnterminatedRawString">
            <summary>Unterminated raw string literal.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRawStringLiterals">
            <summary>raw string literals</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RawStringInVerbatimInterpolatedStrings">
            <summary>Multi-line raw string literals are only allowed in verbatim interpolated strings.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RawStringMustContainContent">
            <summary>Multi-line raw string literals must contain at least one line of content.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewlinesAreNotAllowedInsideANonVerbatimInterpolatedString">
            <summary>Newlines inside a non-verbatim interpolated string are not supported in C# {0}. Please use language version {1} or greater.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureGenericAttributes">
            <summary>generic attributes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters">
            <summary>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InterpolatedStringHandlerArgumentAttributeIgnoredOnLambdaParameters_Title">
            <summary>InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LambdaWithAttributesToExpressionTree">
            <summary>A lambda expression with attributes cannot be converted to an expression tree</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RecordStructConstructorCallsDefaultConstructor">
            <summary>A constructor declared in a 'record struct' with parameter list must have a 'this' initializer that calls the primary constructor or an explicitly declared constructor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StructHasInitializersAndNoDeclaredConstructor">
            <summary>A 'struct' with field initializers must include an explicitly declared constructor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PatternSpanCharCannotBeStringNull">
            <summary>A string 'null' constant is not supported as a pattern for '{0}'. Use an empty string instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EncUpdateFailedDelegateTypeChanged">
            <summary>Cannot update because an inferred delegate type has changed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CompileTimeCheckedOverflow">
            <summary>The operation may overflow '{0}' at runtime (use 'unchecked' syntax to override)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CompileTimeCheckedOverflow_Title">
            <summary>The operation may overflow at runtime (use 'unchecked' syntax to override)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotUseRefInUnmanagedCallersOnly">
            <summary>Cannot use 'ref', 'in', or 'out' in the signature of a method attributed with 'UnmanagedCallersOnly'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNewLinesInInterpolations">
            <summary>newlines in interpolations</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterpolatedStringsReferencingInstanceCannotBeInObjectInitializers">
            <summary>Interpolated string handler conversions that reference the instance being indexed cannot be used in indexer member initializers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotBeMadeNullable">
            <summary>'{0}' cannot be made nullable.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_LowerCaseTypeName">
            <summary>The type name '{0}' only contains lower-cased ascii characters. Such names may become reserved for the language.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_LowerCaseTypeName_Title">
            <summary>The type name only contains lower-cased ascii characters. Such names may become reserved for the language.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RequiredNameDisallowed">
            <summary>Types and aliases cannot be named 'required'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRequiredMembers">
            <summary>required members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideMustHaveRequired">
            <summary>'{0}' must be required because it overrides required member '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RequiredMemberCannotBeHidden">
            <summary>Required member '{0}' cannot be hidden by '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RequiredMemberCannotBeLessVisibleThanContainingType">
            <summary>Required member '{0}' cannot be less visible or have a setter less visible than the containing type '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitRequiredMember">
            <summary>Do not use 'System.Runtime.CompilerServices.RequiredMemberAttribute'. Use the 'required' keyword on required fields and properties instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RequiredMemberMustBeSettable">
            <summary>Required member '{0}' must be settable.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RequiredMemberMustBeSet">
            <summary>Required member '{0}' must be set in the object initializer or attribute constructor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RequiredMembersMustBeAssignedValue">
            <summary>Required member '{0}' must be assigned a value, it cannot use a nested member or collection initializer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RequiredMembersInvalid">
            <summary>The required members list for '{0}' is malformed and cannot be interpreted.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RequiredMembersBaseTypeInvalid">
            <summary>The required members list for the base type '{0}' is malformed and cannot be interpreted. To use this constructor, apply the 'SetsRequiredMembers' attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LineContainsDifferentWhitespace">
            <summary>Line contains different whitespace than the closing line of the raw string literal: '{0}' versus '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoEnumConstraint">
            <summary>Keyword 'enum' cannot be used as a constraint. Did you mean 'struct, System.Enum'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoDelegateConstraint">
            <summary>Keyword 'delegate' cannot be used as a constraint. Did you mean 'System.Delegate'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MisplacedRecord">
            <summary>Unexpected keyword 'record'. Did you mean 'record struct' or 'record class'?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureCheckedUserDefinedOperators">
            <summary>checked user-defined operators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OperatorCantBeChecked">
            <summary>User-defined operator '{0}' cannot be declared checked</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitConversionOperatorCantBeChecked">
            <summary>An 'implicit' user-defined conversion operator cannot be declared checked</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CheckedOperatorNeedsMatch">
            <summary>The operator '{0}' requires a matching non-checked version of the operator to also be defined</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotBeConvertedToUtf8">
            <summary>The input string cannot be converted into the equivalent UTF-8 byte representation. {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureUtf8StringLiterals">
            <summary>UTF-8 string literals</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsUtf8StringLiterals">
            <summary>An expression tree may not contain UTF-8 string conversion or literal.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ChainingToSetsRequiredMembersRequiresSetsRequiredMembers">
            <summary>This constructor must add 'SetsRequiredMembers' because it chains to a constructor that has that attribute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewConstraintCannotHaveRequiredMembers">
            <summary>'{2}' cannot satisfy the 'new()' constraint on parameter '{1}' in the generic type or or method '{0}' because '{2}' has required members.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FileTypeDisallowedInSignature">
            <summary>File-local type '{0}' cannot be used in a member signature in non-file-local type '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FileTypeNoExplicitAccessibility">
            <summary>File-local type '{0}' cannot use accessibility modifiers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FileTypeBase">
            <summary>File-local type '{0}' cannot be used as a base type of non-file-local type '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FileTypeNested">
            <summary>File-local type '{0}' must be defined in a top level type; '{0}' is a nested type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FilePathCannotBeConvertedToUtf8">
            <summary>File-local type '{0}' cannot be used because the containing file path cannot be converted into the equivalent UTF-8 byte representation. {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalUsingStaticFileType">
            <summary>File-local type '{0}' cannot be used in a 'global using static' directive.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FileTypeNameDisallowed">
            <summary>Types and aliases cannot be named 'file'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FileTypeNonUniquePath">
            <summary>File-local type '{0}' must be declared in a file with a unique path. Path '{1}' is used in multiple files.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureUnsignedRightShift">
            <summary>unsigned right shift</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureRelaxedShiftOperator">
            <summary>relaxed shift operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsupportedCompilerFeature">
            <summary>'{0}' requires compiler feature '{1}', which is not supported by this version of the C# compiler.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ObsoleteMembersShouldNotBeRequired">
            <summary>Required member '{0}' should not be attributed with 'ObsoleteAttribute' unless the containing type is obsolete or all constructors are obsolete.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ObsoleteMembersShouldNotBeRequired_Title">
            <summary>Members attributed with 'ObsoleteAttribute' should not be required unless the containing type is obsolete or all constructors are obsolete.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReturningPropertiesCannotBeRequired">
            <summary>Ref returning properties cannot be required.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MisplacedUnchecked">
            <summary>Unexpected keyword 'unchecked'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitImplementationOfInaccessibleInterfaceMember">
            <summary>'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement an inaccessible member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ScriptsAndSubmissionsCannotHaveRequiredMembers">
            <summary>Required members are not allowed on the top level of a script or submission.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAbstractEqualityOperatorSignature">
            <summary>One of the parameters of an equality, or inequality operator declared in interface '{0}' must be a type parameter on '{0}' constrained to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBinaryReadOnlySpanConcatenation">
            <summary>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}' that are not UTF-8 byte representations</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureFileTypes">
            <summary>file types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotMatchOnINumberBase">
            <summary>Cannot use a numeric constant or relational pattern on '{0}' because it inherits from or extends 'INumberBase&lt;T&gt;'. Consider using a type pattern to narrow to a specifc numeric type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_ArrayAccess">
            <summary>array access</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_PointerElementAccess">
            <summary>pointer element access</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ScopedTypeNameDisallowed">
            <summary>Types and aliases cannot be named 'scoped'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnscopedRefAttributeUnsupportedTarget">
            <summary>UnscopedRefAttribute cannot be applied to this item because it is unscoped by default.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RuntimeDoesNotSupportRefFields">
            <summary>Target runtime doesn't support ref fields.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitScopedRef">
            <summary>Do not use 'System.Runtime.CompilerServices.ScopedRefAttribute'. Use the 'scoped' keyword instead.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateAnalyzerReference">
            <summary>Analyzer reference '{0}' specified multiple times</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateAnalyzerReference_Title">
            <summary>Analyzer reference specified multiple times</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FileLocalDuplicateNameInNS">
            <summary>The namespace '{1}' already contains a definition for '{0}' in this file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnscopedScoped">
            <summary>UnscopedRefAttribute cannot be applied to parameters that have a 'scoped' modifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReadOnlyNotSuppAsParamModDidYouMeanIn">
            <summary>'readonly' is not supported as a parameter modifier. Did you mean 'in'?</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CSharp.CSharpCompilerDiagnosticAnalyzer">
            <summary>
            DiagnosticAnalyzer for C# compiler's syntax/semantic/compilation diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Determines if <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/> is of a specified kind.
            </summary>
            <param name="token">The source token.</param>
            <param name="kind">The syntax kind to test for.</param>
            <returns><see langword="true"/> if the token is of the specified kind; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Determines if <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia"/> is of a specified kind.
            </summary>
            <param name="trivia">The source trivia.</param>
            <param name="kind">The syntax kind to test for.</param>
            <returns><see langword="true"/> if the trivia is of the specified kind; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Determines if <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> is of a specified kind.
            </summary>
            <param name="node">The source node.</param>
            <param name="kind">The syntax kind to test for.</param>
            <returns><see langword="true"/> if the node is of the specified kind; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Determines if <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/> is of a specified kind.
            </summary>
            <param name="nodeOrToken">The source node or token.</param>
            <param name="kind">The syntax kind to test for.</param>
            <returns><see langword="true"/> if the node or token is of the specified kind; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns the index of the first node of a specified kind in the node list.
            </summary>
            <param name="list">Node list.</param>
            <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> to find.</param>
            <returns>Returns non-negative index if the list contains a node which matches <paramref name="kind"/>, -1 otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            True if the list has at least one node of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns the index of the first node of a specified kind in the node list.
            </summary>
            <param name="list">Node list.</param>
            <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> to find.</param>
            <returns>Returns non-negative index if the list contains a node which matches <paramref name="kind"/>, -1 otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            True if the list has at least one node of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns the index of the first trivia of a specified kind in the trivia list.
            </summary>
            <param name="list">Trivia list.</param>
            <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> to find.</param>
            <returns>Returns non-negative index if the list contains a trivia which matches <paramref name="kind"/>, -1 otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            True if the list has at least one trivia of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns the index of the first token of a specified kind in the token list.
            </summary>
            <param name="list">Token list.</param>
            <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> to find.</param>
            <returns>Returns non-negative index if the list contains a token which matches <paramref name="kind"/>, -1 otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Tests whether a list contains a token of a particular kind.
            </summary>
            <param name="list"></param>
            <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> to test for.</param>
            <returns>Returns true if the list contains a token which matches <paramref name="kind"/></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Operations.IBoundNodeWithIOperationChildren.Children">
            <summary>
            An array of child bound nodes.
            </summary>
            <remarks>Note that any of the child nodes may be null.</remarks>
        </member>
    </members>
</doc>
